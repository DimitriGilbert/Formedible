{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-builder",
  "type": "registry:block",
  "title": "Formedible AI Builder",
  "description": "An AI-powered form builder component that generates forms from natural language descriptions. Features chat interface, real-time form generation, and multiple AI provider support.",
  "dependencies": [
    "react",
    "lucide-react",
    "clsx",
    "tailwind-merge",
    "@ai-sdk/openai",
    "@ai-sdk/anthropic",
    "@ai-sdk/google",
    "@ai-sdk/mistral",
    "@ai-sdk/openai-compatible",
    "@openrouter/ai-sdk-provider",
    "ai",
    "zod",
    "@codesandbox/sandpack-react"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "card",
    "tabs",
    "dialog",
    "dropdown-menu",
    "scroll-area",
    "badge",
    "alert",
    "skeleton",
    "sidebar",
    "tooltip",
    "separator",
    "slider",
    "https://formedible.dev/r/use-formedible.json"
  ],
  "files": [
    {
      "path": "src/components/formedible/ai/ai-builder.tsx",
      "content": "\"use client\";\n\nimport { useState, useCallback, useEffect } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { ProviderSelection, type ProviderConfig } from \"./provider-selection\";\nimport { ChatInterface } from \"./chat-interface\";\nimport { FormPreview } from \"./form-preview\";\nimport { ConversationHistory, type Conversation } from \"./conversation-history\";\nimport { SidebarIcons, type SidebarView } from \"./sidebar-icons\";\nimport { SidebarContent } from \"./sidebar-content\";\nimport { Button } from \"@/components/ui/button\";\nimport { Sparkles, ChevronDown, ChevronUp, Settings, History, ChevronLeft, ChevronRight, Eye, FileText } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\nimport { extractFormsFromMessages } from \"@/lib/form-extraction-utils\";\nimport { toast } from \"sonner\";\n\n// Create a client instance outside the component to avoid recreation\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      gcTime: 10 * 60 * 1000, // 10 minutes\n      retry: 1,\n    },\n  },\n});\n\nexport type AIBuilderMode = \"direct\" | \"backend\";\n\nexport interface BackendConfig {\n  endpoint: string;\n  headers?: Record<string, string>;\n}\n\nexport interface AIBuilderProps {\n  className?: string;\n  onFormGenerated?: (formCode: string) => void;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nconst STORAGE_KEYS = {\n  PROVIDER_CONFIG: \"formedible-ai-builder-provider-config\",\n  CONVERSATIONS: \"formedible-ai-builder-conversations\",\n  UI_STATE: \"formedible-ai-builder-ui-state\",\n};\n\nfunction AIBuilderCore({ className, onFormGenerated, onFormSubmit, mode = \"direct\", backendConfig }: AIBuilderProps) {\n  const [providerConfig, setProviderConfig] = useState<ProviderConfig | null>(null);\n  const [generatedForms, setGeneratedForms] = useState<Array<{ id: string; code: string; timestamp: Date }>>([]);\n  const [currentFormIndex, setCurrentFormIndex] = useState<number>(0);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [currentConversationId, setCurrentConversationId] = useState<string | undefined>();\n  const [currentMessages, setCurrentMessages] = useState<Message[]>([]);\n  const [isTopSectionCollapsed, setIsTopSectionCollapsed] = useState(false);\n  const [activeView, setActiveView] = useState<SidebarView | null>(null);\n  const [isCollapsed, setIsCollapsed] = useState(false);\n\n  // Check if AI service is properly configured based on mode\n  const isProviderConfigured = useCallback(() => {\n    if (mode === \"backend\") {\n      // For backend mode, just check that backend config is provided\n      return !!(backendConfig && backendConfig.endpoint && backendConfig.endpoint.trim().length > 0);\n    }\n    \n    // For direct mode, check provider configuration\n    if (!providerConfig) return false;\n    \n    // Check if provider requires API key\n    const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n    if (providersRequiringKey.includes(providerConfig.provider as string)) {\n      return !!(providerConfig.apiKey && providerConfig.apiKey.trim().length > 0);\n    }\n    \n    // For openai-compatible, endpoint is required\n    if (providerConfig.provider === \"openai-compatible\") {\n      return !!(providerConfig.endpoint && providerConfig.endpoint.trim().length > 0);\n    }\n    \n    return true;\n  }, [mode, backendConfig, providerConfig]);\n\n  // Load saved data on mount\n  useEffect(() => {\n    try {\n      // Load provider config\n      const savedConfig = localStorage.getItem(STORAGE_KEYS.PROVIDER_CONFIG);\n      if (savedConfig) {\n        setProviderConfig(JSON.parse(savedConfig));\n      }\n\n      // Load conversations\n      const savedConversations = localStorage.getItem(STORAGE_KEYS.CONVERSATIONS);\n      let loadedConversations: Conversation[] = [];\n      if (savedConversations) {\n        const parsedConversations = JSON.parse(savedConversations);\n        loadedConversations = parsedConversations.map((c: any) => ({\n          ...c,\n          createdAt: new Date(c.createdAt),\n          updatedAt: new Date(c.updatedAt),\n        }));\n        setConversations(loadedConversations);\n      }\n\n      // Load UI state\n      const savedUIState = localStorage.getItem(STORAGE_KEYS.UI_STATE);\n      if (savedUIState) {\n        const uiState = JSON.parse(savedUIState);\n        setIsTopSectionCollapsed(uiState.isTopSectionCollapsed || false);\n        \n        // Restore current conversation if it exists\n        if (uiState.currentConversationId && loadedConversations.length > 0) {\n          const currentConversation = loadedConversations.find(c => c.id === uiState.currentConversationId);\n          if (currentConversation) {\n            setCurrentConversationId(uiState.currentConversationId);\n            setCurrentMessages(currentConversation.messages);\n            \n            // Extract forms from conversation messages using shared utility\n            const extractedForms = extractFormsFromMessages(\n              currentConversation.messages,\n              currentConversation.id,\n              new Date(currentConversation.updatedAt)\n            );\n            \n            // Restore generated forms\n            setGeneratedForms(extractedForms);\n            setCurrentFormIndex(0);\n          }\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to load saved AI Builder data:\", error);\n    }\n  }, []);\n\n  // Save provider config when it changes\n  useEffect(() => {\n    if (providerConfig) {\n      try {\n        localStorage.setItem(STORAGE_KEYS.PROVIDER_CONFIG, JSON.stringify(providerConfig));\n      } catch (error) {\n        console.warn(\"Failed to save provider config:\", error);\n      }\n    }\n  }, [providerConfig]);\n\n  // Save conversations when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));\n    } catch (error) {\n      console.warn(\"Failed to save conversations:\", error);\n    }\n  }, [conversations]);\n\n  // Save UI state when it changes\n  useEffect(() => {\n    try {\n      const uiState = {\n        isTopSectionCollapsed,\n        currentConversationId,\n      };\n      localStorage.setItem(STORAGE_KEYS.UI_STATE, JSON.stringify(uiState));\n    } catch (error) {\n      console.warn(\"Failed to save UI state:\", error);\n    }\n  }, [isTopSectionCollapsed, currentConversationId]);\n\n  const handleProviderConfigChange = useCallback((config: ProviderConfig | null) => {\n    setProviderConfig(config);\n  }, []);\n\n  const handleFormGenerated = useCallback((formCode: string) => {\n    const newForm = {\n      id: `form_${Date.now()}`,\n      code: formCode,\n      timestamp: new Date()\n    };\n    \n    setGeneratedForms(prev => {\n      const updated = [...prev, newForm];\n      setCurrentFormIndex(updated.length - 1); // Auto-navigate to newest form\n      return updated;\n    });\n    \n    onFormGenerated?.(formCode);\n  }, [onFormGenerated]);\n\n  const handleStreamingStateChange = useCallback((streaming: boolean) => {\n    setIsGenerating(streaming);\n  }, []);\n\n  const handleFormSubmit = useCallback((formData: Record<string, unknown>) => {\n    console.log(\"Form submitted:\", formData);\n    onFormSubmit?.(formData);\n  }, [onFormSubmit]);\n\n  const handleFormIndexChange = useCallback((index: number) => {\n    setCurrentFormIndex(index);\n  }, []);\n\n  const handleDeleteForm = useCallback((index: number) => {\n    setGeneratedForms(prev => {\n      const updated = prev.filter((_, i) => i !== index);\n      // Adjust current index if necessary\n      if (index <= currentFormIndex && currentFormIndex > 0) {\n        setCurrentFormIndex(currentFormIndex - 1);\n      } else if (index < currentFormIndex) {\n        // No change needed to currentFormIndex\n      } else if (updated.length === 0) {\n        setCurrentFormIndex(0);\n      } else if (currentFormIndex >= updated.length) {\n        setCurrentFormIndex(updated.length - 1);\n      }\n      return updated;\n    });\n  }, [currentFormIndex]);\n\n  const handleConversationUpdate = useCallback((messages: Message[], isStreamEnd: boolean = false) => {\n    // Check if provider is configured before allowing conversation updates\n    if (!isProviderConfigured()) {\n      toast.error(\"Please configure your AI provider first\", {\n        description: \"You need to set up your API key in the settings before you can chat.\"\n      });\n      return;\n    }\n\n    // Always update current messages for UI\n    setCurrentMessages(messages);\n    \n    // Handle conversation creation/update\n    if (messages.length > 0) {\n      if (!currentConversationId) {\n        // Create new conversation when first message is sent\n        const newConversationId = `conversation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        \n        setConversations(prev => {\n          // Double check we don't already have this conversation (race condition protection)\n          const exists = prev.some(conv => conv.id === newConversationId);\n          if (exists) return prev;\n          \n          const newConversation: Conversation = {\n            id: newConversationId,\n            title: \"\", // Will be generated from first message\n            messages,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          };\n          \n          return [...prev, newConversation];\n        });\n        setCurrentConversationId(newConversationId);\n      } else {\n        // Update existing conversation with new messages\n        setConversations(prev => prev.map(conv => \n          conv.id === currentConversationId \n            ? { ...conv, messages, updatedAt: new Date() }\n            : conv\n        ));\n      }\n    }\n  }, [currentConversationId, isProviderConfigured]);\n\n  const handleNewConversation = useCallback(() => {\n    setCurrentConversationId(undefined);\n    setCurrentMessages([]);\n    // Clear forms when starting new conversation\n    setGeneratedForms([]);\n    setCurrentFormIndex(0);\n  }, []);\n\n  // Remove automatic conversation creation\n\n  const handleSelectConversation = useCallback((conversation: Conversation) => {\n    setCurrentConversationId(conversation.id);\n    setCurrentMessages(conversation.messages);\n    \n    // Extract forms from conversation messages using shared utility\n    const extractedForms = extractFormsFromMessages(\n      conversation.messages,\n      conversation.id,\n      new Date(conversation.updatedAt)\n    );\n    \n    console.log('Extracted forms from conversation:', extractedForms.length);\n    \n    // Update generated forms and reset index\n    setGeneratedForms(extractedForms);\n    setCurrentFormIndex(0);\n  }, []);\n\n  const handleDeleteConversation = useCallback((conversationId: string) => {\n    setConversations(prev => prev.filter(c => c.id !== conversationId));\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(undefined);\n      setCurrentMessages([]);\n      // Clear forms when deleting current conversation\n      setGeneratedForms([]);\n      setCurrentFormIndex(0);\n    }\n  }, [currentConversationId]);\n\n  const handleExportConversation = useCallback((conversation: Conversation) => {\n    const dataStr = JSON.stringify(conversation, null, 2);\n    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\n\n    const exportFileDefaultName = `conversation-${conversation.id}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileDefaultName);\n    linkElement.click();\n  }, []);\n\n  const handleToggleCollapse = useCallback(() => {\n    setIsCollapsed(!isCollapsed);\n  }, [isCollapsed]);\n\n  const handleViewChange = useCallback((view: SidebarView | null) => {\n    setActiveView(view);\n    if (view && isCollapsed) {\n      setIsCollapsed(false);\n    }\n  }, [isCollapsed]);\n\n\n\n  return (\n    <div className={cn(\"flex flex-col h-full overflow-hidden\", className)}>\n      <div className=\"flex items-center gap-2 px-1 pb-1 flex-shrink-0\">\n        <Sparkles className=\"h-4 w-4 text-primary\" />\n        <h1 className=\"text-lg font-bold text-foreground\">AI Form Builder</h1>\n      </div>\n\n\n      {/* Main Layout: Sidebar + Content Area */}\n      <div className=\"flex-1 flex min-h-0 overflow-hidden gap-2\">\n        {/* Sidebar */}\n        <SidebarIcons\n          isCollapsed={isCollapsed}\n          onToggleCollapse={handleToggleCollapse}\n          activeView={activeView}\n          onViewChange={handleViewChange}\n        />\n        \n        <SidebarContent\n          activeView={activeView}\n          isCollapsed={isCollapsed}\n          conversations={conversations}\n          currentConversationId={currentConversationId}\n          onSelectConversation={handleSelectConversation}\n          onDeleteConversation={handleDeleteConversation}\n          onNewConversation={handleNewConversation}\n          onExportConversation={handleExportConversation}\n          providerConfig={providerConfig}\n          onConfigChange={handleProviderConfigChange}\n        />\n\n        {/* Chat + Preview Grid */}\n        <div className=\"flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden\">\n          {/* Conditionally show provider form or chat interface */}\n          {!isProviderConfigured() ? (\n            <div className=\"flex flex-col h-full border-2 border-accent/30 rounded-lg shadow-lg bg-card\">\n              <div className=\"px-6 py-4 bg-gradient-to-r from-accent/10 to-transparent border-b\">\n                <h2 className=\"text-lg font-semibold text-foreground\">Setup Required</h2>\n                <p className=\"text-sm text-muted-foreground mt-1\">\n                  {mode === \"backend\" \n                    ? \"Backend endpoint configuration is required\"\n                    : \"Please configure your AI provider to start building forms\"\n                  }\n                </p>\n              </div>\n              <div className=\"flex-1 overflow-y-auto\">\n                {mode === \"direct\" ? (\n                  <ProviderSelection\n                    onConfigChange={handleProviderConfigChange}\n                    initialConfig={providerConfig}\n                    className=\"h-full\"\n                  />\n                ) : (\n                  <div className=\"p-6\">\n                    <div className=\"text-center text-muted-foreground\">\n                      <h3 className=\"text-base font-medium mb-2\">Backend Mode</h3>\n                      <p className=\"text-sm\">\n                        {backendConfig?.endpoint \n                          ? `Endpoint: ${backendConfig.endpoint}`\n                          : \"No backend endpoint configured\"\n                        }\n                      </p>\n                      <p className=\"text-xs mt-4\">\n                        Backend configuration must be provided via props by the developer.\n                      </p>\n                    </div>\n                  </div>\n                )}\n              </div>\n            </div>\n          ) : (\n            <ChatInterface\n              onFormGenerated={handleFormGenerated}\n              onStreamingStateChange={handleStreamingStateChange}\n              onConversationUpdate={handleConversationUpdate}\n              onNewConversation={handleNewConversation}\n              messages={currentMessages}\n              providerConfig={providerConfig}\n              mode={mode}\n              backendConfig={backendConfig}\n              className=\"h-full overflow-hidden\"\n            />\n          )}\n\n          <FormPreview\n            forms={generatedForms}\n            currentFormIndex={currentFormIndex}\n            onFormIndexChange={handleFormIndexChange}\n            onDeleteForm={handleDeleteForm}\n            isStreaming={isGenerating}\n            onFormSubmit={handleFormSubmit}\n            className=\"h-full overflow-hidden\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Export the main component wrapped with QueryClientProvider\nexport function AIBuilder(props: AIBuilderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <AIBuilderCore {...props} />\n    </QueryClientProvider>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-builder.tsx"
    },
    {
      "path": "src/components/formedible/ai/provider-selection.tsx",
      "content": "\"use client\";\n\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { toast } from \"sonner\";\n\nexport type AIProvider =\n  | \"openai\"\n  | \"anthropic\"\n  | \"google\"\n  | \"mistral\"\n  | \"openrouter\"\n  | \"openai-compatible\";\n\nexport interface ProviderConfig {\n  provider: AIProvider;\n  apiKey: string;\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  endpoint?: string;\n}\n\nexport interface ProviderSelectionProps {\n  onConfigChange: (config: ProviderConfig | null) => void;\n  initialConfig?: ProviderConfig | null;\n  className?: string;\n}\n\nconst PROVIDERS = [\n  { value: \"openai\", label: \"OpenAI\", requiresKey: true },\n  { value: \"anthropic\", label: \"Anthropic\", requiresKey: true },\n  { value: \"google\", label: \"Google Gemini\", requiresKey: true },\n  { value: \"mistral\", label: \"Mistral\", requiresKey: true },\n  { value: \"openrouter\", label: \"OpenRouter\", requiresKey: true },\n  {\n    value: \"openai-compatible\",\n    label: \"OpenAI Compatible\",\n    requiresKey: false,\n  },\n] as const;\n\nexport function ProviderSelection({\n  onConfigChange,\n  initialConfig,\n  className,\n}: ProviderSelectionProps) {\n  const { Form } = useFormedible({\n    fields: [\n      {\n        name: \"provider\",\n        type: \"select\",\n        label: \"Provider\",\n        placeholder: \"Select provider...\",\n        options: PROVIDERS.map((p) => ({ value: p.value, label: p.label })),\n      },\n      {\n        name: \"apiKey\",\n        type: \"password\",\n        label: \"API Key\",\n        placeholder: \"Enter your API key...\",\n        // conditional: (values) => {\n        //   const provider = PROVIDERS.find(p => p.value === values.provider);\n        //   return provider?.requiresKey || false;\n        // },\n        description:\n          \"Your API key is stored securely and never sent to our servers\",\n      },\n      {\n        name: \"endpoint\",\n        type: \"text\",\n        label: \"API Endpoint\",\n        placeholder: \"https://api.example.com/v1\",\n        conditional: (values) => values.provider === \"openai-compatible\",\n        description: \"Base URL for OpenAI-compatible API\",\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        provider: initialConfig?.provider,\n        apiKey: initialConfig?.apiKey || \"\",\n        endpoint: initialConfig?.endpoint || \"\",\n      },\n      onSubmit: async ({ value }) => {\n        const config: ProviderConfig = {\n          provider: value.provider as AIProvider,\n          apiKey: value.apiKey || \"\",\n          ...(value.endpoint && { endpoint: value.endpoint }),\n        };\n        \n        // Validate configuration\n        const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n        if (providersRequiringKey.includes(config.provider as string) && (!config.apiKey || config.apiKey.trim().length === 0)) {\n          toast.error(\"API key required\", {\n            description: `Please enter a valid API key for ${config.provider}.`\n          });\n          return;\n        }\n        \n        if (config.provider === \"openai-compatible\" && (!config.endpoint || config.endpoint.trim().length === 0)) {\n          toast.error(\"Endpoint required\", {\n            description: \"Please enter a valid API endpoint for OpenAI-compatible provider.\"\n          });\n          return;\n        }\n        \n        onConfigChange(config);\n        toast.success(\"Provider configured successfully!\", {\n          description: \"You can now start building forms with AI.\"\n        });\n      },\n    },\n    submitLabel: \"💾 Save Configuration\",\n    showSubmitButton: true,\n    autoSubmitOnChange: false,\n  });\n\n  return (\n    <div className={`p-4 space-y-4 ${className || \"\"}`}>\n      <h3 className=\"text-base font-semibold\">AI Provider</h3>\n      <Form />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/provider-selection.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-interface.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\nimport type { AIBuilderMode, BackendConfig } from \"./ai-builder\";\nimport { ChatMessages } from \"./chat-messages\";\nimport type { Message } from \"./chat-messages\";\n\n\nexport type { Message } from \"./chat-messages\";\n\nexport interface ChatInterfaceProps {\n  onFormGenerated?: (formCode: string) => void;\n  onStreamingStateChange?: (isStreaming: boolean) => void;\n  onConversationUpdate?: (messages: Message[], isStreamEnd?: boolean) => void;\n  onNewConversation?: () => void;\n  messages?: Message[];\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nexport function ChatInterface({\n  onFormGenerated,\n  onStreamingStateChange,\n  onConversationUpdate,\n  onNewConversation,\n  messages: externalMessages,\n  className,\n  providerConfig,\n  mode,\n  backendConfig,\n}: ChatInterfaceProps) {\n  return (\n    <ChatMessages\n      onFormGenerated={onFormGenerated}\n      onStreamingStateChange={onStreamingStateChange}\n      onConversationUpdate={onConversationUpdate}\n      onNewConversation={onNewConversation}\n      messages={externalMessages}\n      providerConfig={providerConfig}\n      mode={mode}\n      backendConfig={backendConfig}\n      className={cn(\"h-full\", className)}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-interface.tsx"
    },
    {
      "path": "src/components/formedible/ai/form-preview.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Tooltip, TooltipContent, TooltipTrigger } from \"@/components/ui/tooltip\";\nimport { FormPreviewBase } from \"@/components/formedible/builder/form-preview-base\";\nimport { SandpackPreview } from \"./sandpack-preview\";\nimport { Eye, ChevronLeft, ChevronRight, Trash2, Monitor, Play } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface GeneratedForm {\n  id: string;\n  code: string;\n  timestamp: Date;\n}\n\nexport type PreviewMode = \"static\" | \"live\";\n\nconst PREVIEW_MODE_STORAGE_KEY = \"formedible-preview-mode\";\n\nexport interface FormPreviewProps {\n  forms: GeneratedForm[];\n  currentFormIndex: number;\n  onFormIndexChange: (index: number) => void;\n  onDeleteForm?: (index: number) => void;\n  isStreaming?: boolean;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  className?: string;\n  /** Allow toggling between preview modes */\n  enableModeToggle?: boolean;\n  /** Default preview mode */\n  defaultPreviewMode?: PreviewMode;\n}\n\nexport function FormPreview({ \n  forms, \n  currentFormIndex, \n  onFormIndexChange,\n  onDeleteForm,\n  isStreaming = false, \n  onFormSubmit, \n  className,\n  enableModeToggle = true,\n  defaultPreviewMode = \"static\"\n}: FormPreviewProps) {\n  const currentForm = forms[currentFormIndex];\n  \n  // Preview mode state with localStorage persistence\n  const [previewMode, setPreviewMode] = useState<PreviewMode>(defaultPreviewMode);\n  \n  // Load preview mode from localStorage on mount\n  useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      const savedMode = localStorage.getItem(PREVIEW_MODE_STORAGE_KEY) as PreviewMode;\n      if (savedMode === \"static\" || savedMode === \"live\") {\n        setPreviewMode(savedMode);\n      }\n    }\n  }, []);\n  \n  // Persist preview mode to localStorage\n  const handlePreviewModeChange = (mode: PreviewMode) => {\n    setPreviewMode(mode);\n    if (typeof window !== \"undefined\") {\n      localStorage.setItem(PREVIEW_MODE_STORAGE_KEY, mode);\n    }\n  };\n\n  if (forms.length === 0 && !isStreaming) {\n    return (\n      <FormPreviewBase \n        className={className}\n        title=\"\"\n        emptyStateMessage=\"Start a conversation in the chat to generate your first form. The preview will appear here once the AI creates your form.\"\n      />\n    );\n  }\n\n  return (\n    <Card className={cn(\"flex flex-col h-full\", className)}>\n      <CardHeader className=\"px-3 pt-1 pb-0\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"h-5 w-5\" />\n            Preview\n            {forms.length > 0 && (\n              <span className=\"text-sm font-normal text-muted-foreground\">\n                ({currentFormIndex + 1} of {forms.length})\n              </span>\n            )}\n          </CardTitle>\n          \n          <div className=\"flex items-center gap-2\">\n            {enableModeToggle && (\n              <div className=\"flex items-center gap-2 mr-2\">\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <div className=\"flex items-center gap-2 text-sm\">\n                      <Monitor className=\"h-4 w-4 text-muted-foreground\" />\n                      <span className={cn(\"transition-colors\", previewMode === \"static\" && \"text-foreground font-medium\")}>Static</span>\n                    </div>\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <p>Static preview with current form design</p>\n                  </TooltipContent>\n                </Tooltip>\n                \n                <Switch\n                  checked={previewMode === \"live\"}\n                  onCheckedChange={(checked) => handlePreviewModeChange(checked ? \"live\" : \"static\")}\n                  aria-label=\"Toggle preview mode\"\n                  className=\"h-4 w-7\"\n                />\n                \n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <div className=\"flex items-center gap-2 text-sm\">\n                      <Play className=\"h-4 w-4 text-muted-foreground\" />\n                      <span className={cn(\"transition-colors\", previewMode === \"live\" && \"text-foreground font-medium\")}>Live</span>\n                    </div>\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <p>Interactive live preview with code execution</p>\n                  </TooltipContent>\n                </Tooltip>\n              </div>\n            )}\n            \n            {forms.length > 1 && (\n            <div className=\"flex items-center gap-1\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.max(0, currentFormIndex - 1))}\n                disabled={currentFormIndex === 0}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronLeft className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Previous form</span>\n              </Button>\n              \n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.min(forms.length - 1, currentFormIndex + 1))}\n                disabled={currentFormIndex === forms.length - 1}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronRight className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Next form</span>\n              </Button>\n\n              {onDeleteForm && forms.length > 1 && (\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => onDeleteForm(currentFormIndex)}\n                  className=\"h-8 w-8 p-0 text-destructive hover:text-destructive\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                  <span className=\"sr-only\">Delete form</span>\n                </Button>\n              )}\n            </div>\n            )}\n          </div>\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"flex-1 overflow-hidden\">\n        {previewMode === \"static\" ? (\n          <FormPreviewBase \n            formCode={currentForm?.code}\n            isStreaming={isStreaming && !currentForm}\n            onFormSubmit={onFormSubmit}\n            className=\"border-0 h-full\"\n          />\n        ) : (\n          <SandpackPreview\n            formCode={currentForm?.code}\n            onFormSubmit={onFormSubmit}\n            className=\"h-full\"\n            height=\"100%\"\n            isLoading={isStreaming && !currentForm}\n            showCodeEditor={false}\n            showConsole={false}\n            showFileExplorer={false}\n          />\n        )}\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/form-preview.tsx"
    },
    {
      "path": "src/components/formedible/ai/ai-form-renderer.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useMemo, useCallback, memo } from \"react\";\nimport { z } from \"zod\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { FieldConfig, UseFormedibleOptions } from \"@/lib/formedible/types\";\n\nexport interface AiFormParseResult<TFormData = Record<string, unknown>> {\n  schema: z.ZodSchema<TFormData>;\n  formOptions: UseFormedibleOptions<TFormData>;\n  success: boolean;\n  error?: string;\n}\n\nexport interface AiParserConfig {\n  allowedFieldTypes?: string[];\n  allowedKeys?: string[];\n  allowedFieldKeys?: string[];\n  allowedPageKeys?: string[];\n  allowedProgressKeys?: string[];\n  allowedFormOptionsKeys?: string[];\n}\n\nexport interface AiFormRendererProps {\n  code: string;\n  isStreaming?: boolean;\n  onParseComplete?: (result: AiFormParseResult) => void;\n  onSubmit?: (formData: Record<string, unknown>) => void | Promise<void>;\n  className?: string;\n  parserConfig?: AiParserConfig;\n  debug?: boolean;\n}\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'email', 'password', 'url', 'tel', 'textarea', 'select', \n  'checkbox', 'switch', 'number', 'date', 'slider', 'file', 'rating',\n  'phone', 'colorPicker', 'location', 'duration', 'multiSelect',\n  'autocomplete', 'masked', 'object', 'array', 'radio'\n];\n\nconst DEFAULT_KEYS = [\n  'schema', 'fields', 'pages', 'progress', 'submitLabel', 'nextLabel', \n  'previousLabel', 'formClassName', 'fieldClassName', 'formOptions'\n];\n\nconst DEFAULT_FIELD_KEYS = [\n  'name', 'type', 'label', 'placeholder', 'description', 'options', \n  'min', 'max', 'step', 'accept', 'multiple', 'page', 'conditional',\n  'section', 'ratingConfig', 'phoneConfig', 'colorConfig', 'locationConfig',\n  'durationConfig', 'multiSelectConfig', 'sliderConfig', 'numberConfig',\n  'dateConfig', 'fileConfig', 'textareaConfig', 'passwordConfig', 'emailConfig',\n  'autocompleteConfig', 'maskedInputConfig', 'objectConfig', 'arrayConfig',\n  'validation', 'group', 'tab', 'help', 'inlineValidation', 'datalist'\n];\n\nconst DEFAULT_PAGE_KEYS = ['page', 'title', 'description'];\n\nconst DEFAULT_PROGRESS_KEYS = ['showSteps', 'showPercentage', 'className'];\n\nconst DEFAULT_FORM_OPTIONS_KEYS = [\n  'defaultValues', 'asyncDebounceMs', 'canSubmitWhenInvalid', 'onSubmit', 'onSubmitInvalid'\n];\n\nclass AiFormedibleParser {\n  private config: Required<AiParserConfig>;\n\n  constructor(config?: AiParserConfig) {\n    this.config = {\n      allowedFieldTypes: config?.allowedFieldTypes ?? DEFAULT_FIELD_TYPES,\n      allowedKeys: config?.allowedKeys ?? DEFAULT_KEYS,\n      allowedFieldKeys: config?.allowedFieldKeys ?? DEFAULT_FIELD_KEYS,\n      allowedPageKeys: config?.allowedPageKeys ?? DEFAULT_PAGE_KEYS,\n      allowedProgressKeys: config?.allowedProgressKeys ?? DEFAULT_PROGRESS_KEYS,\n      allowedFormOptionsKeys: config?.allowedFormOptionsKeys ?? DEFAULT_FORM_OPTIONS_KEYS,\n    };\n  }\n\n  parse(code: string): AiFormParseResult {\n    try {\n      const sanitizedCode = this.sanitizeCode(code);\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n      const sanitized = this.validateAndSanitize(parsed);\n      const { schema, formOptions } = this.createFormedibleConfig(sanitized);\n\n      return {\n        schema,\n        formOptions,\n        success: true,\n      };\n    } catch (error) {\n      return {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private sanitizeCode(code: string): string {\n    let sanitized = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '').replace(/\\/\\/.*$/gm, '');\n    sanitized = sanitized.replace(/\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g, '');\n    sanitized = sanitized.replace(/=>\\s*{[^}]*}/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n    return sanitized;\n  }\n\n  private parseObjectLiteral(code: string): unknown {\n    try {\n      return JSON.parse(code);\n    } catch {\n      try {\n        let processedCode = code.trim();\n        processedCode = this.replaceZodExpressions(processedCode);\n        processedCode = processedCode.replace(/([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g, '$1\"$2\":');\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, '$1');\n        processedCode = processedCode.replace(/'/g, '\"');\n        return JSON.parse(processedCode);\n      } catch (conversionError) {\n        throw new Error(`Invalid syntax: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);\n      }\n    }\n  }\n\n  private replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n\n        while (endIndex < result.length && depth > 0) {\n          if (result[endIndex] === '(') {\n            depth++;\n          } else if (result[endIndex] === ')') {\n            depth--;\n          }\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                if (result[chainEndIndex] === '(') {\n                  chainDepth++;\n                } else if (result[chainEndIndex] === ')') {\n                  chainDepth--;\n                }\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          result = result.slice(0, startIndex) + '\"__ZOD_SCHEMA__\"' + result.slice(chainEnd);\n          changed = true;\n        } else {\n          result = result.replace(/z\\.[a-zA-Z]+/, '\"__ZOD_SCHEMA__\"');\n          changed = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private validateAndSanitize(obj: unknown): Record<string, unknown> {\n    if (typeof obj !== 'object' || obj === null) {\n      throw new Error('Definition must be an object');\n    }\n\n    const sanitized: Record<string, unknown> = {};\n    const input = obj as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(input)) {\n      if (!this.config.allowedKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'schema':\n          break;\n        case 'fields':\n          sanitized[key] = this.validateFields(value);\n          break;\n        case 'pages':\n          sanitized[key] = this.validatePages(value);\n          break;\n        case 'progress':\n          sanitized[key] = this.validateProgress(value);\n          break;\n        case 'formOptions':\n          sanitized[key] = this.validateFormOptions(value);\n          break;\n        case 'submitLabel':\n        case 'nextLabel':\n        case 'previousLabel':\n        case 'formClassName':\n        case 'fieldClassName':\n          if (typeof value === 'string') {\n            sanitized[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private validateFields(fields: unknown): FieldConfig[] {\n    if (!Array.isArray(fields)) {\n      throw new Error('Fields must be an array');\n    }\n\n    return fields.map((field, index) => {\n      if (typeof field !== 'object' || field === null) {\n        throw new Error(`Field at index ${index} must be an object`);\n      }\n\n      const sanitizedField: Record<string, unknown> = {};\n      const fieldObj = field as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(fieldObj)) {\n        if (!this.config.allowedFieldKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'name':\n            if (typeof value === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'type':\n            if (typeof value === 'string' && this.config.allowedFieldTypes.includes(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'label':\n          case 'placeholder':\n          case 'description':\n          case 'accept':\n            if (typeof value === 'string') {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'options':\n            if (Array.isArray(value)) {\n              sanitizedField[key] = value.filter(opt => \n                typeof opt === 'string' || \n                (typeof opt === 'object' && opt !== null && \n                 typeof (opt as { value?: unknown }).value === 'string' && \n                 typeof (opt as { label?: unknown }).label === 'string')\n              );\n            }\n            break;\n          case 'min':\n          case 'max':\n          case 'step':\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'multiple':\n          case 'conditional':\n            if (typeof value === 'boolean') {\n              sanitizedField[key] = value;\n            }\n            break;\n          default:\n            if (typeof value === 'object' && value !== null) {\n              sanitizedField[key] = value;\n            }\n            break;\n        }\n      }\n\n      if (!sanitizedField.name || !sanitizedField.type) {\n        throw new Error(`Field at index ${index} must have 'name' and 'type' properties`);\n      }\n\n      return sanitizedField as unknown as FieldConfig;\n    });\n  }\n\n  private validatePages(pages: unknown): Array<{ page: number; title?: string; description?: string }> {\n    if (!Array.isArray(pages)) {\n      return [];\n    }\n\n    return pages.map(page => {\n      if (typeof page !== 'object' || page === null) {\n        return null;\n      }\n\n      const sanitizedPage: Record<string, unknown> = {};\n      const pageObj = page as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(pageObj)) {\n        if (!this.config.allowedPageKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedPage[key] = value;\n            }\n            break;\n          case 'title':\n          case 'description':\n            if (typeof value === 'string') {\n              sanitizedPage[key] = value;\n            }\n            break;\n        }\n      }\n\n      return sanitizedPage.page ? sanitizedPage : null;\n    }).filter(Boolean) as Array<{ page: number; title?: string; description?: string }>;\n  }\n\n  private validateProgress(progress: unknown): Record<string, unknown> {\n    if (typeof progress !== 'object' || progress === null) {\n      return {};\n    }\n\n    const sanitizedProgress: Record<string, unknown> = {};\n    const progressObj = progress as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(progressObj)) {\n      if (!this.config.allowedProgressKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'showSteps':\n        case 'showPercentage':\n          if (typeof value === 'boolean') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n        case 'className':\n          if (typeof value === 'string') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedProgress;\n  }\n\n  private validateFormOptions(formOptions: unknown): Record<string, unknown> {\n    if (typeof formOptions !== 'object' || formOptions === null) {\n      return {};\n    }\n\n    const sanitizedOptions: Record<string, unknown> = {};\n    const optionsObj = formOptions as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(optionsObj)) {\n      if (!this.config.allowedFormOptionsKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'defaultValues':\n          if (typeof value === 'object' && value !== null) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'asyncDebounceMs':\n          if (typeof value === 'number' && !isNaN(value)) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'canSubmitWhenInvalid':\n          if (typeof value === 'boolean') {\n            sanitizedOptions[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedOptions;\n  }\n\n  private createFormedibleConfig(sanitized: Record<string, unknown>): { \n    schema: z.ZodSchema<Record<string, unknown>>; \n    formOptions: UseFormedibleOptions<Record<string, unknown>>; \n  } {\n    const fields = sanitized.fields as FieldConfig[] || [];\n    const schema = this.createSchemaFromFields(fields);\n    const defaultValues = this.createDefaultValues(fields);\n\n    const formOptions: UseFormedibleOptions<Record<string, unknown>> = {\n      fields,\n      schema,\n      pages: sanitized.pages as UseFormedibleOptions<Record<string, unknown>>['pages'],\n      progress: sanitized.progress as UseFormedibleOptions<Record<string, unknown>>['progress'],\n      submitLabel: sanitized.submitLabel as string,\n      nextLabel: sanitized.nextLabel as string,\n      previousLabel: sanitized.previousLabel as string,\n      formClassName: sanitized.formClassName as string,\n      fieldClassName: sanitized.fieldClassName as string,\n      formOptions: {\n        defaultValues,\n        ...(sanitized.formOptions as Record<string, unknown>),\n      },\n    };\n\n    return { schema, formOptions };\n  }\n\n  private createSchemaFromFields(fields: FieldConfig[]): z.ZodSchema<Record<string, unknown>> {\n    const schemaObj: Record<string, z.ZodTypeAny> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'colorPicker':\n        case 'autocomplete':\n        case 'masked':\n        case 'radio':\n        case 'select':\n          schemaObj[field.name] = z.string();\n          break;\n        case 'number':\n        case 'slider':\n        case 'rating':\n          schemaObj[field.name] = z.number();\n          break;\n        case 'checkbox':\n        case 'switch':\n          schemaObj[field.name] = z.boolean();\n          break;\n        case 'date':\n          schemaObj[field.name] = z.date();\n          break;\n        case 'file':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'location':\n          schemaObj[field.name] = z.object({\n            lat: z.number(),\n            lng: z.number(),\n            address: z.string().optional(),\n            city: z.string().optional(),\n            country: z.string().optional(),\n          }).optional();\n          break;\n        case 'duration':\n          schemaObj[field.name] = z.object({\n            hours: z.number().min(0),\n            minutes: z.number().min(0),\n          }).optional();\n          break;\n        case 'multiSelect':\n          schemaObj[field.name] = z.array(z.string());\n          break;\n        case 'object':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'array':\n          schemaObj[field.name] = z.array(z.any());\n          break;\n        default:\n          schemaObj[field.name] = z.string();\n      }\n    });\n\n    return z.object(schemaObj);\n  }\n\n  private createDefaultValues(fields: FieldConfig[]): Record<string, unknown> {\n    const defaults: Record<string, unknown> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'autocomplete':\n        case 'masked':\n          defaults[field.name] = '';\n          break;\n        case 'number':\n        case 'slider':\n          defaults[field.name] = field.min || 0;\n          break;\n        case 'checkbox':\n        case 'switch':\n          defaults[field.name] = false;\n          break;\n        case 'date':\n          defaults[field.name] = new Date().toISOString().split('T')[0];\n          break;\n        case 'select':\n        case 'radio':\n          if (field.options && Array.isArray(field.options) && field.options.length > 0) {\n            const firstOption = field.options[0];\n            defaults[field.name] = typeof firstOption === 'string' ? firstOption : (firstOption as { value: string }).value;\n          } else {\n            defaults[field.name] = '';\n          }\n          break;\n        case 'file':\n          defaults[field.name] = null;\n          break;\n        case 'rating':\n          defaults[field.name] = 1;\n          break;\n        case 'colorPicker':\n          defaults[field.name] = '#000000';\n          break;\n        case 'location':\n          defaults[field.name] = undefined;\n          break;\n        case 'duration':\n          defaults[field.name] = { hours: 0, minutes: 0 };\n          break;\n        case 'multiSelect':\n          defaults[field.name] = [];\n          break;\n        case 'object':\n          defaults[field.name] = {};\n          break;\n        case 'array':\n          defaults[field.name] = [];\n          break;\n        default:\n          defaults[field.name] = '';\n      }\n    });\n\n    return defaults;\n  }\n}\n\nexport function parseAiToFormedible(\n  code: string, \n  config?: AiParserConfig\n): AiFormParseResult {\n  const parser = new AiFormedibleParser(config);\n  return parser.parse(code);\n}\n\nconst AiFormRendererComponent: React.FC<AiFormRendererProps> = ({\n  code,\n  isStreaming = false,\n  onParseComplete,\n  onSubmit,\n  className,\n  parserConfig,\n  debug = false,\n}) => {\n  const [parseResult, setParseResult] = useState<AiFormParseResult | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const parseFormDefinition = useCallback(async () => {\n    if (!code.trim() || isStreaming) return;\n\n    setIsLoading(true);\n\n    try {\n      const result = parseAiToFormedible(code, parserConfig);\n      setParseResult(result);\n      onParseComplete?.(result);\n\n      if (debug && result.error) {\n        console.error('AI Form Parser Error:', result.error);\n      }\n    } catch (err) {\n      const errorResult: AiFormParseResult = {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: err instanceof Error ? err.message : String(err),\n      };\n      setParseResult(errorResult);\n      onParseComplete?.(errorResult);\n\n      if (debug) {\n        console.error('AI Form Renderer Error:', err);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [code, isStreaming, onParseComplete, parserConfig, debug]);\n\n  useEffect(() => {\n    if (!isStreaming && code.trim()) {\n      parseFormDefinition();\n    }\n  }, [code, isStreaming, parseFormDefinition]);\n\n  const formConfig = useMemo(() => {\n    if (!parseResult?.success || !parseResult.formOptions.fields?.length) {\n      return null;\n    }\n\n    return {\n      ...parseResult.formOptions,\n      formOptions: {\n        ...parseResult.formOptions.formOptions,\n        onSubmit: async ({ value }: { value: Record<string, unknown> }) => {\n          await onSubmit?.(value);\n        },\n      },\n    };\n  }, [parseResult, onSubmit]);\n\n  const formedibleResult = useFormedible(formConfig || {\n    fields: [],\n    formOptions: { defaultValues: {} }\n  });\n\n  const renderedForm = useMemo(() => {\n    if (isLoading) {\n      return (\n        <div className=\"flex items-center justify-center p-8\">\n          <div className=\"text-sm text-muted-foreground\">Parsing form...</div>\n        </div>\n      );\n    }\n\n    if (parseResult && !parseResult.success) {\n      return (\n        <div className=\"p-4 border border-destructive/20 bg-destructive/10 rounded-md\">\n          <div className=\"text-sm text-destructive\">\n            <div className=\"font-medium\">Parse Error</div>\n            <div className=\"text-xs mt-1 opacity-80\">{parseResult.error}</div>\n          </div>\n        </div>\n      );\n    }\n\n    if (!formConfig || !parseResult?.success) {\n      return null;\n    }\n\n    return <formedibleResult.Form />;\n  }, [isLoading, parseResult, formConfig, formedibleResult]);\n\n  return (\n    <div className={className}>\n      {renderedForm}\n    </div>\n  );\n};\n\nexport const AiFormRenderer = memo(AiFormRendererComponent);",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-form-renderer.tsx"
    },
    {
      "path": "src/components/formedible/ai/conversation-history.tsx",
      "content": "\"use client\";\n\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { History, MessageSquare, Trash2, Download, Plus } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\n\nexport interface Conversation {\n  id: string;\n  title: string;\n  messages: Message[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ConversationHistoryProps {\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onNewConversation?: () => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  className?: string;\n}\n\nexport function ConversationHistory({\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onNewConversation,\n  onExportConversation,\n  className,\n}: ConversationHistoryProps) {\n\n  const formatDate = (date: Date) => {\n    const now = new Date();\n    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);\n\n    if (diffInHours < 1) {\n      return \"Just now\";\n    } else if (diffInHours < 24) {\n      return `${Math.floor(diffInHours)}h ago`;\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n\n  const getConversationTitle = (conversation: Conversation) => {\n    if (conversation.title) return conversation.title;\n\n    // Generate title from first user message\n    const firstUserMessage = conversation.messages?.find(m => m.role === \"user\");\n    if (firstUserMessage?.content) {\n      const text = firstUserMessage.content;\n      return text.length > 50 ? text.substring(0, 50) + \"...\" : text;\n    }\n\n    return \"New Conversation\";\n  };\n\n  return (\n    <Card className={cn(\"h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <History className=\"h-5 w-5\" />\n            Conversation History\n            <Badge variant=\"secondary\">\n              {conversations.length}\n            </Badge>\n          </CardTitle>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </div>\n      </CardHeader>\n      <CardContent className=\"px-4 pt-0 pb-4\">\n        <div className=\"h-[300px] overflow-y-auto\">\n          {conversations.length === 0 ? (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground py-8\">\n              <MessageSquare className=\"h-8 w-8 mb-2 opacity-50\" />\n              <p className=\"text-sm\">No conversations yet</p>\n              <p className=\"text-xs\">Start a chat to see your history</p>\n            </div>\n          ) : (\n            <div className=\"space-y-1\">\n              {conversations.map((conversation) => (\n                <div\n                  key={conversation.id}\n                  className={cn(\n                    \"group flex items-center justify-between gap-2 px-2 py-1.5 rounded hover:bg-muted/50 cursor-pointer text-sm\",\n                    currentConversationId === conversation.id && \"bg-muted\"\n                  )}\n                  onClick={() => onSelectConversation(conversation)}\n                >\n                  <div className=\"flex-1 min-w-0\">\n                    <p className=\"font-medium truncate text-sm\">\n                      {getConversationTitle(conversation)}\n                    </p>\n                  </div>\n                  <div className=\"flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity shrink-0\">\n                    {onExportConversation && (\n                      <Button\n                        type=\"button\"\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        className=\"h-5 w-5\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          onExportConversation(conversation);\n                        }}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    )}\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-5 w-5 text-destructive hover:text-destructive\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        onDeleteConversation(conversation.id);\n                      }}\n                    >\n                      <Trash2 className=\"h-3 w-3\" />\n                    </Button>\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/conversation-history.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-messages.tsx",
      "content": "\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { streamText, type LanguageModel } from \"ai\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createMistral } from \"@ai-sdk/mistral\";\nimport { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { createOpenAICompatible } from \"@ai-sdk/openai-compatible\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport {\n  AlertCircle,\n  MessageSquare,\n  Send,\n  StopCircle,\n  User,\n  Bot,\n  Loader2,\n  ArrowDown,\n  Plus,\n} from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { CodeBlock } from \"@/components/ui/code-block\";\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\nimport type { AIBuilderMode, BackendConfig } from \"./ai-builder\";\nimport { extractFormedibleCode } from \"@/lib/form-extraction-utils\";\nimport { generateSystemPrompt, defaultParserConfig } from \"@/lib/formedible/parser-config-schema\";\nimport { toast } from \"sonner\";\n\n// MessageContent component to handle code blocks with syntax highlighting\ninterface MessageContentProps {\n  content: string;\n}\n\nfunction MessageContent({ content }: MessageContentProps) {\n  // Detect and render code blocks with syntax highlighting\n  const codeBlockRegex = /```(\\w+)?\\s*\\n([\\s\\S]*?)\\n```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      parts.push(\n        <span\n          key={`text-${lastIndex}`}\n          className=\"whitespace-pre-wrap break-words leading-relaxed\"\n        >\n          {content.slice(lastIndex, match.index)}\n        </span>\n      );\n    }\n\n    // Add code block with syntax highlighting\n    const language = match[1] || \"text\";\n    const code = match[2];\n    parts.push(\n      <div key={`code-${match.index}`} className=\"my-2\">\n        <CodeBlock\n          code={code}\n          language={language}\n          showLineNumbers={false}\n          showCopyButton={true}\n          className=\"text-xs\"\n          darkMode={true}\n          scrollable={false}\n        />\n      </div>\n    );\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Add remaining text\n  if (lastIndex < content.length) {\n    parts.push(\n      <span\n        key={`text-${lastIndex}`}\n        className=\"whitespace-pre-wrap break-words leading-relaxed\"\n      >\n        {content.slice(lastIndex)}\n      </span>\n    );\n  }\n\n  return (\n    <div className=\"space-y-1\">\n      {parts.length > 0 ? (\n        parts\n      ) : (\n        <span className=\"whitespace-pre-wrap break-words leading-relaxed\">\n          {content}\n        </span>\n      )}\n    </div>\n  );\n}\n\nexport interface Message {\n  id: string;\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface ChatMessagesProps {\n  onFormGenerated?: (formCode: string) => void;\n  onStreamingStateChange?: (isStreaming: boolean) => void;\n  onConversationUpdate?: (messages: Message[], isStreamEnd?: boolean) => void;\n  onNewConversation?: () => void;\n  messages?: Message[];\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nexport function ChatMessages({\n  onFormGenerated,\n  onStreamingStateChange,\n  onConversationUpdate,\n  onNewConversation,\n  messages: externalMessages,\n  className,\n  providerConfig,\n  mode = \"direct\",\n  backendConfig,\n}: ChatMessagesProps) {\n  const [input, setInput] = useState(\"\");\n  const [messages, setMessages] = useState<Message[]>(externalMessages || []);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [showScrollToBottom, setShowScrollToBottom] = useState(false);\n  const messagesContainerRef = useRef<HTMLDivElement>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Remove the automatic conversation completion\n\n  const scrollToBottom = useCallback(() => {\n    const container = messagesContainerRef.current;\n    if (container) {\n      container.scrollTop = container.scrollHeight;\n    }\n  }, []);\n\n  const handleScroll = useCallback(() => {\n    if (!messagesContainerRef.current) return;\n\n    const { scrollTop, scrollHeight, clientHeight } =\n      messagesContainerRef.current;\n    const isAtBottom = scrollHeight - scrollTop - clientHeight < 100;\n\n    setShowScrollToBottom(!isAtBottom && messages.length > 0);\n  }, [messages.length]);\n\n  // Sync with external messages when switching conversations\n  useEffect(() => {\n    if (externalMessages !== undefined) {\n      setMessages(externalMessages);\n    }\n  }, [externalMessages]);\n\n  // Remove the useEffect that was causing multiple updates\n\n  // Removed auto-scroll - let users control scrolling manually\n\n  useEffect(() => {\n    const container = messagesContainerRef.current;\n    if (!container) return;\n\n    container.addEventListener(\"scroll\", handleScroll);\n    handleScroll(); // Check initial state\n\n    return () => container.removeEventListener(\"scroll\", handleScroll);\n  }, [handleScroll]);\n\n  const createModel = (config: ProviderConfig): LanguageModel => {\n    const { provider, apiKey, model, endpoint } = config;\n\n    switch (provider) {\n      case \"openai\": {\n        const openaiProvider = createOpenAI({ apiKey });\n        // Flagship latest; swap to \"gpt-5-mini\" if you prefer cost/latency.\n        return openaiProvider(model || \"gpt-5\");\n      }\n\n      case \"anthropic\": {\n        const anthropicProvider = createAnthropic({ apiKey });\n        // Latest Sonnet generation\n        // TODO : fix this shit ! -_-\n        return anthropicProvider(\n          model || \"claude-sonnet-4\"\n        ) as unknown as LanguageModel;\n      }\n\n      case \"google\": {\n        const googleProvider = createGoogleGenerativeAI({ apiKey });\n        // Latest top reasoning model in Gemini API\n        return googleProvider(model || \"gemini-2.5-pro\");\n      }\n\n      case \"mistral\": {\n        const mistralProvider = createMistral({ apiKey });\n        // Mistral Large 2 (GA, sometimes shown as mistral-large-2407)\n        return mistralProvider(model || \"mistral-large-2407\");\n      }\n\n      case \"openrouter\": {\n        const openrouterProvider = createOpenRouter({ apiKey });\n        // OpenRouter must route to Kimi K2 per your requirement\n        // Common IDs: \"openrouter/kimiplus-k2\" (preferred) or \"moonshotai/moonshot-k2\"\n        return openrouterProvider.chat(\n          model || \"openrouter/kimiplus-k2\"\n        ) as LanguageModel;\n      }\n\n      case \"openai-compatible\": {\n        if (!endpoint)\n          throw new Error(\"Endpoint required for OpenAI-compatible providers\");\n        const openaiCompatible = createOpenAICompatible({\n          name: \"openai-compatible\",\n          baseURL: endpoint,\n          ...(apiKey && { apiKey }),\n        });\n        // Use a modern widely supported baseline; adjust to your endpoint's catalog\n        return openaiCompatible(model || \"gpt-4.1-mini\");\n      }\n\n      default:\n        throw new Error(\"Unsupported provider\");\n    }\n  };\n\n  const isServiceConfigured = (): boolean => {\n    if (mode === \"backend\") {\n      return !!(backendConfig && backendConfig.endpoint && backendConfig.endpoint.trim().length > 0);\n    }\n    \n    // For direct mode, check provider configuration\n    if (!providerConfig) return false;\n    \n    // Check if provider requires API key\n    const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n    if (providersRequiringKey.includes(providerConfig.provider as string)) {\n      return !!(providerConfig.apiKey && providerConfig.apiKey.trim().length > 0);\n    }\n    \n    // For openai-compatible, endpoint is required\n    if (providerConfig.provider === \"openai-compatible\") {\n      return !!(providerConfig.endpoint && providerConfig.endpoint.trim().length > 0);\n    }\n    \n    return true;\n  };\n\n  // AI service abstraction - handles both direct and backend modes\n  const generateAIResponse = async (\n    userMessage: string, \n    conversationMessages: Message[],\n    systemPrompt: string,\n    abortSignal: AbortSignal\n  ): Promise<AsyncIterable<string>> => {\n    if (mode === \"backend\") {\n      // Backend mode - make API call to developer's endpoint\n      if (!backendConfig?.endpoint) {\n        throw new Error(\"Backend endpoint not configured\");\n      }\n\n      const response = await fetch(backendConfig.endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...backendConfig.headers,\n        },\n        body: JSON.stringify({\n          messages: conversationMessages.map(msg => ({\n            role: msg.role,\n            content: msg.content,\n          })),\n          systemPrompt,\n          userMessage,\n        }),\n        signal: abortSignal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Backend request failed: ${response.status} ${response.statusText}`);\n      }\n\n      if (!response.body) {\n        throw new Error(\"No response body from backend\");\n      }\n\n      // Return async iterator for streaming response\n      return {\n        async *[Symbol.asyncIterator]() {\n          const reader = response.body!.getReader();\n          const decoder = new TextDecoder();\n          \n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              \n              const chunk = decoder.decode(value, { stream: true });\n              yield chunk;\n            }\n          } finally {\n            reader.releaseLock();\n          }\n        },\n      };\n    } else {\n      // Direct mode - use AI SDK as before\n      if (!providerConfig) {\n        throw new Error(\"Provider configuration required\");\n      }\n\n      const model = createModel(providerConfig);\n      const result = streamText({\n        model,\n        system: systemPrompt,\n        messages: conversationMessages.map((msg) => ({\n          role: msg.role,\n          content: msg.content,\n        })),\n        temperature: providerConfig.temperature || 0.7,\n        maxOutputTokens: providerConfig.maxTokens || 2000,\n        abortSignal,\n      });\n\n      return result.textStream;\n    }\n  };\n\n  const generateResponse = async (userMessage: string) => {\n    if (!isServiceConfigured()) {\n      toast.error(mode === \"backend\" ? \"Backend not configured\" : \"Provider not configured\", {\n        description: mode === \"backend\" \n          ? \"Backend endpoint configuration is required to send messages.\"\n          : \"Please configure your AI provider with a valid API key before sending messages.\"\n      });\n      setError(new Error(\"Service configuration required\"));\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n      onStreamingStateChange?.(true);\n\n      const userMsg: Message = {\n        id: Date.now().toString(),\n        role: \"user\",\n        content: userMessage,\n      };\n\n      const newMessages = [...messages, userMsg];\n      setMessages(newMessages);\n\n      // Get parser configuration from localStorage or use defaults\n      let parserConfig = defaultParserConfig;\n      try {\n        const savedConfig = localStorage.getItem('formedible-parser-config');\n        if (savedConfig) {\n          const parsed = JSON.parse(savedConfig);\n          parserConfig = { ...defaultParserConfig, ...parsed };\n        }\n      } catch (error) {\n        console.warn('Failed to load parser config, using defaults:', error);\n      }\n\n      // Generate dynamic system prompt based on configuration\n      const configuredSystemPrompt = generateSystemPrompt(parserConfig);\n      \n      const baseSystemPrompt = `You are a helpful AI assistant for form creation. You can chat naturally with users about forms, answer questions, and help them design forms.\n\n**IMPORTANT: Only show formedible code blocks when the user specifically asks to create, build, generate, or show a form.**\n\nWhen creating forms, use formedible code blocks with complete JavaScript object literal syntax including Zod schemas. Chat naturally. Ask clarifying questions. Suggest improvements. Only output formedible blocks when specifically requested.`;\n\n      const systemPrompt = configuredSystemPrompt \n        ? `${baseSystemPrompt}\\n\\n${configuredSystemPrompt}` \n        : baseSystemPrompt;\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      // Use the AI service abstraction\n      const textStream = await generateAIResponse(\n        userMessage,\n        [...messages, userMsg],\n        systemPrompt,\n        abortController.signal\n      );\n\n      const assistantMsg: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: \"\",\n      };\n\n      setMessages((prev) => [...prev, assistantMsg]);\n\n      let fullResponse = \"\";\n      for await (const textPart of textStream) {\n        if (abortController.signal.aborted) break;\n\n        fullResponse += textPart;\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === assistantMsg.id ? { ...msg, content: fullResponse } : msg\n          )\n        );\n      }\n\n      // Extract and send formedible code blocks to preview\n      if (fullResponse && onFormGenerated) {\n        const code = extractFormedibleCode(fullResponse);\n        if (code) {\n          onFormGenerated(code);\n        }\n      }\n\n      onStreamingStateChange?.(false);\n\n      // Save conversation to localStorage ONLY on stream end with complete messages\n      const finalMessages = [\n        ...newMessages, // This includes user message\n        { ...assistantMsg, content: fullResponse },\n      ];\n      onConversationUpdate?.(finalMessages, true);\n    } catch (err) {\n      console.error(\"AI Generation Error:\", err);\n      setError(\n        err instanceof Error ? err : new Error(\"Unknown error occurred\")\n      );\n    } finally {\n      setIsLoading(false);\n      onStreamingStateChange?.(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!input.trim() || isLoading) return;\n\n    if (!isServiceConfigured()) {\n      toast.error(mode === \"backend\" ? \"Backend configuration required\" : \"Provider configuration required\", {\n        description: mode === \"backend\" \n          ? \"Backend endpoint configuration is required to send messages.\"\n          : \"Please set up your AI provider with a valid API key in the settings before sending messages.\"\n      });\n      return;\n    }\n\n    const userInput = input;\n    setInput(\"\");\n    generateResponse(userInput);\n  };\n\n  const stop = () => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit(e);\n    }\n  };\n\n  return (\n    <Card\n      className={cn(\n        \"flex flex-col h-full max-h-full border-2 border-accent/30 shadow-lg !py-0 !gap-0 overflow-hidden\",\n        className\n      )}\n    >\n      <CardHeader className=\"px-3 pt-1 pb-0 bg-gradient-to-r from-accent/10 to-transparent\">\n        <CardTitle className=\"flex items-center justify-between text-lg\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-accent/20 rounded-lg\">\n              <MessageSquare className=\"h-5 w-5 text-accent-foreground\" />\n            </div>\n            <span className=\"text-foreground font-semibold\">\n              AI Form Builder Chat\n            </span>\n          </div>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </CardTitle>\n      </CardHeader>\n\n      <CardContent className=\"flex flex-col flex-1 px-3 pt-0 pb-1 min-h-0 max-h-full relative overflow-hidden\">\n        <div\n          ref={messagesContainerRef}\n          className=\"flex-1 overflow-y-auto space-y-3 mb-1 pr-2 min-h-0\"\n        >\n          {messages.length === 0 && (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground\">\n              <Bot className=\"h-12 w-12 mb-4 opacity-50\" />\n              <h3 className=\"text-lg font-medium mb-2\">\n                Welcome to AI Form Builder\n              </h3>\n              <p className=\"text-sm max-w-md\">\n                Describe the form you want to create and I'll generate it for\n                you. Try something like \"Create a contact form with name, email,\n                and message fields\"\n              </p>\n            </div>\n          )}\n\n          {messages.map((message: Message) => (\n            <div\n              key={message.id}\n              className={cn(\n                \"flex gap-3 max-w-4xl\",\n                message.role === \"user\" ? \"ml-auto flex-row-reverse\" : \"mr-auto\"\n              )}\n            >\n              <div\n                className={cn(\n                  \"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-muted text-foreground border-border\"\n                )}\n              >\n                {message.role === \"user\" ? (\n                  <User className=\"h-4 w-4\" />\n                ) : (\n                  <Bot className=\"h-4 w-4\" />\n                )}\n              </div>\n\n              <div\n                className={cn(\n                  \"flex flex-col gap-2 rounded-lg px-4 py-3 text-sm shadow-md border max-w-[85%]\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-background text-foreground border-border\"\n                )}\n              >\n                <MessageContent content={message.content} />\n              </div>\n            </div>\n          ))}\n\n          {isLoading && (\n            <div className=\"flex gap-3 max-w-4xl mr-auto\">\n              <div className=\"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md bg-muted text-foreground border-border\">\n                <Bot className=\"h-4 w-4\" />\n              </div>\n              <div className=\"flex items-center gap-2 rounded-lg px-4 py-3 text-sm shadow-md border bg-background text-foreground border-border\">\n                <Loader2 className=\"h-4 w-4 animate-spin text-primary\" />\n                <span>Generating response...</span>\n              </div>\n            </div>\n          )}\n\n        </div>\n\n        {/* Scroll to bottom button */}\n        {showScrollToBottom && (\n          <Button\n            onClick={scrollToBottom}\n            className=\"absolute bottom-20 right-4 rounded-full w-10 h-10 p-0 shadow-lg z-10\"\n            variant=\"secondary\"\n            size=\"sm\"\n          >\n            <ArrowDown className=\"h-4 w-4\" />\n            <span className=\"sr-only\">Scroll to bottom</span>\n          </Button>\n        )}\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>\n              Failed to send message. Please check your configuration and try\n              again.\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"flex gap-2\">\n          <Textarea\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Describe the form you want to create... (Shift+Enter for new line)\"\n            disabled={isLoading}\n            className=\"flex-1 min-h-[80px] resize-none\"\n            rows={3}\n          />\n\n          {isLoading ? (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n              onClick={stop}\n              className=\"shrink-0\"\n            >\n              <StopCircle className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Stop generation</span>\n            </Button>\n          ) : (\n            <Button\n              type=\"submit\"\n              disabled={!input.trim() || !isServiceConfigured()}\n              size=\"icon\"\n              className=\"shrink-0\"\n            >\n              <Send className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Send message</span>\n            </Button>\n          )}\n        </form>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-messages.tsx"
    },
    {
      "path": "src/components/formedible/ai/sidebar-icons.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { \n  ChevronLeft, \n  ChevronRight, \n  History, \n  Settings, \n  Globe,\n  FileText \n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport type SidebarView = \"history\" | \"settings\" | \"provider\" | \"parser\";\n\ninterface SidebarIconsProps {\n  isCollapsed: boolean;\n  onToggleCollapse: () => void;\n  activeView: SidebarView | null;\n  onViewChange: (view: SidebarView | null) => void;\n}\n\nexport function SidebarIcons({\n  isCollapsed,\n  onToggleCollapse,\n  activeView,\n  onViewChange,\n}: SidebarIconsProps) {\n  const handleIconClick = (view: SidebarView) => {\n    if (activeView === view) {\n      // If clicking the same icon, close the sidebar\n      onViewChange(null);\n    } else {\n      // If clicking different icon, switch view\n      onViewChange(view);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col w-12 bg-muted/20 border-r border-border\">\n      {/* Collapse/expand button */}\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={onToggleCollapse}\n        className=\"h-12 w-12 rounded-none border-b border-border hover:bg-muted/40\"\n      >\n        {isCollapsed ? (\n          <ChevronRight className=\"h-4 w-4\" />\n        ) : (\n          <ChevronLeft className=\"h-4 w-4\" />\n        )}\n        <span className=\"sr-only\">\n          {isCollapsed ? \"Expand sidebar\" : \"Collapse sidebar\"}\n        </span>\n      </Button>\n\n      {/* Icon buttons */}\n      <div className=\"flex flex-col\">\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"history\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"history\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <History className=\"h-4 w-4\" />\n          <span className=\"sr-only\">History</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"settings\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"settings\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <Settings className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Settings</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"provider\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"provider\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <Globe className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Provider</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"parser\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"parser\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <FileText className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Form Parser Settings</span>\n        </Button>\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/sidebar-icons.tsx"
    },
    {
      "path": "src/components/formedible/ai/sidebar-content.tsx",
      "content": "\"use client\";\n\nimport { Card } from \"@/components/ui/card\";\nimport { cn } from \"@/lib/utils\";\nimport type { SidebarView } from \"./sidebar-icons\";\nimport { ConversationHistory, type Conversation, type ConversationHistoryProps } from \"./conversation-history\";\nimport { AgentSettings } from \"./agent-settings\";\nimport { ProviderSelection } from \"./provider-selection\";\nimport { ParserSettings } from \"./parser-settings\";\nimport type { ProviderConfig } from \"./provider-selection\";\n\ninterface SidebarContentProps {\n  activeView: SidebarView | null;\n  isCollapsed: boolean;\n  className?: string;\n  \n  // History props\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onNewConversation?: () => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  \n  // Settings props  \n  providerConfig: ProviderConfig | null;\n  onConfigChange: (config: ProviderConfig | null) => void;\n}\n\nexport function SidebarContent({\n  activeView,\n  isCollapsed,\n  className,\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onNewConversation,\n  onExportConversation,\n  providerConfig,\n  onConfigChange,\n}: SidebarContentProps) {\n  if (isCollapsed || !activeView) {\n    return null;\n  }\n\n  const renderContent = () => {\n    switch (activeView) {\n      case \"history\":\n        return (\n          <ConversationHistory\n            conversations={conversations}\n            currentConversationId={currentConversationId}\n            onSelectConversation={onSelectConversation}\n            onDeleteConversation={onDeleteConversation}\n            onNewConversation={onNewConversation}\n            onExportConversation={onExportConversation}\n            className=\"border-0 shadow-none h-full\"\n          />\n        );\n        \n      case \"settings\":\n        return (\n          <Card className=\"h-full\">\n            <AgentSettings\n              providerConfig={providerConfig}\n              onConfigChange={onConfigChange}\n              className=\"h-full\"\n            />\n          </Card>\n        );\n        \n      case \"provider\":\n        return (\n          <Card className=\"h-full\">\n            <ProviderSelection\n              onConfigChange={onConfigChange}\n              initialConfig={providerConfig}\n              className=\"h-full\"\n            />\n          </Card>\n        );\n        \n      case \"parser\":\n        return (\n          <ParserSettings\n            className=\"h-full\"\n          />\n        );\n        \n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div\n      className={cn(\n        \"w-80 border-r border-border bg-background/50 transition-all duration-200 ease-in-out overflow-hidden\",\n        isCollapsed ? \"w-0\" : \"w-80\",\n        className\n      )}\n    >\n      <div className=\"h-full p-2 overflow-y-auto\">\n        {renderContent()}\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/sidebar-content.tsx"
    },
    {
      "path": "src/components/formedible/ai/agent-settings.tsx",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { ProviderConfig, AIProvider } from \"./provider-selection\";\n\ninterface AgentSettingsProps {\n  providerConfig: ProviderConfig | null;\n  onConfigChange: (config: ProviderConfig | null) => void;\n  className?: string;\n}\n\n// OpenRouter models fetcher with memoization\nconst fetchOpenRouterModels = async (apiKey: string) => {\n  const response = await fetch(\"https://openrouter.ai/api/v1/models\", {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.data\n    .filter((model: any) => model.id && model.name && model.id.trim() !== \"\")\n    .map((model: any) => ({\n      value: model.id,\n      label: model.name,\n    }))\n    .sort((a: any, b: any) => a.label.localeCompare(b.label));\n};\n\n// Memoized function to get model options based on provider\nconst useModelOptions = (\n  provider: AIProvider | undefined,\n  openRouterModels: Array<{ value: string; label: string }> = [],\n  openRouterLoading: boolean = false\n) => {\n  return useMemo(() => {\n    if (provider === \"openai\")\n      return [\n        { value: \"gpt-5\", label: \"GPT-5\" },\n        { value: \"gpt-5-mini\", label: \"GPT-5 Mini\" },\n        { value: \"gpt-4o\", label: \"GPT-4o\" },\n        { value: \"gpt-4o-mini\", label: \"GPT-4o Mini\" },\n      ];\n    if (provider === \"anthropic\")\n      return [\n        { value: \"claude-sonnet-4\", label: \"Claude Sonnet 4\" },\n        { value: \"claude-3-5-sonnet-20241022\", label: \"Claude 3.5 Sonnet\" },\n        { value: \"claude-3-haiku-20240307\", label: \"Claude 3 Haiku\" },\n      ];\n    if (provider === \"google\")\n      return [\n        { value: \"gemini-2.5-pro\", label: \"Gemini 2.5 Pro\" },\n        { value: \"gemini-1.5-pro\", label: \"Gemini 1.5 Pro\" },\n        { value: \"gemini-1.5-flash\", label: \"Gemini 1.5 Flash\" },\n      ];\n    if (provider === \"mistral\")\n      return [\n        { value: \"mistral-large-2407\", label: \"Mistral Large 2407\" },\n        { value: \"mistral-medium-2312\", label: \"Mistral Medium 2312\" },\n        { value: \"mistral-small-2312\", label: \"Mistral Small 2312\" },\n      ];\n    if (provider === \"openrouter\") {\n      if (openRouterLoading) return [{ value: \"loading\", label: \"Loading models...\" }];\n      return openRouterModels.length > 0\n        ? openRouterModels.filter(model => model.value && model.value.trim() !== \"\")\n        : [\n            { value: \"openrouter/kimiplus-k2\", label: \"OpenRouter Kimi Plus K2\" },\n            { value: \"moonshotai/moonshot-k2\", label: \"Moonshot K2\" },\n          ];\n    }\n    if (provider === \"openai-compatible\")\n      return [\n        { value: \"gpt-4.1-mini\", label: \"GPT-4.1 Mini\" },\n        { value: \"custom-model\", label: \"Custom Model\" },\n      ];\n    return [];\n  }, [provider, openRouterModels, openRouterLoading]);\n};\n\nexport function AgentSettings({ providerConfig, onConfigChange, className }: AgentSettingsProps) {\n  // Use TanStack Query for OpenRouter models with proper caching\n  const {\n    data: openRouterModels = [],\n    isLoading: openRouterLoading,\n    error: openRouterError,\n  } = useQuery({\n    queryKey: [\"openrouter-models\", providerConfig?.apiKey],\n    queryFn: () => fetchOpenRouterModels(providerConfig?.apiKey || \"\"),\n    enabled: providerConfig?.provider === \"openrouter\" && !!providerConfig?.apiKey && providerConfig.apiKey.length > 0,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    gcTime: 10 * 60 * 1000, // 10 minutes\n    retry: 1,\n  });\n\n  const availableModels = useModelOptions(\n    providerConfig?.provider,\n    openRouterModels,\n    openRouterLoading\n  );\n\n  const { Form } = useFormedible({\n    fields: !providerConfig ? [] : [\n      {\n        name: \"model\",\n        type: \"select\",\n        label: \"Model\",\n        placeholder: \"Select a model\",\n        options: providerConfig?.provider === \"openrouter\" && openRouterError\n          ? [{ value: \"error\", label: \"Failed to load models - check API key\" }]\n          : availableModels,\n      },\n      {\n        name: \"temperature\",\n        type: \"slider\",\n        label: `Temperature: ${(providerConfig?.temperature || 0.7).toFixed(2)}`,\n        sliderConfig: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        description: \"Controls randomness: Focused ← → Creative\",\n      },\n      {\n        name: \"maxTokens\",\n        type: \"number\",\n        label: \"Max Tokens\",\n        placeholder: \"2000\",\n        description: \"Maximum response length\",\n        numberConfig: {\n          min: 1,\n          max: 32768,\n        },\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        model: providerConfig?.model || \"\",\n        temperature: providerConfig?.temperature || 0.7,\n        maxTokens: providerConfig?.maxTokens || 2000,\n      },\n      onSubmit: async ({ value }) => {\n        if (!providerConfig) return;\n        const updatedConfig: ProviderConfig = {\n          ...providerConfig,\n          model: value.model,\n          temperature: value.temperature,\n          maxTokens: value.maxTokens,\n        };\n        onConfigChange(updatedConfig);\n      },\n    },\n    submitLabel: \"💾 Save Model Settings\",\n    showSubmitButton: !providerConfig ? false : true,\n    autoSubmitOnChange: false,\n  });\n\n  return (\n    <div className={`p-4 space-y-4 ${className || \"\"}`}>\n      <h3 className=\"text-base font-semibold\">Model Settings</h3>\n      {!providerConfig ? (\n        <p className=\"text-muted-foreground\">Select a provider first to configure model settings</p>\n      ) : (\n        <Form />\n      )}\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/agent-settings.tsx"
    },
    {
      "path": "src/components/formedible/ai/parser-settings.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { \n  parserConfigFields, \n  defaultParserConfig, \n  validateParserConfig,\n  mergeParserConfig,\n  generateSystemPrompt,\n  type ParserConfig \n} from \"@/lib/formedible/parser-config-schema\";\nimport { Info, RotateCcw, Copy, Check } from \"lucide-react\";\n\ninterface ParserSettingsProps {\n  className?: string;\n  onConfigChange?: (config: ParserConfig) => void;\n}\n\nexport function ParserSettings({ className, onConfigChange }: ParserSettingsProps) {\n  const [config, setConfig] = useState<ParserConfig>(defaultParserConfig);\n  const [lastSavedConfig, setLastSavedConfig] = useState<ParserConfig>(defaultParserConfig);\n  const [copied, setCopied] = useState(false);\n\n  // Load saved config on mount\n  useEffect(() => {\n    try {\n      const saved = localStorage.getItem('formedible-parser-config');\n      if (saved) {\n        const parsed = JSON.parse(saved);\n        if (validateParserConfig(parsed)) {\n          setConfig(parsed);\n          setLastSavedConfig(parsed);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load parser config:', error);\n    }\n  }, []);\n\n  // Check if there are unsaved changes\n  const hasChanges = JSON.stringify(config) !== JSON.stringify(lastSavedConfig);\n\n  // Save config to localStorage and notify parent\n  const handleSaveConfig = (newConfig: ParserConfig) => {\n    try {\n      localStorage.setItem('formedible-parser-config', JSON.stringify(newConfig));\n      setConfig(newConfig);\n      setLastSavedConfig(newConfig);\n      onConfigChange?.(newConfig);\n    } catch (error) {\n      console.error('Failed to save parser config:', error);\n    }\n  };\n\n  // Reset to defaults\n  const handleReset = () => {\n    const resetConfig = { ...defaultParserConfig };\n    handleSaveConfig(resetConfig);\n  };\n\n  // Copy system prompt to clipboard\n  const handleCopySystemPrompt = async () => {\n    try {\n      const systemPrompt = generateSystemPrompt(lastSavedConfig);\n      const promptToCopy = systemPrompt || 'System prompt will be generated based on current configuration...';\n      \n      await navigator.clipboard.writeText(promptToCopy);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy system prompt:', error);\n    }\n  };\n\n  // Create form fields with conditional logic\n  const formFields = [\n    // Basic Configuration Section\n    ...parserConfigFields\n      .filter(field => \n        ['strictValidation', 'enableSchemaInference', 'fieldTypeValidation'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n      })),\n    \n    // Show Advanced Settings (after basic fields)\n    {\n      name: 'showAdvanced',\n      type: 'switch',\n      label: 'Show Advanced Settings',\n      description: 'Display advanced configuration options',\n      defaultValue: false,\n    },\n    \n    // Advanced Configuration Section (conditional)\n    ...parserConfigFields\n      .filter(field => \n        !['strictValidation', 'enableSchemaInference', 'fieldTypeValidation', 'selectFields', 'systemPromptFields', 'includeTabFormatting', 'includePageFormatting'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n        conditional: (values: any) => values.showAdvanced === true,\n      })),\n\n    // System Prompt Fields\n    ...parserConfigFields\n      .filter(field => \n        ['selectFields', 'systemPromptFields'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n        conditional: field.name === 'systemPromptFields'\n          ? (values: any) => values.selectFields === true\n          : undefined\n      })),\n\n    // Formatting Options (always visible)\n    ...parserConfigFields\n      .filter(field => \n        ['includeTabFormatting', 'includePageFormatting'].includes(field.name)\n      )\n  ];\n\n  const { Form, form } = useFormedible<ParserConfig & { showAdvanced: boolean }>({\n    fields: formFields,\n    formOptions: {\n      defaultValues: { \n        ...config, \n        showAdvanced: false,\n        // Ensure all system prompt fields have proper defaults\n        selectFields: config.selectFields ?? false,\n        systemPromptFields: config.systemPromptFields ?? defaultParserConfig.systemPromptFields,\n        includeTabFormatting: config.includeTabFormatting ?? defaultParserConfig.includeTabFormatting,\n        includePageFormatting: config.includePageFormatting ?? defaultParserConfig.includePageFormatting\n      },\n      onSubmit: async ({ value }) => {\n        // Extract showAdvanced and save the rest\n        const { showAdvanced, ...parserConfig } = value;\n        const mergedConfig = mergeParserConfig({ ...config, ...parserConfig });\n        handleSaveConfig(mergedConfig);\n      },\n      // NO onChange - we only update when the user clicks Save!\n    },\n    submitLabel: hasChanges ? \"Save Settings\" : \"Settings Saved\",\n    showSubmitButton: hasChanges,\n    autoSubmitOnChange: false,\n    layout: {\n      type: 'grid',\n      columns: 1,\n      gap: 'md'\n    }\n  });\n\n  return (\n    <div className={`space-y-4 ${className || \"\"}`}>\n      <Card>\n        <CardHeader className=\"pb-3\">\n          <CardTitle className=\"flex items-center gap-2 text-base\">\n            <Info className=\"h-4 w-4\" />\n            Form Parser Settings\n          </CardTitle>\n          <CardDescription>\n            Configure how the Formedible parser processes form definitions and handles AI interactions.\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n\n          {/* Formedible Form */}\n          <div className=\"space-y-4\">\n            <Form />\n          </div>\n\n          {/* Action Buttons */}\n          <div className=\"flex flex-wrap gap-2 pt-4 border-t\">\n            <Button \n              onClick={handleReset}\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"flex items-center gap-2\"\n            >\n              <RotateCcw className=\"h-3 w-3\" />\n              Reset to Defaults\n            </Button>\n            \n            <Button\n              onClick={handleCopySystemPrompt}\n              variant={copied ? \"default\" : \"outline\"}\n              size=\"sm\"\n              className=\"flex items-center gap-2\"\n            >\n              {copied ? (\n                <>\n                  <Check className=\"h-3 w-3\" />\n                  Copied!\n                </>\n              ) : (\n                <>\n                  <Copy className=\"h-3 w-3\" />\n                  Copy Prompt\n                </>\n              )}\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* System Prompt Preview */}\n      <Card>\n        <CardHeader className=\"pb-3\">\n          <CardTitle className=\"text-sm\">System Prompt Preview</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"p-3 bg-muted rounded-md text-xs overflow-auto max-h-64\">\n            <pre className=\"whitespace-pre-wrap\">\n              {generateSystemPrompt(lastSavedConfig) || 'System prompt will be generated based on current saved configuration...'}\n            </pre>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/parser-settings.tsx"
    },
    {
      "path": "src/components/formedible/ai/sandpack-preview.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useCallback, useMemo } from \"react\";\nimport { \n  SandpackProvider, \n  SandpackLayout, \n  SandpackPreview as SandpackPreviewComponent,\n  SandpackConsole,\n  SandpackFileExplorer,\n  SandpackCodeEditor,\n  SandpackFiles,\n  SandpackPredefinedTemplate\n} from \"@codesandbox/sandpack-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { AlertTriangle, Loader2, CheckCircle, XCircle } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { \n  injectFormCodeIntoSandbox,\n  validateFormCode,\n  createSandboxFiles,\n  type SandboxFiles as SandboxFilesType,\n  type InjectionOptions\n} from \"@/lib/sandbox-code-injector\";\n\nexport interface SandpackPreviewProps {\n  /** The generated form code to preview */\n  formCode?: string;\n  /** Callback when form is submitted in the sandbox */\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  /** Callback when form error occurs in the sandbox */\n  onFormError?: (error: Error) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** Whether to show the code editor alongside preview */\n  showCodeEditor?: boolean;\n  /** Whether to show console output */\n  showConsole?: boolean;\n  /** Whether to show file explorer */\n  showFileExplorer?: boolean;\n  /** Template to use for the sandbox */\n  template?: SandpackPredefinedTemplate;\n  /** Whether the component is in loading state */\n  isLoading?: boolean;\n  /** Custom height for the preview */\n  height?: string;\n  /** Options for code injection */\n  injectionOptions?: InjectionOptions;\n  /** Whether to show validation status */\n  showValidationStatus?: boolean;\n  /** Custom styles to inject */\n  customStyles?: string;\n}\n\n// Default template files for Formedible forms\nconst DEFAULT_FORMEDIBLE_FILES: SandpackFiles = {\n  \"/App.tsx\": `import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport FormComponent from './FormComponent';\nimport './styles.css';\n\nfunction App() {\n  const handleFormSubmit = (data: Record<string, unknown>) => {\n    console.log('Form submitted:', data);\n    \n    // Notify parent component if available\n    if (window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_SUBMIT',\n        data: data\n      }, '*');\n    }\n  };\n\n  return (\n    <div className=\"p-4 max-w-2xl mx-auto\">\n      <FormComponent onSubmit={handleFormSubmit} />\n    </div>\n  );\n}\n\nconst container = document.getElementById('root');\nif (container) {\n  const root = createRoot(container);\n  root.render(<App />);\n}`,\n  \n  \"/FormComponent.tsx\": `import React from 'react';\n\ninterface FormComponentProps {\n  onSubmit?: (data: Record<string, unknown>) => void;\n}\n\nexport default function FormComponent({ onSubmit }: FormComponentProps) {\n  return (\n    <div className=\"p-6 border border-gray-200 rounded-lg bg-white\">\n      <h2 className=\"text-lg font-semibold mb-4\">Loading Form...</h2>\n      <p className=\"text-gray-600\">\n        Your generated form will appear here once the code is processed.\n      </p>\n    </div>\n  );\n}`,\n  \n  \"/styles.css\": `body {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;\n  background-color: #f8f9fa;\n}\n\n.form-container {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n  color: #374151;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n.submit-button {\n  background-color: #3b82f6;\n  color: white;\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.submit-button:hover {\n  background-color: #2563eb;\n}\n\n.error-message {\n  color: #ef4444;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}`,\n\n  \"/package.json\": `{\n  \"name\": \"formedible-preview\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\"\n  },\n  \"main\": \"/App.tsx\"\n}`\n};\n\nexport function SandpackPreview({\n  formCode,\n  onFormSubmit,\n  onFormError,\n  className,\n  showCodeEditor = false,\n  showConsole = false,\n  showFileExplorer = false,\n  template = \"react-ts\",\n  isLoading = false,\n  height = \"500px\",\n  injectionOptions,\n  showValidationStatus = true,\n  customStyles\n}: SandpackPreviewProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [isInitializing, setIsInitializing] = useState(true);\n  const [validationStatus, setValidationStatus] = useState<ReturnType<typeof validateFormCode> | null>(null);\n\n  // Create files object with the form code injected using the new utility\n  const files = useMemo((): SandpackFiles => {\n    if (!formCode) {\n      // Return default files when no form code is provided\n      return createSandboxFiles(\"\", {\n        ...injectionOptions,\n        customStyles\n      });\n    }\n\n    try {\n      // Validate the form code first\n      const validation = validateFormCode(formCode);\n      setValidationStatus(validation);\n\n      if (!validation.isValid) {\n        console.warn(\"Form code validation failed:\", validation.errors);\n        setError(`Validation failed: ${validation.errors.join(', ')}`);\n      } else {\n        setError(null);\n      }\n\n      // Use the injection utility to create sandbox files\n      const baseFiles: SandboxFilesType = {};\n      const injectedFiles = injectFormCodeIntoSandbox(\n        baseFiles,\n        formCode,\n        {\n          useErrorBoundary: true,\n          strictTypeScript: true,\n          customStyles,\n          ...injectionOptions\n        }\n      );\n\n      return injectedFiles;\n    } catch (err) {\n      console.error(\"Error processing form code:\", err);\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(`Failed to process form code: ${errorMessage}`);\n      \n      // Return fallback files\n      return createSandboxFiles(\"\", {\n        ...injectionOptions,\n        customStyles\n      });\n    }\n  }, [formCode, injectionOptions, customStyles]);\n\n  // Handle initialization complete\n  const handleBundlerLoad = useCallback(() => {\n    setIsInitializing(false);\n    setError(null);\n  }, []);\n\n  // Handle runtime errors\n  const handleError = useCallback((error: Error) => {\n    console.error(\"Sandpack error:\", error);\n    setError(error.message);\n    setIsInitializing(false);\n    onFormError?.(error);\n  }, [onFormError]);\n\n  // Handle form submission and error messages from the sandbox\n  React.useEffect(() => {\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data?.type === 'FORM_SUBMIT' && onFormSubmit) {\n        onFormSubmit(event.data.data);\n      } else if (event.data?.type === 'FORM_ERROR' && onFormError) {\n        const error = new Error(event.data.error || 'Unknown form error');\n        onFormError(error);\n      }\n    };\n\n    window.addEventListener('message', handleMessage);\n    return () => window.removeEventListener('message', handleMessage);\n  }, [onFormSubmit, onFormError]);\n\n  if (isLoading) {\n    return (\n      <div className={cn(\"space-y-4\", className)} style={{ height }}>\n        <div className=\"flex items-center gap-2\">\n          <Loader2 className=\"h-4 w-4 animate-spin\" />\n          <span className=\"text-sm text-muted-foreground\">Loading preview environment...</span>\n        </div>\n        <Skeleton className=\"w-full h-full rounded-lg\" />\n      </div>\n    );\n  }\n\n  // Render validation status if enabled\n  const renderValidationStatus = () => {\n    if (!showValidationStatus || !validationStatus) return null;\n\n    return (\n      <div className=\"mb-4 p-3 rounded-lg border\">\n        <div className=\"flex items-center gap-2 mb-2\">\n          {validationStatus.isValid ? (\n            <CheckCircle className=\"h-4 w-4 text-green-600\" />\n          ) : (\n            <XCircle className=\"h-4 w-4 text-red-600\" />\n          )}\n          <span className=\"font-medium text-sm\">\n            {validationStatus.isValid ? \"Code Validated\" : \"Validation Issues\"}\n          </span>\n        </div>\n        \n        {validationStatus.errors.length > 0 && (\n          <div className=\"space-y-1\">\n            <p className=\"text-xs font-medium text-red-600\">Errors:</p>\n            {validationStatus.errors.map((error, index) => (\n              <p key={index} className=\"text-xs text-red-600\">• {error}</p>\n            ))}\n          </div>\n        )}\n        \n        {validationStatus.warnings.length > 0 && (\n          <div className=\"space-y-1 mt-2\">\n            <p className=\"text-xs font-medium text-yellow-600\">Warnings:</p>\n            {validationStatus.warnings.map((warning, index) => (\n              <p key={index} className=\"text-xs text-yellow-600\">• {warning}</p>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  if (error) {\n    return (\n      <div className={cn(\"space-y-4\", className)} style={{ height }}>\n        {renderValidationStatus()}\n        <Alert className=\"h-full flex flex-col justify-center\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription className=\"mt-2\">\n            <strong>Preview Error:</strong> {error}\n            <br />\n            <span className=\"text-sm text-muted-foreground mt-2 block\">\n              The form preview encountered an error. Please check the generated code and try again.\n            </span>\n          </AlertDescription>\n        </Alert>\n      </div>\n    );\n  }\n\n  try {\n    return (\n      <div className={cn(\"w-full overflow-hidden\", className)} style={{ minHeight: height }}>\n        {renderValidationStatus()}\n        <SandpackProvider\n          template={template}\n          files={files}\n          options={{\n            bundlerURL: \"https://sandpack-bundler.codesandbox.io\",\n            visibleFiles: showCodeEditor ? [\"/FormComponent.tsx\", \"/App.tsx\"] : [],\n            activeFile: \"/FormComponent.tsx\",\n            initMode: \"lazy\",\n            autorun: true,\n            autoReload: true\n          }}\n          customSetup={{\n            dependencies: {\n              \"react\": \"^18.2.0\",\n              \"react-dom\": \"^18.2.0\",\n              \"@types/react\": \"^18.2.0\",\n              \"@types/react-dom\": \"^18.2.0\"\n            }\n          }}\n        >\n          <SandpackLayout \n            style={{ height, borderRadius: \"8px\" }}\n            className=\"border\"\n          >\n            {showFileExplorer && <SandpackFileExplorer />}\n            {showCodeEditor && (\n              <SandpackCodeEditor\n                showTabs\n                showLineNumbers\n                showInlineErrors\n                closableTabs\n                wrapContent\n              />\n            )}\n            <SandpackPreviewComponent\n              showOpenInCodeSandbox={false}\n              showRefreshButton={true}\n              showNavigator={false}\n              style={{ height: \"100%\" }}\n            />\n            {showConsole && (\n              <SandpackConsole\n                showHeader={true}\n                showSyntaxError={true}\n                maxMessageCount={100}\n                resetOnPreviewRestart={true}\n              />\n            )}\n          </SandpackLayout>\n        </SandpackProvider>\n      </div>\n    );\n  } catch (err) {\n    console.error(\"Error rendering Sandpack:\", err);\n    return (\n      <Alert className={cn(\"h-full flex flex-col justify-center\", className)}>\n        <AlertTriangle className=\"h-4 w-4\" />\n        <AlertDescription>\n          <strong>Failed to initialize live preview.</strong>\n          <br />\n          <span className=\"text-sm text-muted-foreground mt-2 block\">\n            Please try refreshing or switch to static preview mode.\n          </span>\n        </AlertDescription>\n      </Alert>\n    );\n  }\n}\n\nexport default SandpackPreview;",
      "type": "registry:component",
      "target": "components/formedible/ai/sandpack-preview.tsx"
    },
    {
      "path": "src/lib/form-extraction-utils.ts",
      "content": "/**\n * Shared utility functions for extracting formedible code from messages\n * This ensures DRY principle and consistent behavior between streaming and loading\n */\n\nexport interface ExtractedForm {\n  id: string;\n  code: string;\n  timestamp: Date;\n}\n\n/**\n * Extracts formedible code from a single message content\n */\nexport function extractFormedibleCode(content: string): string | null {\n  const formedibleMatch = content.match(/```formedible\\s*\\n([\\s\\S]*?)\\n```/);\n  return formedibleMatch && formedibleMatch[1] ? formedibleMatch[1].trim() : null;\n}\n\n/**\n * Extracts all forms from conversation messages\n */\nexport function extractFormsFromMessages(\n  messages: Array<{ role: string; content: string }>,\n  conversationId?: string,\n  baseTimestamp?: Date\n): ExtractedForm[] {\n  const extractedForms: ExtractedForm[] = [];\n  \n  messages.forEach((message, messageIndex) => {\n    if (message.role === 'assistant' && message.content) {\n      const code = extractFormedibleCode(message.content);\n      if (code) {\n        extractedForms.push({\n          id: conversationId \n            ? `form_${conversationId}_${messageIndex}`\n            : `form_${Date.now()}_${messageIndex}`,\n          code,\n          timestamp: baseTimestamp || new Date()\n        });\n      }\n    }\n  });\n  \n  return extractedForms;\n}",
      "type": "registry:lib",
      "target": "lib/form-extraction-utils.ts"
    },
    {
      "path": "src/lib/sandbox-code-injector.ts",
      "content": "/**\n * Sandbox Code Injection Utility for Formedible AI Builder\n * \n * This utility handles the injection of generated form code into Sandpack sandbox files,\n * providing validation, error handling, and proper TypeScript type safety.\n */\n\nimport { SandpackFiles } from \"@codesandbox/sandpack-react\";\nimport sandboxTemplates from \"./sandbox-templates.json\";\nimport { \n  createFormedibleSandbox, \n  generateFormComponentFromFields, \n  getTemplateByComplexity,\n  FORMEDIBLE_SANDBOX_DEPENDENCIES,\n  TEMPLATE_VARIATIONS,\n  type TemplateVariation\n} from './sandbox-templates';\n\n// Type definitions for sandbox injection\nexport interface SandboxFiles {\n  [path: string]: {\n    code: string;\n    hidden?: boolean;\n  };\n}\n\nexport interface CodeValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  extractedComponent?: string;\n  hasImports?: boolean;\n  hasExports?: boolean;\n}\n\nexport interface FormCodeMeta {\n  componentName?: string;\n  hasTypeScript: boolean;\n  hasJSX: boolean;\n  hasFormedibleImports: boolean;\n  imports: string[];\n  exports: string[];\n}\n\nexport interface InjectionOptions {\n  /** Whether to wrap the code in error boundaries */\n  useErrorBoundary?: boolean;\n  /** Additional dependencies to inject */\n  additionalDependencies?: Record<string, string>;\n  /** Custom CSS to include */\n  customStyles?: string;\n  /** Whether to enable TypeScript strict mode */\n  strictTypeScript?: boolean;\n  /** Target file for the form component */\n  targetFile?: string;\n  /** Template complexity level */\n  templateComplexity?: \"basic\" | \"intermediate\" | \"advanced\";\n  /** Form configuration for dynamic generation */\n  formConfig?: {\n    fields?: any[];\n    multiPage?: boolean;\n    hasConditional?: boolean;\n    title?: string;\n    description?: string;\n  };\n  /** Whether to use enhanced Formedible templates */\n  useEnhancedTemplates?: boolean;\n}\n\n/**\n * Formedible-sandbox repository dependencies (from https://github.com/DimitriGilbert/formedible-sandbox)\n */\nconst FORMEDIBLE_SANDBOX_DEPENDENCIES_FROM_REPO = {\n  \"react\": \"^19.1.1\",\n  \"react-dom\": \"^19.1.1\",\n  \"@types/react\": \"^18.3.17\",\n  \"@types/react-dom\": \"^18.3.5\",\n  \"@radix-ui/react-accordion\": \"^1.2.2\",\n  \"@radix-ui/react-checkbox\": \"^1.1.4\",\n  \"@radix-ui/react-dialog\": \"^1.1.4\",\n  \"@radix-ui/react-label\": \"^2.1.1\",\n  \"@radix-ui/react-popover\": \"^1.1.4\",\n  \"@radix-ui/react-progress\": \"^1.1.1\",\n  \"@radix-ui/react-radio-group\": \"^1.2.2\",\n  \"@radix-ui/react-select\": \"^2.1.4\",\n  \"@radix-ui/react-slider\": \"^1.2.2\",\n  \"@radix-ui/react-switch\": \"^1.1.2\",\n  \"@radix-ui/react-tabs\": \"^1.1.2\",\n  \"@tanstack/react-form\": \"^0.38.1\",\n  \"clsx\": \"^2.1.1\",\n  \"tailwind-merge\": \"^2.6.0\",\n  \"zod\": \"^3.24.1\",\n  \"sonner\": \"^1.7.1\",\n  \"typescript\": \"^5.7.2\"\n};\n\n/**\n * Default sandbox file templates\n */\nconst DEFAULT_SANDBOX_TEMPLATES = {\n  APP_TSX: `import \"./App.css\";\nimport { GeneratedFormComponent } from \"./GeneratedFormComponent\";\n\nfunction App() {\n  return (\n    <>\n      <GeneratedFormComponent />\n    </>\n  );\n}\n\nexport default App;`,\n\n  FALLBACK_FORM: `import React from 'react';\n\ninterface FormComponentProps {\n  onSubmit?: (data: Record<string, unknown>) => void;\n  onError?: (error: Error) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError }: FormComponentProps) {\n  return (\n    <div className=\"p-6 border border-gray-200 rounded-lg bg-white\">\n      <h2 className=\"text-xl font-semibold mb-4 text-gray-800\">\n        Form Preview\n      </h2>\n      <div className=\"space-y-4\">\n        <p className=\"text-gray-600\">\n          Your generated form will appear here once the code is processed.\n        </p>\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n          <p className=\"text-blue-800 text-sm\">\n            <strong>Note:</strong> The form is being prepared for preview. \n            If you see this message for more than a few seconds, there may be an issue with the generated code.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}`,\n\n  ERROR_BOUNDARY: `import React, { Component, ReactNode } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n}\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  onError?: (error: Error) => void;\n}\n\nclass FormErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Form error boundary caught an error:', error, errorInfo);\n    this.props.onError?.(error);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-6 border border-red-200 rounded-lg bg-red-50\">\n          <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n            Form Rendering Error\n          </h3>\n          <p className=\"text-red-600 mb-4\">\n            There was an error rendering the form component. Please check the generated code for syntax errors.\n          </p>\n          {this.state.error && (\n            <details className=\"text-sm\">\n              <summary className=\"cursor-pointer text-red-700 font-medium\">\n                Error Details\n              </summary>\n              <pre className=\"mt-2 p-2 bg-red-100 rounded text-red-800 text-xs overflow-auto\">\n                {this.state.error.toString()}\n              </pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default FormErrorBoundary;`,\n\n  BASE_STYLES: `/* Formedible Form Preview Styles */\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', sans-serif;\n  background-color: #f8f9fa;\n  line-height: 1.6;\n}\n\n/* Form Container Styles */\n.form-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n/* Field Group Styles */\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n  color: #374151;\n  font-size: 0.875rem;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  transition: border-color 0.2s, box-shadow 0.2s;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n.field-input:invalid {\n  border-color: #ef4444;\n}\n\n.field-input:invalid:focus {\n  border-color: #ef4444;\n  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);\n}\n\n/* Button Styles */\n.submit-button, .primary-button {\n  background-color: #3b82f6;\n  color: white;\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s, transform 0.1s;\n}\n\n.submit-button:hover, .primary-button:hover {\n  background-color: #2563eb;\n}\n\n.submit-button:active, .primary-button:active {\n  transform: translateY(1px);\n}\n\n.secondary-button {\n  background-color: #f3f4f6;\n  color: #374151;\n  padding: 0.75rem 1.5rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.secondary-button:hover {\n  background-color: #e5e7eb;\n}\n\n/* Error and Success Messages */\n.error-message {\n  color: #ef4444;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n.success-message {\n  color: #10b981;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n/* Loading States */\n.loading {\n  opacity: 0.7;\n  pointer-events: none;\n}\n\n.spinner {\n  border: 2px solid #f3f3f3;\n  border-top: 2px solid #3b82f6;\n  border-radius: 50%;\n  width: 1rem;\n  height: 1rem;\n  animation: spin 1s linear infinite;\n  display: inline-block;\n  margin-right: 0.5rem;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n  .form-container {\n    padding: 1rem;\n  }\n  \n  .field-input,\n  .submit-button,\n  .primary-button,\n  .secondary-button {\n    font-size: 0.875rem;\n    padding: 0.625rem 1rem;\n  }\n}`\n};\n\n/**\n * Validates the generated form code for syntax and structure\n */\nexport function validateFormCode(formCode: string): CodeValidationResult {\n  const result: CodeValidationResult = {\n    isValid: true,\n    errors: [],\n    warnings: [],\n    hasImports: false,\n    hasExports: false\n  };\n\n  if (!formCode || formCode.trim().length === 0) {\n    result.isValid = false;\n    result.errors.push(\"Form code is empty or undefined\");\n    return result;\n  }\n\n  try {\n    // Check for basic React component structure\n    const hasReactImport = /import\\s+.*React.*from\\s+['\"]react['\"]/.test(formCode);\n    const hasJSXElements = /<[A-Za-z][^>]*>/.test(formCode);\n    const hasExportDefault = /export\\s+default/.test(formCode);\n    const hasExportFunction = /export\\s+(function|const)\\s+/.test(formCode);\n    \n    result.hasImports = /import\\s+.*from/.test(formCode);\n    result.hasExports = hasExportDefault || hasExportFunction;\n\n    if (!hasReactImport && hasJSXElements) {\n      result.warnings.push(\"JSX detected but React import is missing\");\n    }\n\n    if (!result.hasExports) {\n      result.errors.push(\"Component must have a default export or named export\");\n      result.isValid = false;\n    }\n\n    // Check for common syntax errors\n    const openBraces = (formCode.match(/{/g) || []).length;\n    const closeBraces = (formCode.match(/}/g) || []).length;\n    if (openBraces !== closeBraces) {\n      result.errors.push(`Mismatched braces: ${openBraces} opening, ${closeBraces} closing`);\n      result.isValid = false;\n    }\n\n    const openParens = (formCode.match(/\\(/g) || []).length;\n    const closeParens = (formCode.match(/\\)/g) || []).length;\n    if (openParens !== closeParens) {\n      result.errors.push(`Mismatched parentheses: ${openParens} opening, ${closeParens} closing`);\n      result.isValid = false;\n    }\n\n    // Extract component name if possible\n    const componentMatch = formCode.match(/(?:function|const)\\s+([A-Z][a-zA-Z0-9]*)/);\n    if (componentMatch) {\n      result.extractedComponent = componentMatch[1];\n    }\n\n    // Check for TypeScript syntax\n    if (/:\\s*[A-Z][a-zA-Z0-9<>[\\]|&\\s]*[=;]/.test(formCode) || /interface\\s+/.test(formCode)) {\n      result.warnings.push(\"TypeScript syntax detected - ensure proper type definitions\");\n    }\n\n    // Check for potential security issues (basic check)\n    const dangerousPatterns = [\n      /dangerouslySetInnerHTML/,\n      /eval\\s*\\(/,\n      /Function\\s*\\(/,\n      /document\\.write/,\n      /innerHTML\\s*=/\n    ];\n    \n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(formCode)) {\n        result.warnings.push(\"Potentially unsafe code detected - please review\");\n      }\n    }\n\n  } catch (error) {\n    result.isValid = false;\n    result.errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  return result;\n}\n\n/**\n * Extracts form component from generated code\n */\nexport function extractFormComponent(formCode: string): string {\n  if (!formCode || formCode.trim().length === 0) {\n    return DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM;\n  }\n\n  const validation = validateFormCode(formCode);\n  \n  if (!validation.isValid) {\n    console.warn(\"Form code validation failed:\", validation.errors);\n    // Return fallback but with error info\n    return `${DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM}\n    \n// Validation errors found in generated code:\n// ${validation.errors.map(error => `// - ${error}`).join('\\n')}`;\n  }\n\n  // If the code is valid, return it with proper formatting\n  return formCode.trim();\n}\n\n/**\n * Analyzes form code to extract metadata\n */\nexport function analyzeFormCode(formCode: string): FormCodeMeta {\n  const meta: FormCodeMeta = {\n    hasTypeScript: false,\n    hasJSX: false,\n    hasFormedibleImports: false,\n    imports: [],\n    exports: []\n  };\n\n  // Check for TypeScript\n  meta.hasTypeScript = /:\\s*[A-Z][a-zA-Z0-9<>[\\]|&\\s]*[=;]/.test(formCode) || \n                      /interface\\s+/.test(formCode) || \n                      /type\\s+/.test(formCode);\n\n  // Check for JSX\n  meta.hasJSX = /<[A-Za-z][^>]*>/.test(formCode);\n\n  // Extract imports\n  const importMatches = formCode.match(/import\\s+.*from\\s+['\"][^'\"]*['\"]/g);\n  if (importMatches) {\n    meta.imports = importMatches;\n    meta.hasFormedibleImports = importMatches.some(imp => \n      imp.includes('formedible') || \n      imp.includes('@/') ||\n      imp.includes('lucide-react')\n    );\n  }\n\n  // Extract exports\n  const exportMatches = formCode.match(/export\\s+(default\\s+)?(function|const|class)\\s+([A-Za-z][a-zA-Z0-9]*)/g);\n  if (exportMatches) {\n    meta.exports = exportMatches;\n    \n    // Try to extract component name\n    const componentMatch = exportMatches[0]?.match(/(?:function|const|class)\\s+([A-Z][a-zA-Z0-9]*)/);\n    if (componentMatch) {\n      meta.componentName = componentMatch[1];\n    }\n  }\n\n  return meta;\n}\n\n/**\n * Creates complete sandbox files with proper structure\n */\nexport function createSandboxFiles(\n  formCode: string, \n  options: InjectionOptions = {}\n): SandpackFiles {\n  const {\n    useErrorBoundary = true,\n    additionalDependencies = {},\n    customStyles = \"\",\n    strictTypeScript = true,\n    targetFile = \"/GeneratedFormComponent.tsx\",\n    templateComplexity = \"basic\",\n    formConfig,\n    useEnhancedTemplates = true\n  } = options;\n\n  // If using enhanced templates, create a complete Formedible sandbox\n  if (useEnhancedTemplates) {\n    let enhancedFormCode = formCode;\n    \n    // Generate form component from fields if configuration is provided\n    if (formConfig?.fields && formConfig.fields.length > 0) {\n      enhancedFormCode = generateFormComponentFromFields(formConfig.fields, formConfig);\n    } else if (!formCode || formCode.trim().length === 0) {\n      // Use template based on complexity\n      const template = getTemplateByComplexity(templateComplexity);\n      enhancedFormCode = template.formComponent;\n    }\n\n    // Create enhanced sandbox with complete Formedible integration\n    const enhancedSandbox = createFormedibleSandbox(enhancedFormCode, templateComplexity);\n    \n    // Merge with additional dependencies\n    if (Object.keys(additionalDependencies).length > 0) {\n      const packageJson = JSON.parse(enhancedSandbox[\"/package.json\"].code);\n      packageJson.dependencies = { ...packageJson.dependencies, ...additionalDependencies };\n      enhancedSandbox[\"/package.json\"].code = JSON.stringify(packageJson, null, 2);\n    }\n    \n    // Add custom styles if provided\n    if (customStyles) {\n      enhancedSandbox[\"/styles.css\"].code += `\\n\\n/* Custom Styles */\\n${customStyles}`;\n    }\n    \n    return enhancedSandbox;\n  }\n\n  // Validate and extract form component\n  const extractedFormCode = extractFormComponent(formCode);\n  const formMeta = analyzeFormCode(extractedFormCode);\n\n  // Create base files\n  const files: SandboxFiles = {\n    \"/App.tsx\": {\n      code: DEFAULT_SANDBOX_TEMPLATES.APP_TSX\n    },\n    [targetFile]: {\n      code: extractedFormCode\n    },\n    \"/styles.css\": {\n      code: DEFAULT_SANDBOX_TEMPLATES.BASE_STYLES + (customStyles ? `\\n\\n/* Custom Styles */\\n${customStyles}` : \"\")\n    },\n    \"/package.json\": {\n      code: JSON.stringify({\n        name: \"formedible-preview\",\n        version: \"1.0.0\",\n        dependencies: {\n          ...FORMEDIBLE_SANDBOX_DEPENDENCIES_FROM_REPO,\n          ...additionalDependencies\n        },\n        main: \"/App.tsx\",\n        ...(strictTypeScript && {\n          devDependencies: {\n            \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n            \"@typescript-eslint/parser\": \"^6.0.0\"\n          }\n        })\n      }, null, 2)\n    }\n  };\n\n  // Add error boundary if requested\n  if (useErrorBoundary) {\n    files[\"/ErrorBoundary.tsx\"] = {\n      code: DEFAULT_SANDBOX_TEMPLATES.ERROR_BOUNDARY\n    };\n\n    // Update App.tsx to use error boundary\n    files[\"/App.tsx\"].code = files[\"/App.tsx\"].code.replace(\n      '<FormComponent',\n      `<ErrorBoundary onError={handleFormError}>\n          <FormComponent`\n    ).replace(\n      '/>',\n      '/>\\n        </ErrorBoundary>'\n    ).replace(\n      \"import FormComponent from './FormComponent';\",\n      `import FormComponent from './FormComponent';\nimport ErrorBoundary from './ErrorBoundary';`\n    );\n  }\n\n  // Add TypeScript config if needed\n  if (formMeta.hasTypeScript && strictTypeScript) {\n    files[\"/tsconfig.json\"] = {\n      code: JSON.stringify({\n        compilerOptions: {\n          target: \"es2018\",\n          lib: [\"dom\", \"dom.iterable\", \"es6\"],\n          allowJs: true,\n          skipLibCheck: true,\n          esModuleInterop: true,\n          allowSyntheticDefaultImports: true,\n          strict: true,\n          forceConsistentCasingInFileNames: true,\n          moduleResolution: \"node\",\n          resolveJsonModule: true,\n          isolatedModules: true,\n          noEmit: true,\n          jsx: \"react-jsx\"\n        },\n        include: [\"src\"]\n      }, null, 2),\n      hidden: true\n    };\n  }\n\n  return files;\n}\n\n/**\n * Main injection function - combines validation, extraction, and file creation\n */\nexport function injectFormCodeIntoSandbox(\n  baseSandboxFiles: SandboxFiles,\n  generatedFormCode: string,\n  options: InjectionOptions = {}\n): SandpackFiles {\n  try {\n    // If using enhanced templates, skip legacy validation for now\n    if (options.useEnhancedTemplates !== false) {\n      const enhancedOptions = {\n        ...options,\n        useEnhancedTemplates: true\n      };\n      \n      // Create new sandbox files with enhanced templates\n      const newFiles = createSandboxFiles(generatedFormCode, enhancedOptions);\n      \n      // Merge with base files if provided, giving priority to new files\n      const mergedFiles = { ...baseSandboxFiles, ...newFiles };\n      \n      return mergedFiles;\n    }\n    \n    // Legacy validation approach\n    const validation = validateFormCode(generatedFormCode);\n    \n    if (!validation.isValid) {\n      console.error(\"Form code validation failed:\", validation.errors);\n      \n      // Create fallback sandbox with error information\n      const fallbackFiles = createSandboxFiles(\n        DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM, \n        options\n      );\n      \n      // Add error information to the fallback\n      const fallbackFile = fallbackFiles[\"/FormComponent.tsx\"];\n      if (typeof fallbackFile === 'object' && fallbackFile.code) {\n        fallbackFile.code = `${DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM}\n\n/* \n * VALIDATION ERRORS:\n * ${validation.errors.map(error => ` * ${error}`).join('\\n')}\n */`;\n      }\n      \n      return fallbackFiles;\n    }\n\n    // Create new sandbox files with validated code\n    const newFiles = createSandboxFiles(generatedFormCode, options);\n    \n    // Merge with base files if provided, giving priority to new files\n    const mergedFiles = { ...baseSandboxFiles, ...newFiles };\n    \n    return mergedFiles;\n\n  } catch (error) {\n    console.error(\"Error injecting form code into sandbox:\", error);\n    \n    // Return safe fallback\n    return createSandboxFiles(DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM, options);\n  }\n}\n\n/**\n * Utility to update a single file in existing sandbox\n */\nexport function updateSandboxFile(\n  sandboxFiles: SandpackFiles,\n  filePath: string,\n  newContent: string\n): SandpackFiles {\n  const existingFile = sandboxFiles[filePath];\n  const newFile = typeof existingFile === 'object' \n    ? { ...existingFile, code: newContent }\n    : { code: newContent };\n    \n  return {\n    ...sandboxFiles,\n    [filePath]: newFile\n  };\n}\n\n/**\n * Utility to safely get file content from sandbox\n */\nexport function getSandboxFileContent(\n  sandboxFiles: SandpackFiles,\n  filePath: string\n): string | null {\n  const file = sandboxFiles[filePath];\n  if (typeof file === 'string') {\n    return file;\n  }\n  return file?.code || null;\n}\n\n/**\n * Get available template variations\n */\nexport function getAvailableTemplates(): TemplateVariation[] {\n  return TEMPLATE_VARIATIONS;\n}\n\n/**\n * Create a Formedible sandbox from field configuration\n */\nexport function createSandboxFromFields(\n  fields: any[],\n  options: Omit<InjectionOptions, 'formConfig'> & { \n    title?: string;\n    description?: string;\n    multiPage?: boolean;\n    hasConditional?: boolean;\n  } = {}\n): SandpackFiles {\n  const {\n    title,\n    description,\n    multiPage = false,\n    hasConditional = false,\n    ...injectionOptions\n  } = options;\n  \n  return createSandboxFiles('', {\n    ...injectionOptions,\n    useEnhancedTemplates: true,\n    formConfig: {\n      fields,\n      title,\n      description,\n      multiPage,\n      hasConditional\n    }\n  });\n}\n\n/**\n * Create a sandbox with a specific template\n */\nexport function createSandboxWithTemplate(\n  templateComplexity: \"basic\" | \"intermediate\" | \"advanced\" = \"basic\",\n  options: InjectionOptions = {}\n): SandpackFiles {\n  return createSandboxFiles('', {\n    ...options,\n    useEnhancedTemplates: true,\n    templateComplexity\n  });\n}",
      "type": "registry:lib",
      "target": "lib/sandbox-code-injector.ts"
    },
    {
      "path": "src/lib/sandbox-templates.ts",
      "content": "/**\n * Formedible Sandbox Templates for AI Builder\n * \n * This module provides comprehensive sandbox templates that replicate real Formedible functionality\n * for the Sandpack live preview environment. Templates support all Formedible features including\n * multi-page forms, conditional logic, validation, and various field types.\n */\n\nimport type { SandboxFiles } from \"./sandbox-code-injector\";\n\n/**\n * Dependencies for Formedible sandbox environment\n */\nexport const FORMEDIBLE_SANDBOX_DEPENDENCIES = {\n  \"react\": \"^18.2.0\",\n  \"react-dom\": \"^18.2.0\",\n  \"@types/react\": \"^18.2.0\",\n  \"@types/react-dom\": \"^18.2.0\",\n  \"typescript\": \"^5.0.0\",\n  \"@tanstack/react-form\": \"^1.19.2\",\n  \"lucide-react\": \"^0.263.1\",\n  \"clsx\": \"^2.0.0\",\n  \"tailwind-merge\": \"^2.0.0\",\n  \"zod\": \"^3.22.0\",\n  \"@radix-ui/react-label\": \"^2.1.7\",\n  \"@radix-ui/react-progress\": \"^1.1.7\",\n  \"@radix-ui/react-select\": \"^2.2.5\",\n  \"@radix-ui/react-checkbox\": \"^1.3.2\",\n  \"@radix-ui/react-radio-group\": \"^1.3.7\",\n  \"@radix-ui/react-slider\": \"^1.3.5\",\n  \"@radix-ui/react-switch\": \"^1.2.5\",\n  \"@radix-ui/react-tabs\": \"^1.1.12\",\n  \"class-variance-authority\": \"^0.7.1\",\n  \"sonner\": \"^2.0.7\"\n};\n\n/**\n * Base App.tsx template for Formedible sandbox\n */\nexport const FORMEDIBLE_APP_TEMPLATE = `import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport FormComponent from './FormComponent';\nimport { Toaster } from 'sonner';\nimport './styles.css';\n\ninterface FormData {\n  [key: string]: unknown;\n}\n\nfunction App() {\n  const handleFormSubmit = (data: FormData) => {\n    console.log('Form submitted:', data);\n    \n    // Show success notification\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_SUBMIT',\n        data: data,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  const handleFormError = (error: Error) => {\n    console.error('Form error:', error);\n    \n    // Notify parent component of error\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_ERROR',\n        error: error.message,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  const handleFormChange = (data: FormData) => {\n    console.log('Form changed:', data);\n    \n    // Optional: notify parent of form changes for real-time preview\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_CHANGE',\n        data: data,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-4\">\n      <div className=\"max-w-4xl mx-auto\">\n        <div className=\"bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden\">\n          <div className=\"px-6 py-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-b border-gray-200\">\n            <h1 className=\"text-2xl font-bold text-gray-900\">Form Preview</h1>\n            <p className=\"text-gray-600 mt-1\">Generated with Formedible AI Builder</p>\n          </div>\n          <div className=\"p-6\">\n            <FormComponent \n              onSubmit={handleFormSubmit} \n              onError={handleFormError}\n              onChange={handleFormChange}\n            />\n          </div>\n        </div>\n      </div>\n      <Toaster position=\"top-right\" />\n    </div>\n  );\n}\n\nconst container = document.getElementById('root');\nif (container) {\n  const root = createRoot(container);\n  root.render(<App />);\n} else {\n  console.error('Root container not found');\n}`;\n\n/**\n * useFormedible hook implementation for sandbox environment\n */\nexport const USE_FORMEDIBLE_HOOK_TEMPLATE = `import React, { useState, useMemo } from \"react\";\nimport { useForm } from \"@tanstack/react-form\";\nimport type { AnyFormApi, AnyFieldApi } from \"@tanstack/react-form\";\nimport { cn } from \"./utils\";\nimport type {\n  FormedibleFormApi,\n  FieldComponentProps,\n  BaseFieldProps,\n  FieldConfig,\n  FormProps,\n  UseFormedibleOptions,\n} from \"./types\";\nimport { Button } from \"./components/ui/button\";\nimport { Progress } from \"./components/ui/progress\";\nimport { TextField } from \"./components/fields/text-field\";\nimport { TextareaField } from \"./components/fields/textarea-field\";\nimport { SelectField } from \"./components/fields/select-field\";\nimport { CheckboxField } from \"./components/fields/checkbox-field\";\nimport { NumberField } from \"./components/fields/number-field\";\nimport { RadioField } from \"./components/fields/radio-field\";\n\n// Field components registry\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  number: NumberField,\n  radio: RadioField,\n};\n\nconst DefaultProgressComponent: React.FC<{\n  value: number;\n  currentPage: number;\n  totalPages: number;\n  className?: string;\n}> = ({ value, currentPage, totalPages, className }) => (\n  <div className={cn(\"space-y-2\", className)}>\n    <div className=\"flex justify-between text-sm text-gray-600\">\n      <span>Step {currentPage} of {totalPages}</span>\n      <span>{Math.round(value)}%</span>\n    </div>\n    <Progress value={value} className=\"h-2\" />\n  </div>\n);\n\nexport function useFormedible<TFormValues extends Record<string, unknown>>(\n  options: UseFormedibleOptions<TFormValues>\n) {\n  const {\n    fields = [],\n    submitLabel = \"Submit\",\n    nextLabel = \"Next\",\n    previousLabel = \"Previous\",\n    formClassName,\n    fieldClassName,\n    labelClassName,\n    buttonClassName,\n    submitButtonClassName,\n    pages,\n    progress,\n    defaultComponents,\n    formOptions,\n    onPageChange,\n    disabled,\n    loading,\n    showSubmitButton = true,\n  } = options;\n\n  const [currentPage, setCurrentPage] = useState(1);\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\n\n  // Group fields by pages\n  const fieldsByPage = useMemo(() => {\n    const grouped: { [page: number]: FieldConfig[] } = {};\n    fields.forEach((field) => {\n      const page = field.page || 1;\n      if (!grouped[page]) grouped[page] = [];\n      grouped[page].push(field);\n    });\n    return grouped;\n  }, [fields]);\n\n  const totalPages = Math.max(...Object.keys(fieldsByPage).map(Number), 1);\n  const hasPages = totalPages > 1;\n  const progressValue = hasPages ? ((currentPage - 1) / (totalPages - 1)) * 100 : 100;\n\n  const form = useForm(formOptions || {});\n\n  const getCurrentPageFields = () => {\n    return fieldsByPage[currentPage] || [];\n  };\n\n  const goToNextPage = () => {\n    if (currentPage < totalPages) {\n      const newPage = currentPage + 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, \"next\");\n    }\n  };\n\n  const goToPreviousPage = () => {\n    if (currentPage > 1) {\n      const newPage = currentPage - 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, \"previous\");\n    }\n  };\n\n  const isLastPage = currentPage === totalPages;\n  const isFirstPage = currentPage === 1;\n\n  const renderField = React.useCallback((fieldConfig: FieldConfig) => {\n    const { name, type, label, placeholder, options, validation } = fieldConfig;\n\n    return (\n      <form.Field\n        key={name}\n        name={name as keyof TFormValues & string}\n        validators={\n          validation\n            ? {\n                onChange: ({ value }) => {\n                  const result = validation.safeParse(value);\n                  return result.success\n                    ? undefined\n                    : result.error.issues[0]?.message || \"Invalid value\";\n                },\n              }\n            : undefined\n        }\n      >\n        {(field) => {\n          const FieldComponent = fieldComponents[type] || TextField;\n          const baseProps = {\n            fieldApi: field as unknown as AnyFieldApi,\n            label,\n            placeholder,\n            wrapperClassName: fieldClassName,\n            labelClassName,\n            disabled: disabled || loading || field.form.state.isSubmitting,\n          };\n\n          let props: FieldComponentProps = { ...baseProps };\n\n          if (type === \"select\" && options) {\n            const normalizedOptions = options.map((opt) =>\n              typeof opt === \"string\" ? { value: opt, label: opt } : opt\n            );\n            props = { ...props, options: normalizedOptions };\n          } else if (type === \"radio\" && options) {\n            const normalizedOptions = options.map((opt) =>\n              typeof opt === \"string\" ? { value: opt, label: opt } : opt\n            );\n            props = { ...props, options: normalizedOptions };\n          }\n\n          return <FieldComponent {...props} />;\n        }}\n      </form.Field>\n    );\n  }, [fieldComponents, fieldClassName, labelClassName, disabled, loading]);\n\n  const Form: React.FC<FormProps> = ({ className, children, onSubmit, ...formProps }) => {\n    const handleSubmit = (e: React.FormEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (onSubmit) {\n        onSubmit(e);\n      } else if (isLastPage) {\n        form.handleSubmit();\n      } else {\n        goToNextPage();\n      }\n    };\n\n    const formClass = cn(\"space-y-6\", formClassName, className);\n    const currentFields = getCurrentPageFields();\n\n    const renderProgress = () => {\n      if (!hasPages || !progress) return null;\n      const ProgressComponent = progress.component || DefaultProgressComponent;\n      return (\n        <ProgressComponent\n          value={progressValue}\n          currentPage={currentPage}\n          totalPages={totalPages}\n          className={progress.className}\n        />\n      );\n    };\n\n    const renderNavigation = () => {\n      if (!showSubmitButton) return null;\n      \n      if (!hasPages) {\n        return (\n          <form.Subscribe\n            selector={(state) => ({\n              canSubmit: state.canSubmit,\n              isSubmitting: state.isSubmitting,\n            })}\n          >\n            {(state) => (\n              <div className=\"flex justify-end\">\n                <Button\n                  type=\"submit\"\n                  disabled={!state.canSubmit || state.isSubmitting || disabled || loading}\n                  className={cn(\"px-8\", submitButtonClassName)}\n                >\n                  {loading ? \"Loading...\" : state.isSubmitting ? \"Submitting...\" : submitLabel}\n                </Button>\n              </div>\n            )}\n          </form.Subscribe>\n        );\n      }\n\n      return (\n        <form.Subscribe\n          selector={(state) => ({\n            canSubmit: state.canSubmit,\n            isSubmitting: state.isSubmitting,\n          })}\n        >\n          {(state) => (\n            <div className=\"flex justify-between gap-4\">\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                onClick={goToPreviousPage}\n                disabled={isFirstPage || disabled || loading}\n                className={cn(isFirstPage ? \"invisible\" : \"\", buttonClassName)}\n              >\n                {previousLabel}\n              </Button>\n              <Button\n                type=\"submit\"\n                disabled={(!state.canSubmit || state.isSubmitting || disabled || loading) && isLastPage}\n                className={cn(\"px-8\", isLastPage ? submitButtonClassName : buttonClassName)}\n              >\n                {loading && isLastPage\n                  ? \"Loading...\"\n                  : state.isSubmitting && isLastPage\n                  ? \"Submitting...\"\n                  : isLastPage\n                  ? submitLabel\n                  : nextLabel}\n              </Button>\n            </div>\n          )}\n        </form.Subscribe>\n      );\n    };\n\n    return (\n      <form onSubmit={handleSubmit} className={formClass} {...formProps}>\n        {children || (\n          <>\n            {renderProgress()}\n            <div className=\"space-y-4\">\n              {currentFields.map((field) => renderField(field))}\n            </div>\n            {renderNavigation()}\n          </>\n        )}\n      </form>\n    );\n  };\n\n  return {\n    form,\n    Form,\n    currentPage,\n    totalPages,\n    goToNextPage,\n    goToPreviousPage,\n    isFirstPage,\n    isLastPage,\n    progressValue,\n  };\n}`;\n\n/**\n * Basic types file for sandbox environment\n */\nexport const FORMEDIBLE_TYPES_TEMPLATE = `import React from \"react\";\nimport type { AnyFieldApi } from \"@tanstack/react-form\";\nimport type { FormApi } from \"@tanstack/form-core\";\nimport { z } from \"zod\";\n\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\n  TFormData,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  never\n>;\n\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  placeholder?: string;\n  wrapperClassName?: string;\n  labelClassName?: string;\n  disabled?: boolean;\n}\n\nexport interface FieldComponentProps extends BaseFieldProps {\n  options?: Array<{ value: string; label: string }> | string[];\n  [key: string]: unknown;\n}\n\nexport interface FieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  required?: boolean;\n  defaultValue?: unknown;\n  options?: string[] | Array<{ value: string; label: string }>;\n  validation?: z.ZodSchema<unknown>;\n  page?: number;\n  [key: string]: unknown;\n}\n\nexport interface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  [key: string]: unknown;\n}\n\nexport interface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  labelClassName?: string;\n  buttonClassName?: string;\n  submitButtonClassName?: string;\n  pages?: Array<{ page: number; title?: string; description?: string }>;\n  progress?: {\n    component?: React.ComponentType<any>;\n    className?: string;\n  };\n  defaultComponents?: {\n    [key: string]: React.ComponentType<FieldComponentProps>;\n  };\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => unknown | Promise<unknown>;\n  }>;\n  onPageChange?: (page: number, direction: \"next\" | \"previous\") => void;\n  disabled?: boolean;\n  loading?: boolean;\n  showSubmitButton?: boolean;\n}`;\n\n/**\n * Utility functions for sandbox environment\n */\nexport const FORMEDIBLE_UTILS_TEMPLATE = `import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}`;\n\n/**\n * UI Components - Button\n */\nexport const BUTTON_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"../../utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }`;\n\n/**\n * UI Components - Progress\n */\nexport const PROGRESS_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\nimport { cn } from \"../../utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: \\`translateX(-\\${100 - (value || 0)}%)\\` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }`;\n\n/**\n * Basic field components - Text Field\n */\nexport const TEXT_FIELD_TEMPLATE = `import React from \"react\";\nimport { cn } from \"../../utils\";\nimport { Label } from \"../ui/label\";\nimport { Input } from \"../ui/input\";\nimport type { BaseFieldProps } from \"../../types\";\n\nexport interface TextFieldProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\";\n}\n\nexport function TextField({ fieldApi, label, placeholder, wrapperClassName, labelClassName, disabled, type = \"text\" }: TextFieldProps) {\n  const { name, value, errors, handleChange, handleBlur } = fieldApi;\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      <Input\n        id={name}\n        name={name}\n        type={type}\n        value={value || \"\"}\n        placeholder={placeholder}\n        onChange={(e) => handleChange(e.target.value)}\n        onBlur={handleBlur}\n        disabled={disabled}\n        className={cn(errors.length > 0 && \"border-destructive\")}\n      />\n      {errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">{errors[0]}</p>\n      )}\n    </div>\n  );\n}`;\n\n/**\n * Basic Input component\n */\nexport const INPUT_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport { cn } from \"../../utils\"\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }`;\n\n/**\n * Basic Label component\n */\nexport const LABEL_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"../../utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }`;\n\n/**\n * Comprehensive CSS styles for Formedible forms\n */\nexport const FORMEDIBLE_STYLES_TEMPLATE = `@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');\n\n/* CSS Variables for consistent theming */\n:root {\n  --background: 0 0% 100%;\n  --foreground: 222.2 84% 4.9%;\n  --card: 0 0% 100%;\n  --card-foreground: 222.2 84% 4.9%;\n  --popover: 0 0% 100%;\n  --popover-foreground: 222.2 84% 4.9%;\n  --primary: 221.2 83.2% 53.3%;\n  --primary-foreground: 210 40% 98%;\n  --secondary: 210 40% 96%;\n  --secondary-foreground: 222.2 84% 4.9%;\n  --muted: 210 40% 96%;\n  --muted-foreground: 215.4 16.3% 46.9%;\n  --accent: 210 40% 96%;\n  --accent-foreground: 222.2 84% 4.9%;\n  --destructive: 0 84.2% 60.2%;\n  --destructive-foreground: 210 40% 98%;\n  --border: 214.3 31.8% 91.4%;\n  --input: 214.3 31.8% 91.4%;\n  --ring: 221.2 83.2% 53.3%;\n  --radius: 0.5rem;\n}\n\n.dark {\n  --background: 222.2 84% 4.9%;\n  --foreground: 210 40% 98%;\n  --card: 222.2 84% 4.9%;\n  --card-foreground: 210 40% 98%;\n  --popover: 222.2 84% 4.9%;\n  --popover-foreground: 210 40% 98%;\n  --primary: 217.2 91.2% 59.8%;\n  --primary-foreground: 222.2 84% 4.9%;\n  --secondary: 217.2 32.6% 17.5%;\n  --secondary-foreground: 210 40% 98%;\n  --muted: 217.2 32.6% 17.5%;\n  --muted-foreground: 215 20.2% 65.1%;\n  --accent: 217.2 32.6% 17.5%;\n  --accent-foreground: 210 40% 98%;\n  --destructive: 0 62.8% 30.6%;\n  --destructive-foreground: 210 40% 98%;\n  --border: 217.2 32.6% 17.5%;\n  --input: 217.2 32.6% 17.5%;\n  --ring: 224.3 76.3% 94.1%;\n}\n\n* {\n  border-color: hsl(var(--border));\n}\n\nbody {\n  background-color: hsl(var(--background));\n  color: hsl(var(--foreground));\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;\n  margin: 0;\n  padding: 0;\n  line-height: 1.6;\n}\n\n/* Utility classes for styling */\n.space-y-2 > * + * { margin-top: 0.5rem; }\n.space-y-4 > * + * { margin-top: 1rem; }\n.space-y-6 > * + * { margin-top: 1.5rem; }\n\n.text-sm { font-size: 0.875rem; line-height: 1.25rem; }\n.text-base { font-size: 1rem; line-height: 1.5rem; }\n.text-lg { font-size: 1.125rem; line-height: 1.75rem; }\n.text-xl { font-size: 1.25rem; line-height: 1.75rem; }\n.text-2xl { font-size: 1.5rem; line-height: 2rem; }\n\n.font-medium { font-weight: 500; }\n.font-semibold { font-weight: 600; }\n.font-bold { font-weight: 700; }\n\n.text-gray-600 { color: #6b7280; }\n.text-gray-700 { color: #374151; }\n.text-gray-900 { color: #111827; }\n\n.bg-white { background-color: #ffffff; }\n.bg-gray-50 { background-color: #f9fafb; }\n.bg-gray-100 { background-color: #f3f4f6; }\n.bg-blue-50 { background-color: #eff6ff; }\n.bg-indigo-50 { background-color: #eef2ff; }\n\n.border { border-width: 1px; }\n.border-gray-200 { border-color: #e5e7eb; }\n.border-b { border-bottom-width: 1px; }\n\n.rounded-md { border-radius: 0.375rem; }\n.rounded-lg { border-radius: 0.5rem; }\n.rounded-xl { border-radius: 0.75rem; }\n\n.shadow-lg { box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }\n\n.p-4 { padding: 1rem; }\n.p-6 { padding: 1.5rem; }\n.px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }\n.py-4 { padding-top: 1rem; padding-bottom: 1rem; }\n\n.min-h-screen { min-height: 100vh; }\n.max-w-4xl { max-width: 56rem; }\n.mx-auto { margin-left: auto; margin-right: auto; }\n\n.flex { display: flex; }\n.justify-between { justify-content: space-between; }\n.justify-end { justify-content: flex-end; }\n.items-center { align-items: center; }\n\n.overflow-hidden { overflow: hidden; }\n\n.bg-gradient-to-br { background-image: linear-gradient(to bottom right, var(--tw-gradient-stops)); }\n.bg-gradient-to-r { background-image: linear-gradient(to right, var(--tw-gradient-stops)); }\n\n.from-gray-50 { --tw-gradient-from: #f9fafb; --tw-gradient-to: rgb(249 250 251 / 0); --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to); }\n.to-gray-100 { --tw-gradient-to: #f3f4f6; }\n.from-blue-50 { --tw-gradient-from: #eff6ff; --tw-gradient-to: rgb(239 246 255 / 0); --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to); }\n.to-indigo-50 { --tw-gradient-to: #eef2ff; }\n\n/* Form specific styles */\n.form-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid hsl(var(--border));\n  border-radius: var(--radius);\n  font-size: 1rem;\n  background-color: hsl(var(--background));\n  color: hsl(var(--foreground));\n  transition: border-color 0.2s, box-shadow 0.2s;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: hsl(var(--ring));\n  box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);\n}\n\n.field-input:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Button styles */\n.btn-primary {\n  background-color: hsl(var(--primary));\n  color: hsl(var(--primary-foreground));\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: var(--radius);\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.btn-primary:hover:not(:disabled) {\n  background-color: hsl(var(--primary) / 0.9);\n}\n\n.btn-primary:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.btn-secondary {\n  background-color: hsl(var(--secondary));\n  color: hsl(var(--secondary-foreground));\n  padding: 0.75rem 1.5rem;\n  border: 1px solid hsl(var(--border));\n  border-radius: var(--radius);\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.btn-secondary:hover:not(:disabled) {\n  background-color: hsl(var(--accent));\n}\n\n/* Error states */\n.error-message {\n  color: hsl(var(--destructive));\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n.field-error {\n  border-color: hsl(var(--destructive));\n}\n\n/* Progress bar */\n.progress-bar {\n  width: 100%;\n  height: 0.5rem;\n  background-color: hsl(var(--secondary));\n  border-radius: var(--radius);\n  overflow: hidden;\n  margin-bottom: 1.5rem;\n}\n\n.progress-fill {\n  height: 100%;\n  background-color: hsl(var(--primary));\n  transition: width 0.3s ease-in-out;\n}\n\n/* Loading states */\n.loading {\n  opacity: 0.7;\n  pointer-events: none;\n}\n\n.spinner {\n  border: 2px solid hsl(var(--secondary));\n  border-top: 2px solid hsl(var(--primary));\n  border-radius: 50%;\n  width: 1rem;\n  height: 1rem;\n  animation: spin 1s linear infinite;\n  display: inline-block;\n  margin-right: 0.5rem;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Responsive design */\n@media (max-width: 768px) {\n  .form-container {\n    padding: 1rem;\n  }\n  \n  .field-input,\n  .btn-primary,\n  .btn-secondary {\n    font-size: 0.875rem;\n    padding: 0.625rem 1rem;\n  }\n  \n  .max-w-4xl {\n    max-width: 100%;\n    margin: 0 1rem;\n  }\n}\n\n/* Focus visible for accessibility */\n*:focus-visible {\n  outline: 2px solid hsl(var(--ring));\n  outline-offset: 2px;\n}\n\n/* Selection styles */\n::selection {\n  background-color: hsl(var(--primary) / 0.2);\n}`;\n\n/**\n * TypeScript configuration for sandbox\n */\nexport const TSCONFIG_TEMPLATE = `{\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"es6\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src\"]\n}`;\n\n/**\n * Package.json template with all required dependencies\n */\nexport const PACKAGE_JSON_TEMPLATE = JSON.stringify({\n  name: \"formedible-sandbox\",\n  version: \"1.0.0\",\n  dependencies: FORMEDIBLE_SANDBOX_DEPENDENCIES,\n  main: \"/App.tsx\",\n  devDependencies: {\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\"\n  }\n}, null, 2);\n\n/**\n * Template variations for different form types\n */\nexport interface TemplateVariation {\n  name: string;\n  description: string;\n  complexity: \"basic\" | \"intermediate\" | \"advanced\";\n  formComponent: string;\n  exampleFields: any[];\n}\n\n/**\n * Basic single-page form template\n */\nexport const BASIC_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Basic Form\",\n  description: \"Simple single-page form with basic validation\",\n  complexity: \"basic\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  name: string;\n  email: string;\n  message: string;\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form } = useFormedible<FormData>({\n    fields: [\n      {\n        name: 'name',\n        type: 'text',\n        label: 'Full Name',\n        placeholder: 'Enter your full name',\n        validation: z.string().min(2, 'Name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      {\n        name: 'message',\n        type: 'textarea',\n        label: 'Message',\n        placeholder: 'Enter your message',\n        validation: z.string().min(10, 'Message must be at least 10 characters'),\n      },\n    ],\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return (\n    <Form />\n  );\n}`,\n  exampleFields: [\n    { name: 'name', type: 'text', label: 'Full Name', placeholder: 'Enter your full name' },\n    { name: 'email', type: 'email', label: 'Email Address', placeholder: 'Enter your email address' },\n    { name: 'message', type: 'textarea', label: 'Message', placeholder: 'Enter your message' },\n  ]\n};\n\n/**\n * Multi-page form template\n */\nexport const MULTI_PAGE_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Multi-Page Form\",\n  description: \"Multi-step form with progress indicator and validation\",\n  complexity: \"intermediate\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  company: string;\n  role: string;\n  experience: string;\n  skills: string[];\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form, currentPage, totalPages } = useFormedible<FormData>({\n    fields: [\n      // Page 1: Personal Information\n      {\n        name: 'firstName',\n        type: 'text',\n        label: 'First Name',\n        placeholder: 'Enter your first name',\n        page: 1,\n        validation: z.string().min(2, 'First name must be at least 2 characters'),\n      },\n      {\n        name: 'lastName',\n        type: 'text',\n        label: 'Last Name',\n        placeholder: 'Enter your last name',\n        page: 1,\n        validation: z.string().min(2, 'Last name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        page: 1,\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      {\n        name: 'phone',\n        type: 'tel',\n        label: 'Phone Number',\n        placeholder: 'Enter your phone number',\n        page: 1,\n        validation: z.string().min(10, 'Please enter a valid phone number'),\n      },\n      // Page 2: Professional Information\n      {\n        name: 'company',\n        type: 'text',\n        label: 'Company',\n        placeholder: 'Enter your company name',\n        page: 2,\n        validation: z.string().min(2, 'Company name must be at least 2 characters'),\n      },\n      {\n        name: 'role',\n        type: 'select',\n        label: 'Current Role',\n        placeholder: 'Select your role',\n        page: 2,\n        options: [\n          { value: 'developer', label: 'Software Developer' },\n          { value: 'designer', label: 'UI/UX Designer' },\n          { value: 'manager', label: 'Project Manager' },\n          { value: 'analyst', label: 'Business Analyst' },\n          { value: 'other', label: 'Other' },\n        ],\n        validation: z.string().min(1, 'Please select a role'),\n      },\n      {\n        name: 'experience',\n        type: 'select',\n        label: 'Years of Experience',\n        placeholder: 'Select experience level',\n        page: 2,\n        options: [\n          { value: '0-1', label: '0-1 years' },\n          { value: '2-5', label: '2-5 years' },\n          { value: '6-10', label: '6-10 years' },\n          { value: '10+', label: '10+ years' },\n        ],\n        validation: z.string().min(1, 'Please select experience level'),\n      },\n      // Page 3: Skills (using checkboxes)\n      {\n        name: 'skills',\n        type: 'checkbox',\n        label: 'Technical Skills',\n        placeholder: 'Select your skills',\n        page: 3,\n        options: [\n          { value: 'javascript', label: 'JavaScript' },\n          { value: 'typescript', label: 'TypeScript' },\n          { value: 'react', label: 'React' },\n          { value: 'vue', label: 'Vue.js' },\n          { value: 'angular', label: 'Angular' },\n          { value: 'node', label: 'Node.js' },\n          { value: 'python', label: 'Python' },\n          { value: 'java', label: 'Java' },\n        ],\n        validation: z.array(z.string()).min(1, 'Please select at least one skill'),\n      },\n    ],\n    pages: [\n      { page: 1, title: 'Personal Information', description: 'Tell us about yourself' },\n      { page: 2, title: 'Professional Background', description: 'Share your work experience' },\n      { page: 3, title: 'Technical Skills', description: 'Select your areas of expertise' },\n    ],\n    progress: {\n      className: 'mb-6',\n    },\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return <Form />;\n}`,\n  exampleFields: [\n    { name: 'firstName', type: 'text', label: 'First Name', page: 1 },\n    { name: 'lastName', type: 'text', label: 'Last Name', page: 1 },\n    { name: 'email', type: 'email', label: 'Email Address', page: 1 },\n    { name: 'company', type: 'text', label: 'Company', page: 2 },\n    { name: 'role', type: 'select', label: 'Current Role', page: 2 },\n    { name: 'skills', type: 'checkbox', label: 'Technical Skills', page: 3 },\n  ]\n};\n\n/**\n * Advanced form with conditional logic template\n */\nexport const ADVANCED_CONDITIONAL_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Advanced Conditional Form\",\n  description: \"Complex form with conditional fields, dynamic validation, and multiple field types\",\n  complexity: \"advanced\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  userType: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  companyName?: string;\n  industry?: string;\n  employees?: string;\n  personalInterests?: string[];\n  budget?: number;\n  timeline?: string;\n  additionalRequirements?: string;\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form } = useFormedible<FormData>({\n    fields: [\n      {\n        name: 'userType',\n        type: 'radio',\n        label: 'I am a...',\n        options: [\n          { value: 'individual', label: 'Individual' },\n          { value: 'business', label: 'Business Owner' },\n          { value: 'enterprise', label: 'Enterprise' },\n        ],\n        validation: z.string().min(1, 'Please select user type'),\n      },\n      {\n        name: 'firstName',\n        type: 'text',\n        label: 'First Name',\n        placeholder: 'Enter your first name',\n        validation: z.string().min(2, 'First name must be at least 2 characters'),\n      },\n      {\n        name: 'lastName',\n        type: 'text',\n        label: 'Last Name',\n        placeholder: 'Enter your last name',\n        validation: z.string().min(2, 'Last name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      // Business-specific fields (conditional)\n      {\n        name: 'companyName',\n        type: 'text',\n        label: 'Company Name',\n        placeholder: 'Enter your company name',\n        conditional: (values) => values.userType === 'business' || values.userType === 'enterprise',\n        validation: z.string().min(2, 'Company name must be at least 2 characters').optional(),\n      },\n      {\n        name: 'industry',\n        type: 'select',\n        label: 'Industry',\n        placeholder: 'Select your industry',\n        conditional: (values) => values.userType === 'business' || values.userType === 'enterprise',\n        options: [\n          { value: 'technology', label: 'Technology' },\n          { value: 'finance', label: 'Finance' },\n          { value: 'healthcare', label: 'Healthcare' },\n          { value: 'education', label: 'Education' },\n          { value: 'retail', label: 'Retail' },\n          { value: 'manufacturing', label: 'Manufacturing' },\n          { value: 'other', label: 'Other' },\n        ],\n        validation: z.string().min(1, 'Please select an industry').optional(),\n      },\n      {\n        name: 'employees',\n        type: 'select',\n        label: 'Number of Employees',\n        placeholder: 'Select company size',\n        conditional: (values) => values.userType === 'enterprise',\n        options: [\n          { value: '1-10', label: '1-10 employees' },\n          { value: '11-50', label: '11-50 employees' },\n          { value: '51-200', label: '51-200 employees' },\n          { value: '201-1000', label: '201-1000 employees' },\n          { value: '1000+', label: '1000+ employees' },\n        ],\n        validation: z.string().min(1, 'Please select company size').optional(),\n      },\n      // Individual-specific fields\n      {\n        name: 'personalInterests',\n        type: 'checkbox',\n        label: 'Personal Interests',\n        conditional: (values) => values.userType === 'individual',\n        options: [\n          { value: 'technology', label: 'Technology' },\n          { value: 'design', label: 'Design' },\n          { value: 'marketing', label: 'Marketing' },\n          { value: 'business', label: 'Business' },\n          { value: 'education', label: 'Education' },\n          { value: 'health', label: 'Health & Wellness' },\n        ],\n        validation: z.array(z.string()).min(1, 'Please select at least one interest').optional(),\n      },\n      // Common fields for all user types\n      {\n        name: 'budget',\n        type: 'number',\n        label: 'Budget Range',\n        placeholder: 'Enter your budget in USD',\n        validation: z.number().min(1, 'Budget must be greater than 0').optional(),\n      },\n      {\n        name: 'timeline',\n        type: 'select',\n        label: 'Project Timeline',\n        placeholder: 'When do you need this completed?',\n        options: [\n          { value: 'asap', label: 'As soon as possible' },\n          { value: '1-month', label: 'Within 1 month' },\n          { value: '3-months', label: 'Within 3 months' },\n          { value: '6-months', label: 'Within 6 months' },\n          { value: 'flexible', label: 'Flexible timeline' },\n        ],\n        validation: z.string().min(1, 'Please select a timeline'),\n      },\n      {\n        name: 'additionalRequirements',\n        type: 'textarea',\n        label: 'Additional Requirements',\n        placeholder: 'Tell us more about your specific needs...',\n        validation: z.string().optional(),\n      },\n    ],\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          // Simulate API call\n          console.log('Submitting form:', value);\n          await new Promise(resolve => setTimeout(resolve, 1000));\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return <Form />;\n}`,\n  exampleFields: [\n    { name: 'userType', type: 'radio', label: 'User Type' },\n    { name: 'firstName', type: 'text', label: 'First Name' },\n    { name: 'companyName', type: 'text', label: 'Company Name', conditional: true },\n    { name: 'industry', type: 'select', label: 'Industry', conditional: true },\n    { name: 'personalInterests', type: 'checkbox', label: 'Personal Interests', conditional: true },\n    { name: 'budget', type: 'number', label: 'Budget Range' },\n  ]\n};\n\n/**\n * Get all available templates\n */\nexport const TEMPLATE_VARIATIONS: TemplateVariation[] = [\n  BASIC_FORM_TEMPLATE,\n  MULTI_PAGE_FORM_TEMPLATE,\n  ADVANCED_CONDITIONAL_FORM_TEMPLATE,\n];\n\n/**\n * Create a complete Formedible sandbox with all necessary files\n */\nexport function createFormedibleSandbox(\n  formComponent: string = BASIC_FORM_TEMPLATE.formComponent,\n  templateType: \"basic\" | \"intermediate\" | \"advanced\" = \"basic\"\n): SandboxFiles {\n  return {\n    \"/App.tsx\": {\n      code: FORMEDIBLE_APP_TEMPLATE\n    },\n    \"/FormComponent.tsx\": {\n      code: formComponent\n    },\n    \"/hooks/use-formedible.tsx\": {\n      code: USE_FORMEDIBLE_HOOK_TEMPLATE\n    },\n    \"/types.ts\": {\n      code: FORMEDIBLE_TYPES_TEMPLATE\n    },\n    \"/utils.ts\": {\n      code: FORMEDIBLE_UTILS_TEMPLATE\n    },\n    \"/components/ui/button.tsx\": {\n      code: BUTTON_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/progress.tsx\": {\n      code: PROGRESS_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/input.tsx\": {\n      code: INPUT_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/label.tsx\": {\n      code: LABEL_COMPONENT_TEMPLATE\n    },\n    \"/components/fields/text-field.tsx\": {\n      code: TEXT_FIELD_TEMPLATE\n    },\n    \"/styles.css\": {\n      code: FORMEDIBLE_STYLES_TEMPLATE\n    },\n    \"/package.json\": {\n      code: PACKAGE_JSON_TEMPLATE,\n      hidden: true\n    },\n    \"/tsconfig.json\": {\n      code: TSCONFIG_TEMPLATE,\n      hidden: true\n    }\n  };\n}\n\n/**\n * Get template by complexity level\n */\nexport function getTemplateByComplexity(complexity: \"basic\" | \"intermediate\" | \"advanced\"): TemplateVariation {\n  return TEMPLATE_VARIATIONS.find(template => template.complexity === complexity) || BASIC_FORM_TEMPLATE;\n}\n\n/**\n * Generate form component code from field configuration\n */\nexport function generateFormComponentFromFields(\n  fields: any[],\n  formConfig?: { \n    multiPage?: boolean; \n    hasConditional?: boolean; \n    title?: string;\n    description?: string;\n  }\n): string {\n  const { multiPage = false, hasConditional = false, title = \"Generated Form\", description } = formConfig || {};\n\n  const fieldsCode = fields.map(field => {\n    const validation = field.validation ? \n      `validation: z.string().min(1, 'This field is required'),` : '';\n    const options = field.options ? \n      `options: ${JSON.stringify(field.options)},` : '';\n    const conditional = field.conditional ? \n      `conditional: (values) => ${field.conditional},` : '';\n    \n    return `      {\n        name: '${field.name}',\n        type: '${field.type}',\n        label: '${field.label || field.name}',\n        placeholder: '${field.placeholder || ''}',\n        ${field.page ? `page: ${field.page},` : ''}\n        ${validation}\n        ${options}\n        ${conditional}\n      }`;\n  }).join(',\\n');\n\n  const pagesConfig = multiPage && fields.some(f => f.page) ? `\n    pages: [\n      ${[...new Set(fields.filter(f => f.page).map(f => f.page))].sort().map(pageNum => \n        `{ page: ${pageNum}, title: 'Step ${pageNum}', description: 'Please fill out this step' }`\n      ).join(',\\n      ')}\n    ],\n    progress: {\n      className: 'mb-6',\n    },` : '';\n\n  return `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  ${fields.map(field => `${field.name}: ${field.type === 'number' ? 'number' : field.type === 'checkbox' ? 'string[]' : 'string'};`).join('\\n  ')}\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form } = useFormedible<FormData>({\n    fields: [\n${fieldsCode}\n    ],${pagesConfig}\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          console.log('Form submitted:', value);\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return (\n    <div className=\"space-y-6\">\n      ${title ? `<div className=\"text-center\">\n        <h2 className=\"text-2xl font-bold text-gray-900\">${title}</h2>\n        ${description ? `<p className=\"text-gray-600 mt-2\">${description}</p>` : ''}\n      </div>` : ''}\n      <Form />\n    </div>\n  );\n}`;\n}",
      "type": "registry:lib",
      "target": "lib/sandbox-templates.ts"
    }
  ]
}