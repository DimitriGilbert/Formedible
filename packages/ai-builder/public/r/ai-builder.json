{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-builder",
  "type": "registry:block",
  "title": "Formedible AI Builder",
  "description": "An AI-powered form builder component that generates forms from natural language descriptions. Features chat interface, real-time form generation, and multiple AI provider support.",
  "dependencies": [
    "react",
    "lucide-react",
    "clsx",
    "tailwind-merge",
    "@ai-sdk/openai",
    "@ai-sdk/anthropic",
    "@ai-sdk/google",
    "@ai-sdk/mistral",
    "@ai-sdk/openai-compatible",
    "@openrouter/ai-sdk-provider",
    "ai",
    "zod",
    "@codesandbox/sandpack-react"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "card",
    "tabs",
    "dialog",
    "dropdown-menu",
    "scroll-area",
    "badge",
    "alert",
    "skeleton",
    "sidebar",
    "tooltip",
    "separator",
    "slider",
    "https://formedible.dev/r/use-formedible.json"
  ],
  "files": [
    {
      "path": "src/components/formedible/ai/ai-builder.tsx",
      "content": "\"use client\";\n\nimport { useState, useCallback, useEffect } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { ProviderSelection, type ProviderConfig } from \"./provider-selection\";\nimport { ChatInterface } from \"./chat-interface\";\nimport { FormPreview } from \"./form-preview\";\nimport { ConversationHistory, type Conversation } from \"./conversation-history\";\nimport { SidebarIcons, type SidebarView } from \"./sidebar-icons\";\nimport { SidebarContent } from \"./sidebar-content\";\nimport { Button } from \"@/components/ui/button\";\nimport { Sparkles, ChevronDown, ChevronUp, Settings, History, ChevronLeft, ChevronRight, Eye, FileText } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\nimport { extractFormsFromMessages } from \"@/lib/form-extraction-utils\";\nimport { toast } from \"sonner\";\n\n// Create a client instance outside the component to avoid recreation\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      gcTime: 10 * 60 * 1000, // 10 minutes\n      retry: 1,\n    },\n  },\n});\n\nexport type AIBuilderMode = \"direct\" | \"backend\";\n\nexport interface BackendConfig {\n  endpoint: string;\n  headers?: Record<string, string>;\n}\n\nexport interface AIBuilderProps {\n  className?: string;\n  onFormGenerated?: (formCode: string) => void;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nconst STORAGE_KEYS = {\n  PROVIDER_CONFIG: \"formedible-ai-builder-provider-config\",\n  CONVERSATIONS: \"formedible-ai-builder-conversations\",\n  UI_STATE: \"formedible-ai-builder-ui-state\",\n};\n\nfunction AIBuilderCore({ className, onFormGenerated, onFormSubmit, mode = \"direct\", backendConfig }: AIBuilderProps) {\n  const [providerConfig, setProviderConfig] = useState<ProviderConfig | null>(null);\n  const [generatedForms, setGeneratedForms] = useState<Array<{ id: string; code: string; timestamp: Date }>>([]);\n  const [currentFormIndex, setCurrentFormIndex] = useState<number>(0);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [currentConversationId, setCurrentConversationId] = useState<string | undefined>();\n  const [currentMessages, setCurrentMessages] = useState<Message[]>([]);\n  const [isTopSectionCollapsed, setIsTopSectionCollapsed] = useState(false);\n  const [activeView, setActiveView] = useState<SidebarView | null>(null);\n  const [isCollapsed, setIsCollapsed] = useState(false);\n\n  // Check if AI service is properly configured based on mode\n  const isProviderConfigured = useCallback(() => {\n    if (mode === \"backend\") {\n      // For backend mode, just check that backend config is provided\n      return !!(backendConfig && backendConfig.endpoint && backendConfig.endpoint.trim().length > 0);\n    }\n    \n    // For direct mode, check provider configuration\n    if (!providerConfig) return false;\n    \n    // Check if provider requires API key\n    const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n    if (providersRequiringKey.includes(providerConfig.provider as string)) {\n      return !!(providerConfig.apiKey && providerConfig.apiKey.trim().length > 0);\n    }\n    \n    // For openai-compatible, endpoint is required\n    if (providerConfig.provider === \"openai-compatible\") {\n      return !!(providerConfig.endpoint && providerConfig.endpoint.trim().length > 0);\n    }\n    \n    return true;\n  }, [mode, backendConfig, providerConfig]);\n\n  // Load saved data on mount\n  useEffect(() => {\n    try {\n      // Load provider config\n      const savedConfig = localStorage.getItem(STORAGE_KEYS.PROVIDER_CONFIG);\n      if (savedConfig) {\n        setProviderConfig(JSON.parse(savedConfig));\n      }\n\n      // Load conversations\n      const savedConversations = localStorage.getItem(STORAGE_KEYS.CONVERSATIONS);\n      let loadedConversations: Conversation[] = [];\n      if (savedConversations) {\n        const parsedConversations = JSON.parse(savedConversations);\n        loadedConversations = parsedConversations.map((c: any) => ({\n          ...c,\n          createdAt: new Date(c.createdAt),\n          updatedAt: new Date(c.updatedAt),\n        }));\n        setConversations(loadedConversations);\n      }\n\n      // Load UI state\n      const savedUIState = localStorage.getItem(STORAGE_KEYS.UI_STATE);\n      if (savedUIState) {\n        const uiState = JSON.parse(savedUIState);\n        setIsTopSectionCollapsed(uiState.isTopSectionCollapsed || false);\n        \n        // Restore current conversation if it exists\n        if (uiState.currentConversationId && loadedConversations.length > 0) {\n          const currentConversation = loadedConversations.find(c => c.id === uiState.currentConversationId);\n          if (currentConversation) {\n            setCurrentConversationId(uiState.currentConversationId);\n            setCurrentMessages(currentConversation.messages);\n            \n            // Extract forms from conversation messages using shared utility\n            const extractedForms = extractFormsFromMessages(\n              currentConversation.messages,\n              currentConversation.id,\n              new Date(currentConversation.updatedAt)\n            );\n            \n            // Restore generated forms\n            setGeneratedForms(extractedForms);\n            setCurrentFormIndex(0);\n          }\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to load saved AI Builder data:\", error);\n    }\n  }, []);\n\n  // Save provider config when it changes\n  useEffect(() => {\n    if (providerConfig) {\n      try {\n        localStorage.setItem(STORAGE_KEYS.PROVIDER_CONFIG, JSON.stringify(providerConfig));\n      } catch (error) {\n        console.warn(\"Failed to save provider config:\", error);\n      }\n    }\n  }, [providerConfig]);\n\n  // Save conversations when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));\n    } catch (error) {\n      console.warn(\"Failed to save conversations:\", error);\n    }\n  }, [conversations]);\n\n  // Save UI state when it changes\n  useEffect(() => {\n    try {\n      const uiState = {\n        isTopSectionCollapsed,\n        currentConversationId,\n      };\n      localStorage.setItem(STORAGE_KEYS.UI_STATE, JSON.stringify(uiState));\n    } catch (error) {\n      console.warn(\"Failed to save UI state:\", error);\n    }\n  }, [isTopSectionCollapsed, currentConversationId]);\n\n  const handleProviderConfigChange = useCallback((config: ProviderConfig | null) => {\n    setProviderConfig(config);\n  }, []);\n\n  const handleFormGenerated = useCallback((formCode: string) => {\n    const newForm = {\n      id: `form_${Date.now()}`,\n      code: formCode,\n      timestamp: new Date()\n    };\n    \n    setGeneratedForms(prev => {\n      const updated = [...prev, newForm];\n      setCurrentFormIndex(updated.length - 1); // Auto-navigate to newest form\n      return updated;\n    });\n    \n    onFormGenerated?.(formCode);\n  }, [onFormGenerated]);\n\n  const handleStreamingStateChange = useCallback((streaming: boolean) => {\n    setIsGenerating(streaming);\n  }, []);\n\n  const handleFormSubmit = useCallback((formData: Record<string, unknown>) => {\n    console.log(\"Form submitted:\", formData);\n    onFormSubmit?.(formData);\n  }, [onFormSubmit]);\n\n  const handleFormIndexChange = useCallback((index: number) => {\n    setCurrentFormIndex(index);\n  }, []);\n\n  const handleDeleteForm = useCallback((index: number) => {\n    setGeneratedForms(prev => {\n      const updated = prev.filter((_, i) => i !== index);\n      // Adjust current index if necessary\n      if (index <= currentFormIndex && currentFormIndex > 0) {\n        setCurrentFormIndex(currentFormIndex - 1);\n      } else if (index < currentFormIndex) {\n        // No change needed to currentFormIndex\n      } else if (updated.length === 0) {\n        setCurrentFormIndex(0);\n      } else if (currentFormIndex >= updated.length) {\n        setCurrentFormIndex(updated.length - 1);\n      }\n      return updated;\n    });\n  }, [currentFormIndex]);\n\n  const handleConversationUpdate = useCallback((messages: Message[], isStreamEnd: boolean = false) => {\n    // Check if provider is configured before allowing conversation updates\n    if (!isProviderConfigured()) {\n      toast.error(\"Please configure your AI provider first\", {\n        description: \"You need to set up your API key in the settings before you can chat.\"\n      });\n      return;\n    }\n\n    // Always update current messages for UI\n    setCurrentMessages(messages);\n    \n    // Handle conversation creation/update\n    if (messages.length > 0) {\n      if (!currentConversationId) {\n        // Create new conversation when first message is sent\n        const newConversationId = `conversation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        \n        setConversations(prev => {\n          // Double check we don't already have this conversation (race condition protection)\n          const exists = prev.some(conv => conv.id === newConversationId);\n          if (exists) return prev;\n          \n          const newConversation: Conversation = {\n            id: newConversationId,\n            title: \"\", // Will be generated from first message\n            messages,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          };\n          \n          return [...prev, newConversation];\n        });\n        setCurrentConversationId(newConversationId);\n      } else {\n        // Update existing conversation with new messages\n        setConversations(prev => prev.map(conv => \n          conv.id === currentConversationId \n            ? { ...conv, messages, updatedAt: new Date() }\n            : conv\n        ));\n      }\n    }\n  }, [currentConversationId, isProviderConfigured]);\n\n  const handleNewConversation = useCallback(() => {\n    setCurrentConversationId(undefined);\n    setCurrentMessages([]);\n    // Clear forms when starting new conversation\n    setGeneratedForms([]);\n    setCurrentFormIndex(0);\n  }, []);\n\n  // Remove automatic conversation creation\n\n  const handleSelectConversation = useCallback((conversation: Conversation) => {\n    setCurrentConversationId(conversation.id);\n    setCurrentMessages(conversation.messages);\n    \n    // Extract forms from conversation messages using shared utility\n    const extractedForms = extractFormsFromMessages(\n      conversation.messages,\n      conversation.id,\n      new Date(conversation.updatedAt)\n    );\n    \n    console.log('Extracted forms from conversation:', extractedForms.length);\n    \n    // Update generated forms and reset index\n    setGeneratedForms(extractedForms);\n    setCurrentFormIndex(0);\n  }, []);\n\n  const handleDeleteConversation = useCallback((conversationId: string) => {\n    setConversations(prev => prev.filter(c => c.id !== conversationId));\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(undefined);\n      setCurrentMessages([]);\n      // Clear forms when deleting current conversation\n      setGeneratedForms([]);\n      setCurrentFormIndex(0);\n    }\n  }, [currentConversationId]);\n\n  const handleExportConversation = useCallback((conversation: Conversation) => {\n    const dataStr = JSON.stringify(conversation, null, 2);\n    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\n\n    const exportFileDefaultName = `conversation-${conversation.id}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileDefaultName);\n    linkElement.click();\n  }, []);\n\n  const handleToggleCollapse = useCallback(() => {\n    setIsCollapsed(!isCollapsed);\n  }, [isCollapsed]);\n\n  const handleViewChange = useCallback((view: SidebarView | null) => {\n    setActiveView(view);\n    if (view && isCollapsed) {\n      setIsCollapsed(false);\n    }\n  }, [isCollapsed]);\n\n\n\n  return (\n    <div className={cn(\"flex flex-col h-full overflow-hidden\", className)}>\n      <div className=\"flex items-center gap-2 px-1 pb-1 flex-shrink-0\">\n        <Sparkles className=\"h-4 w-4 text-primary\" />\n        <h1 className=\"text-lg font-bold text-foreground\">AI Form Builder</h1>\n      </div>\n\n\n      {/* Main Layout: Sidebar + Content Area */}\n      <div className=\"flex-1 flex min-h-0 overflow-hidden gap-2\">\n        {/* Sidebar */}\n        <SidebarIcons\n          isCollapsed={isCollapsed}\n          onToggleCollapse={handleToggleCollapse}\n          activeView={activeView}\n          onViewChange={handleViewChange}\n        />\n        \n        <SidebarContent\n          activeView={activeView}\n          isCollapsed={isCollapsed}\n          conversations={conversations}\n          currentConversationId={currentConversationId}\n          onSelectConversation={handleSelectConversation}\n          onDeleteConversation={handleDeleteConversation}\n          onNewConversation={handleNewConversation}\n          onExportConversation={handleExportConversation}\n          providerConfig={providerConfig}\n          onConfigChange={handleProviderConfigChange}\n        />\n\n        {/* Chat + Preview Grid */}\n        <div className=\"flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden\">\n          {/* Conditionally show provider form or chat interface */}\n          {!isProviderConfigured() ? (\n            <div className=\"flex flex-col h-full border-2 border-accent/30 rounded-lg shadow-lg bg-card\">\n              <div className=\"px-6 py-4 bg-gradient-to-r from-accent/10 to-transparent border-b\">\n                <h2 className=\"text-lg font-semibold text-foreground\">Setup Required</h2>\n                <p className=\"text-sm text-muted-foreground mt-1\">\n                  {mode === \"backend\" \n                    ? \"Backend endpoint configuration is required\"\n                    : \"Please configure your AI provider to start building forms\"\n                  }\n                </p>\n              </div>\n              <div className=\"flex-1 overflow-y-auto\">\n                {mode === \"direct\" ? (\n                  <ProviderSelection\n                    onConfigChange={handleProviderConfigChange}\n                    initialConfig={providerConfig}\n                    className=\"h-full\"\n                  />\n                ) : (\n                  <div className=\"p-6\">\n                    <div className=\"text-center text-muted-foreground\">\n                      <h3 className=\"text-base font-medium mb-2\">Backend Mode</h3>\n                      <p className=\"text-sm\">\n                        {backendConfig?.endpoint \n                          ? `Endpoint: ${backendConfig.endpoint}`\n                          : \"No backend endpoint configured\"\n                        }\n                      </p>\n                      <p className=\"text-xs mt-4\">\n                        Backend configuration must be provided via props by the developer.\n                      </p>\n                    </div>\n                  </div>\n                )}\n              </div>\n            </div>\n          ) : (\n            <ChatInterface\n              onFormGenerated={handleFormGenerated}\n              onStreamingStateChange={handleStreamingStateChange}\n              onConversationUpdate={handleConversationUpdate}\n              onNewConversation={handleNewConversation}\n              messages={currentMessages}\n              providerConfig={providerConfig}\n              mode={mode}\n              backendConfig={backendConfig}\n              className=\"h-full overflow-hidden\"\n            />\n          )}\n\n          <FormPreview\n            forms={generatedForms}\n            currentFormIndex={currentFormIndex}\n            onFormIndexChange={handleFormIndexChange}\n            onDeleteForm={handleDeleteForm}\n            isStreaming={isGenerating}\n            onFormSubmit={handleFormSubmit}\n            className=\"h-full overflow-hidden\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Export the main component wrapped with QueryClientProvider\nexport function AIBuilder(props: AIBuilderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <AIBuilderCore {...props} />\n    </QueryClientProvider>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-builder.tsx"
    },
    {
      "path": "src/components/formedible/ai/provider-selection.tsx",
      "content": "\"use client\";\n\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { toast } from \"sonner\";\n\nexport type AIProvider =\n  | \"openai\"\n  | \"anthropic\"\n  | \"google\"\n  | \"mistral\"\n  | \"openrouter\"\n  | \"openai-compatible\";\n\nexport interface ProviderConfig {\n  provider: AIProvider;\n  apiKey: string;\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  endpoint?: string;\n}\n\nexport interface ProviderSelectionProps {\n  onConfigChange: (config: ProviderConfig | null) => void;\n  initialConfig?: ProviderConfig | null;\n  className?: string;\n}\n\nconst PROVIDERS = [\n  { value: \"openai\", label: \"OpenAI\", requiresKey: true },\n  { value: \"anthropic\", label: \"Anthropic\", requiresKey: true },\n  { value: \"google\", label: \"Google Gemini\", requiresKey: true },\n  { value: \"mistral\", label: \"Mistral\", requiresKey: true },\n  { value: \"openrouter\", label: \"OpenRouter\", requiresKey: true },\n  {\n    value: \"openai-compatible\",\n    label: \"OpenAI Compatible\",\n    requiresKey: false,\n  },\n] as const;\n\nexport function ProviderSelection({\n  onConfigChange,\n  initialConfig,\n  className,\n}: ProviderSelectionProps) {\n  const { Form } = useFormedible({\n    fields: [\n      {\n        name: \"provider\",\n        type: \"select\",\n        label: \"Provider\",\n        placeholder: \"Select provider...\",\n        options: PROVIDERS.map((p) => ({ value: p.value, label: p.label })),\n      },\n      {\n        name: \"apiKey\",\n        type: \"password\",\n        label: \"API Key\",\n        placeholder: \"Enter your API key...\",\n        // conditional: (values) => {\n        //   const provider = PROVIDERS.find(p => p.value === values.provider);\n        //   return provider?.requiresKey || false;\n        // },\n        description:\n          \"Your API key is stored securely and never sent to our servers\",\n      },\n      {\n        name: \"endpoint\",\n        type: \"text\",\n        label: \"API Endpoint\",\n        placeholder: \"https://api.example.com/v1\",\n        conditional: (values) => values.provider === \"openai-compatible\",\n        description: \"Base URL for OpenAI-compatible API\",\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        provider: initialConfig?.provider,\n        apiKey: initialConfig?.apiKey || \"\",\n        endpoint: initialConfig?.endpoint || \"\",\n      },\n      onSubmit: async ({ value }) => {\n        const config: ProviderConfig = {\n          provider: value.provider as AIProvider,\n          apiKey: value.apiKey || \"\",\n          ...(value.endpoint && { endpoint: value.endpoint }),\n        };\n        \n        // Validate configuration\n        const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n        if (providersRequiringKey.includes(config.provider as string) && (!config.apiKey || config.apiKey.trim().length === 0)) {\n          toast.error(\"API key required\", {\n            description: `Please enter a valid API key for ${config.provider}.`\n          });\n          return;\n        }\n        \n        if (config.provider === \"openai-compatible\" && (!config.endpoint || config.endpoint.trim().length === 0)) {\n          toast.error(\"Endpoint required\", {\n            description: \"Please enter a valid API endpoint for OpenAI-compatible provider.\"\n          });\n          return;\n        }\n        \n        onConfigChange(config);\n        toast.success(\"Provider configured successfully!\", {\n          description: \"You can now start building forms with AI.\"\n        });\n      },\n    },\n    submitLabel: \"💾 Save Configuration\",\n    showSubmitButton: true,\n    autoSubmitOnChange: false,\n  });\n\n  return (\n    <div className={`p-4 space-y-4 ${className || \"\"}`}>\n      <h3 className=\"text-base font-semibold\">AI Provider</h3>\n      <Form />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/provider-selection.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-interface.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\nimport type { AIBuilderMode, BackendConfig } from \"./ai-builder\";\nimport { ChatMessages } from \"./chat-messages\";\nimport type { Message } from \"./chat-messages\";\n\n\nexport type { Message } from \"./chat-messages\";\n\nexport interface ChatInterfaceProps {\n  onFormGenerated?: (formCode: string) => void;\n  onStreamingStateChange?: (isStreaming: boolean) => void;\n  onConversationUpdate?: (messages: Message[], isStreamEnd?: boolean) => void;\n  onNewConversation?: () => void;\n  messages?: Message[];\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nexport function ChatInterface({\n  onFormGenerated,\n  onStreamingStateChange,\n  onConversationUpdate,\n  onNewConversation,\n  messages: externalMessages,\n  className,\n  providerConfig,\n  mode,\n  backendConfig,\n}: ChatInterfaceProps) {\n  return (\n    <ChatMessages\n      onFormGenerated={onFormGenerated}\n      onStreamingStateChange={onStreamingStateChange}\n      onConversationUpdate={onConversationUpdate}\n      onNewConversation={onNewConversation}\n      messages={externalMessages}\n      providerConfig={providerConfig}\n      mode={mode}\n      backendConfig={backendConfig}\n      className={cn(\"h-full\", className)}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-interface.tsx"
    },
    {
      "path": "src/components/formedible/ai/form-preview.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Tooltip, TooltipContent, TooltipTrigger } from \"@/components/ui/tooltip\";\nimport { FormPreviewBase } from \"@/components/formedible/builder/form-preview-base\";\nimport { SandpackPreview } from \"./sandpack-preview\";\nimport { Eye, ChevronLeft, ChevronRight, Trash2, Monitor, Play } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface GeneratedForm {\n  id: string;\n  code: string;\n  timestamp: Date;\n}\n\nexport type PreviewMode = \"static\" | \"live\";\n\nconst PREVIEW_MODE_STORAGE_KEY = \"formedible-preview-mode\";\n\nexport interface FormPreviewProps {\n  forms: GeneratedForm[];\n  currentFormIndex: number;\n  onFormIndexChange: (index: number) => void;\n  onDeleteForm?: (index: number) => void;\n  isStreaming?: boolean;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  className?: string;\n  /** Allow toggling between preview modes */\n  enableModeToggle?: boolean;\n  /** Default preview mode */\n  defaultPreviewMode?: PreviewMode;\n}\n\nexport function FormPreview({ \n  forms, \n  currentFormIndex, \n  onFormIndexChange,\n  onDeleteForm,\n  isStreaming = false, \n  onFormSubmit, \n  className,\n  enableModeToggle = true,\n  defaultPreviewMode = \"static\"\n}: FormPreviewProps) {\n  const currentForm = forms[currentFormIndex];\n  \n  // Preview mode state with localStorage persistence\n  const [previewMode, setPreviewMode] = useState<PreviewMode>(defaultPreviewMode);\n  \n  // Load preview mode from localStorage on mount\n  useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      const savedMode = localStorage.getItem(PREVIEW_MODE_STORAGE_KEY) as PreviewMode;\n      if (savedMode === \"static\" || savedMode === \"live\") {\n        setPreviewMode(savedMode);\n      }\n    }\n  }, []);\n  \n  // Persist preview mode to localStorage\n  const handlePreviewModeChange = (mode: PreviewMode) => {\n    setPreviewMode(mode);\n    if (typeof window !== \"undefined\") {\n      localStorage.setItem(PREVIEW_MODE_STORAGE_KEY, mode);\n    }\n  };\n\n  if (forms.length === 0 && !isStreaming) {\n    return (\n      <FormPreviewBase \n        className={className}\n        title=\"\"\n        emptyStateMessage=\"Start a conversation in the chat to generate your first form. The preview will appear here once the AI creates your form.\"\n      />\n    );\n  }\n\n  return (\n    <Card className={cn(\"flex flex-col h-full\", className)}>\n      <CardHeader className=\"px-3 pt-1 pb-0\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"h-5 w-5\" />\n            Preview\n            {forms.length > 0 && (\n              <span className=\"text-sm font-normal text-muted-foreground\">\n                ({currentFormIndex + 1} of {forms.length})\n              </span>\n            )}\n          </CardTitle>\n          \n          <div className=\"flex items-center gap-2\">\n            {enableModeToggle && (\n              <div className=\"flex items-center gap-2 mr-2\">\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <div className=\"flex items-center gap-2 text-sm\">\n                      <Monitor className=\"h-4 w-4 text-muted-foreground\" />\n                      <span className={cn(\"transition-colors\", previewMode === \"static\" && \"text-foreground font-medium\")}>Static</span>\n                    </div>\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <p>Static preview with current form design</p>\n                  </TooltipContent>\n                </Tooltip>\n                \n                <Switch\n                  checked={previewMode === \"live\"}\n                  onCheckedChange={(checked) => handlePreviewModeChange(checked ? \"live\" : \"static\")}\n                  aria-label=\"Toggle preview mode\"\n                  className=\"h-4 w-7\"\n                />\n                \n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <div className=\"flex items-center gap-2 text-sm\">\n                      <Play className=\"h-4 w-4 text-muted-foreground\" />\n                      <span className={cn(\"transition-colors\", previewMode === \"live\" && \"text-foreground font-medium\")}>Live</span>\n                    </div>\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <p>Interactive live preview with code execution</p>\n                  </TooltipContent>\n                </Tooltip>\n              </div>\n            )}\n            \n            {forms.length > 1 && (\n            <div className=\"flex items-center gap-1\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.max(0, currentFormIndex - 1))}\n                disabled={currentFormIndex === 0}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronLeft className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Previous form</span>\n              </Button>\n              \n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.min(forms.length - 1, currentFormIndex + 1))}\n                disabled={currentFormIndex === forms.length - 1}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronRight className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Next form</span>\n              </Button>\n\n              {onDeleteForm && forms.length > 1 && (\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => onDeleteForm(currentFormIndex)}\n                  className=\"h-8 w-8 p-0 text-destructive hover:text-destructive\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                  <span className=\"sr-only\">Delete form</span>\n                </Button>\n              )}\n            </div>\n            )}\n          </div>\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"flex-1 overflow-hidden\">\n        {previewMode === \"static\" ? (\n          <FormPreviewBase \n            formCode={currentForm?.code}\n            isStreaming={isStreaming && !currentForm}\n            onFormSubmit={onFormSubmit}\n            className=\"border-0 h-full\"\n          />\n        ) : (\n          <SandpackPreview\n            formCode={currentForm?.code}\n            onFormSubmit={onFormSubmit}\n            className=\"h-full\"\n            height=\"100%\"\n            isLoading={isStreaming && !currentForm}\n            showCodeEditor={false}\n            showConsole={false}\n            showFileExplorer={false}\n          />\n        )}\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/form-preview.tsx"
    },
    {
      "path": "src/components/formedible/ai/ai-form-renderer.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useMemo, useCallback, memo } from \"react\";\nimport { z } from \"zod\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { FieldConfig, UseFormedibleOptions } from \"@/lib/formedible/types\";\n\nexport interface AiFormParseResult<TFormData = Record<string, unknown>> {\n  schema: z.ZodSchema<TFormData>;\n  formOptions: UseFormedibleOptions<TFormData>;\n  success: boolean;\n  error?: string;\n}\n\nexport interface AiParserConfig {\n  allowedFieldTypes?: string[];\n  allowedKeys?: string[];\n  allowedFieldKeys?: string[];\n  allowedPageKeys?: string[];\n  allowedProgressKeys?: string[];\n  allowedFormOptionsKeys?: string[];\n}\n\nexport interface AiFormRendererProps {\n  code: string;\n  isStreaming?: boolean;\n  onParseComplete?: (result: AiFormParseResult) => void;\n  onSubmit?: (formData: Record<string, unknown>) => void | Promise<void>;\n  className?: string;\n  parserConfig?: AiParserConfig;\n  debug?: boolean;\n}\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'email', 'password', 'url', 'tel', 'textarea', 'select', \n  'checkbox', 'switch', 'number', 'date', 'slider', 'file', 'rating',\n  'phone', 'colorPicker', 'location', 'duration', 'multiSelect',\n  'autocomplete', 'masked', 'object', 'array', 'radio'\n];\n\nconst DEFAULT_KEYS = [\n  'schema', 'fields', 'pages', 'progress', 'submitLabel', 'nextLabel', \n  'previousLabel', 'formClassName', 'fieldClassName', 'formOptions'\n];\n\nconst DEFAULT_FIELD_KEYS = [\n  'name', 'type', 'label', 'placeholder', 'description', 'options', \n  'min', 'max', 'step', 'accept', 'multiple', 'page', 'conditional',\n  'section', 'ratingConfig', 'phoneConfig', 'colorConfig', 'locationConfig',\n  'durationConfig', 'multiSelectConfig', 'sliderConfig', 'numberConfig',\n  'dateConfig', 'fileConfig', 'textareaConfig', 'passwordConfig', 'emailConfig',\n  'autocompleteConfig', 'maskedInputConfig', 'objectConfig', 'arrayConfig',\n  'validation', 'group', 'tab', 'help', 'inlineValidation', 'datalist'\n];\n\nconst DEFAULT_PAGE_KEYS = ['page', 'title', 'description'];\n\nconst DEFAULT_PROGRESS_KEYS = ['showSteps', 'showPercentage', 'className'];\n\nconst DEFAULT_FORM_OPTIONS_KEYS = [\n  'defaultValues', 'asyncDebounceMs', 'canSubmitWhenInvalid', 'onSubmit', 'onSubmitInvalid'\n];\n\nclass AiFormedibleParser {\n  private config: Required<AiParserConfig>;\n\n  constructor(config?: AiParserConfig) {\n    this.config = {\n      allowedFieldTypes: config?.allowedFieldTypes ?? DEFAULT_FIELD_TYPES,\n      allowedKeys: config?.allowedKeys ?? DEFAULT_KEYS,\n      allowedFieldKeys: config?.allowedFieldKeys ?? DEFAULT_FIELD_KEYS,\n      allowedPageKeys: config?.allowedPageKeys ?? DEFAULT_PAGE_KEYS,\n      allowedProgressKeys: config?.allowedProgressKeys ?? DEFAULT_PROGRESS_KEYS,\n      allowedFormOptionsKeys: config?.allowedFormOptionsKeys ?? DEFAULT_FORM_OPTIONS_KEYS,\n    };\n  }\n\n  parse(code: string): AiFormParseResult {\n    try {\n      const sanitizedCode = this.sanitizeCode(code);\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n      const sanitized = this.validateAndSanitize(parsed);\n      const { schema, formOptions } = this.createFormedibleConfig(sanitized);\n\n      return {\n        schema,\n        formOptions,\n        success: true,\n      };\n    } catch (error) {\n      return {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private sanitizeCode(code: string): string {\n    let sanitized = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '').replace(/\\/\\/.*$/gm, '');\n    sanitized = sanitized.replace(/\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g, '');\n    sanitized = sanitized.replace(/=>\\s*{[^}]*}/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n    return sanitized;\n  }\n\n  private parseObjectLiteral(code: string): unknown {\n    try {\n      return JSON.parse(code);\n    } catch {\n      try {\n        let processedCode = code.trim();\n        processedCode = this.replaceZodExpressions(processedCode);\n        processedCode = processedCode.replace(/([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g, '$1\"$2\":');\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, '$1');\n        processedCode = processedCode.replace(/'/g, '\"');\n        return JSON.parse(processedCode);\n      } catch (conversionError) {\n        throw new Error(`Invalid syntax: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);\n      }\n    }\n  }\n\n  private replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n\n        while (endIndex < result.length && depth > 0) {\n          if (result[endIndex] === '(') {\n            depth++;\n          } else if (result[endIndex] === ')') {\n            depth--;\n          }\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                if (result[chainEndIndex] === '(') {\n                  chainDepth++;\n                } else if (result[chainEndIndex] === ')') {\n                  chainDepth--;\n                }\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          result = result.slice(0, startIndex) + '\"__ZOD_SCHEMA__\"' + result.slice(chainEnd);\n          changed = true;\n        } else {\n          result = result.replace(/z\\.[a-zA-Z]+/, '\"__ZOD_SCHEMA__\"');\n          changed = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private validateAndSanitize(obj: unknown): Record<string, unknown> {\n    if (typeof obj !== 'object' || obj === null) {\n      throw new Error('Definition must be an object');\n    }\n\n    const sanitized: Record<string, unknown> = {};\n    const input = obj as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(input)) {\n      if (!this.config.allowedKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'schema':\n          break;\n        case 'fields':\n          sanitized[key] = this.validateFields(value);\n          break;\n        case 'pages':\n          sanitized[key] = this.validatePages(value);\n          break;\n        case 'progress':\n          sanitized[key] = this.validateProgress(value);\n          break;\n        case 'formOptions':\n          sanitized[key] = this.validateFormOptions(value);\n          break;\n        case 'submitLabel':\n        case 'nextLabel':\n        case 'previousLabel':\n        case 'formClassName':\n        case 'fieldClassName':\n          if (typeof value === 'string') {\n            sanitized[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private validateFields(fields: unknown): FieldConfig[] {\n    if (!Array.isArray(fields)) {\n      throw new Error('Fields must be an array');\n    }\n\n    return fields.map((field, index) => {\n      if (typeof field !== 'object' || field === null) {\n        throw new Error(`Field at index ${index} must be an object`);\n      }\n\n      const sanitizedField: Record<string, unknown> = {};\n      const fieldObj = field as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(fieldObj)) {\n        if (!this.config.allowedFieldKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'name':\n            if (typeof value === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'type':\n            if (typeof value === 'string' && this.config.allowedFieldTypes.includes(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'label':\n          case 'placeholder':\n          case 'description':\n          case 'accept':\n            if (typeof value === 'string') {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'options':\n            if (Array.isArray(value)) {\n              sanitizedField[key] = value.filter(opt => \n                typeof opt === 'string' || \n                (typeof opt === 'object' && opt !== null && \n                 typeof (opt as { value?: unknown }).value === 'string' && \n                 typeof (opt as { label?: unknown }).label === 'string')\n              );\n            }\n            break;\n          case 'min':\n          case 'max':\n          case 'step':\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'multiple':\n          case 'conditional':\n            if (typeof value === 'boolean') {\n              sanitizedField[key] = value;\n            }\n            break;\n          default:\n            if (typeof value === 'object' && value !== null) {\n              sanitizedField[key] = value;\n            }\n            break;\n        }\n      }\n\n      if (!sanitizedField.name || !sanitizedField.type) {\n        throw new Error(`Field at index ${index} must have 'name' and 'type' properties`);\n      }\n\n      return sanitizedField as unknown as FieldConfig;\n    });\n  }\n\n  private validatePages(pages: unknown): Array<{ page: number; title?: string; description?: string }> {\n    if (!Array.isArray(pages)) {\n      return [];\n    }\n\n    return pages.map(page => {\n      if (typeof page !== 'object' || page === null) {\n        return null;\n      }\n\n      const sanitizedPage: Record<string, unknown> = {};\n      const pageObj = page as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(pageObj)) {\n        if (!this.config.allowedPageKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedPage[key] = value;\n            }\n            break;\n          case 'title':\n          case 'description':\n            if (typeof value === 'string') {\n              sanitizedPage[key] = value;\n            }\n            break;\n        }\n      }\n\n      return sanitizedPage.page ? sanitizedPage : null;\n    }).filter(Boolean) as Array<{ page: number; title?: string; description?: string }>;\n  }\n\n  private validateProgress(progress: unknown): Record<string, unknown> {\n    if (typeof progress !== 'object' || progress === null) {\n      return {};\n    }\n\n    const sanitizedProgress: Record<string, unknown> = {};\n    const progressObj = progress as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(progressObj)) {\n      if (!this.config.allowedProgressKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'showSteps':\n        case 'showPercentage':\n          if (typeof value === 'boolean') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n        case 'className':\n          if (typeof value === 'string') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedProgress;\n  }\n\n  private validateFormOptions(formOptions: unknown): Record<string, unknown> {\n    if (typeof formOptions !== 'object' || formOptions === null) {\n      return {};\n    }\n\n    const sanitizedOptions: Record<string, unknown> = {};\n    const optionsObj = formOptions as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(optionsObj)) {\n      if (!this.config.allowedFormOptionsKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'defaultValues':\n          if (typeof value === 'object' && value !== null) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'asyncDebounceMs':\n          if (typeof value === 'number' && !isNaN(value)) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'canSubmitWhenInvalid':\n          if (typeof value === 'boolean') {\n            sanitizedOptions[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedOptions;\n  }\n\n  private createFormedibleConfig(sanitized: Record<string, unknown>): { \n    schema: z.ZodSchema<Record<string, unknown>>; \n    formOptions: UseFormedibleOptions<Record<string, unknown>>; \n  } {\n    const fields = sanitized.fields as FieldConfig[] || [];\n    const schema = this.createSchemaFromFields(fields);\n    const defaultValues = this.createDefaultValues(fields);\n\n    const formOptions: UseFormedibleOptions<Record<string, unknown>> = {\n      fields,\n      schema,\n      pages: sanitized.pages as UseFormedibleOptions<Record<string, unknown>>['pages'],\n      progress: sanitized.progress as UseFormedibleOptions<Record<string, unknown>>['progress'],\n      submitLabel: sanitized.submitLabel as string,\n      nextLabel: sanitized.nextLabel as string,\n      previousLabel: sanitized.previousLabel as string,\n      formClassName: sanitized.formClassName as string,\n      fieldClassName: sanitized.fieldClassName as string,\n      formOptions: {\n        defaultValues,\n        ...(sanitized.formOptions as Record<string, unknown>),\n      },\n    };\n\n    return { schema, formOptions };\n  }\n\n  private createSchemaFromFields(fields: FieldConfig[]): z.ZodSchema<Record<string, unknown>> {\n    const schemaObj: Record<string, z.ZodTypeAny> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'colorPicker':\n        case 'autocomplete':\n        case 'masked':\n        case 'radio':\n        case 'select':\n          schemaObj[field.name] = z.string();\n          break;\n        case 'number':\n        case 'slider':\n        case 'rating':\n          schemaObj[field.name] = z.number();\n          break;\n        case 'checkbox':\n        case 'switch':\n          schemaObj[field.name] = z.boolean();\n          break;\n        case 'date':\n          schemaObj[field.name] = z.date();\n          break;\n        case 'file':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'location':\n          schemaObj[field.name] = z.object({\n            lat: z.number(),\n            lng: z.number(),\n            address: z.string().optional(),\n            city: z.string().optional(),\n            country: z.string().optional(),\n          }).optional();\n          break;\n        case 'duration':\n          schemaObj[field.name] = z.object({\n            hours: z.number().min(0),\n            minutes: z.number().min(0),\n          }).optional();\n          break;\n        case 'multiSelect':\n          schemaObj[field.name] = z.array(z.string());\n          break;\n        case 'object':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'array':\n          schemaObj[field.name] = z.array(z.any());\n          break;\n        default:\n          schemaObj[field.name] = z.string();\n      }\n    });\n\n    return z.object(schemaObj);\n  }\n\n  private createDefaultValues(fields: FieldConfig[]): Record<string, unknown> {\n    const defaults: Record<string, unknown> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'autocomplete':\n        case 'masked':\n          defaults[field.name] = '';\n          break;\n        case 'number':\n        case 'slider':\n          defaults[field.name] = field.min || 0;\n          break;\n        case 'checkbox':\n        case 'switch':\n          defaults[field.name] = false;\n          break;\n        case 'date':\n          defaults[field.name] = new Date().toISOString().split('T')[0];\n          break;\n        case 'select':\n        case 'radio':\n          if (field.options && Array.isArray(field.options) && field.options.length > 0) {\n            const firstOption = field.options[0];\n            defaults[field.name] = typeof firstOption === 'string' ? firstOption : (firstOption as { value: string }).value;\n          } else {\n            defaults[field.name] = '';\n          }\n          break;\n        case 'file':\n          defaults[field.name] = null;\n          break;\n        case 'rating':\n          defaults[field.name] = 1;\n          break;\n        case 'colorPicker':\n          defaults[field.name] = '#000000';\n          break;\n        case 'location':\n          defaults[field.name] = undefined;\n          break;\n        case 'duration':\n          defaults[field.name] = { hours: 0, minutes: 0 };\n          break;\n        case 'multiSelect':\n          defaults[field.name] = [];\n          break;\n        case 'object':\n          defaults[field.name] = {};\n          break;\n        case 'array':\n          defaults[field.name] = [];\n          break;\n        default:\n          defaults[field.name] = '';\n      }\n    });\n\n    return defaults;\n  }\n}\n\nexport function parseAiToFormedible(\n  code: string, \n  config?: AiParserConfig\n): AiFormParseResult {\n  const parser = new AiFormedibleParser(config);\n  return parser.parse(code);\n}\n\nconst AiFormRendererComponent: React.FC<AiFormRendererProps> = ({\n  code,\n  isStreaming = false,\n  onParseComplete,\n  onSubmit,\n  className,\n  parserConfig,\n  debug = false,\n}) => {\n  const [parseResult, setParseResult] = useState<AiFormParseResult | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const parseFormDefinition = useCallback(async () => {\n    if (!code.trim() || isStreaming) return;\n\n    setIsLoading(true);\n\n    try {\n      const result = parseAiToFormedible(code, parserConfig);\n      setParseResult(result);\n      onParseComplete?.(result);\n\n      if (debug && result.error) {\n        console.error('AI Form Parser Error:', result.error);\n      }\n    } catch (err) {\n      const errorResult: AiFormParseResult = {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: err instanceof Error ? err.message : String(err),\n      };\n      setParseResult(errorResult);\n      onParseComplete?.(errorResult);\n\n      if (debug) {\n        console.error('AI Form Renderer Error:', err);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [code, isStreaming, onParseComplete, parserConfig, debug]);\n\n  useEffect(() => {\n    if (!isStreaming && code.trim()) {\n      parseFormDefinition();\n    }\n  }, [code, isStreaming, parseFormDefinition]);\n\n  const formConfig = useMemo(() => {\n    if (!parseResult?.success || !parseResult.formOptions.fields?.length) {\n      return null;\n    }\n\n    return {\n      ...parseResult.formOptions,\n      formOptions: {\n        ...parseResult.formOptions.formOptions,\n        onSubmit: async ({ value }: { value: Record<string, unknown> }) => {\n          await onSubmit?.(value);\n        },\n      },\n    };\n  }, [parseResult, onSubmit]);\n\n  const formedibleResult = useFormedible(formConfig || {\n    fields: [],\n    formOptions: { defaultValues: {} }\n  });\n\n  const renderedForm = useMemo(() => {\n    if (isLoading) {\n      return (\n        <div className=\"flex items-center justify-center p-8\">\n          <div className=\"text-sm text-muted-foreground\">Parsing form...</div>\n        </div>\n      );\n    }\n\n    if (parseResult && !parseResult.success) {\n      return (\n        <div className=\"p-4 border border-destructive/20 bg-destructive/10 rounded-md\">\n          <div className=\"text-sm text-destructive\">\n            <div className=\"font-medium\">Parse Error</div>\n            <div className=\"text-xs mt-1 opacity-80\">{parseResult.error}</div>\n          </div>\n        </div>\n      );\n    }\n\n    if (!formConfig || !parseResult?.success) {\n      return null;\n    }\n\n    return <formedibleResult.Form />;\n  }, [isLoading, parseResult, formConfig, formedibleResult]);\n\n  return (\n    <div className={className}>\n      {renderedForm}\n    </div>\n  );\n};\n\nexport const AiFormRenderer = memo(AiFormRendererComponent);",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-form-renderer.tsx"
    },
    {
      "path": "src/components/formedible/ai/conversation-history.tsx",
      "content": "\"use client\";\n\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { History, MessageSquare, Trash2, Download, Plus } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\n\nexport interface Conversation {\n  id: string;\n  title: string;\n  messages: Message[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ConversationHistoryProps {\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onNewConversation?: () => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  className?: string;\n}\n\nexport function ConversationHistory({\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onNewConversation,\n  onExportConversation,\n  className,\n}: ConversationHistoryProps) {\n\n  const formatDate = (date: Date) => {\n    const now = new Date();\n    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);\n\n    if (diffInHours < 1) {\n      return \"Just now\";\n    } else if (diffInHours < 24) {\n      return `${Math.floor(diffInHours)}h ago`;\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n\n  const getConversationTitle = (conversation: Conversation) => {\n    if (conversation.title) return conversation.title;\n\n    // Generate title from first user message\n    const firstUserMessage = conversation.messages?.find(m => m.role === \"user\");\n    if (firstUserMessage?.content) {\n      const text = firstUserMessage.content;\n      return text.length > 50 ? text.substring(0, 50) + \"...\" : text;\n    }\n\n    return \"New Conversation\";\n  };\n\n  return (\n    <Card className={cn(\"h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <History className=\"h-5 w-5\" />\n            Conversation History\n            <Badge variant=\"secondary\">\n              {conversations.length}\n            </Badge>\n          </CardTitle>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </div>\n      </CardHeader>\n      <CardContent className=\"px-4 pt-0 pb-4\">\n        <div className=\"h-[300px] overflow-y-auto\">\n          {conversations.length === 0 ? (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground py-8\">\n              <MessageSquare className=\"h-8 w-8 mb-2 opacity-50\" />\n              <p className=\"text-sm\">No conversations yet</p>\n              <p className=\"text-xs\">Start a chat to see your history</p>\n            </div>\n          ) : (\n            <div className=\"space-y-1\">\n              {conversations.map((conversation) => (\n                <div\n                  key={conversation.id}\n                  className={cn(\n                    \"group flex items-center justify-between gap-2 px-2 py-1.5 rounded hover:bg-muted/50 cursor-pointer text-sm\",\n                    currentConversationId === conversation.id && \"bg-muted\"\n                  )}\n                  onClick={() => onSelectConversation(conversation)}\n                >\n                  <div className=\"flex-1 min-w-0\">\n                    <p className=\"font-medium truncate text-sm\">\n                      {getConversationTitle(conversation)}\n                    </p>\n                  </div>\n                  <div className=\"flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity shrink-0\">\n                    {onExportConversation && (\n                      <Button\n                        type=\"button\"\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        className=\"h-5 w-5\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          onExportConversation(conversation);\n                        }}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    )}\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-5 w-5 text-destructive hover:text-destructive\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        onDeleteConversation(conversation.id);\n                      }}\n                    >\n                      <Trash2 className=\"h-3 w-3\" />\n                    </Button>\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/conversation-history.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-messages.tsx",
      "content": "\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { streamText, type LanguageModel } from \"ai\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createMistral } from \"@ai-sdk/mistral\";\nimport { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { createOpenAICompatible } from \"@ai-sdk/openai-compatible\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport {\n  AlertCircle,\n  MessageSquare,\n  Send,\n  StopCircle,\n  User,\n  Bot,\n  Loader2,\n  ArrowDown,\n  Plus,\n} from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { CodeBlock } from \"@/components/ui/code-block\";\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\nimport type { AIBuilderMode, BackendConfig } from \"./ai-builder\";\nimport { extractFormedibleCode } from \"@/lib/form-extraction-utils\";\nimport { generateSystemPrompt, defaultParserConfig } from \"@/lib/formedible/parser-config-schema\";\nimport { toast } from \"sonner\";\n\n// MessageContent component to handle code blocks with syntax highlighting\ninterface MessageContentProps {\n  content: string;\n}\n\nfunction MessageContent({ content }: MessageContentProps) {\n  // Detect and render code blocks with syntax highlighting\n  const codeBlockRegex = /```(\\w+)?\\s*\\n([\\s\\S]*?)\\n```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      parts.push(\n        <span\n          key={`text-${lastIndex}`}\n          className=\"whitespace-pre-wrap break-words leading-relaxed\"\n        >\n          {content.slice(lastIndex, match.index)}\n        </span>\n      );\n    }\n\n    // Add code block with syntax highlighting\n    const language = match[1] || \"text\";\n    const code = match[2];\n    parts.push(\n      <div key={`code-${match.index}`} className=\"my-2\">\n        <CodeBlock\n          code={code}\n          language={language}\n          showLineNumbers={false}\n          showCopyButton={true}\n          className=\"text-xs\"\n          darkMode={true}\n          scrollable={false}\n        />\n      </div>\n    );\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Add remaining text\n  if (lastIndex < content.length) {\n    parts.push(\n      <span\n        key={`text-${lastIndex}`}\n        className=\"whitespace-pre-wrap break-words leading-relaxed\"\n      >\n        {content.slice(lastIndex)}\n      </span>\n    );\n  }\n\n  return (\n    <div className=\"space-y-1\">\n      {parts.length > 0 ? (\n        parts\n      ) : (\n        <span className=\"whitespace-pre-wrap break-words leading-relaxed\">\n          {content}\n        </span>\n      )}\n    </div>\n  );\n}\n\nexport interface Message {\n  id: string;\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface ChatMessagesProps {\n  onFormGenerated?: (formCode: string) => void;\n  onStreamingStateChange?: (isStreaming: boolean) => void;\n  onConversationUpdate?: (messages: Message[], isStreamEnd?: boolean) => void;\n  onNewConversation?: () => void;\n  messages?: Message[];\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n  mode?: AIBuilderMode;\n  backendConfig?: BackendConfig;\n}\n\nexport function ChatMessages({\n  onFormGenerated,\n  onStreamingStateChange,\n  onConversationUpdate,\n  onNewConversation,\n  messages: externalMessages,\n  className,\n  providerConfig,\n  mode = \"direct\",\n  backendConfig,\n}: ChatMessagesProps) {\n  const [input, setInput] = useState(\"\");\n  const [messages, setMessages] = useState<Message[]>(externalMessages || []);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [showScrollToBottom, setShowScrollToBottom] = useState(false);\n  const messagesContainerRef = useRef<HTMLDivElement>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Remove the automatic conversation completion\n\n  const scrollToBottom = useCallback(() => {\n    const container = messagesContainerRef.current;\n    if (container) {\n      container.scrollTop = container.scrollHeight;\n    }\n  }, []);\n\n  const handleScroll = useCallback(() => {\n    if (!messagesContainerRef.current) return;\n\n    const { scrollTop, scrollHeight, clientHeight } =\n      messagesContainerRef.current;\n    const isAtBottom = scrollHeight - scrollTop - clientHeight < 100;\n\n    setShowScrollToBottom(!isAtBottom && messages.length > 0);\n  }, [messages.length]);\n\n  // Sync with external messages when switching conversations\n  useEffect(() => {\n    if (externalMessages !== undefined) {\n      setMessages(externalMessages);\n    }\n  }, [externalMessages]);\n\n  // Remove the useEffect that was causing multiple updates\n\n  // Removed auto-scroll - let users control scrolling manually\n\n  useEffect(() => {\n    const container = messagesContainerRef.current;\n    if (!container) return;\n\n    container.addEventListener(\"scroll\", handleScroll);\n    handleScroll(); // Check initial state\n\n    return () => container.removeEventListener(\"scroll\", handleScroll);\n  }, [handleScroll]);\n\n  const createModel = (config: ProviderConfig): LanguageModel => {\n    const { provider, apiKey, model, endpoint } = config;\n\n    switch (provider) {\n      case \"openai\": {\n        const openaiProvider = createOpenAI({ apiKey });\n        // Flagship latest; swap to \"gpt-5-mini\" if you prefer cost/latency.\n        return openaiProvider(model || \"gpt-5\");\n      }\n\n      case \"anthropic\": {\n        const anthropicProvider = createAnthropic({ apiKey });\n        // Latest Sonnet generation\n        // TODO : fix this shit ! -_-\n        return anthropicProvider(\n          model || \"claude-sonnet-4\"\n        ) as unknown as LanguageModel;\n      }\n\n      case \"google\": {\n        const googleProvider = createGoogleGenerativeAI({ apiKey });\n        // Latest top reasoning model in Gemini API\n        return googleProvider(model || \"gemini-2.5-pro\");\n      }\n\n      case \"mistral\": {\n        const mistralProvider = createMistral({ apiKey });\n        // Mistral Large 2 (GA, sometimes shown as mistral-large-2407)\n        return mistralProvider(model || \"mistral-large-2407\");\n      }\n\n      case \"openrouter\": {\n        const openrouterProvider = createOpenRouter({ apiKey });\n        // OpenRouter must route to Kimi K2 per your requirement\n        // Common IDs: \"openrouter/kimiplus-k2\" (preferred) or \"moonshotai/moonshot-k2\"\n        return openrouterProvider.chat(\n          model || \"openrouter/kimiplus-k2\"\n        ) as LanguageModel;\n      }\n\n      case \"openai-compatible\": {\n        if (!endpoint)\n          throw new Error(\"Endpoint required for OpenAI-compatible providers\");\n        const openaiCompatible = createOpenAICompatible({\n          name: \"openai-compatible\",\n          baseURL: endpoint,\n          ...(apiKey && { apiKey }),\n        });\n        // Use a modern widely supported baseline; adjust to your endpoint's catalog\n        return openaiCompatible(model || \"gpt-4.1-mini\");\n      }\n\n      default:\n        throw new Error(\"Unsupported provider\");\n    }\n  };\n\n  const isServiceConfigured = (): boolean => {\n    if (mode === \"backend\") {\n      return !!(backendConfig && backendConfig.endpoint && backendConfig.endpoint.trim().length > 0);\n    }\n    \n    // For direct mode, check provider configuration\n    if (!providerConfig) return false;\n    \n    // Check if provider requires API key\n    const providersRequiringKey = [\"openai\", \"anthropic\", \"google\", \"mistral\", \"openrouter\"];\n    if (providersRequiringKey.includes(providerConfig.provider as string)) {\n      return !!(providerConfig.apiKey && providerConfig.apiKey.trim().length > 0);\n    }\n    \n    // For openai-compatible, endpoint is required\n    if (providerConfig.provider === \"openai-compatible\") {\n      return !!(providerConfig.endpoint && providerConfig.endpoint.trim().length > 0);\n    }\n    \n    return true;\n  };\n\n  // AI service abstraction - handles both direct and backend modes\n  const generateAIResponse = async (\n    userMessage: string, \n    conversationMessages: Message[],\n    systemPrompt: string,\n    abortSignal: AbortSignal\n  ): Promise<AsyncIterable<string>> => {\n    if (mode === \"backend\") {\n      // Backend mode - make API call to developer's endpoint\n      if (!backendConfig?.endpoint) {\n        throw new Error(\"Backend endpoint not configured\");\n      }\n\n      const response = await fetch(backendConfig.endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...backendConfig.headers,\n        },\n        body: JSON.stringify({\n          messages: conversationMessages.map(msg => ({\n            role: msg.role,\n            content: msg.content,\n          })),\n          systemPrompt,\n          userMessage,\n        }),\n        signal: abortSignal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Backend request failed: ${response.status} ${response.statusText}`);\n      }\n\n      if (!response.body) {\n        throw new Error(\"No response body from backend\");\n      }\n\n      // Return async iterator for streaming response\n      return {\n        async *[Symbol.asyncIterator]() {\n          const reader = response.body!.getReader();\n          const decoder = new TextDecoder();\n          \n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              \n              const chunk = decoder.decode(value, { stream: true });\n              yield chunk;\n            }\n          } finally {\n            reader.releaseLock();\n          }\n        },\n      };\n    } else {\n      // Direct mode - use AI SDK as before\n      if (!providerConfig) {\n        throw new Error(\"Provider configuration required\");\n      }\n\n      const model = createModel(providerConfig);\n      const result = streamText({\n        model,\n        system: systemPrompt,\n        messages: conversationMessages.map((msg) => ({\n          role: msg.role,\n          content: msg.content,\n        })),\n        temperature: providerConfig.temperature || 0.7,\n        maxOutputTokens: providerConfig.maxTokens || 2000,\n        abortSignal,\n      });\n\n      return result.textStream;\n    }\n  };\n\n  const generateResponse = async (userMessage: string) => {\n    if (!isServiceConfigured()) {\n      toast.error(mode === \"backend\" ? \"Backend not configured\" : \"Provider not configured\", {\n        description: mode === \"backend\" \n          ? \"Backend endpoint configuration is required to send messages.\"\n          : \"Please configure your AI provider with a valid API key before sending messages.\"\n      });\n      setError(new Error(\"Service configuration required\"));\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n      onStreamingStateChange?.(true);\n\n      const userMsg: Message = {\n        id: Date.now().toString(),\n        role: \"user\",\n        content: userMessage,\n      };\n\n      const newMessages = [...messages, userMsg];\n      setMessages(newMessages);\n\n      // Get parser configuration from localStorage or use defaults\n      let parserConfig = defaultParserConfig;\n      try {\n        const savedConfig = localStorage.getItem('formedible-parser-config');\n        if (savedConfig) {\n          const parsed = JSON.parse(savedConfig);\n          parserConfig = { ...defaultParserConfig, ...parsed };\n        }\n      } catch (error) {\n        console.warn('Failed to load parser config, using defaults:', error);\n      }\n\n      // Generate dynamic system prompt based on configuration\n      const configuredSystemPrompt = generateSystemPrompt(parserConfig);\n      \n      const baseSystemPrompt = `You are a helpful AI assistant for form creation. You can chat naturally with users about forms, answer questions, and help them design forms.\n\n**IMPORTANT: Only show formedible code blocks when the user specifically asks to create, build, generate, or show a form.**\n\nWhen creating forms, use formedible code blocks with complete JavaScript object literal syntax including Zod schemas. Chat naturally. Ask clarifying questions. Suggest improvements. Only output formedible blocks when specifically requested.`;\n\n      const systemPrompt = configuredSystemPrompt \n        ? `${baseSystemPrompt}\\n\\n${configuredSystemPrompt}` \n        : baseSystemPrompt;\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      // Use the AI service abstraction\n      const textStream = await generateAIResponse(\n        userMessage,\n        [...messages, userMsg],\n        systemPrompt,\n        abortController.signal\n      );\n\n      const assistantMsg: Message = {\n        id: (Date.now() + 1).toString(),\n        role: \"assistant\",\n        content: \"\",\n      };\n\n      setMessages((prev) => [...prev, assistantMsg]);\n\n      let fullResponse = \"\";\n      for await (const textPart of textStream) {\n        if (abortController.signal.aborted) break;\n\n        fullResponse += textPart;\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === assistantMsg.id ? { ...msg, content: fullResponse } : msg\n          )\n        );\n      }\n\n      // Extract and send formedible code blocks to preview\n      if (fullResponse && onFormGenerated) {\n        const code = extractFormedibleCode(fullResponse);\n        if (code) {\n          onFormGenerated(code);\n        }\n      }\n\n      onStreamingStateChange?.(false);\n\n      // Save conversation to localStorage ONLY on stream end with complete messages\n      const finalMessages = [\n        ...newMessages, // This includes user message\n        { ...assistantMsg, content: fullResponse },\n      ];\n      onConversationUpdate?.(finalMessages, true);\n    } catch (err) {\n      console.error(\"AI Generation Error:\", err);\n      setError(\n        err instanceof Error ? err : new Error(\"Unknown error occurred\")\n      );\n    } finally {\n      setIsLoading(false);\n      onStreamingStateChange?.(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!input.trim() || isLoading) return;\n\n    if (!isServiceConfigured()) {\n      toast.error(mode === \"backend\" ? \"Backend configuration required\" : \"Provider configuration required\", {\n        description: mode === \"backend\" \n          ? \"Backend endpoint configuration is required to send messages.\"\n          : \"Please set up your AI provider with a valid API key in the settings before sending messages.\"\n      });\n      return;\n    }\n\n    const userInput = input;\n    setInput(\"\");\n    generateResponse(userInput);\n  };\n\n  const stop = () => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit(e);\n    }\n  };\n\n  return (\n    <Card\n      className={cn(\n        \"flex flex-col h-full max-h-full border-2 border-accent/30 shadow-lg !py-0 !gap-0 overflow-hidden\",\n        className\n      )}\n    >\n      <CardHeader className=\"px-3 pt-1 pb-0 bg-gradient-to-r from-accent/10 to-transparent\">\n        <CardTitle className=\"flex items-center justify-between text-lg\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-accent/20 rounded-lg\">\n              <MessageSquare className=\"h-5 w-5 text-accent-foreground\" />\n            </div>\n            <span className=\"text-foreground font-semibold\">\n              AI Form Builder Chat\n            </span>\n          </div>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </CardTitle>\n      </CardHeader>\n\n      <CardContent className=\"flex flex-col flex-1 px-3 pt-0 pb-1 min-h-0 max-h-full relative overflow-hidden\">\n        <div\n          ref={messagesContainerRef}\n          className=\"flex-1 overflow-y-auto space-y-3 mb-1 pr-2 min-h-0\"\n        >\n          {messages.length === 0 && (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground\">\n              <Bot className=\"h-12 w-12 mb-4 opacity-50\" />\n              <h3 className=\"text-lg font-medium mb-2\">\n                Welcome to AI Form Builder\n              </h3>\n              <p className=\"text-sm max-w-md\">\n                Describe the form you want to create and I'll generate it for\n                you. Try something like \"Create a contact form with name, email,\n                and message fields\"\n              </p>\n            </div>\n          )}\n\n          {messages.map((message: Message) => (\n            <div\n              key={message.id}\n              className={cn(\n                \"flex gap-3 max-w-4xl\",\n                message.role === \"user\" ? \"ml-auto flex-row-reverse\" : \"mr-auto\"\n              )}\n            >\n              <div\n                className={cn(\n                  \"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-muted text-foreground border-border\"\n                )}\n              >\n                {message.role === \"user\" ? (\n                  <User className=\"h-4 w-4\" />\n                ) : (\n                  <Bot className=\"h-4 w-4\" />\n                )}\n              </div>\n\n              <div\n                className={cn(\n                  \"flex flex-col gap-2 rounded-lg px-4 py-3 text-sm shadow-md border max-w-[85%]\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-background text-foreground border-border\"\n                )}\n              >\n                <MessageContent content={message.content} />\n              </div>\n            </div>\n          ))}\n\n          {isLoading && (\n            <div className=\"flex gap-3 max-w-4xl mr-auto\">\n              <div className=\"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md bg-muted text-foreground border-border\">\n                <Bot className=\"h-4 w-4\" />\n              </div>\n              <div className=\"flex items-center gap-2 rounded-lg px-4 py-3 text-sm shadow-md border bg-background text-foreground border-border\">\n                <Loader2 className=\"h-4 w-4 animate-spin text-primary\" />\n                <span>Generating response...</span>\n              </div>\n            </div>\n          )}\n\n        </div>\n\n        {/* Scroll to bottom button */}\n        {showScrollToBottom && (\n          <Button\n            onClick={scrollToBottom}\n            className=\"absolute bottom-20 right-4 rounded-full w-10 h-10 p-0 shadow-lg z-10\"\n            variant=\"secondary\"\n            size=\"sm\"\n          >\n            <ArrowDown className=\"h-4 w-4\" />\n            <span className=\"sr-only\">Scroll to bottom</span>\n          </Button>\n        )}\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>\n              Failed to send message. Please check your configuration and try\n              again.\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"flex gap-2\">\n          <Textarea\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Describe the form you want to create... (Shift+Enter for new line)\"\n            disabled={isLoading}\n            className=\"flex-1 min-h-[80px] resize-none\"\n            rows={3}\n          />\n\n          {isLoading ? (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n              onClick={stop}\n              className=\"shrink-0\"\n            >\n              <StopCircle className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Stop generation</span>\n            </Button>\n          ) : (\n            <Button\n              type=\"submit\"\n              disabled={!input.trim() || !isServiceConfigured()}\n              size=\"icon\"\n              className=\"shrink-0\"\n            >\n              <Send className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Send message</span>\n            </Button>\n          )}\n        </form>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-messages.tsx"
    },
    {
      "path": "src/components/formedible/ai/sidebar-icons.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { \n  ChevronLeft, \n  ChevronRight, \n  History, \n  Settings, \n  Globe,\n  FileText \n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport type SidebarView = \"history\" | \"settings\" | \"provider\" | \"parser\";\n\ninterface SidebarIconsProps {\n  isCollapsed: boolean;\n  onToggleCollapse: () => void;\n  activeView: SidebarView | null;\n  onViewChange: (view: SidebarView | null) => void;\n}\n\nexport function SidebarIcons({\n  isCollapsed,\n  onToggleCollapse,\n  activeView,\n  onViewChange,\n}: SidebarIconsProps) {\n  const handleIconClick = (view: SidebarView) => {\n    if (activeView === view) {\n      // If clicking the same icon, close the sidebar\n      onViewChange(null);\n    } else {\n      // If clicking different icon, switch view\n      onViewChange(view);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col w-12 bg-muted/20 border-r border-border\">\n      {/* Collapse/expand button */}\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={onToggleCollapse}\n        className=\"h-12 w-12 rounded-none border-b border-border hover:bg-muted/40\"\n      >\n        {isCollapsed ? (\n          <ChevronRight className=\"h-4 w-4\" />\n        ) : (\n          <ChevronLeft className=\"h-4 w-4\" />\n        )}\n        <span className=\"sr-only\">\n          {isCollapsed ? \"Expand sidebar\" : \"Collapse sidebar\"}\n        </span>\n      </Button>\n\n      {/* Icon buttons */}\n      <div className=\"flex flex-col\">\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"history\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"history\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <History className=\"h-4 w-4\" />\n          <span className=\"sr-only\">History</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"settings\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"settings\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <Settings className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Settings</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"provider\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"provider\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <Globe className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Provider</span>\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => handleIconClick(\"parser\")}\n          className={cn(\n            \"h-12 w-12 rounded-none hover:bg-muted/40\",\n            activeView === \"parser\" && \"bg-muted text-foreground\"\n          )}\n        >\n          <FileText className=\"h-4 w-4\" />\n          <span className=\"sr-only\">Form Parser Settings</span>\n        </Button>\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/sidebar-icons.tsx"
    },
    {
      "path": "src/components/formedible/ai/sidebar-content.tsx",
      "content": "\"use client\";\n\nimport { Card } from \"@/components/ui/card\";\nimport { cn } from \"@/lib/utils\";\nimport type { SidebarView } from \"./sidebar-icons\";\nimport { ConversationHistory, type Conversation, type ConversationHistoryProps } from \"./conversation-history\";\nimport { AgentSettings } from \"./agent-settings\";\nimport { ProviderSelection } from \"./provider-selection\";\nimport { ParserSettings } from \"./parser-settings\";\nimport type { ProviderConfig } from \"./provider-selection\";\n\ninterface SidebarContentProps {\n  activeView: SidebarView | null;\n  isCollapsed: boolean;\n  className?: string;\n  \n  // History props\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onNewConversation?: () => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  \n  // Settings props  \n  providerConfig: ProviderConfig | null;\n  onConfigChange: (config: ProviderConfig | null) => void;\n}\n\nexport function SidebarContent({\n  activeView,\n  isCollapsed,\n  className,\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onNewConversation,\n  onExportConversation,\n  providerConfig,\n  onConfigChange,\n}: SidebarContentProps) {\n  if (isCollapsed || !activeView) {\n    return null;\n  }\n\n  const renderContent = () => {\n    switch (activeView) {\n      case \"history\":\n        return (\n          <ConversationHistory\n            conversations={conversations}\n            currentConversationId={currentConversationId}\n            onSelectConversation={onSelectConversation}\n            onDeleteConversation={onDeleteConversation}\n            onNewConversation={onNewConversation}\n            onExportConversation={onExportConversation}\n            className=\"border-0 shadow-none h-full\"\n          />\n        );\n        \n      case \"settings\":\n        return (\n          <Card className=\"h-full\">\n            <AgentSettings\n              providerConfig={providerConfig}\n              onConfigChange={onConfigChange}\n              className=\"h-full\"\n            />\n          </Card>\n        );\n        \n      case \"provider\":\n        return (\n          <Card className=\"h-full\">\n            <ProviderSelection\n              onConfigChange={onConfigChange}\n              initialConfig={providerConfig}\n              className=\"h-full\"\n            />\n          </Card>\n        );\n        \n      case \"parser\":\n        return (\n          <ParserSettings\n            className=\"h-full\"\n          />\n        );\n        \n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div\n      className={cn(\n        \"w-80 border-r border-border bg-background/50 transition-all duration-200 ease-in-out overflow-hidden\",\n        isCollapsed ? \"w-0\" : \"w-80\",\n        className\n      )}\n    >\n      <div className=\"h-full p-2 overflow-y-auto\">\n        {renderContent()}\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/sidebar-content.tsx"
    },
    {
      "path": "src/components/formedible/ai/agent-settings.tsx",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { ProviderConfig, AIProvider } from \"./provider-selection\";\n\ninterface AgentSettingsProps {\n  providerConfig: ProviderConfig | null;\n  onConfigChange: (config: ProviderConfig | null) => void;\n  className?: string;\n}\n\n// OpenRouter models fetcher with memoization\nconst fetchOpenRouterModels = async (apiKey: string) => {\n  const response = await fetch(\"https://openrouter.ai/api/v1/models\", {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.data\n    .filter((model: any) => model.id && model.name && model.id.trim() !== \"\")\n    .map((model: any) => ({\n      value: model.id,\n      label: model.name,\n    }))\n    .sort((a: any, b: any) => a.label.localeCompare(b.label));\n};\n\n// Memoized function to get model options based on provider\nconst useModelOptions = (\n  provider: AIProvider | undefined,\n  openRouterModels: Array<{ value: string; label: string }> = [],\n  openRouterLoading: boolean = false\n) => {\n  return useMemo(() => {\n    if (provider === \"openai\")\n      return [\n        { value: \"gpt-5\", label: \"GPT-5\" },\n        { value: \"gpt-5-mini\", label: \"GPT-5 Mini\" },\n        { value: \"gpt-4o\", label: \"GPT-4o\" },\n        { value: \"gpt-4o-mini\", label: \"GPT-4o Mini\" },\n      ];\n    if (provider === \"anthropic\")\n      return [\n        { value: \"claude-sonnet-4\", label: \"Claude Sonnet 4\" },\n        { value: \"claude-3-5-sonnet-20241022\", label: \"Claude 3.5 Sonnet\" },\n        { value: \"claude-3-haiku-20240307\", label: \"Claude 3 Haiku\" },\n      ];\n    if (provider === \"google\")\n      return [\n        { value: \"gemini-2.5-pro\", label: \"Gemini 2.5 Pro\" },\n        { value: \"gemini-1.5-pro\", label: \"Gemini 1.5 Pro\" },\n        { value: \"gemini-1.5-flash\", label: \"Gemini 1.5 Flash\" },\n      ];\n    if (provider === \"mistral\")\n      return [\n        { value: \"mistral-large-2407\", label: \"Mistral Large 2407\" },\n        { value: \"mistral-medium-2312\", label: \"Mistral Medium 2312\" },\n        { value: \"mistral-small-2312\", label: \"Mistral Small 2312\" },\n      ];\n    if (provider === \"openrouter\") {\n      if (openRouterLoading) return [{ value: \"loading\", label: \"Loading models...\" }];\n      return openRouterModels.length > 0\n        ? openRouterModels.filter(model => model.value && model.value.trim() !== \"\")\n        : [\n            { value: \"openrouter/kimiplus-k2\", label: \"OpenRouter Kimi Plus K2\" },\n            { value: \"moonshotai/moonshot-k2\", label: \"Moonshot K2\" },\n          ];\n    }\n    if (provider === \"openai-compatible\")\n      return [\n        { value: \"gpt-4.1-mini\", label: \"GPT-4.1 Mini\" },\n        { value: \"custom-model\", label: \"Custom Model\" },\n      ];\n    return [];\n  }, [provider, openRouterModels, openRouterLoading]);\n};\n\nexport function AgentSettings({ providerConfig, onConfigChange, className }: AgentSettingsProps) {\n  // Use TanStack Query for OpenRouter models with proper caching\n  const {\n    data: openRouterModels = [],\n    isLoading: openRouterLoading,\n    error: openRouterError,\n  } = useQuery({\n    queryKey: [\"openrouter-models\", providerConfig?.apiKey],\n    queryFn: () => fetchOpenRouterModels(providerConfig?.apiKey || \"\"),\n    enabled: providerConfig?.provider === \"openrouter\" && !!providerConfig?.apiKey && providerConfig.apiKey.length > 0,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    gcTime: 10 * 60 * 1000, // 10 minutes\n    retry: 1,\n  });\n\n  const availableModels = useModelOptions(\n    providerConfig?.provider,\n    openRouterModels,\n    openRouterLoading\n  );\n\n  const { Form } = useFormedible({\n    fields: !providerConfig ? [] : [\n      {\n        name: \"model\",\n        type: \"select\",\n        label: \"Model\",\n        placeholder: \"Select a model\",\n        options: providerConfig?.provider === \"openrouter\" && openRouterError\n          ? [{ value: \"error\", label: \"Failed to load models - check API key\" }]\n          : availableModels,\n      },\n      {\n        name: \"temperature\",\n        type: \"slider\",\n        label: `Temperature: ${(providerConfig?.temperature || 0.7).toFixed(2)}`,\n        sliderConfig: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        description: \"Controls randomness: Focused ← → Creative\",\n      },\n      {\n        name: \"maxTokens\",\n        type: \"number\",\n        label: \"Max Tokens\",\n        placeholder: \"2000\",\n        description: \"Maximum response length\",\n        numberConfig: {\n          min: 1,\n          max: 32768,\n        },\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        model: providerConfig?.model || \"\",\n        temperature: providerConfig?.temperature || 0.7,\n        maxTokens: providerConfig?.maxTokens || 2000,\n      },\n      onSubmit: async ({ value }) => {\n        if (!providerConfig) return;\n        const updatedConfig: ProviderConfig = {\n          ...providerConfig,\n          model: value.model,\n          temperature: value.temperature,\n          maxTokens: value.maxTokens,\n        };\n        onConfigChange(updatedConfig);\n      },\n    },\n    submitLabel: \"💾 Save Model Settings\",\n    showSubmitButton: !providerConfig ? false : true,\n    autoSubmitOnChange: false,\n  });\n\n  return (\n    <div className={`p-4 space-y-4 ${className || \"\"}`}>\n      <h3 className=\"text-base font-semibold\">Model Settings</h3>\n      {!providerConfig ? (\n        <p className=\"text-muted-foreground\">Select a provider first to configure model settings</p>\n      ) : (\n        <Form />\n      )}\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/agent-settings.tsx"
    },
    {
      "path": "src/components/formedible/ai/parser-settings.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { \n  parserConfigFields, \n  defaultParserConfig, \n  validateParserConfig,\n  mergeParserConfig,\n  generateSystemPrompt,\n  type ParserConfig \n} from \"@/lib/formedible/parser-config-schema\";\nimport { Info, RotateCcw, Copy, Check } from \"lucide-react\";\n\ninterface ParserSettingsProps {\n  className?: string;\n  onConfigChange?: (config: ParserConfig) => void;\n}\n\nexport function ParserSettings({ className, onConfigChange }: ParserSettingsProps) {\n  const [config, setConfig] = useState<ParserConfig>(defaultParserConfig);\n  const [lastSavedConfig, setLastSavedConfig] = useState<ParserConfig>(defaultParserConfig);\n  const [copied, setCopied] = useState(false);\n\n  // Load saved config on mount\n  useEffect(() => {\n    try {\n      const saved = localStorage.getItem('formedible-parser-config');\n      if (saved) {\n        const parsed = JSON.parse(saved);\n        if (validateParserConfig(parsed)) {\n          setConfig(parsed);\n          setLastSavedConfig(parsed);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load parser config:', error);\n    }\n  }, []);\n\n  // Check if there are unsaved changes\n  const hasChanges = JSON.stringify(config) !== JSON.stringify(lastSavedConfig);\n\n  // Save config to localStorage and notify parent\n  const handleSaveConfig = (newConfig: ParserConfig) => {\n    try {\n      localStorage.setItem('formedible-parser-config', JSON.stringify(newConfig));\n      setConfig(newConfig);\n      setLastSavedConfig(newConfig);\n      onConfigChange?.(newConfig);\n    } catch (error) {\n      console.error('Failed to save parser config:', error);\n    }\n  };\n\n  // Reset to defaults\n  const handleReset = () => {\n    const resetConfig = { ...defaultParserConfig };\n    handleSaveConfig(resetConfig);\n  };\n\n  // Copy system prompt to clipboard\n  const handleCopySystemPrompt = async () => {\n    try {\n      const systemPrompt = generateSystemPrompt(lastSavedConfig);\n      const promptToCopy = systemPrompt || 'System prompt will be generated based on current configuration...';\n      \n      await navigator.clipboard.writeText(promptToCopy);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy system prompt:', error);\n    }\n  };\n\n  // Create form fields with conditional logic\n  const formFields = [\n    // Basic Configuration Section\n    ...parserConfigFields\n      .filter(field => \n        ['strictValidation', 'enableSchemaInference', 'fieldTypeValidation'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n      })),\n    \n    // Show Advanced Settings (after basic fields)\n    {\n      name: 'showAdvanced',\n      type: 'switch',\n      label: 'Show Advanced Settings',\n      description: 'Display advanced configuration options',\n      defaultValue: false,\n    },\n    \n    // Advanced Configuration Section (conditional)\n    ...parserConfigFields\n      .filter(field => \n        !['strictValidation', 'enableSchemaInference', 'fieldTypeValidation', 'selectFields', 'systemPromptFields', 'includeTabFormatting', 'includePageFormatting'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n        conditional: (values: any) => values.showAdvanced === true,\n      })),\n\n    // System Prompt Fields\n    ...parserConfigFields\n      .filter(field => \n        ['selectFields', 'systemPromptFields'].includes(field.name)\n      )\n      .map(field => ({\n        ...field,\n        conditional: field.name === 'systemPromptFields'\n          ? (values: any) => values.selectFields === true\n          : undefined\n      })),\n\n    // Formatting Options (always visible)\n    ...parserConfigFields\n      .filter(field => \n        ['includeTabFormatting', 'includePageFormatting'].includes(field.name)\n      )\n  ];\n\n  const { Form, form } = useFormedible<ParserConfig & { showAdvanced: boolean }>({\n    fields: formFields,\n    formOptions: {\n      defaultValues: { \n        ...config, \n        showAdvanced: false,\n        // Ensure all system prompt fields have proper defaults\n        selectFields: config.selectFields ?? false,\n        systemPromptFields: config.systemPromptFields ?? defaultParserConfig.systemPromptFields,\n        includeTabFormatting: config.includeTabFormatting ?? defaultParserConfig.includeTabFormatting,\n        includePageFormatting: config.includePageFormatting ?? defaultParserConfig.includePageFormatting\n      },\n      onSubmit: async ({ value }) => {\n        // Extract showAdvanced and save the rest\n        const { showAdvanced, ...parserConfig } = value;\n        const mergedConfig = mergeParserConfig({ ...config, ...parserConfig });\n        handleSaveConfig(mergedConfig);\n      },\n      // NO onChange - we only update when the user clicks Save!\n    },\n    submitLabel: hasChanges ? \"Save Settings\" : \"Settings Saved\",\n    showSubmitButton: hasChanges,\n    autoSubmitOnChange: false,\n    layout: {\n      type: 'grid',\n      columns: 1,\n      gap: 'md'\n    }\n  });\n\n  return (\n    <div className={`space-y-4 ${className || \"\"}`}>\n      <Card>\n        <CardHeader className=\"pb-3\">\n          <CardTitle className=\"flex items-center gap-2 text-base\">\n            <Info className=\"h-4 w-4\" />\n            Form Parser Settings\n          </CardTitle>\n          <CardDescription>\n            Configure how the Formedible parser processes form definitions and handles AI interactions.\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n\n          {/* Formedible Form */}\n          <div className=\"space-y-4\">\n            <Form />\n          </div>\n\n          {/* Action Buttons */}\n          <div className=\"flex flex-wrap gap-2 pt-4 border-t\">\n            <Button \n              onClick={handleReset}\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"flex items-center gap-2\"\n            >\n              <RotateCcw className=\"h-3 w-3\" />\n              Reset to Defaults\n            </Button>\n            \n            <Button\n              onClick={handleCopySystemPrompt}\n              variant={copied ? \"default\" : \"outline\"}\n              size=\"sm\"\n              className=\"flex items-center gap-2\"\n            >\n              {copied ? (\n                <>\n                  <Check className=\"h-3 w-3\" />\n                  Copied!\n                </>\n              ) : (\n                <>\n                  <Copy className=\"h-3 w-3\" />\n                  Copy Prompt\n                </>\n              )}\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* System Prompt Preview */}\n      <Card>\n        <CardHeader className=\"pb-3\">\n          <CardTitle className=\"text-sm\">System Prompt Preview</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"p-3 bg-muted rounded-md text-xs overflow-auto max-h-64\">\n            <pre className=\"whitespace-pre-wrap\">\n              {generateSystemPrompt(lastSavedConfig) || 'System prompt will be generated based on current saved configuration...'}\n            </pre>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/parser-settings.tsx"
    },
    {
      "path": "src/components/formedible/ai/sandpack-preview.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useCallback, useMemo, useRef } from \"react\";\nimport { \n  SandpackProvider, \n  SandpackLayout, \n  SandpackPreview as SandpackPreviewComponent,\n  SandpackConsole,\n  SandpackFileExplorer,\n  SandpackCodeEditor,\n  SandpackFiles,\n  SandpackPredefinedTemplate,\n  useSandpack\n} from \"@codesandbox/sandpack-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Tooltip, TooltipTrigger, TooltipContent } from \"@/components/ui/tooltip\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { \n  AlertTriangle, \n  Loader2, \n  CheckCircle, \n  XCircle, \n  ExternalLink,\n  RefreshCw,\n  Terminal,\n  TerminalSquare,\n  Eye,\n  EyeOff,\n  Settings,\n  Code2,\n  Play\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { \n  injectFormCodeIntoSandbox,\n  validateFormCode,\n  createSandboxFiles,\n  type SandboxFiles as SandboxFilesType,\n  type InjectionOptions\n} from \"@/lib/sandbox-code-injector\";\nimport {\n  getCachedTemplate,\n  setCachedTemplate,\n  generateCacheKey,\n  getCacheStatistics\n} from \"@/lib/sandbox-cache\";\nimport {\n  analyzeFormCode,\n  splitFormCode,\n  splitResultToSandpackFiles\n} from \"@/lib/code-splitting-utils\";\n\nexport interface SandpackPreviewProps {\n  /** The generated form code to preview */\n  formCode?: string;\n  /** Callback when form is submitted in the sandbox */\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  /** Callback when form error occurs in the sandbox */\n  onFormError?: (error: Error) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** Whether to show the code editor alongside preview */\n  showCodeEditor?: boolean;\n  /** Whether to show console output */\n  showConsole?: boolean;\n  /** Whether to show file explorer */\n  showFileExplorer?: boolean;\n  /** Template to use for the sandbox */\n  template?: SandpackPredefinedTemplate;\n  /** Whether the component is in loading state */\n  isLoading?: boolean;\n  /** Custom height for the preview */\n  height?: string;\n  /** Options for code injection */\n  injectionOptions?: InjectionOptions;\n  /** Whether to show validation status */\n  showValidationStatus?: boolean;\n  /** Custom styles to inject */\n  customStyles?: string;\n  /** Whether to show the toolbar controls */\n  showToolbar?: boolean;\n  /** Whether to show loading progress */\n  showProgress?: boolean;\n  /** Callback when preview is refreshed */\n  onRefresh?: () => void;\n  /** Callback when CodeSandbox is opened */\n  onOpenCodeSandbox?: (sandboxUrl: string) => void;\n  /** Whether to enable performance optimizations */\n  enablePerformanceMode?: boolean;\n  /** Whether to show performance metrics */\n  showPerformanceMetrics?: boolean;\n  /** Form fields for code splitting analysis */\n  formFields?: any[];\n  /** Whether to enable code splitting for large forms */\n  enableCodeSplitting?: boolean;\n}\n\n// Default template files for Formedible forms\nconst DEFAULT_FORMEDIBLE_FILES: SandpackFiles = {\n  \"/App.tsx\": `import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport FormComponent from './FormComponent';\nimport './styles.css';\n\nfunction App() {\n  const handleFormSubmit = (data: Record<string, unknown>) => {\n    console.log('Form submitted:', data);\n    \n    // Notify parent component if available\n    if (window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_SUBMIT',\n        data: data\n      }, '*');\n    }\n  };\n\n  return (\n    <div className=\"p-4 max-w-2xl mx-auto\">\n      <FormComponent onSubmit={handleFormSubmit} />\n    </div>\n  );\n}\n\nconst container = document.getElementById('root');\nif (container) {\n  const root = createRoot(container);\n  root.render(<App />);\n}`,\n  \n  \"/FormComponent.tsx\": `import React from 'react';\n\ninterface FormComponentProps {\n  onSubmit?: (data: Record<string, unknown>) => void;\n}\n\nexport default function FormComponent({ onSubmit }: FormComponentProps) {\n  return (\n    <div className=\"p-6 border border-gray-200 rounded-lg bg-white\">\n      <h2 className=\"text-lg font-semibold mb-4\">Loading Form...</h2>\n      <p className=\"text-gray-600\">\n        Your generated form will appear here once the code is processed.\n      </p>\n    </div>\n  );\n}`,\n  \n  \"/styles.css\": `body {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;\n  background-color: #f8f9fa;\n}\n\n.form-container {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n  color: #374151;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n.submit-button {\n  background-color: #3b82f6;\n  color: white;\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.submit-button:hover {\n  background-color: #2563eb;\n}\n\n.error-message {\n  color: #ef4444;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}`,\n\n  \"/package.json\": `{\n  \"name\": \"formedible-preview\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\"\n  },\n  \"main\": \"/App.tsx\"\n}`\n};\n\nexport function SandpackPreview({\n  formCode,\n  onFormSubmit,\n  onFormError,\n  className,\n  showCodeEditor = false,\n  showConsole = false,\n  showFileExplorer = false,\n  template = \"react-ts\",\n  isLoading = false,\n  height = \"100%\",\n  injectionOptions,\n  showValidationStatus = true,\n  customStyles,\n  showToolbar = true,\n  showProgress = true,\n  onRefresh,\n  onOpenCodeSandbox,\n  enablePerformanceMode = true,\n  showPerformanceMetrics = false,\n  formFields = [],\n  enableCodeSplitting = true\n}: SandpackPreviewProps) {\n  const [error, setError] = useState<string | null>(null);\n  const [isInitializing, setIsInitializing] = useState(true);\n  const [validationStatus, setValidationStatus] = useState<ReturnType<typeof validateFormCode> | null>(null);\n  const [consoleVisible, setConsoleVisible] = useState(showConsole);\n  const [refreshKey, setRefreshKey] = useState(0);\n  const [bundleProgress, setBundleProgress] = useState(0);\n  const [bundleStatus, setBundleStatus] = useState<'idle' | 'bundling' | 'success' | 'error'>('idle');\n  const [performanceMetrics, setPerformanceMetrics] = useState<{\n    cacheHit: boolean;\n    loadTime: number;\n    splitStrategy: string;\n    bundleSize: number;\n  } | null>(null);\n  const sandpackRef = useRef<any>(null);\n  const loadStartTime = useRef<number>(0);\n\n  // Create files object with performance optimizations and caching\n  const files = useMemo((): SandpackFiles => {\n    loadStartTime.current = performance.now();\n    \n    if (!formCode) {\n      // Return default files when no form code is provided\n      return createSandboxFiles(\"\", {\n        ...injectionOptions,\n        customStyles\n      });\n    }\n\n    try {\n      // Generate cache key for performance optimization\n      const cacheKey = enablePerformanceMode \n        ? generateCacheKey(formCode, {\n            showCodeEditor,\n            showConsole,\n            showFileExplorer,\n            templateComplexity: injectionOptions?.templateComplexity\n          })\n        : null;\n\n      // Try to get cached template first (synchronous check)\n      let cachedResult: SandpackFiles | null = null;\n      if (cacheKey && enablePerformanceMode) {\n        // getCachedTemplate is async, but for now we'll skip the cache check in the memoized function\n        // and implement proper async caching in a later iteration\n        cachedResult = null;\n      }\n\n      // Validate the form code first - but don't set state in useMemo\n      const validation = validateFormCode(formCode);\n\n      // Analyze form for code splitting if enabled\n      let finalFiles: SandpackFiles;\n      let splitStrategy = 'none';\n\n      if (enableCodeSplitting && enablePerformanceMode && formFields.length > 0) {\n        const analysis = analyzeFormCode(formCode, formFields);\n        \n        if (analysis.shouldSplit) {\n          const splitResult = splitFormCode(formCode, formFields, {\n            maxComponentSize: 5000,\n            maxFieldsPerChunk: 10,\n            enableLazyLoading: true\n          });\n          \n          if (splitResult.chunks.length > 0) {\n            // Convert split result to sandbox files\n            const splitFiles = splitResultToSandpackFiles(splitResult);\n            \n            // Merge with base sandbox structure\n            const baseFiles = createSandboxFiles(\"\", {\n              ...injectionOptions,\n              customStyles\n            });\n            \n            finalFiles = { ...baseFiles, ...splitFiles };\n            splitStrategy = analysis.recommendedSplitStrategy;\n          } else {\n            // Fallback to normal injection\n            finalFiles = injectFormCodeIntoSandbox({}, formCode, {\n              useErrorBoundary: true,\n              strictTypeScript: true,\n              customStyles,\n              ...injectionOptions\n            });\n          }\n        } else {\n          // Form doesn't need splitting\n          finalFiles = injectFormCodeIntoSandbox({}, formCode, {\n            useErrorBoundary: true,\n            strictTypeScript: true,\n            customStyles,\n            ...injectionOptions\n          });\n        }\n      } else {\n        // Standard injection without splitting\n        finalFiles = injectFormCodeIntoSandbox({}, formCode, {\n          useErrorBoundary: true,\n          strictTypeScript: true,\n          customStyles,\n          ...injectionOptions\n        });\n      }\n\n      // Cache the result for future use\n      if (cacheKey && enablePerformanceMode && !cachedResult) {\n        setCachedTemplate(cacheKey, finalFiles, formCode);\n      }\n\n      // Performance metrics removed to prevent infinite re-renders\n\n      return finalFiles;\n\n    } catch (err) {\n      console.error(\"Error processing form code:\", err);\n      \n      // Return fallback files - don't set state in useMemo\n      return createSandboxFiles(\"\", {\n        ...injectionOptions,\n        customStyles\n      });\n    }\n  }, [formCode, injectionOptions, customStyles, enablePerformanceMode, enableCodeSplitting, formFields, showCodeEditor, showConsole, showFileExplorer]);\n\n  // Handle validation and error states separately to avoid infinite loops\n  React.useEffect(() => {\n    if (formCode) {\n      try {\n        const validation = validateFormCode(formCode);\n        setValidationStatus(validation);\n\n        if (!validation.isValid) {\n          console.warn(\"Form code validation failed:\", validation.errors);\n          setError(`Validation failed: ${validation.errors.join(', ')}`);\n        } else {\n          setError(null);\n        }\n      } catch (err) {\n        console.error(\"Error validating form code:\", err);\n        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n        setError(`Failed to process form code: ${errorMessage}`);\n      }\n    } else {\n      setValidationStatus(null);\n      setError(null);\n    }\n  }, [formCode]);\n\n  // Handle initialization complete\n  const handleBundlerLoad = useCallback(() => {\n    setIsInitializing(false);\n    setError(null);\n    setBundleStatus('success');\n    setBundleProgress(100);\n  }, []);\n\n  // Handle runtime errors\n  const handleError = useCallback((error: Error) => {\n    console.error(\"Sandpack error:\", error);\n    setError(error.message);\n    setIsInitializing(false);\n    setBundleStatus('error');\n    onFormError?.(error);\n  }, [onFormError]);\n\n  // Handle bundle progress\n  const handleBundleProgress = useCallback((progress: number) => {\n    setBundleProgress(progress);\n    if (progress > 0 && progress < 100) {\n      setBundleStatus('bundling');\n    }\n  }, []);\n\n  // Handle refresh functionality\n  const handleRefresh = useCallback(() => {\n    setRefreshKey(prev => prev + 1);\n    setIsInitializing(true);\n    setBundleStatus('idle');\n    setBundleProgress(0);\n    setError(null);\n    onRefresh?.();\n  }, [onRefresh]);\n\n  // Handle console toggle\n  const handleConsoleToggle = useCallback(() => {\n    setConsoleVisible(prev => !prev);\n  }, []);\n\n  // Handle open in CodeSandbox\n  const handleOpenCodeSandbox = useCallback(() => {\n    try {\n      // Create CodeSandbox URL with current files\n      const sandboxFiles = files;\n      const parameters = {\n        files: Object.entries(sandboxFiles).reduce((acc, [path, file]) => {\n          const content = typeof file === 'string' ? file : file.code || '';\n          acc[path.startsWith('/') ? path.slice(1) : path] = {\n            content\n          };\n          return acc;\n        }, {} as Record<string, { content: string }>)\n      };\n      \n      const compressed = btoa(JSON.stringify(parameters));\n      const sandboxUrl = `https://codesandbox.io/api/v1/sandboxes/define?parameters=${compressed}`;\n      \n      // Open in new tab\n      window.open(sandboxUrl, '_blank');\n      onOpenCodeSandbox?.(sandboxUrl);\n    } catch (error) {\n      console.error('Failed to open CodeSandbox:', error);\n    }\n  }, [files, onOpenCodeSandbox]);\n\n  // Handle form submission and error messages from the sandbox\n  React.useEffect(() => {\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data?.type === 'FORM_SUBMIT' && onFormSubmit) {\n        onFormSubmit(event.data.data);\n      } else if (event.data?.type === 'FORM_ERROR' && onFormError) {\n        const error = new Error(event.data.error || 'Unknown form error');\n        onFormError(error);\n      }\n    };\n\n    window.addEventListener('message', handleMessage);\n    return () => window.removeEventListener('message', handleMessage);\n  }, [onFormSubmit, onFormError]);\n\n  // Enhanced loading component with progress\n  const renderLoadingState = () => (\n    <div className={cn(\"space-y-4 h-full flex flex-col\", className)}>\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <Loader2 className=\"h-4 w-4 animate-spin\" />\n          <span className=\"text-sm text-muted-foreground\">\n            {bundleStatus === 'bundling' ? 'Bundling code...' : 'Loading preview environment...'}\n          </span>\n        </div>\n        {showProgress && bundleProgress > 0 && (\n          <Badge variant=\"secondary\" className=\"text-xs\">\n            {bundleProgress}%\n          </Badge>\n        )}\n      </div>\n      {showProgress && bundleProgress > 0 && (\n        <Progress value={bundleProgress} className=\"h-2\" />\n      )}\n      <Skeleton className=\"w-full flex-1 rounded-lg\" />\n    </div>\n  );\n\n  if (isLoading) {\n    return renderLoadingState();\n  }\n\n  // Enhanced toolbar component\n  const renderToolbar = () => {\n    if (!showToolbar) return null;\n\n    return (\n      <div className=\"flex items-center justify-between p-3 bg-gray-50 border-b border-gray-200 rounded-t-lg\">\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex items-center gap-1\">\n            <Play className=\"h-4 w-4 text-blue-600\" />\n            <span className=\"text-sm font-medium text-gray-700\">Live Preview</span>\n          </div>\n          {bundleStatus === 'success' && (\n            <Badge variant=\"secondary\" className=\"text-xs bg-green-100 text-green-700\">\n              <CheckCircle className=\"h-3 w-3 mr-1\" />\n              Ready\n            </Badge>\n          )}\n          {bundleStatus === 'bundling' && (\n            <Badge variant=\"secondary\" className=\"text-xs bg-blue-100 text-blue-700\">\n              <Loader2 className=\"h-3 w-3 mr-1 animate-spin\" />\n              Building...\n            </Badge>\n          )}\n          {bundleStatus === 'error' && (\n            <Badge variant=\"destructive\" className=\"text-xs\">\n              <XCircle className=\"h-3 w-3 mr-1\" />\n              Error\n            </Badge>\n          )}\n        </div>\n        \n        <div className=\"flex items-center gap-1\">\n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleConsoleToggle}\n                className={cn(\n                  \"h-8 w-8 p-0\",\n                  consoleVisible && \"bg-blue-100 text-blue-700\"\n                )}\n              >\n                {consoleVisible ? (\n                  <EyeOff className=\"h-4 w-4\" />\n                ) : (\n                  <Terminal className=\"h-4 w-4\" />\n                )}\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Toggle Console</p>\n            </TooltipContent>\n          </Tooltip>\n          \n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleRefresh}\n                disabled={bundleStatus === 'bundling'}\n                className=\"h-8 w-8 p-0\"\n              >\n                <RefreshCw className={cn(\n                  \"h-4 w-4\",\n                  bundleStatus === 'bundling' && \"animate-spin\"\n                )} />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Refresh Preview</p>\n            </TooltipContent>\n          </Tooltip>\n          \n          <Separator orientation=\"vertical\" className=\"h-4 mx-1\" />\n          \n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleOpenCodeSandbox}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ExternalLink className=\"h-4 w-4\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Open in CodeSandbox</p>\n            </TooltipContent>\n          </Tooltip>\n        </div>\n      </div>\n    );\n  };\n\n  // Render validation status if enabled\n  const renderValidationStatus = () => {\n    if (!showValidationStatus || !validationStatus) return null;\n\n    return (\n      <div className=\"mb-4 p-3 rounded-lg border\">\n        <div className=\"flex items-center gap-2 mb-2\">\n          {validationStatus.isValid ? (\n            <CheckCircle className=\"h-4 w-4 text-green-600\" />\n          ) : (\n            <XCircle className=\"h-4 w-4 text-red-600\" />\n          )}\n          <span className=\"font-medium text-sm\">\n            {validationStatus.isValid ? \"Code Validated\" : \"Validation Issues\"}\n          </span>\n        </div>\n        \n        {validationStatus.errors.length > 0 && (\n          <div className=\"space-y-1\">\n            <p className=\"text-xs font-medium text-red-600\">Errors:</p>\n            {validationStatus.errors.map((error, index) => (\n              <p key={index} className=\"text-xs text-red-600\">• {error}</p>\n            ))}\n          </div>\n        )}\n        \n        {validationStatus.warnings.length > 0 && (\n          <div className=\"space-y-1 mt-2\">\n            <p className=\"text-xs font-medium text-yellow-600\">Warnings:</p>\n            {validationStatus.warnings.map((warning, index) => (\n              <p key={index} className=\"text-xs text-yellow-600\">• {warning}</p>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Enhanced error component with recovery options\n  const renderErrorState = () => (\n    <div className={cn(\"border rounded-lg overflow-hidden h-full flex flex-col\", className)}>\n      {renderToolbar()}\n      {renderValidationStatus()}\n      <div className=\"p-6 flex flex-col justify-center items-center flex-1\">\n        <Alert className=\"max-w-md\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription className=\"mt-2\">\n            <strong>Preview Error:</strong> {error}\n            <br />\n            <span className=\"text-sm text-muted-foreground mt-2 block\">\n              The form preview encountered an error. Please check the generated code and try again.\n            </span>\n            <div className=\"flex gap-2 mt-4\">\n              <Button \n                variant=\"outline\" \n                size=\"sm\" \n                onClick={handleRefresh}\n                className=\"text-xs\"\n              >\n                <RefreshCw className=\"h-3 w-3 mr-1\" />\n                Retry\n              </Button>\n              <Button \n                variant=\"outline\" \n                size=\"sm\" \n                onClick={handleOpenCodeSandbox}\n                className=\"text-xs\"\n              >\n                <ExternalLink className=\"h-3 w-3 mr-1\" />\n                Debug in CodeSandbox\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      </div>\n    </div>\n  );\n\n  if (error) {\n    return renderErrorState();\n  }\n\n  // Enhanced Sandpack wrapper component\n  const SandpackWrapper = ({ children }: { children: React.ReactNode }) => {\n    return (\n      <div className={cn(\"border rounded-lg overflow-hidden h-full w-full flex flex-col\", className)}>\n        {renderToolbar()}\n        {renderValidationStatus()}\n        <div key={refreshKey} className=\"relative flex-1 min-h-0 w-full\">\n          {children}\n        </div>\n      </div>\n    );\n  };\n\n  try {\n    return (\n      <SandpackWrapper>\n        <SandpackProvider\n          template={template}\n          files={files}\n          style={{ height: \"100%\", width: \"100%\" }}\n          customSetup={{\n            dependencies: {\n              // Core React\n              \"react\": \"^19.1.1\",\n              \"react-dom\": \"^19.1.1\",\n              \n              // SWC Runtime (browser-compatible only)\n              \"@swc/helpers\": \"^0.5.5\",\n              \n              // Radix UI Components (comprehensive list)\n              \"@radix-ui/react-accordion\": \"^1.2.2\",\n              \"@radix-ui/react-checkbox\": \"^1.1.4\",\n              \"@radix-ui/react-dialog\": \"^1.1.4\",\n              \"@radix-ui/react-label\": \"^2.1.1\",\n              \"@radix-ui/react-popover\": \"^1.1.4\",\n              \"@radix-ui/react-progress\": \"^1.1.1\",\n              \"@radix-ui/react-radio-group\": \"^1.2.2\",\n              \"@radix-ui/react-select\": \"^2.1.4\",\n              \"@radix-ui/react-slider\": \"^1.2.2\",\n              \"@radix-ui/react-switch\": \"^1.1.2\",\n              \"@radix-ui/react-tabs\": \"^1.1.2\",\n              \"@radix-ui/react-primitive\": \"^2.0.0\",\n              \"@radix-ui/react-collection\": \"^1.1.0\",\n              \"@radix-ui/react-compose-refs\": \"^1.1.0\",\n              \"@radix-ui/react-context\": \"^1.1.1\",\n              \"@radix-ui/react-dismissable-layer\": \"^1.1.1\",\n              \"@radix-ui/react-focus-guards\": \"^1.1.1\",\n              \"@radix-ui/react-focus-scope\": \"^1.1.0\",\n              \"@radix-ui/react-id\": \"^1.1.0\",\n              \"@radix-ui/react-portal\": \"^1.1.2\",\n              \"@radix-ui/react-presence\": \"^1.1.1\",\n              \"@radix-ui/react-slot\": \"^1.1.0\",\n              \"@radix-ui/react-use-callback-ref\": \"^1.1.0\",\n              \"@radix-ui/react-use-controllable-state\": \"^1.1.0\",\n              \"@radix-ui/react-use-escape-keydown\": \"^1.1.0\",\n              \"@radix-ui/react-use-layout-effect\": \"^1.1.0\",\n              \"@radix-ui/react-use-previous\": \"^1.1.0\",\n              \"@radix-ui/react-use-rect\": \"^1.1.0\",\n              \"@radix-ui/react-use-size\": \"^1.1.0\",\n              \"@radix-ui/react-visually-hidden\": \"^1.1.0\",\n              \n              // Formedible ecosystem\n              \"@tanstack/react-form\": \"^0.38.1\",\n              \"zod\": \"^3.24.1\",\n              \"clsx\": \"^2.1.1\",\n              \"tailwind-merge\": \"^2.6.0\",\n              \"sonner\": \"^1.7.1\",\n              \n              // Additional runtime dependencies\n              \"lucide-react\": \"^0.400.0\"\n            },\n            devDependencies: {\n              \"@types/react\": \"^18.3.17\",\n              \"@types/react-dom\": \"^18.3.5\",\n              \"typescript\": \"^5.7.2\"\n            }\n          }}\n          options={{\n            bundlerURL: \"https://sandpack-bundler.codesandbox.io\",\n            visibleFiles: showCodeEditor ? [\"/FormComponent.tsx\", \"/App.tsx\"] : [],\n            activeFile: \"/FormComponent.tsx\",\n            initMode: \"lazy\",\n            autorun: true,\n            autoReload: true,\n            recompileMode: \"delayed\",\n            recompileDelay: 300\n          }}\n        >\n          <SandpackLayout \n            style={{ height: \"100%\", width: \"100%\" }}\n            className={showToolbar ? \"rounded-b-lg\" : \"border rounded-lg\"}\n          >\n            {showFileExplorer && <SandpackFileExplorer />}\n            {showCodeEditor && (\n              <SandpackCodeEditor\n                showTabs\n                showLineNumbers\n                showInlineErrors\n                closableTabs\n                wrapContent\n                style={{ height: \"100%\" }}\n              />\n            )}\n            <div className=\"flex flex-col h-full w-full\">\n              <SandpackPreviewComponent\n                showOpenInCodeSandbox={false}\n                showRefreshButton={false}\n                showNavigator={false}\n                style={{ \n                  height: consoleVisible && (showConsole || consoleVisible) ? \"60%\" : \"100%\",\n                  width: \"100%\",\n                  borderRadius: \"0\"\n                }}\n              />\n              {(showConsole || consoleVisible) && (\n                <div \n                  className=\"border-t bg-gray-900 text-gray-100\"\n                  style={{ \n                    height: \"40%\",\n                    display: consoleVisible ? \"block\" : \"none\"\n                  }}\n                >\n                  <div className=\"flex items-center justify-between px-3 py-2 border-b border-gray-700\">\n                    <div className=\"flex items-center gap-2\">\n                      <TerminalSquare className=\"h-4 w-4\" />\n                      <span className=\"text-sm font-medium\">Console Output</span>\n                    </div>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={handleConsoleToggle}\n                      className=\"h-6 w-6 p-0 text-gray-300 hover:text-white hover:bg-gray-800\"\n                    >\n                      <XCircle className=\"h-4 w-4\" />\n                    </Button>\n                  </div>\n                  <SandpackConsole\n                    showHeader={false}\n                    showSyntaxError={true}\n                    maxMessageCount={100}\n                    resetOnPreviewRestart={true}\n                    style={{ \n                      height: \"calc(100% - 40px)\",\n                      backgroundColor: \"rgb(17 24 39)\",\n                      border: \"none\"\n                    }}\n                  />\n                </div>\n              )}\n            </div>\n          </SandpackLayout>\n        </SandpackProvider>\n      </SandpackWrapper>\n    );\n  } catch (err) {\n    console.error(\"Error rendering Sandpack:\", err);\n    return (\n      <SandpackWrapper>\n        <Alert className=\"h-full flex flex-col justify-center m-6\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription>\n            <strong>Failed to initialize live preview.</strong>\n            <br />\n            <span className=\"text-sm text-muted-foreground mt-2 block\">\n              Please try refreshing or switch to static preview mode.\n            </span>\n            <div className=\"flex gap-2 mt-4\">\n              <Button \n                variant=\"outline\" \n                size=\"sm\" \n                onClick={handleRefresh}\n                className=\"text-xs\"\n              >\n                <RefreshCw className=\"h-3 w-3 mr-1\" />\n                Retry\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      </SandpackWrapper>\n    );\n  }\n}\n\nexport default SandpackPreview;",
      "type": "registry:component",
      "target": "components/formedible/ai/sandpack-preview.tsx"
    },
    {
      "path": "src/components/formedible/ai/lazy-sandpack-preview.tsx",
      "content": "\"use client\";\n\nimport React, { lazy, Suspense, useState, useCallback, useMemo } from \"react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { \n  Loader2, \n  AlertTriangle, \n  Play, \n  Code2, \n  Eye,\n  Settings,\n  Zap\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\n// Lazy load the heavy Sandpack components\nconst SandpackPreview = lazy(() => import(\"./sandpack-preview\"));\n\nexport interface LazySandpackPreviewProps {\n  /** The generated form code to preview */\n  formCode?: string;\n  /** Callback when form is submitted in the sandbox */\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  /** Callback when form error occurs in the sandbox */\n  onFormError?: (error: Error) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** Whether to show the code editor alongside preview */\n  showCodeEditor?: boolean;\n  /** Whether to show console output */\n  showConsole?: boolean;\n  /** Whether to show file explorer */\n  showFileExplorer?: boolean;\n  /** Custom height for the preview */\n  height?: string;\n  /** Whether to auto-load the preview */\n  autoLoad?: boolean;\n  /** Performance mode: 'fast' | 'balanced' | 'full' */\n  performanceMode?: 'fast' | 'balanced' | 'full';\n  /** Cache key for template caching */\n  cacheKey?: string;\n  /** Whether to show performance metrics */\n  showPerformanceMetrics?: boolean;\n  /** Custom loading message */\n  loadingMessage?: string;\n  /** Whether to preload Sandpack on hover */\n  preloadOnHover?: boolean;\n}\n\n// Performance metrics interface\ninterface PerformanceMetrics {\n  initTime: number;\n  bundleTime: number;\n  renderTime: number;\n  cacheHit: boolean;\n}\n\n// Component cache to store loaded instances\nconst componentCache = new Map<string, React.ComponentType<any>>();\nconst templateCache = new Map<string, any>();\nconst performanceMetrics = new Map<string, PerformanceMetrics>();\n\n/**\n * Lazy-loaded Sandpack Preview with performance optimizations\n */\nexport function LazySandpackPreview({\n  formCode,\n  onFormSubmit,\n  onFormError,\n  className,\n  showCodeEditor = false,\n  showConsole = false,\n  showFileExplorer = false,\n  height = \"min(80vh, 600px)\",\n  autoLoad = false,\n  performanceMode = 'balanced',\n  cacheKey,\n  showPerformanceMetrics = false,\n  loadingMessage = \"Loading live preview...\",\n  preloadOnHover = true\n}: LazySandpackPreviewProps) {\n  const [isLoading, setIsLoading] = useState(!autoLoad);\n  const [loadError, setLoadError] = useState<string | null>(null);\n  const [startTime, setStartTime] = useState<number>(0);\n  const [isPreloading, setIsPreloading] = useState(false);\n  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);\n\n  // Generate cache key if not provided\n  const effectiveCacheKey = useMemo(() => {\n    if (cacheKey) return cacheKey;\n    \n    // Create cache key based on form code hash and configuration\n    const configHash = JSON.stringify({\n      showCodeEditor,\n      showConsole,\n      showFileExplorer,\n      performanceMode\n    });\n    \n    const formHash = formCode ? btoa(formCode.substring(0, 100)) : 'empty';\n    return `sandpack-${formHash}-${btoa(configHash)}`.replace(/[^a-zA-Z0-9-]/g, '');\n  }, [cacheKey, formCode, showCodeEditor, showConsole, showFileExplorer, performanceMode]);\n\n  // Check if component is cached\n  const isCached = useMemo(() => {\n    return componentCache.has(effectiveCacheKey) && templateCache.has(effectiveCacheKey);\n  }, [effectiveCacheKey]);\n\n  // Preload component on hover if enabled\n  const handlePreload = useCallback(async () => {\n    if (!preloadOnHover || isPreloading || !isLoading) return;\n    \n    setIsPreloading(true);\n    try {\n      // Preload the component\n      await import(\"./sandpack-preview\");\n    } catch (error) {\n      console.warn(\"Failed to preload Sandpack component:\", error);\n    } finally {\n      setIsPreloading(false);\n    }\n  }, [preloadOnHover, isPreloading, isLoading]);\n\n  // Handle loading the preview\n  const handleLoadPreview = useCallback(async () => {\n    if (!isLoading) return;\n\n    const loadStartTime = performance.now();\n    setStartTime(loadStartTime);\n    setLoadError(null);\n\n    try {\n      // Check cache first\n      let cacheHit = false;\n      if (isCached) {\n        cacheHit = true;\n        console.log(\"Loading from cache:\", effectiveCacheKey);\n      }\n\n      // Load the component\n      setIsLoading(false);\n      \n      // Record performance metrics\n      const initTime = performance.now() - loadStartTime;\n      const newMetrics: PerformanceMetrics = {\n        initTime,\n        bundleTime: 0,\n        renderTime: 0,\n        cacheHit\n      };\n      \n      setMetrics(newMetrics);\n      performanceMetrics.set(effectiveCacheKey, newMetrics);\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to load preview';\n      setLoadError(errorMessage);\n      console.error(\"Failed to load Sandpack preview:\", error);\n    }\n  }, [isLoading, isCached, effectiveCacheKey]);\n\n  // Performance-optimized options based on mode\n  const sandpackOptions = useMemo(() => {\n    const baseOptions = {\n      formCode,\n      onFormSubmit,\n      onFormError,\n      className: cn(\"lazy-sandpack-container\", className),\n      height\n    };\n\n    switch (performanceMode) {\n      case 'fast':\n        return {\n          ...baseOptions,\n          showCodeEditor: false,\n          showConsole: false,\n          showFileExplorer: false,\n          showToolbar: true,\n          showProgress: false,\n          showValidationStatus: false\n        };\n      \n      case 'balanced':\n        return {\n          ...baseOptions,\n          showCodeEditor,\n          showConsole: false,\n          showFileExplorer: false,\n          showToolbar: true,\n          showProgress: true,\n          showValidationStatus: true\n        };\n      \n      case 'full':\n        return {\n          ...baseOptions,\n          showCodeEditor,\n          showConsole,\n          showFileExplorer,\n          showToolbar: true,\n          showProgress: true,\n          showValidationStatus: true\n        };\n      \n      default:\n        return baseOptions;\n    }\n  }, [\n    formCode,\n    onFormSubmit,\n    onFormError,\n    className,\n    height,\n    showCodeEditor,\n    showConsole,\n    showFileExplorer,\n    performanceMode\n  ]);\n\n  // Enhanced loading placeholder with performance mode indicators\n  const renderLoadingPlaceholder = () => (\n    <Card \n      className={cn(\"cursor-pointer transition-all duration-200 hover:shadow-lg\", className)}\n      style={{ height }}\n      onMouseEnter={handlePreload}\n      onClick={handleLoadPreview}\n    >\n      <CardHeader className=\"pb-3\">\n        <CardTitle className=\"flex items-center gap-2 text-lg\">\n          <div className=\"flex items-center gap-2\">\n            <Play className=\"h-5 w-5 text-blue-600\" />\n            <span>Live Preview</span>\n          </div>\n          <div className=\"flex items-center gap-1 ml-auto\">\n            {performanceMode === 'fast' && (\n              <div className=\"flex items-center gap-1 text-green-600 text-sm\">\n                <Zap className=\"h-3 w-3\" />\n                <span className=\"text-xs\">Fast Mode</span>\n              </div>\n            )}\n            {isCached && (\n              <div className=\"flex items-center gap-1 text-blue-600 text-sm\">\n                <Settings className=\"h-3 w-3\" />\n                <span className=\"text-xs\">Cached</span>\n              </div>\n            )}\n            {isPreloading && (\n              <Loader2 className=\"h-4 w-4 animate-spin text-gray-400\" />\n            )}\n          </div>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"space-y-2 flex-1\">\n            <p className=\"text-sm text-muted-foreground\">{loadingMessage}</p>\n            <p className=\"text-xs text-muted-foreground\">\n              Click to load interactive preview with full form functionality\n            </p>\n            {showPerformanceMetrics && metrics && (\n              <div className=\"text-xs text-muted-foreground space-y-1\">\n                <div>Init: {metrics.initTime.toFixed(2)}ms</div>\n                <div>Cache: {metrics.cacheHit ? 'Hit' : 'Miss'}</div>\n              </div>\n            )}\n          </div>\n          <div className=\"flex flex-col items-center gap-2\">\n            <div className=\"flex items-center gap-2 text-sm text-blue-600\">\n              <Code2 className=\"h-4 w-4\" />\n              <span>Interactive Form</span>\n            </div>\n            {performanceMode !== 'fast' && (\n              <div className=\"flex gap-1\">\n                {showCodeEditor && <Eye className=\"h-3 w-3 text-gray-400\" />}\n                {showConsole && <Settings className=\"h-3 w-3 text-gray-400\" />}\n                {showFileExplorer && <Code2 className=\"h-3 w-3 text-gray-400\" />}\n              </div>\n            )}\n          </div>\n        </div>\n        <div className=\"space-y-2\">\n          <Skeleton className=\"h-8 w-full\" />\n          <Skeleton className=\"h-12 w-full\" />\n          <Skeleton className=\"h-8 w-2/3\" />\n          <Skeleton className=\"h-10 w-1/3\" />\n        </div>\n      </CardContent>\n    </Card>\n  );\n\n  // Error state\n  const renderErrorState = () => (\n    <Card className={className} style={{ height }}>\n      <CardContent className=\"flex flex-col justify-center items-center h-full p-6\">\n        <Alert className=\"max-w-md\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription className=\"mt-2\">\n            <strong>Failed to load live preview:</strong> {loadError}\n            <div className=\"flex gap-2 mt-4\">\n              <Button \n                variant=\"outline\" \n                size=\"sm\" \n                onClick={handleLoadPreview}\n                className=\"text-xs\"\n              >\n                <Loader2 className=\"h-3 w-3 mr-1\" />\n                Retry\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      </CardContent>\n    </Card>\n  );\n\n  // Suspense fallback with performance metrics\n  const renderSuspenseFallback = () => (\n    <Card className={className} style={{ height }}>\n      <CardContent className=\"flex flex-col justify-center items-center h-full p-6 space-y-4\">\n        <div className=\"flex items-center gap-2\">\n          <Loader2 className=\"h-5 w-5 animate-spin text-blue-600\" />\n          <span className=\"text-sm font-medium\">Initializing live preview...</span>\n        </div>\n        {showPerformanceMetrics && startTime > 0 && (\n          <div className=\"text-xs text-muted-foreground\">\n            Loading: {((performance.now() - startTime) / 1000).toFixed(1)}s\n          </div>\n        )}\n        <div className=\"space-y-2 w-full max-w-md\">\n          <Skeleton className=\"h-4 w-full\" />\n          <Skeleton className=\"h-8 w-full\" />\n          <Skeleton className=\"h-4 w-2/3\" />\n        </div>\n      </CardContent>\n    </Card>\n  );\n\n  // Show error state if there's an error\n  if (loadError) {\n    return renderErrorState();\n  }\n\n  // Show loading placeholder if not yet loaded\n  if (isLoading) {\n    return renderLoadingPlaceholder();\n  }\n\n  // Render the actual Sandpack component with Suspense\n  return (\n    <Suspense fallback={renderSuspenseFallback()}>\n      <SandpackPreview \n        {...sandpackOptions}\n        onFormSubmit={(data) => {\n          // Update metrics on form interaction\n          if (metrics) {\n            const updatedMetrics = {\n              ...metrics,\n              renderTime: performance.now() - startTime\n            };\n            setMetrics(updatedMetrics);\n            performanceMetrics.set(effectiveCacheKey, updatedMetrics);\n          }\n          onFormSubmit?.(data);\n        }}\n        onFormError={(error) => {\n          console.error(\"Form error in lazy Sandpack:\", error);\n          onFormError?.(error);\n        }}\n      />\n      {showPerformanceMetrics && metrics && (\n        <div className=\"mt-2 text-xs text-muted-foreground bg-gray-50 p-2 rounded\">\n          <div className=\"flex gap-4\">\n            <span>Init: {metrics.initTime.toFixed(2)}ms</span>\n            <span>Cache: {metrics.cacheHit ? '✓' : '✗'}</span>\n            <span>Mode: {performanceMode}</span>\n            {metrics.renderTime > 0 && <span>Render: {metrics.renderTime.toFixed(2)}ms</span>}\n          </div>\n        </div>\n      )}\n    </Suspense>\n  );\n}\n\n/**\n * Preload Sandpack component for better performance\n */\nexport function preloadSandpackPreview(): Promise<any> {\n  return import(\"./sandpack-preview\");\n}\n\n/**\n * Clear component cache (useful for development)\n */\nexport function clearSandpackCache(): void {\n  componentCache.clear();\n  templateCache.clear();\n  performanceMetrics.clear();\n}\n\n/**\n * Get cache statistics\n */\nexport function getSandpackCacheStats() {\n  return {\n    components: componentCache.size,\n    templates: templateCache.size,\n    metrics: performanceMetrics.size\n  };\n}\n\nexport default LazySandpackPreview;",
      "type": "registry:component",
      "target": "components/formedible/ai/lazy-sandpack-preview.tsx"
    },
    {
      "path": "src/lib/form-extraction-utils.ts",
      "content": "/**\n * Shared utility functions for extracting formedible code from messages\n * This ensures DRY principle and consistent behavior between streaming and loading\n */\n\nexport interface ExtractedForm {\n  id: string;\n  code: string;\n  timestamp: Date;\n}\n\n/**\n * Extracts formedible code from a single message content\n */\nexport function extractFormedibleCode(content: string): string | null {\n  const formedibleMatch = content.match(/```formedible\\s*\\n([\\s\\S]*?)\\n```/);\n  return formedibleMatch && formedibleMatch[1] ? formedibleMatch[1].trim() : null;\n}\n\n/**\n * Extracts all forms from conversation messages\n */\nexport function extractFormsFromMessages(\n  messages: Array<{ role: string; content: string }>,\n  conversationId?: string,\n  baseTimestamp?: Date\n): ExtractedForm[] {\n  const extractedForms: ExtractedForm[] = [];\n  \n  messages.forEach((message, messageIndex) => {\n    if (message.role === 'assistant' && message.content) {\n      const code = extractFormedibleCode(message.content);\n      if (code) {\n        extractedForms.push({\n          id: conversationId \n            ? `form_${conversationId}_${messageIndex}`\n            : `form_${Date.now()}_${messageIndex}`,\n          code,\n          timestamp: baseTimestamp || new Date()\n        });\n      }\n    }\n  });\n  \n  return extractedForms;\n}",
      "type": "registry:lib",
      "target": "lib/form-extraction-utils.ts"
    },
    {
      "path": "src/lib/sandbox-code-injector.ts",
      "content": "/**\n * Sandbox Code Injection Utility for Formedible AI Builder\n * \n * This utility handles the injection of generated form code into Sandpack sandbox files,\n * providing validation, error handling, and proper TypeScript type safety.\n */\n\nimport { SandpackFiles } from \"@codesandbox/sandpack-react\";\nimport sandboxTemplates from \"./sandbox-templates.json\";\nimport { \n  createFormedibleSandbox, \n  generateFormComponentFromFields, \n  getTemplateByComplexity,\n  FORMEDIBLE_SANDBOX_DEPENDENCIES,\n  TEMPLATE_VARIATIONS,\n  type TemplateVariation\n} from './sandbox-templates';\n\n// Type definitions for sandbox injection\nexport interface SandboxFiles {\n  [path: string]: {\n    code: string;\n    hidden?: boolean;\n  };\n}\n\nexport interface CodeValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  extractedComponent?: string;\n  hasImports?: boolean;\n  hasExports?: boolean;\n}\n\nexport interface FormCodeMeta {\n  componentName?: string;\n  hasTypeScript: boolean;\n  hasJSX: boolean;\n  hasFormedibleImports: boolean;\n  imports: string[];\n  exports: string[];\n}\n\nexport interface InjectionOptions {\n  /** Whether to wrap the code in error boundaries */\n  useErrorBoundary?: boolean;\n  /** Additional dependencies to inject */\n  additionalDependencies?: Record<string, string>;\n  /** Custom CSS to include */\n  customStyles?: string;\n  /** Whether to enable TypeScript strict mode */\n  strictTypeScript?: boolean;\n  /** Target file for the form component */\n  targetFile?: string;\n  /** Template complexity level */\n  templateComplexity?: \"basic\" | \"intermediate\" | \"advanced\";\n  /** Form configuration for dynamic generation */\n  formConfig?: {\n    fields?: any[];\n    multiPage?: boolean;\n    hasConditional?: boolean;\n    title?: string;\n    description?: string;\n  };\n  /** Whether to use enhanced Formedible templates */\n  useEnhancedTemplates?: boolean;\n}\n\n/**\n * Formedible-sandbox repository dependencies (from https://github.com/DimitriGilbert/formedible-sandbox)\n */\nconst FORMEDIBLE_SANDBOX_DEPENDENCIES_FROM_REPO = {\n  \"react\": \"^19.1.1\",\n  \"react-dom\": \"^19.1.1\",\n  \"@types/react\": \"^18.3.17\",\n  \"@types/react-dom\": \"^18.3.5\",\n  \"@radix-ui/react-accordion\": \"^1.2.2\",\n  \"@radix-ui/react-checkbox\": \"^1.1.4\",\n  \"@radix-ui/react-dialog\": \"^1.1.4\",\n  \"@radix-ui/react-label\": \"^2.1.1\",\n  \"@radix-ui/react-popover\": \"^1.1.4\",\n  \"@radix-ui/react-progress\": \"^1.1.1\",\n  \"@radix-ui/react-radio-group\": \"^1.2.2\",\n  \"@radix-ui/react-select\": \"^2.1.4\",\n  \"@radix-ui/react-slider\": \"^1.2.2\",\n  \"@radix-ui/react-switch\": \"^1.1.2\",\n  \"@radix-ui/react-tabs\": \"^1.1.2\",\n  \"@tanstack/react-form\": \"^0.38.1\",\n  \"clsx\": \"^2.1.1\",\n  \"tailwind-merge\": \"^2.6.0\",\n  \"zod\": \"^3.24.1\",\n  \"sonner\": \"^1.7.1\",\n  \"typescript\": \"^5.7.2\",\n  \"@swc/helpers\": \"^0.5.5\"\n};\n\n/**\n * Default sandbox file templates\n */\nconst DEFAULT_SANDBOX_TEMPLATES = {\n  APP_TSX: `import \"./App.css\";\nimport { GeneratedFormComponent } from \"./GeneratedFormComponent\";\n\nfunction App() {\n  return (\n    <>\n      <GeneratedFormComponent />\n    </>\n  );\n}\n\nexport default App;`,\n\n  FALLBACK_FORM: `import React from 'react';\n\ninterface FormComponentProps {\n  onSubmit?: (data: Record<string, unknown>) => void;\n  onError?: (error: Error) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError }: FormComponentProps) {\n  return (\n    <div className=\"p-6 border border-gray-200 rounded-lg bg-white\">\n      <h2 className=\"text-xl font-semibold mb-4 text-gray-800\">\n        Form Preview\n      </h2>\n      <div className=\"space-y-4\">\n        <p className=\"text-gray-600\">\n          Your generated form will appear here once the code is processed.\n        </p>\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n          <p className=\"text-blue-800 text-sm\">\n            <strong>Note:</strong> The form is being prepared for preview. \n            If you see this message for more than a few seconds, there may be an issue with the generated code.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}`,\n\n  ERROR_BOUNDARY: `import React, { Component, ReactNode } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n}\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  onError?: (error: Error) => void;\n}\n\nclass FormErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Form error boundary caught an error:', error, errorInfo);\n    this.props.onError?.(error);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-6 border border-red-200 rounded-lg bg-red-50\">\n          <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n            Form Rendering Error\n          </h3>\n          <p className=\"text-red-600 mb-4\">\n            There was an error rendering the form component. Please check the generated code for syntax errors.\n          </p>\n          {this.state.error && (\n            <details className=\"text-sm\">\n              <summary className=\"cursor-pointer text-red-700 font-medium\">\n                Error Details\n              </summary>\n              <pre className=\"mt-2 p-2 bg-red-100 rounded text-red-800 text-xs overflow-auto\">\n                {this.state.error.toString()}\n              </pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default FormErrorBoundary;`,\n\n  BASE_STYLES: `/* Formedible Form Preview Styles */\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', sans-serif;\n  background-color: #f8f9fa;\n  line-height: 1.6;\n}\n\n/* Form Container Styles */\n.form-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n/* Field Group Styles */\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n  color: #374151;\n  font-size: 0.875rem;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  transition: border-color 0.2s, box-shadow 0.2s;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n.field-input:invalid {\n  border-color: #ef4444;\n}\n\n.field-input:invalid:focus {\n  border-color: #ef4444;\n  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);\n}\n\n/* Button Styles */\n.submit-button, .primary-button {\n  background-color: #3b82f6;\n  color: white;\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s, transform 0.1s;\n}\n\n.submit-button:hover, .primary-button:hover {\n  background-color: #2563eb;\n}\n\n.submit-button:active, .primary-button:active {\n  transform: translateY(1px);\n}\n\n.secondary-button {\n  background-color: #f3f4f6;\n  color: #374151;\n  padding: 0.75rem 1.5rem;\n  border: 1px solid #d1d5db;\n  border-radius: 0.5rem;\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.secondary-button:hover {\n  background-color: #e5e7eb;\n}\n\n/* Error and Success Messages */\n.error-message {\n  color: #ef4444;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n.success-message {\n  color: #10b981;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n/* Loading States */\n.loading {\n  opacity: 0.7;\n  pointer-events: none;\n}\n\n.spinner {\n  border: 2px solid #f3f3f3;\n  border-top: 2px solid #3b82f6;\n  border-radius: 50%;\n  width: 1rem;\n  height: 1rem;\n  animation: spin 1s linear infinite;\n  display: inline-block;\n  margin-right: 0.5rem;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n  .form-container {\n    padding: 1rem;\n  }\n  \n  .field-input,\n  .submit-button,\n  .primary-button,\n  .secondary-button {\n    font-size: 0.875rem;\n    padding: 0.625rem 1rem;\n  }\n}`\n};\n\n/**\n * Validates the generated form code for syntax and structure\n */\nexport function validateFormCode(formCode: string): CodeValidationResult {\n  const result: CodeValidationResult = {\n    isValid: true,\n    errors: [],\n    warnings: [],\n    hasImports: false,\n    hasExports: false\n  };\n\n  if (!formCode || formCode.trim().length === 0) {\n    result.isValid = false;\n    result.errors.push(\"Form code is empty or undefined\");\n    return result;\n  }\n\n  try {\n    // Check for basic React component structure\n    const hasReactImport = /import\\s+.*React.*from\\s+['\"]react['\"]/.test(formCode);\n    const hasJSXElements = /<[A-Za-z][^>]*>/.test(formCode);\n    const hasExportDefault = /export\\s+default/.test(formCode);\n    const hasExportFunction = /export\\s+(function|const)\\s+/.test(formCode);\n    const hasFunction = /(function|const)\\s+[A-Z][a-zA-Z0-9]*/.test(formCode);\n    const hasComponent = /[A-Z][a-zA-Z0-9]*\\s*=/.test(formCode) || hasFunction;\n    \n    result.hasImports = /import\\s+.*from/.test(formCode);\n    result.hasExports = hasExportDefault || hasExportFunction || hasComponent;\n\n    if (!hasReactImport && hasJSXElements) {\n      result.warnings.push(\"JSX detected but React import is missing\");\n    }\n\n    // Be more lenient for form components - if it has JSX or looks like a component, assume it's valid\n    if (!result.hasExports && !hasJSXElements && !hasComponent) {\n      result.warnings.push(\"No clear component export found - this may affect rendering\");\n    }\n\n    // Check for common syntax errors\n    const openBraces = (formCode.match(/{/g) || []).length;\n    const closeBraces = (formCode.match(/}/g) || []).length;\n    if (openBraces !== closeBraces) {\n      result.errors.push(`Mismatched braces: ${openBraces} opening, ${closeBraces} closing`);\n      result.isValid = false;\n    }\n\n    const openParens = (formCode.match(/\\(/g) || []).length;\n    const closeParens = (formCode.match(/\\)/g) || []).length;\n    if (openParens !== closeParens) {\n      result.errors.push(`Mismatched parentheses: ${openParens} opening, ${closeParens} closing`);\n      result.isValid = false;\n    }\n\n    // Extract component name if possible\n    const componentMatch = formCode.match(/(?:function|const)\\s+([A-Z][a-zA-Z0-9]*)/);\n    if (componentMatch) {\n      result.extractedComponent = componentMatch[1];\n    }\n\n    // Check for TypeScript syntax\n    if (/:\\s*[A-Z][a-zA-Z0-9<>[\\]|&\\s]*[=;]/.test(formCode) || /interface\\s+/.test(formCode)) {\n      result.warnings.push(\"TypeScript syntax detected - ensure proper type definitions\");\n    }\n\n    // Check for potential security issues (basic check)\n    const dangerousPatterns = [\n      /dangerouslySetInnerHTML/,\n      /eval\\s*\\(/,\n      /Function\\s*\\(/,\n      /document\\.write/,\n      /innerHTML\\s*=/\n    ];\n    \n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(formCode)) {\n        result.warnings.push(\"Potentially unsafe code detected - please review\");\n      }\n    }\n\n  } catch (error) {\n    result.isValid = false;\n    result.errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  return result;\n}\n\n/**\n * Safely encodes content to base64 to avoid JavaScript syntax errors\n */\nfunction encodeToBase64(content: string): string {\n  try {\n    return btoa(unescape(encodeURIComponent(content)));\n  } catch (error) {\n    console.warn(\"Failed to encode content to base64:\", error);\n    // Fallback: escape dangerous characters\n    return content\n      .replace(/\"/g, '\\\\\"')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r');\n  }\n}\n\n/**\n * Creates a safe form component with base64 encoded content\n */\nfunction createSafeFormComponent(formCode: string): string {\n  const encodedContent = encodeToBase64(formCode);\n  \n  return `import React from 'react';\n\n// Base64 encoded form configuration to avoid JavaScript syntax errors\nconst encodedFormConfig = \"${encodedContent}\";\n\n// Decode the configuration safely\nfunction decodeFormConfig(): any {\n  try {\n    const decoded = atob(encodedFormConfig);\n    const unescaped = decodeURIComponent(escape(decoded));\n    return JSON.parse(unescaped);\n  } catch (error) {\n    console.error(\"Failed to decode form configuration:\", error);\n    return {\n      title: \"Form Configuration Error\",\n      description: \"Failed to load form configuration\",\n      fields: []\n    };\n  }\n}\n\nexport default function FormComponent({ onSubmit }: {\n  onSubmit?: (data: Record<string, any>) => void;\n}) {\n  const formConfig = decodeFormConfig();\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    const formData = new FormData(e.target as HTMLFormElement);\n    const data = Object.fromEntries(formData.entries());\n    onSubmit?.(data);\n  };\n  \n  return (\n    <div className=\"max-w-2xl mx-auto p-6\">\n      <div className=\"mb-6\">\n        <h1 className=\"text-2xl font-bold mb-2\">{formConfig.title}</h1>\n        {formConfig.description && (\n          <p className=\"text-gray-600\">{formConfig.description}</p>\n        )}\n      </div>\n      \n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        {formConfig.fields && formConfig.fields.length > 0 ? (\n          formConfig.fields.map((field: any, index: number) => (\n            <div key={index} className=\"space-y-2\">\n              <label className=\"block text-sm font-medium text-gray-700\">\n                {field.label || field.name}\n                {field.required && <span className=\"text-red-500 ml-1\">*</span>}\n              </label>\n              \n              {field.type === 'textarea' ? (\n                <textarea\n                  name={field.name}\n                  placeholder={field.placeholder}\n                  required={field.required}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                  rows={4}\n                />\n              ) : field.type === 'select' ? (\n                <select\n                  name={field.name}\n                  required={field.required}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                >\n                  <option value=\"\">Select an option</option>\n                  {field.options && field.options.map((option: any, i: number) => (\n                    <option key={i} value={option.value}>{option.label}</option>\n                  ))}\n                </select>\n              ) : (\n                <input\n                  type={field.type || 'text'}\n                  name={field.name}\n                  placeholder={field.placeholder}\n                  required={field.required}\n                  min={field.min}\n                  max={field.max}\n                  step={field.step}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                />\n              )}\n              \n              {field.description && (\n                <p className=\"text-xs text-gray-500\">{field.description}</p>\n              )}\n            </div>\n          ))\n        ) : (\n          <div className=\"text-center py-8 text-gray-500\">\n            <p>No form fields configured</p>\n            <p className=\"text-xs mt-2\">Form configuration: {JSON.stringify(formConfig, null, 2)}</p>\n          </div>\n        )}\n        \n        <button\n          type=\"submit\"\n          className=\"w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors\"\n        >\n          Submit\n        </button>\n      </form>\n      \n      <div className=\"mt-6 p-4 bg-gray-50 rounded-md\">\n        <details className=\"text-xs text-gray-600\">\n          <summary className=\"cursor-pointer\">Debug Info</summary>\n          <pre className=\"mt-2 whitespace-pre-wrap\">{JSON.stringify(formConfig, null, 2)}</pre>\n        </details>\n      </div>\n    </div>\n  );\n}`;\n}\n\n/**\n * Extracts form component from generated code with safe base64 encoding\n */\nexport function extractFormComponent(formCode: string): string {\n  if (!formCode || formCode.trim().length === 0) {\n    return DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM;\n  }\n\n  // ALWAYS check if it's JSON first - this is the most common error case\n  const trimmedCode = formCode.trim();\n  console.log(\"extractFormComponent called with:\", { \n    length: formCode.length, \n    startsWithBrace: trimmedCode.startsWith('{'),\n    endsWithBrace: trimmedCode.endsWith('}'),\n    first50: trimmedCode.substring(0, 50) \n  });\n  \n  if (trimmedCode.startsWith('{') && trimmedCode.endsWith('}')) {\n    try {\n      const parsed = JSON.parse(formCode);\n      // If it parses as JSON, it needs base64 encoding\n      console.log(\"✅ Detected JSON form configuration, creating safe component\");\n      const safeComponent = createSafeFormComponent(formCode);\n      console.log(\"✅ Created safe component:\", safeComponent.substring(0, 200) + \"...\");\n      return safeComponent;\n    } catch (error) {\n      // If it looks like JSON but fails to parse, also use base64 encoding for safety\n      console.log(\"⚠️ Malformed JSON detected, creating safe component:\", error);\n      return createSafeFormComponent(formCode);\n    }\n  }\n\n  const validation = validateFormCode(formCode);\n  \n  if (!validation.isValid) {\n    console.warn(\"Form code validation failed:\", validation.errors);\n    \n    // If there are only warnings or minor issues, try to use the code anyway\n    if (validation.errors.length === 0 || validation.errors.every(err => err.includes(\"export\"))) {\n      // Try to wrap the code in a basic export if it looks like a component\n      if (/<[A-Za-z][^>]*>/.test(formCode) || /(function|const)\\s+[A-Z]/.test(formCode)) {\n        const componentName = formCode.match(/(function|const)\\s+([A-Z][a-zA-Z0-9]*)/)?.[2] || 'FormComponent';\n        if (!formCode.includes('export default') && !formCode.includes('export {')) {\n          return `${formCode.trim()}\\n\\nexport default ${componentName};`;\n        }\n      }\n    }\n    \n    // For syntax errors, try to create a safe component with the content\n    if (validation.errors.some(err => err.includes(\"syntax\") || err.includes(\"semicolon\"))) {\n      console.log(\"Syntax errors detected, creating safe base64 component\");\n      return createSafeFormComponent(formCode);\n    }\n    \n    // Return fallback only for serious errors\n    return `${DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM}\n    \n// Validation issues found in generated code:\n// ${validation.errors.map(error => `// - ${error}`).join('\\n')}\n// ${validation.warnings.map(warning => `// WARNING: ${warning}`).join('\\n')}`;\n  }\n\n  // If the code is valid, return it with proper formatting\n  return formCode.trim();\n}\n\n/**\n * Analyzes form code to extract metadata\n */\nexport function analyzeFormCode(formCode: string): FormCodeMeta {\n  const meta: FormCodeMeta = {\n    hasTypeScript: false,\n    hasJSX: false,\n    hasFormedibleImports: false,\n    imports: [],\n    exports: []\n  };\n\n  // Check for TypeScript\n  meta.hasTypeScript = /:\\s*[A-Z][a-zA-Z0-9<>[\\]|&\\s]*[=;]/.test(formCode) || \n                      /interface\\s+/.test(formCode) || \n                      /type\\s+/.test(formCode);\n\n  // Check for JSX\n  meta.hasJSX = /<[A-Za-z][^>]*>/.test(formCode);\n\n  // Extract imports\n  const importMatches = formCode.match(/import\\s+.*from\\s+['\"][^'\"]*['\"]/g);\n  if (importMatches) {\n    meta.imports = importMatches;\n    meta.hasFormedibleImports = importMatches.some(imp => \n      imp.includes('formedible') || \n      imp.includes('@/') ||\n      imp.includes('lucide-react')\n    );\n  }\n\n  // Extract exports\n  const exportMatches = formCode.match(/export\\s+(default\\s+)?(function|const|class)\\s+([A-Za-z][a-zA-Z0-9]*)/g);\n  if (exportMatches) {\n    meta.exports = exportMatches;\n    \n    // Try to extract component name\n    const componentMatch = exportMatches[0]?.match(/(?:function|const|class)\\s+([A-Z][a-zA-Z0-9]*)/);\n    if (componentMatch) {\n      meta.componentName = componentMatch[1];\n    }\n  }\n\n  return meta;\n}\n\n/**\n * Creates complete sandbox files with proper structure\n */\nexport function createSandboxFiles(\n  formCode: string, \n  options: InjectionOptions = {}\n): SandpackFiles {\n  const {\n    useErrorBoundary = true,\n    additionalDependencies = {},\n    customStyles = \"\",\n    strictTypeScript = true,\n    targetFile = \"/GeneratedFormComponent.tsx\",\n    templateComplexity = \"basic\",\n    formConfig,\n    useEnhancedTemplates = true\n  } = options;\n\n  // If using enhanced templates, create a complete Formedible sandbox\n  if (useEnhancedTemplates) {\n    let enhancedFormCode = formCode;\n    \n    // Generate form component from fields if configuration is provided\n    if (formConfig?.fields && formConfig.fields.length > 0) {\n      enhancedFormCode = generateFormComponentFromFields(formConfig.fields, formConfig);\n    } else if (!formCode || formCode.trim().length === 0) {\n      // Use template based on complexity\n      const template = getTemplateByComplexity(templateComplexity);\n      enhancedFormCode = template.formComponent;\n    }\n\n    // Create enhanced sandbox with complete Formedible integration\n    const enhancedSandbox = createFormedibleSandbox(enhancedFormCode, templateComplexity);\n    \n    // Merge with additional dependencies\n    if (Object.keys(additionalDependencies).length > 0) {\n      const packageJson = JSON.parse(enhancedSandbox[\"/package.json\"].code);\n      packageJson.dependencies = { ...packageJson.dependencies, ...additionalDependencies };\n      enhancedSandbox[\"/package.json\"].code = JSON.stringify(packageJson, null, 2);\n    }\n    \n    // Add custom styles if provided\n    if (customStyles) {\n      enhancedSandbox[\"/styles.css\"].code += `\\n\\n/* Custom Styles */\\n${customStyles}`;\n    }\n    \n    return enhancedSandbox;\n  }\n\n  // Validate and extract form component\n  const extractedFormCode = extractFormComponent(formCode);\n  const formMeta = analyzeFormCode(extractedFormCode);\n\n  // Create base files\n  const files: SandboxFiles = {\n    \"/App.tsx\": {\n      code: DEFAULT_SANDBOX_TEMPLATES.APP_TSX\n    },\n    [targetFile]: {\n      code: extractedFormCode\n    },\n    \"/styles.css\": {\n      code: DEFAULT_SANDBOX_TEMPLATES.BASE_STYLES + (customStyles ? `\\n\\n/* Custom Styles */\\n${customStyles}` : \"\")\n    },\n    \"/package.json\": {\n      code: JSON.stringify({\n        name: \"formedible-preview\",\n        version: \"1.0.0\",\n        dependencies: {\n          ...FORMEDIBLE_SANDBOX_DEPENDENCIES_FROM_REPO,\n          ...additionalDependencies\n        },\n        main: \"/App.tsx\",\n        ...(strictTypeScript && {\n          devDependencies: {\n            \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n            \"@typescript-eslint/parser\": \"^6.0.0\"\n          }\n        })\n      }, null, 2)\n    }\n  };\n\n  // Add error boundary if requested\n  if (useErrorBoundary) {\n    files[\"/ErrorBoundary.tsx\"] = {\n      code: DEFAULT_SANDBOX_TEMPLATES.ERROR_BOUNDARY\n    };\n\n    // Update App.tsx to use error boundary\n    files[\"/App.tsx\"].code = files[\"/App.tsx\"].code.replace(\n      '<FormComponent',\n      `<ErrorBoundary onError={handleFormError}>\n          <FormComponent`\n    ).replace(\n      '/>',\n      '/>\\n        </ErrorBoundary>'\n    ).replace(\n      \"import FormComponent from './FormComponent';\",\n      `import FormComponent from './FormComponent';\nimport ErrorBoundary from './ErrorBoundary';`\n    );\n  }\n\n  // Add TypeScript config if needed\n  if (formMeta.hasTypeScript && strictTypeScript) {\n    files[\"/tsconfig.json\"] = {\n      code: JSON.stringify({\n        compilerOptions: {\n          target: \"es2018\",\n          lib: [\"dom\", \"dom.iterable\", \"es6\"],\n          allowJs: true,\n          skipLibCheck: true,\n          esModuleInterop: true,\n          allowSyntheticDefaultImports: true,\n          strict: true,\n          forceConsistentCasingInFileNames: true,\n          moduleResolution: \"node\",\n          resolveJsonModule: true,\n          isolatedModules: true,\n          noEmit: true,\n          jsx: \"react-jsx\"\n        },\n        include: [\"src\"]\n      }, null, 2),\n      hidden: true\n    };\n  }\n\n  return files;\n}\n\n/**\n * Main injection function - combines validation, extraction, and file creation\n */\nexport function injectFormCodeIntoSandbox(\n  baseSandboxFiles: SandboxFiles,\n  generatedFormCode: string,\n  options: InjectionOptions = {}\n): SandpackFiles {\n  try {\n    // If using enhanced templates, skip legacy validation for now\n    if (options.useEnhancedTemplates !== false) {\n      const enhancedOptions = {\n        ...options,\n        useEnhancedTemplates: true\n      };\n      \n      // Create new sandbox files with enhanced templates\n      const newFiles = createSandboxFiles(generatedFormCode, enhancedOptions);\n      \n      // Merge with base files if provided, giving priority to new files\n      const mergedFiles = { ...baseSandboxFiles, ...newFiles };\n      \n      return mergedFiles;\n    }\n    \n    // Legacy validation approach\n    const validation = validateFormCode(generatedFormCode);\n    \n    if (!validation.isValid) {\n      console.error(\"Form code validation failed:\", validation.errors);\n      \n      // Create fallback sandbox with error information\n      const fallbackFiles = createSandboxFiles(\n        DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM, \n        options\n      );\n      \n      // Add error information to the fallback\n      const fallbackFile = fallbackFiles[\"/FormComponent.tsx\"];\n      if (typeof fallbackFile === 'object' && fallbackFile.code) {\n        fallbackFile.code = `${DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM}\n\n/* \n * VALIDATION ERRORS:\n * ${validation.errors.map(error => ` * ${error}`).join('\\n')}\n */`;\n      }\n      \n      return fallbackFiles;\n    }\n\n    // Create new sandbox files with validated code\n    const newFiles = createSandboxFiles(generatedFormCode, options);\n    \n    // Merge with base files if provided, giving priority to new files\n    const mergedFiles = { ...baseSandboxFiles, ...newFiles };\n    \n    return mergedFiles;\n\n  } catch (error) {\n    console.error(\"Error injecting form code into sandbox:\", error);\n    \n    // Return safe fallback\n    return createSandboxFiles(DEFAULT_SANDBOX_TEMPLATES.FALLBACK_FORM, options);\n  }\n}\n\n/**\n * Utility to update a single file in existing sandbox\n */\nexport function updateSandboxFile(\n  sandboxFiles: SandpackFiles,\n  filePath: string,\n  newContent: string\n): SandpackFiles {\n  const existingFile = sandboxFiles[filePath];\n  const newFile = typeof existingFile === 'object' \n    ? { ...existingFile, code: newContent }\n    : { code: newContent };\n    \n  return {\n    ...sandboxFiles,\n    [filePath]: newFile\n  };\n}\n\n/**\n * Utility to safely get file content from sandbox\n */\nexport function getSandboxFileContent(\n  sandboxFiles: SandpackFiles,\n  filePath: string\n): string | null {\n  const file = sandboxFiles[filePath];\n  if (typeof file === 'string') {\n    return file;\n  }\n  return file?.code || null;\n}\n\n/**\n * Get available template variations\n */\nexport function getAvailableTemplates(): TemplateVariation[] {\n  return TEMPLATE_VARIATIONS;\n}\n\n/**\n * Create a Formedible sandbox from field configuration\n */\nexport function createSandboxFromFields(\n  fields: any[],\n  options: Omit<InjectionOptions, 'formConfig'> & { \n    title?: string;\n    description?: string;\n    multiPage?: boolean;\n    hasConditional?: boolean;\n  } = {}\n): SandpackFiles {\n  const {\n    title,\n    description,\n    multiPage = false,\n    hasConditional = false,\n    ...injectionOptions\n  } = options;\n  \n  return createSandboxFiles('', {\n    ...injectionOptions,\n    useEnhancedTemplates: true,\n    formConfig: {\n      fields,\n      title,\n      description,\n      multiPage,\n      hasConditional\n    }\n  });\n}\n\n/**\n * Create a sandbox with a specific template\n */\nexport function createSandboxWithTemplate(\n  templateComplexity: \"basic\" | \"intermediate\" | \"advanced\" = \"basic\",\n  options: InjectionOptions = {}\n): SandpackFiles {\n  return createSandboxFiles('', {\n    ...options,\n    useEnhancedTemplates: true,\n    templateComplexity\n  });\n}",
      "type": "registry:lib",
      "target": "lib/sandbox-code-injector.ts"
    },
    {
      "path": "src/lib/sandbox-templates.ts",
      "content": "/**\n * Formedible Sandbox Templates for AI Builder\n * \n * This module provides comprehensive sandbox templates that replicate real Formedible functionality\n * for the Sandpack live preview environment. Templates support all Formedible features including\n * multi-page forms, conditional logic, validation, and various field types.\n */\n\nimport type { SandboxFiles } from \"./sandbox-code-injector\";\n\n/**\n * Dependencies for Formedible sandbox environment\n */\nexport const FORMEDIBLE_SANDBOX_DEPENDENCIES = {\n  \"react\": \"^18.2.0\",\n  \"react-dom\": \"^18.2.0\",\n  \"@types/react\": \"^18.2.0\",\n  \"@types/react-dom\": \"^18.2.0\",\n  \"typescript\": \"^5.0.0\",\n  \"@tanstack/react-form\": \"^1.19.2\",\n  \"lucide-react\": \"^0.263.1\",\n  \"clsx\": \"^2.0.0\",\n  \"tailwind-merge\": \"^2.0.0\",\n  \"zod\": \"^3.22.0\",\n  \"@radix-ui/react-label\": \"^2.1.7\",\n  \"@radix-ui/react-progress\": \"^1.1.7\",\n  \"@radix-ui/react-select\": \"^2.2.5\",\n  \"@radix-ui/react-checkbox\": \"^1.3.2\",\n  \"@radix-ui/react-radio-group\": \"^1.3.7\",\n  \"@radix-ui/react-slider\": \"^1.3.5\",\n  \"@radix-ui/react-switch\": \"^1.2.5\",\n  \"@radix-ui/react-tabs\": \"^1.1.12\",\n  \"class-variance-authority\": \"^0.7.1\",\n  \"sonner\": \"^2.0.7\"\n};\n\n/**\n * Base App.tsx template for Formedible sandbox\n */\nexport const FORMEDIBLE_APP_TEMPLATE = `import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport FormComponent from './FormComponent';\nimport { Toaster } from 'sonner';\nimport './styles.css';\n\ninterface FormData {\n  [key: string]: unknown;\n}\n\nfunction App() {\n  const handleFormSubmit = (data: FormData) => {\n    console.log('Form submitted:', data);\n    \n    // Show success notification\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_SUBMIT',\n        data: data,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  const handleFormError = (error: Error) => {\n    console.error('Form error:', error);\n    \n    // Notify parent component of error\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_ERROR',\n        error: error.message,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  const handleFormChange = (data: FormData) => {\n    console.log('Form changed:', data);\n    \n    // Optional: notify parent of form changes for real-time preview\n    if (typeof window !== 'undefined' && window.parent && window.parent.postMessage) {\n      window.parent.postMessage({\n        type: 'FORM_CHANGE',\n        data: data,\n        timestamp: Date.now()\n      }, '*');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-4\">\n      <div className=\"max-w-4xl mx-auto\">\n        <div className=\"bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden\">\n          <div className=\"px-6 py-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-b border-gray-200\">\n            <h1 className=\"text-2xl font-bold text-gray-900\">Form Preview</h1>\n            <p className=\"text-gray-600 mt-1\">Generated with Formedible AI Builder</p>\n          </div>\n          <div className=\"p-6\">\n            <FormComponent \n              onSubmit={handleFormSubmit} \n              onError={handleFormError}\n              onChange={handleFormChange}\n            />\n          </div>\n        </div>\n      </div>\n      <Toaster position=\"top-right\" />\n    </div>\n  );\n}\n\nconst container = document.getElementById('root');\nif (container) {\n  const root = createRoot(container);\n  root.render(<App />);\n} else {\n  console.error('Root container not found');\n}`;\n\n/**\n * useFormedible hook implementation for sandbox environment\n */\nexport const USE_FORMEDIBLE_HOOK_TEMPLATE = `import React, { useState, useMemo } from \"react\";\nimport { useForm } from \"@tanstack/react-form\";\nimport type { AnyFormApi, AnyFieldApi } from \"@tanstack/react-form\";\nimport { cn } from \"./utils\";\nimport type {\n  FormedibleFormApi,\n  FieldComponentProps,\n  BaseFieldProps,\n  FieldConfig,\n  FormProps,\n  UseFormedibleOptions,\n} from \"./types\";\nimport { Button } from \"./components/ui/button\";\nimport { Progress } from \"./components/ui/progress\";\nimport { TextField } from \"./components/fields/text-field\";\nimport { TextareaField } from \"./components/fields/textarea-field\";\nimport { SelectField } from \"./components/fields/select-field\";\nimport { CheckboxField } from \"./components/fields/checkbox-field\";\nimport { NumberField } from \"./components/fields/number-field\";\nimport { RadioField } from \"./components/fields/radio-field\";\n\n// Field components registry\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  number: NumberField,\n  radio: RadioField,\n};\n\nconst DefaultProgressComponent: React.FC<{\n  value: number;\n  currentPage: number;\n  totalPages: number;\n  className?: string;\n}> = ({ value, currentPage, totalPages, className }) => (\n  <div className={cn(\"space-y-2\", className)}>\n    <div className=\"flex justify-between text-sm text-gray-600\">\n      <span>Step {currentPage} of {totalPages}</span>\n      <span>{Math.round(value)}%</span>\n    </div>\n    <Progress value={value} className=\"h-2\" />\n  </div>\n);\n\nexport function useFormedible<TFormValues extends Record<string, unknown>>(\n  options: UseFormedibleOptions<TFormValues>\n) {\n  const {\n    fields = [],\n    submitLabel = \"Submit\",\n    nextLabel = \"Next\",\n    previousLabel = \"Previous\",\n    formClassName,\n    fieldClassName,\n    labelClassName,\n    buttonClassName,\n    submitButtonClassName,\n    pages,\n    progress,\n    defaultComponents,\n    formOptions,\n    onPageChange,\n    disabled,\n    loading,\n    showSubmitButton = true,\n  } = options;\n\n  const [currentPage, setCurrentPage] = useState(1);\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\n\n  // Group fields by pages\n  const fieldsByPage = useMemo(() => {\n    const grouped: { [page: number]: FieldConfig[] } = {};\n    fields.forEach((field) => {\n      const page = field.page || 1;\n      if (!grouped[page]) grouped[page] = [];\n      grouped[page].push(field);\n    });\n    return grouped;\n  }, [fields]);\n\n  const totalPages = Math.max(...Object.keys(fieldsByPage).map(Number), 1);\n  const hasPages = totalPages > 1;\n  const progressValue = hasPages ? ((currentPage - 1) / (totalPages - 1)) * 100 : 100;\n\n  const form = useForm(formOptions || {});\n\n  const getCurrentPageFields = () => {\n    return fieldsByPage[currentPage] || [];\n  };\n\n  const goToNextPage = () => {\n    if (currentPage < totalPages) {\n      const newPage = currentPage + 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, \"next\");\n    }\n  };\n\n  const goToPreviousPage = () => {\n    if (currentPage > 1) {\n      const newPage = currentPage - 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, \"previous\");\n    }\n  };\n\n  const isLastPage = currentPage === totalPages;\n  const isFirstPage = currentPage === 1;\n\n  const renderField = React.useCallback((fieldConfig: FieldConfig) => {\n    const { name, type, label, placeholder, options, validation } = fieldConfig;\n\n    return (\n      <form.Field\n        key={name}\n        name={name as keyof TFormValues & string}\n        validators={\n          validation\n            ? {\n                onChange: ({ value }) => {\n                  const result = validation.safeParse(value);\n                  return result.success\n                    ? undefined\n                    : result.error.issues[0]?.message || \"Invalid value\";\n                },\n              }\n            : undefined\n        }\n      >\n        {(field) => {\n          const FieldComponent = fieldComponents[type] || TextField;\n          const baseProps = {\n            fieldApi: field as unknown as AnyFieldApi,\n            label,\n            placeholder,\n            wrapperClassName: fieldClassName,\n            labelClassName,\n            disabled: disabled || loading || field.form.state.isSubmitting,\n          };\n\n          let props: FieldComponentProps = { ...baseProps };\n\n          if (type === \"select\" && options) {\n            const normalizedOptions = options.map((opt) =>\n              typeof opt === \"string\" ? { value: opt, label: opt } : opt\n            );\n            props = { ...props, options: normalizedOptions };\n          } else if (type === \"radio\" && options) {\n            const normalizedOptions = options.map((opt) =>\n              typeof opt === \"string\" ? { value: opt, label: opt } : opt\n            );\n            props = { ...props, options: normalizedOptions };\n          }\n\n          return <FieldComponent {...props} />;\n        }}\n      </form.Field>\n    );\n  }, [fieldComponents, fieldClassName, labelClassName, disabled, loading]);\n\n  const Form: React.FC<FormProps> = ({ className, children, onSubmit, ...formProps }) => {\n    const handleSubmit = (e: React.FormEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (onSubmit) {\n        onSubmit(e);\n      } else if (isLastPage) {\n        form.handleSubmit();\n      } else {\n        goToNextPage();\n      }\n    };\n\n    const formClass = cn(\"space-y-6\", formClassName, className);\n    const currentFields = getCurrentPageFields();\n\n    const renderProgress = () => {\n      if (!hasPages || !progress) return null;\n      const ProgressComponent = progress.component || DefaultProgressComponent;\n      return (\n        <ProgressComponent\n          value={progressValue}\n          currentPage={currentPage}\n          totalPages={totalPages}\n          className={progress.className}\n        />\n      );\n    };\n\n    const renderNavigation = () => {\n      if (!showSubmitButton) return null;\n      \n      if (!hasPages) {\n        return (\n          <form.Subscribe\n            selector={(state) => ({\n              canSubmit: state.canSubmit,\n              isSubmitting: state.isSubmitting,\n            })}\n          >\n            {(state) => (\n              <div className=\"flex justify-end\">\n                <Button\n                  type=\"submit\"\n                  disabled={!state.canSubmit || state.isSubmitting || disabled || loading}\n                  className={cn(\"px-8\", submitButtonClassName)}\n                >\n                  {loading ? \"Loading...\" : state.isSubmitting ? \"Submitting...\" : submitLabel}\n                </Button>\n              </div>\n            )}\n          </form.Subscribe>\n        );\n      }\n\n      return (\n        <form.Subscribe\n          selector={(state) => ({\n            canSubmit: state.canSubmit,\n            isSubmitting: state.isSubmitting,\n          })}\n        >\n          {(state) => (\n            <div className=\"flex justify-between gap-4\">\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                onClick={goToPreviousPage}\n                disabled={isFirstPage || disabled || loading}\n                className={cn(isFirstPage ? \"invisible\" : \"\", buttonClassName)}\n              >\n                {previousLabel}\n              </Button>\n              <Button\n                type=\"submit\"\n                disabled={(!state.canSubmit || state.isSubmitting || disabled || loading) && isLastPage}\n                className={cn(\"px-8\", isLastPage ? submitButtonClassName : buttonClassName)}\n              >\n                {loading && isLastPage\n                  ? \"Loading...\"\n                  : state.isSubmitting && isLastPage\n                  ? \"Submitting...\"\n                  : isLastPage\n                  ? submitLabel\n                  : nextLabel}\n              </Button>\n            </div>\n          )}\n        </form.Subscribe>\n      );\n    };\n\n    return (\n      <form onSubmit={handleSubmit} className={formClass} {...formProps}>\n        {children || (\n          <>\n            {renderProgress()}\n            <div className=\"space-y-4\">\n              {currentFields.map((field) => renderField(field))}\n            </div>\n            {renderNavigation()}\n          </>\n        )}\n      </form>\n    );\n  };\n\n  return {\n    form,\n    Form,\n    currentPage,\n    totalPages,\n    goToNextPage,\n    goToPreviousPage,\n    isFirstPage,\n    isLastPage,\n    progressValue,\n  };\n}`;\n\n/**\n * Basic types file for sandbox environment\n */\nexport const FORMEDIBLE_TYPES_TEMPLATE = `import React from \"react\";\nimport type { AnyFieldApi } from \"@tanstack/react-form\";\nimport type { FormApi } from \"@tanstack/form-core\";\nimport { z } from \"zod\";\n\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\n  TFormData,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  never\n>;\n\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  placeholder?: string;\n  wrapperClassName?: string;\n  labelClassName?: string;\n  disabled?: boolean;\n}\n\nexport interface FieldComponentProps extends BaseFieldProps {\n  options?: Array<{ value: string; label: string }> | string[];\n  [key: string]: unknown;\n}\n\nexport interface FieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  required?: boolean;\n  defaultValue?: unknown;\n  options?: string[] | Array<{ value: string; label: string }>;\n  validation?: z.ZodSchema<unknown>;\n  page?: number;\n  [key: string]: unknown;\n}\n\nexport interface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  [key: string]: unknown;\n}\n\nexport interface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  labelClassName?: string;\n  buttonClassName?: string;\n  submitButtonClassName?: string;\n  pages?: Array<{ page: number; title?: string; description?: string }>;\n  progress?: {\n    component?: React.ComponentType<any>;\n    className?: string;\n  };\n  defaultComponents?: {\n    [key: string]: React.ComponentType<FieldComponentProps>;\n  };\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => unknown | Promise<unknown>;\n  }>;\n  onPageChange?: (page: number, direction: \"next\" | \"previous\") => void;\n  disabled?: boolean;\n  loading?: boolean;\n  showSubmitButton?: boolean;\n}`;\n\n/**\n * Utility functions for sandbox environment\n */\nexport const FORMEDIBLE_UTILS_TEMPLATE = `import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}`;\n\n/**\n * UI Components - Button\n */\nexport const BUTTON_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"../../utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }`;\n\n/**\n * UI Components - Progress\n */\nexport const PROGRESS_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\nimport { cn } from \"../../utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: \\`translateX(-\\${100 - (value || 0)}%)\\` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }`;\n\n/**\n * Basic field components - Text Field\n */\nexport const TEXT_FIELD_TEMPLATE = `import React from \"react\";\nimport { cn } from \"../../utils\";\nimport { Label } from \"../ui/label\";\nimport { Input } from \"../ui/input\";\nimport type { BaseFieldProps } from \"../../types\";\n\nexport interface TextFieldProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\";\n}\n\nexport function TextField({ fieldApi, label, placeholder, wrapperClassName, labelClassName, disabled, type = \"text\" }: TextFieldProps) {\n  const { name, value, errors, handleChange, handleBlur } = fieldApi;\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      <Input\n        id={name}\n        name={name}\n        type={type}\n        value={value || \"\"}\n        placeholder={placeholder}\n        onChange={(e) => handleChange(e.target.value)}\n        onBlur={handleBlur}\n        disabled={disabled}\n        className={cn(errors.length > 0 && \"border-destructive\")}\n      />\n      {errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">{errors[0]}</p>\n      )}\n    </div>\n  );\n}`;\n\n/**\n * Basic Input component\n */\nexport const INPUT_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport { cn } from \"../../utils\"\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }`;\n\n/**\n * Basic Label component\n */\nexport const LABEL_COMPONENT_TEMPLATE = `import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"../../utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }`;\n\n/**\n * Comprehensive CSS styles for Formedible forms\n */\nexport const FORMEDIBLE_STYLES_TEMPLATE = `@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');\n\n/* CSS Variables for consistent theming */\n:root {\n  --background: 0 0% 100%;\n  --foreground: 222.2 84% 4.9%;\n  --card: 0 0% 100%;\n  --card-foreground: 222.2 84% 4.9%;\n  --popover: 0 0% 100%;\n  --popover-foreground: 222.2 84% 4.9%;\n  --primary: 221.2 83.2% 53.3%;\n  --primary-foreground: 210 40% 98%;\n  --secondary: 210 40% 96%;\n  --secondary-foreground: 222.2 84% 4.9%;\n  --muted: 210 40% 96%;\n  --muted-foreground: 215.4 16.3% 46.9%;\n  --accent: 210 40% 96%;\n  --accent-foreground: 222.2 84% 4.9%;\n  --destructive: 0 84.2% 60.2%;\n  --destructive-foreground: 210 40% 98%;\n  --border: 214.3 31.8% 91.4%;\n  --input: 214.3 31.8% 91.4%;\n  --ring: 221.2 83.2% 53.3%;\n  --radius: 0.5rem;\n}\n\n.dark {\n  --background: 222.2 84% 4.9%;\n  --foreground: 210 40% 98%;\n  --card: 222.2 84% 4.9%;\n  --card-foreground: 210 40% 98%;\n  --popover: 222.2 84% 4.9%;\n  --popover-foreground: 210 40% 98%;\n  --primary: 217.2 91.2% 59.8%;\n  --primary-foreground: 222.2 84% 4.9%;\n  --secondary: 217.2 32.6% 17.5%;\n  --secondary-foreground: 210 40% 98%;\n  --muted: 217.2 32.6% 17.5%;\n  --muted-foreground: 215 20.2% 65.1%;\n  --accent: 217.2 32.6% 17.5%;\n  --accent-foreground: 210 40% 98%;\n  --destructive: 0 62.8% 30.6%;\n  --destructive-foreground: 210 40% 98%;\n  --border: 217.2 32.6% 17.5%;\n  --input: 217.2 32.6% 17.5%;\n  --ring: 224.3 76.3% 94.1%;\n}\n\n* {\n  border-color: hsl(var(--border));\n}\n\nbody {\n  background-color: hsl(var(--background));\n  color: hsl(var(--foreground));\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;\n  margin: 0;\n  padding: 0;\n  line-height: 1.6;\n}\n\n/* Utility classes for styling */\n.space-y-2 > * + * { margin-top: 0.5rem; }\n.space-y-4 > * + * { margin-top: 1rem; }\n.space-y-6 > * + * { margin-top: 1.5rem; }\n\n.text-sm { font-size: 0.875rem; line-height: 1.25rem; }\n.text-base { font-size: 1rem; line-height: 1.5rem; }\n.text-lg { font-size: 1.125rem; line-height: 1.75rem; }\n.text-xl { font-size: 1.25rem; line-height: 1.75rem; }\n.text-2xl { font-size: 1.5rem; line-height: 2rem; }\n\n.font-medium { font-weight: 500; }\n.font-semibold { font-weight: 600; }\n.font-bold { font-weight: 700; }\n\n.text-gray-600 { color: #6b7280; }\n.text-gray-700 { color: #374151; }\n.text-gray-900 { color: #111827; }\n\n.bg-white { background-color: #ffffff; }\n.bg-gray-50 { background-color: #f9fafb; }\n.bg-gray-100 { background-color: #f3f4f6; }\n.bg-blue-50 { background-color: #eff6ff; }\n.bg-indigo-50 { background-color: #eef2ff; }\n\n.border { border-width: 1px; }\n.border-gray-200 { border-color: #e5e7eb; }\n.border-b { border-bottom-width: 1px; }\n\n.rounded-md { border-radius: 0.375rem; }\n.rounded-lg { border-radius: 0.5rem; }\n.rounded-xl { border-radius: 0.75rem; }\n\n.shadow-lg { box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }\n\n.p-4 { padding: 1rem; }\n.p-6 { padding: 1.5rem; }\n.px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }\n.py-4 { padding-top: 1rem; padding-bottom: 1rem; }\n\n.min-h-screen { min-height: 100vh; }\n.max-w-4xl { max-width: 56rem; }\n.mx-auto { margin-left: auto; margin-right: auto; }\n\n.flex { display: flex; }\n.justify-between { justify-content: space-between; }\n.justify-end { justify-content: flex-end; }\n.items-center { align-items: center; }\n\n.overflow-hidden { overflow: hidden; }\n\n.bg-gradient-to-br { background-image: linear-gradient(to bottom right, var(--tw-gradient-stops)); }\n.bg-gradient-to-r { background-image: linear-gradient(to right, var(--tw-gradient-stops)); }\n\n.from-gray-50 { --tw-gradient-from: #f9fafb; --tw-gradient-to: rgb(249 250 251 / 0); --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to); }\n.to-gray-100 { --tw-gradient-to: #f3f4f6; }\n.from-blue-50 { --tw-gradient-from: #eff6ff; --tw-gradient-to: rgb(239 246 255 / 0); --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to); }\n.to-indigo-50 { --tw-gradient-to: #eef2ff; }\n\n/* Form specific styles */\n.form-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n.field-group {\n  margin-bottom: 1.5rem;\n}\n\n.field-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid hsl(var(--border));\n  border-radius: var(--radius);\n  font-size: 1rem;\n  background-color: hsl(var(--background));\n  color: hsl(var(--foreground));\n  transition: border-color 0.2s, box-shadow 0.2s;\n}\n\n.field-input:focus {\n  outline: none;\n  border-color: hsl(var(--ring));\n  box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);\n}\n\n.field-input:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Button styles */\n.btn-primary {\n  background-color: hsl(var(--primary));\n  color: hsl(var(--primary-foreground));\n  padding: 0.75rem 1.5rem;\n  border: none;\n  border-radius: var(--radius);\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.btn-primary:hover:not(:disabled) {\n  background-color: hsl(var(--primary) / 0.9);\n}\n\n.btn-primary:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.btn-secondary {\n  background-color: hsl(var(--secondary));\n  color: hsl(var(--secondary-foreground));\n  padding: 0.75rem 1.5rem;\n  border: 1px solid hsl(var(--border));\n  border-radius: var(--radius);\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.btn-secondary:hover:not(:disabled) {\n  background-color: hsl(var(--accent));\n}\n\n/* Error states */\n.error-message {\n  color: hsl(var(--destructive));\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n\n.field-error {\n  border-color: hsl(var(--destructive));\n}\n\n/* Progress bar */\n.progress-bar {\n  width: 100%;\n  height: 0.5rem;\n  background-color: hsl(var(--secondary));\n  border-radius: var(--radius);\n  overflow: hidden;\n  margin-bottom: 1.5rem;\n}\n\n.progress-fill {\n  height: 100%;\n  background-color: hsl(var(--primary));\n  transition: width 0.3s ease-in-out;\n}\n\n/* Loading states */\n.loading {\n  opacity: 0.7;\n  pointer-events: none;\n}\n\n.spinner {\n  border: 2px solid hsl(var(--secondary));\n  border-top: 2px solid hsl(var(--primary));\n  border-radius: 50%;\n  width: 1rem;\n  height: 1rem;\n  animation: spin 1s linear infinite;\n  display: inline-block;\n  margin-right: 0.5rem;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Responsive design */\n@media (max-width: 768px) {\n  .form-container {\n    padding: 1rem;\n  }\n  \n  .field-input,\n  .btn-primary,\n  .btn-secondary {\n    font-size: 0.875rem;\n    padding: 0.625rem 1rem;\n  }\n  \n  .max-w-4xl {\n    max-width: 100%;\n    margin: 0 1rem;\n  }\n}\n\n/* Focus visible for accessibility */\n*:focus-visible {\n  outline: 2px solid hsl(var(--ring));\n  outline-offset: 2px;\n}\n\n/* Selection styles */\n::selection {\n  background-color: hsl(var(--primary) / 0.2);\n}`;\n\n/**\n * TypeScript configuration for sandbox\n */\nexport const TSCONFIG_TEMPLATE = `{\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"es6\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src\"]\n}`;\n\n/**\n * Package.json template with all required dependencies\n */\nexport const PACKAGE_JSON_TEMPLATE = JSON.stringify({\n  name: \"formedible-sandbox\",\n  version: \"1.0.0\",\n  dependencies: FORMEDIBLE_SANDBOX_DEPENDENCIES,\n  main: \"/App.tsx\",\n  devDependencies: {\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\"\n  }\n}, null, 2);\n\n/**\n * Template variations for different form types\n */\nexport interface TemplateVariation {\n  name: string;\n  description: string;\n  complexity: \"basic\" | \"intermediate\" | \"advanced\";\n  formComponent: string;\n  exampleFields: any[];\n}\n\n/**\n * Basic single-page form template\n */\nexport const BASIC_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Basic Form\",\n  description: \"Simple single-page form with basic validation\",\n  complexity: \"basic\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  name: string;\n  email: string;\n  message: string;\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form } = useFormedible<FormData>({\n    fields: [\n      {\n        name: 'name',\n        type: 'text',\n        label: 'Full Name',\n        placeholder: 'Enter your full name',\n        validation: z.string().min(2, 'Name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      {\n        name: 'message',\n        type: 'textarea',\n        label: 'Message',\n        placeholder: 'Enter your message',\n        validation: z.string().min(10, 'Message must be at least 10 characters'),\n      },\n    ],\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return (\n    <Form />\n  );\n}`,\n  exampleFields: [\n    { name: 'name', type: 'text', label: 'Full Name', placeholder: 'Enter your full name' },\n    { name: 'email', type: 'email', label: 'Email Address', placeholder: 'Enter your email address' },\n    { name: 'message', type: 'textarea', label: 'Message', placeholder: 'Enter your message' },\n  ]\n};\n\n/**\n * Multi-page form template\n */\nexport const MULTI_PAGE_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Multi-Page Form\",\n  description: \"Multi-step form with progress indicator and validation\",\n  complexity: \"intermediate\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  company: string;\n  role: string;\n  experience: string;\n  skills: string[];\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form, currentPage, totalPages } = useFormedible<FormData>({\n    fields: [\n      // Page 1: Personal Information\n      {\n        name: 'firstName',\n        type: 'text',\n        label: 'First Name',\n        placeholder: 'Enter your first name',\n        page: 1,\n        validation: z.string().min(2, 'First name must be at least 2 characters'),\n      },\n      {\n        name: 'lastName',\n        type: 'text',\n        label: 'Last Name',\n        placeholder: 'Enter your last name',\n        page: 1,\n        validation: z.string().min(2, 'Last name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        page: 1,\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      {\n        name: 'phone',\n        type: 'tel',\n        label: 'Phone Number',\n        placeholder: 'Enter your phone number',\n        page: 1,\n        validation: z.string().min(10, 'Please enter a valid phone number'),\n      },\n      // Page 2: Professional Information\n      {\n        name: 'company',\n        type: 'text',\n        label: 'Company',\n        placeholder: 'Enter your company name',\n        page: 2,\n        validation: z.string().min(2, 'Company name must be at least 2 characters'),\n      },\n      {\n        name: 'role',\n        type: 'select',\n        label: 'Current Role',\n        placeholder: 'Select your role',\n        page: 2,\n        options: [\n          { value: 'developer', label: 'Software Developer' },\n          { value: 'designer', label: 'UI/UX Designer' },\n          { value: 'manager', label: 'Project Manager' },\n          { value: 'analyst', label: 'Business Analyst' },\n          { value: 'other', label: 'Other' },\n        ],\n        validation: z.string().min(1, 'Please select a role'),\n      },\n      {\n        name: 'experience',\n        type: 'select',\n        label: 'Years of Experience',\n        placeholder: 'Select experience level',\n        page: 2,\n        options: [\n          { value: '0-1', label: '0-1 years' },\n          { value: '2-5', label: '2-5 years' },\n          { value: '6-10', label: '6-10 years' },\n          { value: '10+', label: '10+ years' },\n        ],\n        validation: z.string().min(1, 'Please select experience level'),\n      },\n      // Page 3: Skills (using checkboxes)\n      {\n        name: 'skills',\n        type: 'checkbox',\n        label: 'Technical Skills',\n        placeholder: 'Select your skills',\n        page: 3,\n        options: [\n          { value: 'javascript', label: 'JavaScript' },\n          { value: 'typescript', label: 'TypeScript' },\n          { value: 'react', label: 'React' },\n          { value: 'vue', label: 'Vue.js' },\n          { value: 'angular', label: 'Angular' },\n          { value: 'node', label: 'Node.js' },\n          { value: 'python', label: 'Python' },\n          { value: 'java', label: 'Java' },\n        ],\n        validation: z.array(z.string()).min(1, 'Please select at least one skill'),\n      },\n    ],\n    pages: [\n      { page: 1, title: 'Personal Information', description: 'Tell us about yourself' },\n      { page: 2, title: 'Professional Background', description: 'Share your work experience' },\n      { page: 3, title: 'Technical Skills', description: 'Select your areas of expertise' },\n    ],\n    progress: {\n      className: 'mb-6',\n    },\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return <Form />;\n}`,\n  exampleFields: [\n    { name: 'firstName', type: 'text', label: 'First Name', page: 1 },\n    { name: 'lastName', type: 'text', label: 'Last Name', page: 1 },\n    { name: 'email', type: 'email', label: 'Email Address', page: 1 },\n    { name: 'company', type: 'text', label: 'Company', page: 2 },\n    { name: 'role', type: 'select', label: 'Current Role', page: 2 },\n    { name: 'skills', type: 'checkbox', label: 'Technical Skills', page: 3 },\n  ]\n};\n\n/**\n * Advanced form with conditional logic template\n */\nexport const ADVANCED_CONDITIONAL_FORM_TEMPLATE: TemplateVariation = {\n  name: \"Advanced Conditional Form\",\n  description: \"Complex form with conditional fields, dynamic validation, and multiple field types\",\n  complexity: \"advanced\",\n  formComponent: `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  userType: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  companyName?: string;\n  industry?: string;\n  employees?: string;\n  personalInterests?: string[];\n  budget?: number;\n  timeline?: string;\n  additionalRequirements?: string;\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form, form } = useFormedible<FormData>({\n    fields: [\n      {\n        name: 'userType',\n        type: 'radio',\n        label: 'I am a...',\n        options: [\n          { value: 'individual', label: 'Individual' },\n          { value: 'business', label: 'Business Owner' },\n          { value: 'enterprise', label: 'Enterprise' },\n        ],\n        validation: z.string().min(1, 'Please select user type'),\n      },\n      {\n        name: 'firstName',\n        type: 'text',\n        label: 'First Name',\n        placeholder: 'Enter your first name',\n        validation: z.string().min(2, 'First name must be at least 2 characters'),\n      },\n      {\n        name: 'lastName',\n        type: 'text',\n        label: 'Last Name',\n        placeholder: 'Enter your last name',\n        validation: z.string().min(2, 'Last name must be at least 2 characters'),\n      },\n      {\n        name: 'email',\n        type: 'email',\n        label: 'Email Address',\n        placeholder: 'Enter your email address',\n        validation: z.string().email('Please enter a valid email address'),\n      },\n      // Business-specific fields (conditional)\n      {\n        name: 'companyName',\n        type: 'text',\n        label: 'Company Name',\n        placeholder: 'Enter your company name',\n        conditional: (values) => values.userType === 'business' || values.userType === 'enterprise',\n        validation: z.string().min(2, 'Company name must be at least 2 characters').optional(),\n      },\n      {\n        name: 'industry',\n        type: 'select',\n        label: 'Industry',\n        placeholder: 'Select your industry',\n        conditional: (values) => values.userType === 'business' || values.userType === 'enterprise',\n        options: [\n          { value: 'technology', label: 'Technology' },\n          { value: 'finance', label: 'Finance' },\n          { value: 'healthcare', label: 'Healthcare' },\n          { value: 'education', label: 'Education' },\n          { value: 'retail', label: 'Retail' },\n          { value: 'manufacturing', label: 'Manufacturing' },\n          { value: 'other', label: 'Other' },\n        ],\n        validation: z.string().min(1, 'Please select an industry').optional(),\n      },\n      {\n        name: 'employees',\n        type: 'select',\n        label: 'Number of Employees',\n        placeholder: 'Select company size',\n        conditional: (values) => values.userType === 'enterprise',\n        options: [\n          { value: '1-10', label: '1-10 employees' },\n          { value: '11-50', label: '11-50 employees' },\n          { value: '51-200', label: '51-200 employees' },\n          { value: '201-1000', label: '201-1000 employees' },\n          { value: '1000+', label: '1000+ employees' },\n        ],\n        validation: z.string().min(1, 'Please select company size').optional(),\n      },\n      // Individual-specific fields\n      {\n        name: 'personalInterests',\n        type: 'checkbox',\n        label: 'Personal Interests',\n        conditional: (values) => values.userType === 'individual',\n        options: [\n          { value: 'technology', label: 'Technology' },\n          { value: 'design', label: 'Design' },\n          { value: 'marketing', label: 'Marketing' },\n          { value: 'business', label: 'Business' },\n          { value: 'education', label: 'Education' },\n          { value: 'health', label: 'Health & Wellness' },\n        ],\n        validation: z.array(z.string()).min(1, 'Please select at least one interest').optional(),\n      },\n      // Common fields for all user types\n      {\n        name: 'budget',\n        type: 'number',\n        label: 'Budget Range',\n        placeholder: 'Enter your budget in USD',\n        validation: z.number().min(1, 'Budget must be greater than 0').optional(),\n      },\n      {\n        name: 'timeline',\n        type: 'select',\n        label: 'Project Timeline',\n        placeholder: 'When do you need this completed?',\n        options: [\n          { value: 'asap', label: 'As soon as possible' },\n          { value: '1-month', label: 'Within 1 month' },\n          { value: '3-months', label: 'Within 3 months' },\n          { value: '6-months', label: 'Within 6 months' },\n          { value: 'flexible', label: 'Flexible timeline' },\n        ],\n        validation: z.string().min(1, 'Please select a timeline'),\n      },\n      {\n        name: 'additionalRequirements',\n        type: 'textarea',\n        label: 'Additional Requirements',\n        placeholder: 'Tell us more about your specific needs...',\n        validation: z.string().optional(),\n      },\n    ],\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          // Simulate API call\n          console.log('Submitting form:', value);\n          await new Promise(resolve => setTimeout(resolve, 1000));\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return <Form />;\n}`,\n  exampleFields: [\n    { name: 'userType', type: 'radio', label: 'User Type' },\n    { name: 'firstName', type: 'text', label: 'First Name' },\n    { name: 'companyName', type: 'text', label: 'Company Name', conditional: true },\n    { name: 'industry', type: 'select', label: 'Industry', conditional: true },\n    { name: 'personalInterests', type: 'checkbox', label: 'Personal Interests', conditional: true },\n    { name: 'budget', type: 'number', label: 'Budget Range' },\n  ]\n};\n\n/**\n * Get all available templates\n */\nexport const TEMPLATE_VARIATIONS: TemplateVariation[] = [\n  BASIC_FORM_TEMPLATE,\n  MULTI_PAGE_FORM_TEMPLATE,\n  ADVANCED_CONDITIONAL_FORM_TEMPLATE,\n];\n\n/**\n * Create a complete Formedible sandbox with all necessary files\n */\nexport function createFormedibleSandbox(\n  formComponent: string = BASIC_FORM_TEMPLATE.formComponent,\n  templateType: \"basic\" | \"intermediate\" | \"advanced\" = \"basic\"\n): SandboxFiles {\n  // CRITICAL: Process the form component through extractFormComponent to handle JSON safely\n  const { extractFormComponent } = require('./sandbox-code-injector');\n  const safeFormComponent = extractFormComponent(formComponent);\n  \n  return {\n    \"/App.tsx\": {\n      code: FORMEDIBLE_APP_TEMPLATE\n    },\n    \"/FormComponent.tsx\": {\n      code: safeFormComponent\n    },\n    \"/hooks/use-formedible.tsx\": {\n      code: USE_FORMEDIBLE_HOOK_TEMPLATE\n    },\n    \"/types.ts\": {\n      code: FORMEDIBLE_TYPES_TEMPLATE\n    },\n    \"/utils.ts\": {\n      code: FORMEDIBLE_UTILS_TEMPLATE\n    },\n    \"/components/ui/button.tsx\": {\n      code: BUTTON_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/progress.tsx\": {\n      code: PROGRESS_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/input.tsx\": {\n      code: INPUT_COMPONENT_TEMPLATE\n    },\n    \"/components/ui/label.tsx\": {\n      code: LABEL_COMPONENT_TEMPLATE\n    },\n    \"/components/fields/text-field.tsx\": {\n      code: TEXT_FIELD_TEMPLATE\n    },\n    \"/styles.css\": {\n      code: FORMEDIBLE_STYLES_TEMPLATE\n    },\n    \"/package.json\": {\n      code: PACKAGE_JSON_TEMPLATE,\n      hidden: true\n    },\n    \"/tsconfig.json\": {\n      code: TSCONFIG_TEMPLATE,\n      hidden: true\n    }\n  };\n}\n\n/**\n * Get template by complexity level\n */\nexport function getTemplateByComplexity(complexity: \"basic\" | \"intermediate\" | \"advanced\"): TemplateVariation {\n  return TEMPLATE_VARIATIONS.find(template => template.complexity === complexity) || BASIC_FORM_TEMPLATE;\n}\n\n/**\n * Generate form component code from field configuration\n */\nexport function generateFormComponentFromFields(\n  fields: any[],\n  formConfig?: { \n    multiPage?: boolean; \n    hasConditional?: boolean; \n    title?: string;\n    description?: string;\n  }\n): string {\n  const { multiPage = false, hasConditional = false, title = \"Generated Form\", description } = formConfig || {};\n\n  const fieldsCode = fields.map(field => {\n    const validation = field.validation ? \n      `validation: z.string().min(1, 'This field is required'),` : '';\n    const options = field.options ? \n      `options: ${JSON.stringify(field.options)},` : '';\n    const conditional = field.conditional ? \n      `conditional: (values) => ${field.conditional},` : '';\n    \n    return `      {\n        name: '${field.name}',\n        type: '${field.type}',\n        label: '${field.label || field.name}',\n        placeholder: '${field.placeholder || ''}',\n        ${field.page ? `page: ${field.page},` : ''}\n        ${validation}\n        ${options}\n        ${conditional}\n      }`;\n  }).join(',\\n');\n\n  const pagesConfig = multiPage && fields.some(f => f.page) ? `\n    pages: [\n      ${[...new Set(fields.filter(f => f.page).map(f => f.page))].sort().map(pageNum => \n        `{ page: ${pageNum}, title: 'Step ${pageNum}', description: 'Please fill out this step' }`\n      ).join(',\\n      ')}\n    ],\n    progress: {\n      className: 'mb-6',\n    },` : '';\n\n  return `import React from 'react';\nimport { useFormedible } from './hooks/use-formedible';\nimport { z } from 'zod';\n\ninterface FormData {\n  ${fields.map(field => `${field.name}: ${field.type === 'number' ? 'number' : field.type === 'checkbox' ? 'string[]' : 'string'};`).join('\\n  ')}\n}\n\ninterface FormComponentProps {\n  onSubmit?: (data: FormData) => void;\n  onError?: (error: Error) => void;\n  onChange?: (data: FormData) => void;\n}\n\nexport default function FormComponent({ onSubmit, onError, onChange }: FormComponentProps) {\n  const { Form } = useFormedible<FormData>({\n    fields: [\n${fieldsCode}\n    ],${pagesConfig}\n    formOptions: {\n      onSubmit: async ({ value }) => {\n        try {\n          console.log('Form submitted:', value);\n          onSubmit?.(value);\n        } catch (error) {\n          onError?.(error as Error);\n        }\n      },\n      onChange: ({ value }) => {\n        onChange?.(value);\n      },\n    },\n  });\n\n  return (\n    <div className=\"space-y-6\">\n      ${title ? `<div className=\"text-center\">\n        <h2 className=\"text-2xl font-bold text-gray-900\">${title}</h2>\n        ${description ? `<p className=\"text-gray-600 mt-2\">${description}</p>` : ''}\n      </div>` : ''}\n      <Form />\n    </div>\n  );\n}`;\n}",
      "type": "registry:lib",
      "target": "lib/sandbox-templates.ts"
    },
    {
      "path": "src/lib/sandbox-cache.ts",
      "content": "/**\n * Advanced Caching System for Sandpack Templates and Form Components\n * \n * Implements intelligent caching strategies to optimize loading times and reduce\n * bundle size for Formedible form previews.\n */\n\nimport { SandpackFiles } from \"@codesandbox/sandpack-react\";\n\n// Cache configuration\ninterface CacheConfig {\n  maxSize: number;\n  maxAge: number; // in milliseconds\n  compressionEnabled: boolean;\n  persistToStorage: boolean;\n}\n\n// Cache entry structure\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  accessCount: number;\n  lastAccess: number;\n  size: number;\n  compressed?: boolean;\n  hash: string;\n}\n\n// Cache statistics\ninterface CacheStats {\n  hits: number;\n  misses: number;\n  evictions: number;\n  totalSize: number;\n  entryCount: number;\n  hitRate: number;\n}\n\n// Template metadata for intelligent caching\ninterface TemplateMetadata {\n  complexity: 'basic' | 'intermediate' | 'advanced';\n  features: string[];\n  dependencies: string[];\n  formFieldCount: number;\n  hasConditionalLogic: boolean;\n  hasMultiPage: boolean;\n  codeLength: number;\n}\n\n/**\n * Intelligent LRU Cache with compression and persistence\n */\nclass IntelligentCache<T> {\n  private cache = new Map<string, CacheEntry<T>>();\n  private stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    totalSize: 0,\n    entryCount: 0,\n    hitRate: 0\n  };\n\n  constructor(private config: CacheConfig) {}\n\n  /**\n   * Generate hash for cache key\n   */\n  private generateHash(key: string): string {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      const char = key.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Calculate approximate size of data\n   */\n  private calculateSize(data: T): number {\n    if (typeof data === 'string') {\n      return data.length * 2; // UTF-16 encoding\n    }\n    if (data && typeof data === 'object') {\n      return JSON.stringify(data).length * 2;\n    }\n    return 50; // Default size estimate\n  }\n\n  /**\n   * Compress data if enabled\n   */\n  private async compressData(data: T): Promise<T> {\n    if (!this.config.compressionEnabled) return data;\n    \n    try {\n      // Simple compression using JSON stringification optimization\n      if (typeof data === 'object') {\n        const jsonString = JSON.stringify(data);\n        // Remove unnecessary whitespace and optimize structure\n        const optimized = jsonString.replace(/\\s+/g, ' ').trim();\n        return JSON.parse(optimized) as T;\n      }\n      return data;\n    } catch {\n      return data;\n    }\n  }\n\n  /**\n   * Check if entry is expired\n   */\n  private isExpired(entry: CacheEntry<T>): boolean {\n    return Date.now() - entry.timestamp > this.config.maxAge;\n  }\n\n  /**\n   * Evict least recently used entries\n   */\n  private evictLRU(): void {\n    if (this.cache.size <= this.config.maxSize) return;\n\n    const entries = Array.from(this.cache.entries());\n    entries.sort((a, b) => a[1].lastAccess - b[1].lastAccess);\n\n    const evictCount = Math.ceil(this.cache.size * 0.1); // Evict 10%\n    for (let i = 0; i < evictCount && i < entries.length; i++) {\n      const [key, entry] = entries[i];\n      this.cache.delete(key);\n      this.stats.totalSize -= entry.size;\n      this.stats.evictions++;\n    }\n    \n    this.stats.entryCount = this.cache.size;\n  }\n\n  /**\n   * Set cache entry\n   */\n  async set(key: string, data: T, metadata?: TemplateMetadata): Promise<void> {\n    const hash = this.generateHash(key);\n    const compressed = await this.compressData(data);\n    const size = this.calculateSize(compressed);\n    \n    const entry: CacheEntry<T> = {\n      data: compressed,\n      timestamp: Date.now(),\n      accessCount: 0,\n      lastAccess: Date.now(),\n      size,\n      compressed: this.config.compressionEnabled,\n      hash\n    };\n\n    // Remove existing entry if it exists\n    if (this.cache.has(key)) {\n      const existing = this.cache.get(key)!;\n      this.stats.totalSize -= existing.size;\n    }\n\n    this.cache.set(key, entry);\n    this.stats.totalSize += size;\n    this.stats.entryCount = this.cache.size;\n\n    // Evict if necessary\n    this.evictLRU();\n\n    // Persist to storage if enabled\n    if (this.config.persistToStorage) {\n      this.persistToStorage(key, entry);\n    }\n  }\n\n  /**\n   * Get cache entry\n   */\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      this.stats.misses++;\n      this.updateHitRate();\n      return null;\n    }\n\n    // Check expiration\n    if (this.isExpired(entry)) {\n      this.cache.delete(key);\n      this.stats.totalSize -= entry.size;\n      this.stats.entryCount = this.cache.size;\n      this.stats.misses++;\n      this.updateHitRate();\n      return null;\n    }\n\n    // Update access info\n    entry.accessCount++;\n    entry.lastAccess = Date.now();\n    this.stats.hits++;\n    this.updateHitRate();\n\n    return entry.data;\n  }\n\n  /**\n   * Update hit rate calculation\n   */\n  private updateHitRate(): void {\n    const total = this.stats.hits + this.stats.misses;\n    this.stats.hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;\n  }\n\n  /**\n   * Clear expired entries\n   */\n  clearExpired(): number {\n    let clearedCount = 0;\n    const now = Date.now();\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.config.maxAge) {\n        this.cache.delete(key);\n        this.stats.totalSize -= entry.size;\n        clearedCount++;\n      }\n    }\n    \n    this.stats.entryCount = this.cache.size;\n    return clearedCount;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Clear entire cache\n   */\n  clear(): void {\n    this.cache.clear();\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      totalSize: 0,\n      entryCount: 0,\n      hitRate: 0\n    };\n  }\n\n  /**\n   * Persist to localStorage (if available)\n   */\n  private persistToStorage(key: string, entry: CacheEntry<T>): void {\n    if (typeof window === 'undefined' || !window.localStorage) return;\n    \n    try {\n      const storageKey = `sandpack_cache_${key}`;\n      const storageData = {\n        ...entry,\n        data: typeof entry.data === 'object' ? JSON.stringify(entry.data) : entry.data\n      };\n      \n      localStorage.setItem(storageKey, JSON.stringify(storageData));\n    } catch (error) {\n      console.warn('Failed to persist cache to localStorage:', error);\n    }\n  }\n\n  /**\n   * Load from localStorage (if available)\n   */\n  loadFromStorage(key: string): T | null {\n    if (typeof window === 'undefined' || !window.localStorage) return null;\n    \n    try {\n      const storageKey = `sandpack_cache_${key}`;\n      const stored = localStorage.getItem(storageKey);\n      \n      if (!stored) return null;\n      \n      const storageData = JSON.parse(stored);\n      \n      // Check expiration\n      if (Date.now() - storageData.timestamp > this.config.maxAge) {\n        localStorage.removeItem(storageKey);\n        return null;\n      }\n      \n      // Parse data back if it was stringified\n      const data = typeof storageData.data === 'string' && storageData.data.startsWith('{') \n        ? JSON.parse(storageData.data) \n        : storageData.data;\n      \n      // Add back to memory cache\n      this.cache.set(key, storageData);\n      this.stats.totalSize += storageData.size;\n      this.stats.entryCount = this.cache.size;\n      \n      return data;\n    } catch (error) {\n      console.warn('Failed to load cache from localStorage:', error);\n      return null;\n    }\n  }\n}\n\n// Global cache instances\nconst templateCache = new IntelligentCache<SandpackFiles>({\n  maxSize: 50,\n  maxAge: 30 * 60 * 1000, // 30 minutes\n  compressionEnabled: true,\n  persistToStorage: true\n});\n\nconst formCodeCache = new IntelligentCache<string>({\n  maxSize: 100,\n  maxAge: 10 * 60 * 1000, // 10 minutes\n  compressionEnabled: true,\n  persistToStorage: false\n});\n\nconst metadataCache = new IntelligentCache<TemplateMetadata>({\n  maxSize: 200,\n  maxAge: 60 * 60 * 1000, // 1 hour\n  compressionEnabled: false,\n  persistToStorage: true\n});\n\n/**\n * Generate intelligent cache key based on form characteristics\n */\nexport function generateCacheKey(\n  formCode: string, \n  options: {\n    showCodeEditor?: boolean;\n    showConsole?: boolean;\n    showFileExplorer?: boolean;\n    templateComplexity?: string;\n    formConfig?: any;\n  } = {}\n): string {\n  // Create a signature based on content and options\n  const contentHash = hashString(formCode.substring(0, 200));\n  const optionsHash = hashString(JSON.stringify(options));\n  \n  return `${contentHash}-${optionsHash}`;\n}\n\n/**\n * Simple string hashing function\n */\nfunction hashString(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(36);\n}\n\n/**\n * Extract template metadata from form code\n */\nexport function extractTemplateMetadata(formCode: string): TemplateMetadata {\n  const features: string[] = [];\n  const dependencies: string[] = [];\n  \n  // Analyze code for features\n  if (formCode.includes('useState')) features.push('state-management');\n  if (formCode.includes('useEffect')) features.push('lifecycle');\n  if (formCode.includes('conditional')) features.push('conditional-logic');\n  if (formCode.includes('multi-page') || formCode.includes('step')) features.push('multi-page');\n  if (formCode.includes('validation')) features.push('validation');\n  \n  // Extract dependencies\n  const importMatches = formCode.match(/import\\s+.*from\\s+['\"]([^'\"]*)['\"]/g);\n  if (importMatches) {\n    dependencies.push(...importMatches.map(match => {\n      const depMatch = match.match(/from\\s+['\"]([^'\"]*)['\"]/);\n      return depMatch ? depMatch[1] : '';\n    }).filter(Boolean));\n  }\n  \n  // Count form fields (rough estimate)\n  const fieldCount = (formCode.match(/input|select|textarea/gi) || []).length;\n  \n  return {\n    complexity: fieldCount > 10 ? 'advanced' : fieldCount > 5 ? 'intermediate' : 'basic',\n    features,\n    dependencies,\n    formFieldCount: fieldCount,\n    hasConditionalLogic: features.includes('conditional-logic'),\n    hasMultiPage: features.includes('multi-page'),\n    codeLength: formCode.length\n  };\n}\n\n/**\n * Cached template retrieval\n */\nexport async function getCachedTemplate(cacheKey: string): Promise<SandpackFiles | null> {\n  // Try memory cache first\n  let cached = templateCache.get(cacheKey);\n  \n  // Try storage cache if not in memory\n  if (!cached) {\n    cached = templateCache.loadFromStorage(cacheKey);\n  }\n  \n  return cached;\n}\n\n/**\n * Cache template with metadata\n */\nexport async function setCachedTemplate(\n  cacheKey: string, \n  template: SandpackFiles, \n  formCode: string\n): Promise<void> {\n  const metadata = extractTemplateMetadata(formCode);\n  \n  await Promise.all([\n    templateCache.set(cacheKey, template, metadata),\n    metadataCache.set(cacheKey, metadata)\n  ]);\n}\n\n/**\n * Cached form code retrieval\n */\nexport function getCachedFormCode(cacheKey: string): string | null {\n  return formCodeCache.get(cacheKey);\n}\n\n/**\n * Cache form code\n */\nexport async function setCachedFormCode(cacheKey: string, formCode: string): Promise<void> {\n  await formCodeCache.set(cacheKey, formCode);\n}\n\n/**\n * Preload popular templates\n */\nexport async function preloadPopularTemplates(): Promise<void> {\n  const popularTemplates = [\n    { complexity: 'basic', features: [] },\n    { complexity: 'intermediate', features: ['validation'] },\n    { complexity: 'advanced', features: ['multi-page', 'conditional-logic'] }\n  ];\n  \n  // This would integrate with the template generation system\n  // Implementation depends on the actual template creation logic\n  console.log('Preloading popular templates:', popularTemplates);\n}\n\n/**\n * Clean up expired cache entries\n */\nexport function cleanupCache(): void {\n  const expired = templateCache.clearExpired() + \n                 formCodeCache.clearExpired() + \n                 metadataCache.clearExpired();\n  \n  console.log(`Cleaned up ${expired} expired cache entries`);\n}\n\n/**\n * Get comprehensive cache statistics\n */\nexport function getCacheStatistics() {\n  return {\n    templates: templateCache.getStats(),\n    formCode: formCodeCache.getStats(),\n    metadata: metadataCache.getStats(),\n    timestamp: new Date().toISOString()\n  };\n}\n\n/**\n * Clear all caches\n */\nexport function clearAllCaches(): void {\n  templateCache.clear();\n  formCodeCache.clear();\n  metadataCache.clear();\n}\n\n// Cleanup expired entries every 5 minutes\nif (typeof window !== 'undefined') {\n  setInterval(cleanupCache, 5 * 60 * 1000);\n}\n\n// Export cache instances for advanced usage\nexport { templateCache, formCodeCache, metadataCache };",
      "type": "registry:lib",
      "target": "lib/sandbox-cache.ts"
    },
    {
      "path": "src/lib/code-splitting-utils.ts",
      "content": "/**\n * Code Splitting Utilities for Large Form Components\n * \n * Implements intelligent code splitting strategies to improve loading performance\n * for complex Formedible forms with many fields and advanced features.\n */\n\nimport type { SandpackFiles } from \"@codesandbox/sandpack-react\";\n\n// Configuration for code splitting thresholds\ninterface CodeSplittingConfig {\n  maxComponentSize: number; // Maximum size in characters before splitting\n  maxFieldsPerChunk: number; // Maximum fields per component chunk\n  splitByFieldType: boolean; // Whether to split by field types\n  splitByPage: boolean; // Whether to split multi-page forms\n  enableLazyLoading: boolean; // Whether to enable lazy loading for chunks\n}\n\n// Default configuration\nconst DEFAULT_CONFIG: CodeSplittingConfig = {\n  maxComponentSize: 5000,\n  maxFieldsPerChunk: 10,\n  splitByFieldType: true,\n  splitByPage: true,\n  enableLazyLoading: true\n};\n\n// Field type categories for intelligent splitting\nconst FIELD_TYPE_CATEGORIES = {\n  basic: ['text', 'email', 'password', 'number', 'tel', 'url'],\n  selection: ['select', 'radio', 'checkbox', 'multiselect'],\n  advanced: ['date', 'datetime', 'time', 'file', 'color', 'range'],\n  rich: ['textarea', 'richtext', 'wysiwyg', 'markdown'],\n  custom: ['custom', 'composite', 'repeater', 'matrix']\n};\n\n// Form analysis result\ninterface FormAnalysis {\n  totalSize: number;\n  fieldCount: number;\n  pageCount: number;\n  fieldTypes: Record<string, number>;\n  hasConditionalLogic: boolean;\n  hasValidation: boolean;\n  hasCustomComponents: boolean;\n  complexityScore: number;\n  shouldSplit: boolean;\n  recommendedSplitStrategy: 'none' | 'fields' | 'pages' | 'types' | 'hybrid';\n}\n\n// Code chunk information\ninterface CodeChunk {\n  id: string;\n  name: string;\n  code: string;\n  dependencies: string[];\n  fields: any[];\n  size: number;\n  category: string;\n  lazyLoad: boolean;\n}\n\n// Split result\ninterface SplitResult {\n  chunks: CodeChunk[];\n  mainComponent: string;\n  imports: string[];\n  totalSize: number;\n  compressionRatio: number;\n}\n\n/**\n * Analyze form code to determine if splitting is beneficial\n */\nexport function analyzeFormCode(formCode: string, fields: any[] = []): FormAnalysis {\n  const size = formCode.length;\n  const fieldCount = fields.length || estimateFieldCount(formCode);\n  const pageCount = estimatePageCount(formCode);\n  \n  // Count field types\n  const fieldTypes: Record<string, number> = {};\n  fields.forEach(field => {\n    const type = field.type || 'text';\n    fieldTypes[type] = (fieldTypes[type] || 0) + 1;\n  });\n  \n  // Detect features\n  const hasConditionalLogic = /conditional|if\\s*\\(|when\\s*\\(|show.*when/i.test(formCode);\n  const hasValidation = /validation|validate|required|min|max|pattern/i.test(formCode);\n  const hasCustomComponents = /custom|composite|complex/i.test(formCode);\n  \n  // Calculate complexity score (0-100)\n  let complexityScore = 0;\n  complexityScore += Math.min(fieldCount * 2, 40); // Field count contribution (max 40)\n  complexityScore += Math.min(size / 100, 20); // Code size contribution (max 20)\n  complexityScore += pageCount * 10; // Multi-page contribution\n  complexityScore += hasConditionalLogic ? 15 : 0; // Conditional logic\n  complexityScore += hasValidation ? 10 : 0; // Validation\n  complexityScore += hasCustomComponents ? 15 : 0; // Custom components\n  \n  // Determine if splitting is beneficial\n  const shouldSplit = size > DEFAULT_CONFIG.maxComponentSize || \n                     fieldCount > DEFAULT_CONFIG.maxFieldsPerChunk ||\n                     complexityScore > 60;\n  \n  // Recommend split strategy\n  let recommendedSplitStrategy: FormAnalysis['recommendedSplitStrategy'] = 'none';\n  if (shouldSplit) {\n    if (pageCount > 1) {\n      recommendedSplitStrategy = 'pages';\n    } else if (fieldCount > DEFAULT_CONFIG.maxFieldsPerChunk * 2) {\n      recommendedSplitStrategy = 'fields';\n    } else if (Object.keys(fieldTypes).length > 3) {\n      recommendedSplitStrategy = 'types';\n    } else {\n      recommendedSplitStrategy = 'hybrid';\n    }\n  }\n  \n  return {\n    totalSize: size,\n    fieldCount,\n    pageCount,\n    fieldTypes,\n    hasConditionalLogic,\n    hasValidation,\n    hasCustomComponents,\n    complexityScore,\n    shouldSplit,\n    recommendedSplitStrategy\n  };\n}\n\n/**\n * Split form code into optimized chunks\n */\nexport function splitFormCode(\n  formCode: string, \n  fields: any[] = [], \n  config: Partial<CodeSplittingConfig> = {}\n): SplitResult {\n  const finalConfig = { ...DEFAULT_CONFIG, ...config };\n  const analysis = analyzeFormCode(formCode, fields);\n  \n  if (!analysis.shouldSplit) {\n    return {\n      chunks: [],\n      mainComponent: formCode,\n      imports: extractImports(formCode),\n      totalSize: formCode.length,\n      compressionRatio: 1.0\n    };\n  }\n  \n  const chunks: CodeChunk[] = [];\n  let mainComponentCode = '';\n  \n  switch (analysis.recommendedSplitStrategy) {\n    case 'pages':\n      return splitByPages(formCode, fields, finalConfig);\n    case 'fields':\n      return splitByFields(formCode, fields, finalConfig);\n    case 'types':\n      return splitByFieldTypes(formCode, fields, finalConfig);\n    case 'hybrid':\n      return splitHybrid(formCode, fields, finalConfig);\n    default:\n      return {\n        chunks: [],\n        mainComponent: formCode,\n        imports: extractImports(formCode),\n        totalSize: formCode.length,\n        compressionRatio: 1.0\n      };\n  }\n}\n\n/**\n * Split by form pages\n */\nfunction splitByPages(\n  formCode: string, \n  fields: any[], \n  config: CodeSplittingConfig\n): SplitResult {\n  const chunks: CodeChunk[] = [];\n  const pageGroups = groupFieldsByPage(fields);\n  \n  pageGroups.forEach((pageFields, pageIndex) => {\n    const chunkCode = generatePageComponent(pageFields, pageIndex);\n    \n    chunks.push({\n      id: `page-${pageIndex}`,\n      name: `FormPage${pageIndex + 1}`,\n      code: chunkCode,\n      dependencies: extractDependencies(chunkCode),\n      fields: pageFields,\n      size: chunkCode.length,\n      category: 'page',\n      lazyLoad: config.enableLazyLoading && pageIndex > 0\n    });\n  });\n  \n  const mainComponent = generateMainFormComponent(chunks, 'pages');\n  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0) + mainComponent.length;\n  \n  return {\n    chunks,\n    mainComponent,\n    imports: extractImports(formCode),\n    totalSize,\n    compressionRatio: formCode.length / totalSize\n  };\n}\n\n/**\n * Split by field groups\n */\nfunction splitByFields(\n  formCode: string, \n  fields: any[], \n  config: CodeSplittingConfig\n): SplitResult {\n  const chunks: CodeChunk[] = [];\n  const fieldGroups = chunkArray(fields, config.maxFieldsPerChunk);\n  \n  fieldGroups.forEach((fieldGroup, groupIndex) => {\n    const chunkCode = generateFieldGroupComponent(fieldGroup, groupIndex);\n    \n    chunks.push({\n      id: `fields-${groupIndex}`,\n      name: `FieldGroup${groupIndex + 1}`,\n      code: chunkCode,\n      dependencies: extractDependencies(chunkCode),\n      fields: fieldGroup,\n      size: chunkCode.length,\n      category: 'fields',\n      lazyLoad: config.enableLazyLoading && groupIndex > 0\n    });\n  });\n  \n  const mainComponent = generateMainFormComponent(chunks, 'fields');\n  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0) + mainComponent.length;\n  \n  return {\n    chunks,\n    mainComponent,\n    imports: extractImports(formCode),\n    totalSize,\n    compressionRatio: formCode.length / totalSize\n  };\n}\n\n/**\n * Split by field types\n */\nfunction splitByFieldTypes(\n  formCode: string, \n  fields: any[], \n  config: CodeSplittingConfig\n): SplitResult {\n  const chunks: CodeChunk[] = [];\n  const typeGroups = groupFieldsByType(fields);\n  \n  Object.entries(typeGroups).forEach(([category, categoryFields]) => {\n    if (categoryFields.length === 0) return;\n    \n    const chunkCode = generateTypeComponent(categoryFields, category);\n    \n    chunks.push({\n      id: `type-${category}`,\n      name: `${category.charAt(0).toUpperCase() + category.slice(1)}Fields`,\n      code: chunkCode,\n      dependencies: extractDependencies(chunkCode),\n      fields: categoryFields,\n      size: chunkCode.length,\n      category: 'type',\n      lazyLoad: config.enableLazyLoading && category !== 'basic'\n    });\n  });\n  \n  const mainComponent = generateMainFormComponent(chunks, 'types');\n  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0) + mainComponent.length;\n  \n  return {\n    chunks,\n    mainComponent,\n    imports: extractImports(formCode),\n    totalSize,\n    compressionRatio: formCode.length / totalSize\n  };\n}\n\n/**\n * Hybrid splitting strategy\n */\nfunction splitHybrid(\n  formCode: string, \n  fields: any[], \n  config: CodeSplittingConfig\n): SplitResult {\n  const chunks: CodeChunk[] = [];\n  \n  // First split by pages if multi-page\n  const pageGroups = groupFieldsByPage(fields);\n  \n  pageGroups.forEach((pageFields, pageIndex) => {\n    // Then split large pages by field types\n    if (pageFields.length > config.maxFieldsPerChunk) {\n      const typeGroups = groupFieldsByType(pageFields);\n      \n      Object.entries(typeGroups).forEach(([category, categoryFields]) => {\n        if (categoryFields.length === 0) return;\n        \n        const chunkCode = generateHybridComponent(categoryFields, pageIndex, category);\n        \n        chunks.push({\n          id: `page${pageIndex}-${category}`,\n          name: `Page${pageIndex + 1}${category.charAt(0).toUpperCase() + category.slice(1)}`,\n          code: chunkCode,\n          dependencies: extractDependencies(chunkCode),\n          fields: categoryFields,\n          size: chunkCode.length,\n          category: 'hybrid',\n          lazyLoad: config.enableLazyLoading && (pageIndex > 0 || category !== 'basic')\n        });\n      });\n    } else {\n      // Keep small pages as single chunks\n      const chunkCode = generatePageComponent(pageFields, pageIndex);\n      \n      chunks.push({\n        id: `page-${pageIndex}`,\n        name: `FormPage${pageIndex + 1}`,\n        code: chunkCode,\n        dependencies: extractDependencies(chunkCode),\n        fields: pageFields,\n        size: chunkCode.length,\n        category: 'page',\n        lazyLoad: config.enableLazyLoading && pageIndex > 0\n      });\n    }\n  });\n  \n  const mainComponent = generateMainFormComponent(chunks, 'hybrid');\n  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0) + mainComponent.length;\n  \n  return {\n    chunks,\n    mainComponent,\n    imports: extractImports(formCode),\n    totalSize,\n    compressionRatio: formCode.length / totalSize\n  };\n}\n\n/**\n * Convert split result to Sandpack files\n */\nexport function splitResultToSandpackFiles(splitResult: SplitResult): SandpackFiles {\n  const files: SandpackFiles = {};\n  \n  // Main component\n  files['/FormComponent.tsx'] = {\n    code: splitResult.mainComponent\n  };\n  \n  // Chunk files\n  splitResult.chunks.forEach(chunk => {\n    const filename = chunk.lazyLoad ? \n      `/components/lazy/${chunk.name}.tsx` : \n      `/components/${chunk.name}.tsx`;\n      \n    files[filename] = {\n      code: chunk.code\n    };\n  });\n  \n  // Create index file for chunks\n  const chunkExports = splitResult.chunks\n    .map(chunk => `export { default as ${chunk.name} } from './${chunk.lazyLoad ? 'lazy/' : ''}${chunk.name}';`)\n    .join('\\n');\n    \n  files['/components/index.ts'] = {\n    code: chunkExports\n  };\n  \n  return files;\n}\n\n// Helper functions\n\nfunction estimateFieldCount(code: string): number {\n  const fieldMatches = code.match(/input|select|textarea|field/gi);\n  return fieldMatches ? fieldMatches.length : 0;\n}\n\nfunction estimatePageCount(code: string): number {\n  const pageMatches = code.match(/page|step|section/gi);\n  return Math.max(pageMatches ? pageMatches.length : 1, 1);\n}\n\nfunction extractImports(code: string): string[] {\n  const importMatches = code.match(/import\\s+.*?from\\s+['\"].*?['\"];?/g);\n  return importMatches || [];\n}\n\nfunction extractDependencies(code: string): string[] {\n  const deps = extractImports(code).map(imp => {\n    const match = imp.match(/from\\s+['\"]([^'\"]*)['\"]/);\n    return match ? match[1] : '';\n  }).filter(Boolean);\n  \n  return [...new Set(deps)];\n}\n\nfunction groupFieldsByPage(fields: any[]): any[][] {\n  // Simple implementation - group by page property or assume single page\n  const pages: any[][] = [[]];\n  \n  fields.forEach(field => {\n    const pageIndex = field.page || 0;\n    if (!pages[pageIndex]) pages[pageIndex] = [];\n    pages[pageIndex].push(field);\n  });\n  \n  return pages.filter(page => page.length > 0);\n}\n\nfunction groupFieldsByType(fields: any[]): Record<string, any[]> {\n  const groups: Record<string, any[]> = {\n    basic: [],\n    selection: [],\n    advanced: [],\n    rich: [],\n    custom: []\n  };\n  \n  fields.forEach(field => {\n    const type = field.type || 'text';\n    let category = 'custom';\n    \n    for (const [cat, types] of Object.entries(FIELD_TYPE_CATEGORIES)) {\n      if (types.includes(type)) {\n        category = cat;\n        break;\n      }\n    }\n    \n    groups[category].push(field);\n  });\n  \n  return groups;\n}\n\nfunction chunkArray<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\nfunction generatePageComponent(fields: any[], pageIndex: number): string {\n  return `import React from 'react';\n\nexport default function FormPage${pageIndex + 1}({ formData, onUpdate }: {\n  formData: Record<string, any>;\n  onUpdate: (data: Record<string, any>) => void;\n}) {\n  return (\n    <div className=\"form-page\" data-page=\"${pageIndex}\">\n      <h3 className=\"text-lg font-semibold mb-4\">Step ${pageIndex + 1}</h3>\n      {/* Fields for page ${pageIndex + 1} */}\n      {/* Generated fields would go here */}\n    </div>\n  );\n}`;\n}\n\nfunction generateFieldGroupComponent(fields: any[], groupIndex: number): string {\n  return `import React from 'react';\n\nexport default function FieldGroup${groupIndex + 1}({ formData, onUpdate }: {\n  formData: Record<string, any>;\n  onUpdate: (data: Record<string, any>) => void;\n}) {\n  return (\n    <div className=\"field-group\" data-group=\"${groupIndex}\">\n      {/* Field group ${groupIndex + 1} with ${fields.length} fields */}\n      {/* Generated fields would go here */}\n    </div>\n  );\n}`;\n}\n\nfunction generateTypeComponent(fields: any[], category: string): string {\n  return `import React from 'react';\n\nexport default function ${category.charAt(0).toUpperCase() + category.slice(1)}Fields({ formData, onUpdate }: {\n  formData: Record<string, any>;\n  onUpdate: (data: Record<string, any>) => void;\n}) {\n  return (\n    <div className=\"field-type-group\" data-type=\"${category}\">\n      {/* ${category} fields component with ${fields.length} fields */}\n      {/* Generated fields would go here */}\n    </div>\n  );\n}`;\n}\n\nfunction generateHybridComponent(fields: any[], pageIndex: number, category: string): string {\n  return `import React from 'react';\n\nexport default function Page${pageIndex + 1}${category.charAt(0).toUpperCase() + category.slice(1)}({ formData, onUpdate }: {\n  formData: Record<string, any>;\n  onUpdate: (data: Record<string, any>) => void;\n}) {\n  return (\n    <div className=\"hybrid-component\" data-page=\"${pageIndex}\" data-type=\"${category}\">\n      {/* Page ${pageIndex + 1} ${category} fields with ${fields.length} fields */}\n      {/* Generated fields would go here */}\n    </div>\n  );\n}`;\n}\n\nfunction generateMainFormComponent(chunks: CodeChunk[], strategy: string): string {\n  const imports = chunks\n    .map(chunk => `import ${chunk.lazyLoad ? '{ lazy }' : chunk.name} from './components/${chunk.lazyLoad ? 'lazy/' : ''}${chunk.name}';`)\n    .join('\\n');\n  \n  const lazyImports = chunks\n    .filter(chunk => chunk.lazyLoad)\n    .map(chunk => `const ${chunk.name} = lazy(() => import('./components/lazy/${chunk.name}'));`)\n    .join('\\n');\n    \n  return `import React, { useState, Suspense } from 'react';\n${imports}\n${lazyImports}\n\nexport default function FormComponent({ onSubmit }: {\n  onSubmit?: (data: Record<string, any>) => void;\n}) {\n  const [formData, setFormData] = useState({});\n  \n  const handleUpdate = (newData: Record<string, any>) => {\n    setFormData(prev => ({ ...prev, ...newData }));\n  };\n  \n  const handleSubmit = () => {\n    onSubmit?.(formData);\n  };\n  \n  return (\n    <div className=\"form-container split-strategy-${strategy}\">\n      <Suspense fallback={<div className=\"loading\">Loading form sections...</div>}>\n        {/* Rendered chunks would go here */}\n        {/* This is a simplified version - actual implementation would render chunks based on strategy */}\n      </Suspense>\n      \n      <button \n        type=\"button\" \n        onClick={handleSubmit}\n        className=\"submit-button mt-6\"\n      >\n        Submit Form\n      </button>\n    </div>\n  );\n}`;\n}\n\nexport { DEFAULT_CONFIG as CODE_SPLITTING_CONFIG };",
      "type": "registry:lib",
      "target": "lib/code-splitting-utils.ts"
    },
    {
      "path": "src/lib/sandbox-templates.json",
      "content": "{\n  \"/vite.config.ts\": \"import path from \\\"path\\\";\\nimport tailwindcss from \\\"@tailwindcss/vite\\\";\\nimport { defineConfig } from \\\"vite\\\";\\nimport react from \\\"@vitejs/plugin-react\\\";\\n\\n// https://vite.dev/config/\\nexport default defineConfig({\\n  plugins: [react(), tailwindcss()],\\n  resolve: {\\n    alias: {\\n      \\\"@\\\": path.resolve(__dirname, \\\"./src\\\"),\\n    },\\n  },\\n});\\n\",\n  \"/tsconfig.json\": \"{\\n  \\\"files\\\": [],\\n  \\\"references\\\": [\\n    { \\\"path\\\": \\\"./tsconfig.app.json\\\" },\\n    { \\\"path\\\": \\\"./tsconfig.node.json\\\" }\\n  ],\\n  \\\"compilerOptions\\\": {\\n    \\\"baseUrl\\\": \\\".\\\",\\n    \\\"paths\\\": {\\n      \\\"@/*\\\": [\\\"./src/*\\\"]\\n    }\\n  }\\n}\\n\",\n  \"/tsconfig.app.json\": \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"tsBuildInfoFile\\\": \\\"./node_modules/.tmp/tsconfig.app.tsbuildinfo\\\",\\n    \\\"target\\\": \\\"ES2022\\\",\\n    \\\"useDefineForClassFields\\\": true,\\n    \\\"lib\\\": [\\\"ES2022\\\", \\\"DOM\\\", \\\"DOM.Iterable\\\"],\\n    \\\"module\\\": \\\"ESNext\\\",\\n    \\\"skipLibCheck\\\": true,\\n\\n    /* Bundler mode */\\n    \\\"moduleResolution\\\": \\\"bundler\\\",\\n    \\\"allowImportingTsExtensions\\\": true,\\n    \\\"verbatimModuleSyntax\\\": true,\\n    \\\"moduleDetection\\\": \\\"force\\\",\\n    \\\"noEmit\\\": true,\\n    \\\"jsx\\\": \\\"react-jsx\\\",\\n\\n    /* Linting */\\n    \\\"strict\\\": true,\\n    \\\"noUnusedLocals\\\": true,\\n    \\\"noUnusedParameters\\\": true,\\n    \\\"erasableSyntaxOnly\\\": true,\\n    \\\"noFallthroughCasesInSwitch\\\": true,\\n    \\\"noUncheckedSideEffectImports\\\": true,\\n    \\\"baseUrl\\\": \\\".\\\",\\n    \\\"paths\\\": {\\n      \\\"@/*\\\": [\\\"./src/*\\\"]\\n    }\\n  },\\n  \\\"include\\\": [\\\"src\\\"]\\n}\\n\",\n  \"/tsconfig.node.json\": \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"tsBuildInfoFile\\\": \\\"./node_modules/.tmp/tsconfig.node.tsbuildinfo\\\",\\n    \\\"target\\\": \\\"ES2023\\\",\\n    \\\"lib\\\": [\\\"ES2023\\\"],\\n    \\\"module\\\": \\\"ESNext\\\",\\n    \\\"skipLibCheck\\\": true,\\n\\n    /* Bundler mode */\\n    \\\"moduleResolution\\\": \\\"bundler\\\",\\n    \\\"allowImportingTsExtensions\\\": true,\\n    \\\"verbatimModuleSyntax\\\": true,\\n    \\\"moduleDetection\\\": \\\"force\\\",\\n    \\\"noEmit\\\": true,\\n\\n    /* Linting */\\n    \\\"strict\\\": true,\\n    \\\"noUnusedLocals\\\": true,\\n    \\\"noUnusedParameters\\\": true,\\n    \\\"erasableSyntaxOnly\\\": true,\\n    \\\"noFallthroughCasesInSwitch\\\": true,\\n    \\\"noUncheckedSideEffectImports\\\": true\\n  },\\n  \\\"include\\\": [\\\"vite.config.ts\\\"]\\n}\\n\",\n  \"/index.html\": \"<!doctype html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"UTF-8\\\" />\\n    <link rel=\\\"icon\\\" type=\\\"image/svg+xml\\\" href=\\\"/vite.svg\\\" />\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\n    <title>Vite + React + TS</title>\\n  </head>\\n  <body>\\n    <div id=\\\"root\\\"></div>\\n    <script type=\\\"module\\\" src=\\\"/src/main.tsx\\\"></script>\\n  </body>\\n</html>\\n\",\n  \"/src/main.tsx\": \"import { StrictMode } from 'react'\\nimport { createRoot } from 'react-dom/client'\\nimport './index.css'\\nimport App from './App.tsx'\\n\\ncreateRoot(document.getElementById('root')!).render(\\n  <StrictMode>\\n    <App />\\n  </StrictMode>,\\n)\\n\",\n  \"/src/vite-env.d.ts\": \"/// <reference types=\\\"vite/client\\\" />\\n\",\n  \"/src/components/formedible/fields/array-field.tsx\": \"\\\"use client\\\";\\nimport React, { useCallback, useMemo, useState } from \\\"react\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { Plus, Trash2, GripVertical } from \\\"lucide-react\\\";\\nimport type { ArrayFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\nimport { NestedFieldRenderer } from \\\"./shared-field-renderer\\\";\\n\\nexport const ArrayField: React.FC<ArrayFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  arrayConfig,\\n}) => {\\n  const name = fieldApi.name;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n\\n  const value = useMemo(\\n    () => (fieldApi.state?.value as unknown[]) || [],\\n    [fieldApi.state?.value]\\n  );\\n\\n  const {\\n    itemType,\\n    itemLabel,\\n    itemPlaceholder,\\n    minItems = 0,\\n    maxItems = 10,\\n    addButtonLabel = \\\"Add Item\\\",\\n    removeButtonLabel = \\\"Remove\\\",\\n    itemComponent: CustomItemComponent,\\n    sortable = false,\\n    defaultValue = \\\"\\\",\\n    itemProps = {},\\n    objectConfig,\\n  } = arrayConfig || {};\\n\\n  // Create field config for each item\\n  const createItemFieldConfig = useCallback(\\n    (index: number) => {\\n      const baseConfig: any = {\\n        name: `${name}[${index}]`,\\n        type: itemType || \\\"text\\\",\\n        label: itemLabel ? `${itemLabel} ${index + 1}` : undefined,\\n        placeholder: itemPlaceholder,\\n        component: CustomItemComponent,\\n        ...itemProps,\\n      };\\n\\n      // Add object config if item type is object\\n      if (itemType === \\\"object\\\" && objectConfig) {\\n        baseConfig.objectConfig = objectConfig;\\n      }\\n\\n      return baseConfig;\\n    },\\n    [\\n      name,\\n      itemType,\\n      itemLabel,\\n      itemPlaceholder,\\n      CustomItemComponent,\\n      itemProps,\\n      objectConfig,\\n    ]\\n  );\\n\\n  const addItem = useCallback(() => {\\n    if (value.length >= maxItems) return;\\n\\n    const newValue = [...value, defaultValue];\\n    fieldApi.handleChange(newValue);\\n  }, [value, maxItems, defaultValue, fieldApi]);\\n\\n  const removeItem = useCallback(\\n    (index: number) => {\\n      if (value.length <= minItems) return;\\n\\n      const newValue = value.filter((_, i) => i !== index);\\n      fieldApi.handleChange(newValue);\\n      fieldApi.handleBlur();\\n    },\\n    [value, minItems, fieldApi]\\n  );\\n\\n  const updateItem = useCallback(\\n    (index: number, newItemValue: unknown) => {\\n      const newValue = [...value];\\n      newValue[index] = newItemValue;\\n      fieldApi.handleChange(newValue);\\n    },\\n    [value, fieldApi]\\n  );\\n\\n  const moveItem = useCallback(\\n    (fromIndex: number, toIndex: number) => {\\n      if (!sortable) return;\\n      if (fromIndex === toIndex) return;\\n\\n      const newValue = [...value];\\n      const [movedItem] = newValue.splice(fromIndex, 1);\\n      newValue.splice(toIndex, 0, movedItem);\\n      fieldApi.handleChange(newValue);\\n    },\\n    [value, fieldApi, sortable]\\n  );\\n\\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\\n\\n  // Create a mock field API for each item\\n  const createItemFieldApi = useCallback(\\n    (index: number) => {\\n      return {\\n        name: `${name}[${index}]`,\\n        state: {\\n          value: value[index],\\n          meta: {\\n            errors: [],\\n            isTouched: false,\\n            isValidating: false,\\n          },\\n        },\\n        handleChange: (newValue: unknown) => updateItem(index, newValue),\\n        handleBlur: () => fieldApi.handleBlur(),\\n        form: fieldApi.form,\\n      };\\n    },\\n    [name, value, updateItem, fieldApi]\\n  );\\n\\n  const canAddMore = value.length < maxItems;\\n  const canRemove = value.length > minItems;\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-4\\\">\\n        <div className=\\\"space-y-3\\\">\\n          {value.map((_, index) => (\\n            <div\\n              key={index}\\n              className=\\\"flex items-start gap-2 p-3 border rounded-lg bg-card\\\"\\n              onDragOver={\\n                sortable\\n                  ? (e) => {\\n                      e.preventDefault();\\n                      e.dataTransfer.dropEffect = \\\"move\\\";\\n                    }\\n                  : undefined\\n              }\\n              onDrop={\\n                sortable\\n                  ? (e) => {\\n                      e.preventDefault();\\n                      if (draggedIndex !== null && draggedIndex !== index) {\\n                        moveItem(draggedIndex, index);\\n                      }\\n                    }\\n                  : undefined\\n              }\\n            >\\n              {sortable && (\\n                <button\\n                  type=\\\"button\\\"\\n                  className=\\\"mt-2 p-1 hover:bg-muted rounded cursor-grab active:cursor-grabbing\\\"\\n                  draggable\\n                  onDragStart={(e) => {\\n                    setDraggedIndex(index);\\n                    e.dataTransfer.effectAllowed = \\\"move\\\";\\n                  }}\\n                  onDragEnd={() => {\\n                    setDraggedIndex(null);\\n                  }}\\n                  disabled={isDisabled}\\n                >\\n                  <GripVertical className=\\\"h-4 w-4 text-muted-foreground\\\" />\\n                </button>\\n              )}\\n\\n              <div className=\\\"flex-1\\\">\\n                <NestedFieldRenderer\\n                  fieldConfig={createItemFieldConfig(index)}\\n                  fieldApi={createItemFieldApi(index) as any}\\n                  form={fieldApi.form}\\n                  currentValues={\\n                    (value[index] || {}) as Record<string, unknown>\\n                  }\\n                />\\n              </div>\\n\\n              {canRemove && (\\n                <Button\\n                  type=\\\"button\\\"\\n                  variant=\\\"outline\\\"\\n                  size=\\\"sm\\\"\\n                  onClick={() => removeItem(index)}\\n                  className=\\\"mt-2 h-8 w-8 p-0 text-destructive hover:text-destructive\\\"\\n                  title={removeButtonLabel}\\n                  disabled={isDisabled}\\n                >\\n                  <Trash2 className=\\\"h-4 w-4\\\" />\\n                </Button>\\n              )}\\n            </div>\\n          ))}\\n\\n          {value.length === 0 && (\\n            <div className=\\\"text-center py-8 text-muted-foreground border-2 border-dashed rounded-lg\\\">\\n              <p className=\\\"text-sm\\\">No items added yet</p>\\n              <p className=\\\"text-xs mt-1\\\">\\n                Click &quot;{addButtonLabel}&quot; to add your first item\\n              </p>\\n            </div>\\n          )}\\n        </div>\\n\\n        {canAddMore && (\\n          <Button\\n            type=\\\"button\\\"\\n            variant=\\\"outline\\\"\\n            onClick={addItem}\\n            className=\\\"w-full\\\"\\n            disabled={isDisabled}\\n          >\\n            <Plus className=\\\"h-4 w-4 mr-2\\\" />\\n            {addButtonLabel}\\n          </Button>\\n        )}\\n\\n        {minItems > 0 && value.length < minItems && (\\n          <p className=\\\"text-xs text-muted-foreground\\\">\\n            Minimum {minItems} item{minItems !== 1 ? \\\"s\\\" : \\\"\\\"} required\\n          </p>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/autocomplete-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect, useRef } from \\\"react\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { Card } from \\\"@/components/ui/card\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\ninterface AutocompleteOption {\\n  value: string;\\n  label: string;\\n}\\n\\ninterface AutocompleteFieldProps extends BaseFieldProps {\\n  autocompleteConfig?: {\\n    options?: string[] | AutocompleteOption[];\\n    asyncOptions?: (query: string) => Promise<string[] | AutocompleteOption[]>;\\n    debounceMs?: number;\\n    minChars?: number;\\n    maxResults?: number;\\n    allowCustom?: boolean;\\n    placeholder?: string;\\n    noOptionsText?: string;\\n    loadingText?: string;\\n  };\\n}\\n\\nexport const AutocompleteField: React.FC<AutocompleteFieldProps> = ({\\n  fieldApi,\\n  placeholder,\\n  inputClassName,\\n  autocompleteConfig = {},\\n  ...wrapperProps\\n}) => {\\n  const {\\n    options = [],\\n    asyncOptions,\\n    debounceMs = 300,\\n    minChars = 1,\\n    maxResults = 10,\\n    allowCustom = true,\\n    noOptionsText = \\\"No options found\\\",\\n    loadingText = \\\"Loading...\\\",\\n  } = autocompleteConfig;\\n\\n  const [inputValue, setInputValue] = useState(fieldApi.state?.value || \\\"\\\");\\n  const [filteredOptions, setFilteredOptions] = useState<AutocompleteOption[]>(\\n    []\\n  );\\n  const [isOpen, setIsOpen] = useState(false);\\n  const [isLoading, setIsLoading] = useState(false);\\n  const [highlightedIndex, setHighlightedIndex] = useState(-1);\\n\\n  const inputRef = useRef<HTMLInputElement>(null);\\n  const listRef = useRef<HTMLDivElement>(null);\\n  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);\\n\\n  // Normalize options to consistent format\\n  const normalizeOptions = (\\n    opts: string[] | AutocompleteOption[]\\n  ): AutocompleteOption[] => {\\n    return opts.map((opt) =>\\n      typeof opt === \\\"string\\\" ? { value: opt, label: opt } : opt\\n    );\\n  };\\n\\n  // Filter static options\\n  const filterStaticOptions = React.useCallback(\\n    (query: string): AutocompleteOption[] => {\\n      if (!query || query.length < minChars) return [];\\n\\n      const normalizedOptions = normalizeOptions(options);\\n      return normalizedOptions\\n        .filter(\\n          (option) =>\\n            option.label.toLowerCase().includes(query.toLowerCase()) ||\\n            option.value.toLowerCase().includes(query.toLowerCase())\\n        )\\n        .slice(0, maxResults);\\n    },\\n    [minChars, options, maxResults]\\n  );\\n\\n  // Handle async options\\n  const fetchAsyncOptions = React.useCallback(\\n    async (query: string) => {\\n      if (!asyncOptions || query.length < minChars) return;\\n\\n      setIsLoading(true);\\n      try {\\n        const results = await asyncOptions(query);\\n        const normalizedResults = normalizeOptions(results);\\n        setFilteredOptions(normalizedResults.slice(0, maxResults));\\n      } catch (error) {\\n        console.error(\\\"Autocomplete async options error:\\\", error);\\n        setFilteredOptions([]);\\n      } finally {\\n        setIsLoading(false);\\n      }\\n    },\\n    [asyncOptions, minChars, maxResults]\\n  );\\n\\n  // Debounced search\\n  useEffect(() => {\\n    if (debounceRef.current) {\\n      clearTimeout(debounceRef.current);\\n    }\\n\\n    debounceRef.current = setTimeout(() => {\\n      if (asyncOptions) {\\n        fetchAsyncOptions(inputValue);\\n      } else {\\n        setFilteredOptions(filterStaticOptions(inputValue));\\n      }\\n    }, debounceMs);\\n\\n    return () => {\\n      if (debounceRef.current) {\\n        clearTimeout(debounceRef.current);\\n      }\\n    };\\n  }, [\\n    inputValue,\\n    asyncOptions,\\n    debounceMs,\\n    fetchAsyncOptions,\\n    filterStaticOptions,\\n  ]);\\n\\n  // Handle input change\\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const value = e.target.value;\\n    setInputValue(value);\\n    setIsOpen(true);\\n    setHighlightedIndex(-1);\\n\\n    if (allowCustom) {\\n      fieldApi.handleChange(value);\\n    }\\n  };\\n\\n  // Handle option selection\\n  const handleOptionSelect = (option: AutocompleteOption) => {\\n    setInputValue(option.label);\\n    fieldApi.handleChange(option.value);\\n    setIsOpen(false);\\n    setHighlightedIndex(-1);\\n    inputRef.current?.blur();\\n  };\\n\\n  // Handle keyboard navigation\\n  const handleKeyDown = (e: React.KeyboardEvent) => {\\n    if (!isOpen) {\\n      if (e.key === \\\"ArrowDown\\\" || e.key === \\\"Enter\\\") {\\n        setIsOpen(true);\\n        return;\\n      }\\n      return;\\n    }\\n\\n    switch (e.key) {\\n      case \\\"ArrowDown\\\":\\n        e.preventDefault();\\n        setHighlightedIndex((prev) =>\\n          prev < filteredOptions.length - 1 ? prev + 1 : prev\\n        );\\n        break;\\n      case \\\"ArrowUp\\\":\\n        e.preventDefault();\\n        setHighlightedIndex((prev) => (prev > 0 ? prev - 1 : -1));\\n        break;\\n      case \\\"Enter\\\":\\n        e.preventDefault();\\n        if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {\\n          handleOptionSelect(filteredOptions[highlightedIndex]);\\n        } else if (allowCustom && inputValue) {\\n          fieldApi.handleChange(inputValue);\\n          setIsOpen(false);\\n        }\\n        break;\\n      case \\\"Escape\\\":\\n        setIsOpen(false);\\n        setHighlightedIndex(-1);\\n        inputRef.current?.blur();\\n        break;\\n    }\\n  };\\n\\n  // Handle focus/blur\\n  const handleFocus = () => {\\n    if (inputValue.length >= minChars) {\\n      setIsOpen(true);\\n    }\\n  };\\n\\n  const handleInputBlur = () => {\\n    // Delay closing to allow option clicks\\n    setTimeout(() => {\\n      if (!listRef.current?.contains(document.activeElement)) {\\n        setIsOpen(false);\\n        setHighlightedIndex(-1);\\n      }\\n    }, 150);\\n  };\\n\\n  // Scroll highlighted option into view\\n  useEffect(() => {\\n    if (highlightedIndex >= 0 && listRef.current) {\\n      const highlightedElement = listRef.current.children[\\n        highlightedIndex\\n      ] as HTMLElement;\\n      if (highlightedElement) {\\n        highlightedElement.scrollIntoView({\\n          block: \\\"nearest\\\",\\n          behavior: \\\"smooth\\\",\\n        });\\n      }\\n    }\\n  }, [highlightedIndex]);\\n\\n  const showDropdown =\\n    isOpen &&\\n    (filteredOptions.length > 0 ||\\n      isLoading ||\\n      (inputValue.length >= minChars && !isLoading));\\n\\n  const isDisabled = fieldApi.form.state.isSubmitting;\\n\\n  return (\\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\\n      <div className=\\\"relative\\\">\\n        <Input\\n          ref={inputRef}\\n          id={fieldApi.name}\\n          name={fieldApi.name}\\n          value={inputValue}\\n          onChange={handleInputChange}\\n          onKeyDown={handleKeyDown}\\n          onFocus={handleFocus}\\n          onBlur={() => {\\n            handleInputBlur();\\n            fieldApi.handleBlur();\\n          }}\\n          placeholder={\\n            placeholder || autocompleteConfig.placeholder || \\\"Type to search...\\\"\\n          }\\n          className={cn(inputClassName, isOpen && \\\"rounded-b-none\\\")}\\n          autoComplete=\\\"off\\\"\\n          disabled={isDisabled}\\n        />\\n\\n        {showDropdown && (\\n          <Card className=\\\"absolute top-full left-0 right-0 z-50 max-h-60 overflow-y-auto border-t-0 rounded-t-none\\\">\\n            <div ref={listRef} className=\\\"p-1\\\">\\n              {isLoading && (\\n                <div className=\\\"px-3 py-2 text-sm text-muted-foreground\\\">\\n                  {loadingText}\\n                </div>\\n              )}\\n\\n              {!isLoading &&\\n                filteredOptions.length === 0 &&\\n                inputValue.length >= minChars && (\\n                  <div className=\\\"px-3 py-2 text-sm text-muted-foreground\\\">\\n                    {noOptionsText}\\n                    {allowCustom && (\\n                      <Button\\n                        type=\\\"button\\\"\\n                        variant=\\\"ghost\\\"\\n                        size=\\\"sm\\\"\\n                        className=\\\"ml-2 h-auto p-1 text-xs\\\"\\n                        onClick={() => {\\n                          fieldApi.handleChange(inputValue);\\n                          setIsOpen(false);\\n                        }}\\n                        disabled={isDisabled}\\n                      >\\n                        Use \\\"{inputValue}\\\"\\n                      </Button>\\n                    )}\\n                  </div>\\n                )}\\n\\n              {!isLoading &&\\n                filteredOptions.map((option, index) => (\\n                  <button\\n                    key={`${option.value}-${index}`}\\n                    type=\\\"button\\\"\\n                    className={cn(\\n                      \\\"w-full text-left px-3 py-2 text-sm rounded-sm transition-colors\\\",\\n                      \\\"hover:bg-muted focus:bg-muted focus:outline-none\\\",\\n                      highlightedIndex === index && \\\"bg-muted\\\"\\n                    )}\\n                    onClick={() => handleOptionSelect(option)}\\n                    onMouseEnter={() => setHighlightedIndex(index)}\\n                    disabled={isDisabled}\\n                  >\\n                    <div className=\\\"font-medium\\\">{option.label}</div>\\n                    {option.value !== option.label && (\\n                      <div className=\\\"text-xs text-muted-foreground\\\">\\n                        {option.value}\\n                      </div>\\n                    )}\\n                  </button>\\n                ))}\\n            </div>\\n          </Card>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/base-field-wrapper.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { FieldWrapperProps } from \\\"@/lib/formedible/types\\\";\\nexport type { FieldWrapperProps } from \\\"@/lib/formedible/types\\\";\\n\\n// Simplified wrapper that doesn't interfere with TanStack Form's state management\\nexport const FieldWrapper: React.FC<FieldWrapperProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  labelClassName,\\n  wrapperClassName,\\n  children,\\n  htmlFor,\\n  showErrors = true,\\n}) => {\\n  const name = fieldApi.name;\\n  const hasErrors =\\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  return (\\n    <div className={cn(\\\"space-y-1.5\\\", wrapperClassName)}>\\n      {label && (\\n        <Label\\n          htmlFor={htmlFor || name}\\n          className={cn(\\\"text-sm font-medium\\\", labelClassName)}\\n        >\\n          {label}\\n        </Label>\\n      )}\\n      {description && (\\n        <p className=\\\"text-xs text-muted-foreground\\\">{description}</p>\\n      )}\\n\\n      {children}\\n\\n      {showErrors && hasErrors && (\\n        <div className=\\\"text-xs text-destructive pt-1\\\">\\n          {fieldApi.state?.meta?.errors?.map(\\n            (err: string | Error, index: number) => (\\n              <p key={index}>\\n                {typeof err === \\\"string\\\"\\n                  ? err\\n                  : (err as Error)?.message || \\\"Invalid\\\"}\\n              </p>\\n            )\\n          )}\\n        </div>\\n      )}\\n    </div>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/checkbox-field.tsx\": \"import React from \\\"react\\\";\\nimport { Checkbox } from \\\"@/components/ui/checkbox\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nexport const CheckboxField: React.FC<BaseFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n}) => {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state?.value as boolean | undefined;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n\\n  const onCheckedChange = (checked: boolean) => {\\n    fieldApi.handleChange(checked);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  return (\\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\\n    // because Checkbox components need the label positioned next to (not above) the control\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={undefined}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"flex items-center space-x-2\\\">\\n        <Checkbox\\n          id={name}\\n          checked={!!value}\\n          onCheckedChange={onCheckedChange}\\n          onBlur={onBlur}\\n          disabled={isDisabled}\\n          aria-describedby={description ? `${name}-description` : undefined}\\n        />\\n        {label && (\\n          <Label\\n            htmlFor={name}\\n            className={cn(\\n              \\\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\\\",\\n              labelClassName\\n            )}\\n          >\\n            {label}\\n          </Label>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/color-picker-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useRef, useEffect } from \\\"react\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { Palette, Check } from \\\"lucide-react\\\";\\nimport type { ColorPickerFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nconst DEFAULT_PRESETS = [\\n  \\\"#FF0000\\\",\\n  \\\"#FF8000\\\",\\n  \\\"#FFFF00\\\",\\n  \\\"#80FF00\\\",\\n  \\\"#00FF00\\\",\\n  \\\"#00FF80\\\",\\n  \\\"#00FFFF\\\",\\n  \\\"#0080FF\\\",\\n  \\\"#0000FF\\\",\\n  \\\"#8000FF\\\",\\n  \\\"#FF00FF\\\",\\n  \\\"#FF0080\\\",\\n  \\\"#000000\\\",\\n  \\\"#404040\\\",\\n  \\\"#808080\\\",\\n  \\\"#C0C0C0\\\",\\n  \\\"#FFFFFF\\\",\\n  \\\"#8B4513\\\",\\n];\\n\\n// Color conversion utilities\\nconst hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\\n  const result = /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(hex);\\n  return result\\n    ? {\\n        r: parseInt(result[1], 16),\\n        g: parseInt(result[2], 16),\\n        b: parseInt(result[3], 16),\\n      }\\n    : null;\\n};\\n\\nconst hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {\\n  const rgb = hexToRgb(hex);\\n  if (!rgb) return null;\\n\\n  const { r, g, b } = rgb;\\n  const rNorm = r / 255;\\n  const gNorm = g / 255;\\n  const bNorm = b / 255;\\n\\n  const max = Math.max(rNorm, gNorm, bNorm);\\n  const min = Math.min(rNorm, gNorm, bNorm);\\n  const diff = max - min;\\n\\n  let h = 0;\\n  let s = 0;\\n  const l = (max + min) / 2;\\n\\n  if (diff !== 0) {\\n    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);\\n\\n    switch (max) {\\n      case rNorm:\\n        h = (gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0);\\n        break;\\n      case gNorm:\\n        h = (bNorm - rNorm) / diff + 2;\\n        break;\\n      case bNorm:\\n        h = (rNorm - gNorm) / diff + 4;\\n        break;\\n    }\\n    h /= 6;\\n  }\\n\\n  return {\\n    h: Math.round(h * 360),\\n    s: Math.round(s * 100),\\n    l: Math.round(l * 100),\\n  };\\n};\\n\\nconst formatColor = (hex: string, format: \\\"hex\\\" | \\\"rgb\\\" | \\\"hsl\\\"): string => {\\n  switch (format) {\\n    case \\\"rgb\\\": {\\n      const rgb = hexToRgb(hex);\\n      return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\\n    }\\n    case \\\"hsl\\\": {\\n      const hsl = hexToHsl(hex);\\n      return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\\n    }\\n    default:\\n      return hex;\\n  }\\n};\\n\\nexport const ColorPickerField: React.FC<ColorPickerFieldSpecificProps> = ({\\n  fieldApi,\\n  colorConfig = {},\\n  inputClassName,\\n  ...wrapperProps\\n}) => {\\n  const {\\n    format = \\\"hex\\\",\\n    showPreview = true,\\n    presetColors = DEFAULT_PRESETS,\\n    allowCustom = true,\\n  } = colorConfig;\\n\\n  const value = (fieldApi.state?.value as string) || \\\"#000000\\\";\\n\\n  const [isOpen, setIsOpen] = useState(false);\\n  const [customInput, setCustomInput] = useState(value);\\n  const containerRef = useRef<HTMLDivElement>(null);\\n  const colorInputRef = useRef<HTMLInputElement>(null);\\n\\n  // Ensure value is always a valid hex color\\n  const normalizedValue = value.startsWith(\\\"#\\\") ? value : `#${value}`;\\n  const displayValue = formatColor(normalizedValue, format);\\n\\n  // Close dropdown when clicking outside\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (\\n        containerRef.current &&\\n        !containerRef.current.contains(event.target as Node)\\n      ) {\\n        setIsOpen(false);\\n      }\\n    };\\n\\n    document.addEventListener(\\\"mousedown\\\", handleClickOutside);\\n    return () => document.removeEventListener(\\\"mousedown\\\", handleClickOutside);\\n  }, []);\\n\\n  const handleColorSelect = (color: string) => {\\n    const formattedColor = formatColor(color, format);\\n    fieldApi.handleChange(formattedColor);\\n    setCustomInput(color);\\n    setIsOpen(false);\\n    fieldApi.handleBlur();\\n  };\\n\\n  const handleCustomInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const inputValue = e.target.value;\\n    setCustomInput(inputValue);\\n\\n    // Validate and update if it's a valid color\\n    if (inputValue.match(/^#[0-9A-Fa-f]{6}$/)) {\\n      const formattedColor = formatColor(inputValue, format);\\n      fieldApi.handleChange(formattedColor);\\n    }\\n  };\\n\\n  const handleNativeColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const color = e.target.value;\\n    const formattedColor = formatColor(color, format);\\n    fieldApi.handleChange(formattedColor);\\n    setCustomInput(color);\\n  };\\n\\n  const isValidColor = (color: string): boolean => {\\n    return /^#[0-9A-Fa-f]{6}$/.test(color);\\n  };\\n\\n  const isDisabled = fieldApi.form.state.isSubmitting;\\n\\n  return (\\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\\n      <div className=\\\"relative space-y-2\\\" ref={containerRef}>\\n        <div className=\\\"flex gap-2\\\">\\n          {/* Color preview and trigger */}\\n          <div className=\\\"relative\\\">\\n            <Button\\n              type=\\\"button\\\"\\n              variant=\\\"outline\\\"\\n              className={cn(\\n                \\\"w-12 h-10 p-0 border-2\\\",\\n                fieldApi.state?.meta?.errors.length ? \\\"border-destructive\\\" : \\\"\\\",\\n                inputClassName\\n              )}\\n              onClick={() => setIsOpen(!isOpen)}\\n              disabled={isDisabled}\\n              style={{ backgroundColor: normalizedValue }}\\n            >\\n              {!showPreview && <Palette className=\\\"h-4 w-4\\\" />}\\n            </Button>\\n\\n            {/* Native color input (hidden) */}\\n            <input\\n              ref={colorInputRef}\\n              type=\\\"color\\\"\\n              value={normalizedValue}\\n              onChange={handleNativeColorChange}\\n              onBlur={() => fieldApi.handleBlur()}\\n              className=\\\"absolute inset-0 w-full h-full opacity-0 cursor-pointer\\\"\\n              disabled={isDisabled}\\n            />\\n          </div>\\n\\n          {/* Color value input */}\\n          <Input\\n            value={displayValue}\\n            onChange={(e) => {\\n              const inputValue = e.target.value;\\n              fieldApi.handleChange(inputValue);\\n              // Try to extract hex value for internal use\\n              if (inputValue.startsWith(\\\"#\\\")) {\\n                setCustomInput(inputValue);\\n              }\\n            }}\\n            onBlur={() => {\\n              fieldApi.handleBlur();\\n            }}\\n            placeholder={\\\"#000000\\\"}\\n            className={cn(\\n              \\\"flex-1\\\",\\n              fieldApi.state?.meta?.errors.length ? \\\"border-destructive\\\" : \\\"\\\"\\n            )}\\n            disabled={isDisabled}\\n          />\\n        </div>\\n\\n        {/* Color picker dropdown */}\\n        {isOpen && (\\n          <div className=\\\"absolute z-50 mt-1 p-4 bg-popover border rounded-md shadow-lg w-64\\\">\\n            {/* Preset colors */}\\n            <div className=\\\"mb-4\\\">\\n              <h4 className=\\\"text-sm font-medium mb-2\\\">Preset Colors</h4>\\n              <div className=\\\"grid grid-cols-6 gap-2\\\">\\n                {presetColors.map((color, index) => (\\n                  <button\\n                    key={index}\\n                    type=\\\"button\\\"\\n                    className={cn(\\n                      \\\"w-8 h-8 rounded border-2 hover:scale-110 transition-transform\\\",\\n                      normalizedValue.toLowerCase() === color.toLowerCase()\\n                        ? \\\"border-primary ring-2 ring-primary ring-offset-2\\\"\\n                        : \\\"border-muted hover:border-primary\\\"\\n                    )}\\n                    style={{ backgroundColor: color }}\\n                    onClick={() => handleColorSelect(color)}\\n                    title={color}\\n                  >\\n                    {normalizedValue.toLowerCase() === color.toLowerCase() && (\\n                      <Check className=\\\"h-4 w-4 text-white drop-shadow-lg\\\" />\\n                    )}\\n                  </button>\\n                ))}\\n              </div>\\n            </div>\\n\\n            {/* Custom color input */}\\n            {allowCustom && (\\n              <div>\\n                <h4 className=\\\"text-sm font-medium mb-2\\\">Custom Color</h4>\\n                <div className=\\\"flex gap-2\\\">\\n                  <Input\\n                    value={customInput}\\n                    onChange={handleCustomInputChange}\\n                    placeholder=\\\"#000000\\\"\\n                    className=\\\"flex-1 text-xs\\\"\\n                  />\\n                  <Button\\n                    type=\\\"button\\\"\\n                    size=\\\"sm\\\"\\n                    onClick={() => handleColorSelect(customInput)}\\n                    disabled={!isValidColor(customInput)}\\n                  >\\n                    Apply\\n                  </Button>\\n                </div>\\n              </div>\\n            )}\\n          </div>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/date-field.tsx\": \"import React from \\\"react\\\";\\nimport { format, parseISO } from \\\"date-fns\\\";\\nimport { Calendar as CalendarIcon } from \\\"lucide-react\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { Calendar } from \\\"@/components/ui/calendar\\\";\\nimport {\\n  Popover,\\n  PopoverContent,\\n  PopoverTrigger,\\n} from \\\"@/components/ui/popover\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nexport const DateField: React.FC<BaseFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n}) => {\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors =\\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const [isOpen, setIsOpen] = React.useState(false);\\n\\n  const value = fieldApi.state?.value;\\n  const selectedDate = value\\n    ? value instanceof Date\\n      ? value\\n      : typeof value === \\\"string\\\"\\n      ? parseISO(value)\\n      : undefined\\n    : undefined;\\n\\n  const handleDateSelect = (date: Date | undefined) => {\\n    fieldApi.handleChange(date);\\n    fieldApi.handleBlur();\\n    setIsOpen(false);\\n  };\\n\\n  const computedInputClassName = cn(\\n    \\\"w-full justify-start text-left font-normal\\\",\\n    !selectedDate && \\\"text-muted-foreground\\\",\\n    hasErrors ? \\\"border-destructive\\\" : \\\"\\\",\\n    inputClassName\\n  );\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\\n        <PopoverTrigger asChild>\\n          <Button\\n            variant=\\\"outline\\\"\\n            className={computedInputClassName}\\n            disabled={isDisabled}\\n            onClick={() => setIsOpen(true)}\\n          >\\n            <CalendarIcon className=\\\"mr-2 h-4 w-4\\\" />\\n            {selectedDate ? (\\n              format(selectedDate, \\\"PPP\\\")\\n            ) : (\\n              <span>{placeholder || \\\"Pick a date\\\"}</span>\\n            )}\\n          </Button>\\n        </PopoverTrigger>\\n        <PopoverContent className=\\\"w-auto p-0\\\">\\n          <Calendar\\n            mode=\\\"single\\\"\\n            selected={selectedDate}\\n            onSelect={handleDateSelect}\\n            initialFocus\\n            disabled={isDisabled}\\n          />\\n        </PopoverContent>\\n      </Popover>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/duration-picker-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState } from \\\"react\\\";\\nimport type { BaseFieldProps, DurationConfig } from \\\"@/lib/formedible/types\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport {\\n  Select,\\n  SelectContent,\\n  SelectItem,\\n  SelectTrigger,\\n  SelectValue,\\n} from \\\"@/components/ui/select\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\n\\ninterface DurationPickerFieldProps extends BaseFieldProps {\\n  durationConfig?: DurationConfig;\\n}\\n\\nconst parseDuration = (value: any) => {\\n  if (!value) return { hours: 0, minutes: 0, seconds: 0 };\\n\\n  if (typeof value === \\\"number\\\") {\\n    const totalSeconds = Math.abs(value);\\n    return {\\n      hours: Math.floor(totalSeconds / 3600),\\n      minutes: Math.floor((totalSeconds % 3600) / 60),\\n      seconds: totalSeconds % 60,\\n    };\\n  }\\n\\n  if (typeof value === \\\"object\\\") {\\n    return {\\n      hours: value.hours || 0,\\n      minutes: value.minutes || 0,\\n      seconds: value.seconds || 0,\\n    };\\n  }\\n\\n  return { hours: 0, minutes: 0, seconds: 0 };\\n};\\n\\nconst formatOutput = (\\n  hours: number,\\n  minutes: number,\\n  seconds: number,\\n  format: string\\n) => {\\n  const totalSeconds = hours * 3600 + minutes * 60 + seconds;\\n\\n  switch (format) {\\n    case \\\"hours\\\":\\n      return hours + minutes / 60 + seconds / 3600;\\n    case \\\"minutes\\\":\\n      return hours * 60 + minutes + seconds / 60;\\n    case \\\"seconds\\\":\\n      return totalSeconds;\\n    default:\\n      return { hours, minutes, seconds, totalSeconds };\\n  }\\n};\\n\\nexport const DurationPickerField: React.FC<DurationPickerFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  wrapperClassName,\\n  labelClassName,\\n  inputClassName,\\n  durationConfig,\\n}) => {\\n  const name = fieldApi.name;\\n  const format = durationConfig?.format || \\\"hms\\\";\\n  const maxHours = durationConfig?.maxHours || 23;\\n  const maxMinutes = durationConfig?.maxMinutes || 59;\\n  const maxSeconds = durationConfig?.maxSeconds || 59;\\n  const showLabels = durationConfig?.showLabels !== false;\\n\\n  const currentValue = parseDuration(fieldApi.state?.value);\\n  const [hours, setHours] = useState(currentValue.hours);\\n  const [minutes, setMinutes] = useState(currentValue.minutes);\\n  const [seconds, setSeconds] = useState(currentValue.seconds);\\n\\n  const updateField = (h: number, m: number, s: number) => {\\n    const output = formatOutput(h, m, s, format);\\n    fieldApi.handleChange(output);\\n  };\\n\\n  const handleHoursChange = (h: number) => {\\n    setHours(h);\\n    updateField(h, minutes, seconds);\\n  };\\n\\n  const handleMinutesChange = (m: number) => {\\n    setMinutes(m);\\n    updateField(hours, m, seconds);\\n  };\\n\\n  const handleSecondsChange = (s: number) => {\\n    setSeconds(s);\\n    updateField(hours, minutes, s);\\n  };\\n\\n  const formatDuration = () => {\\n    const parts = [];\\n    if (format.includes(\\\"h\\\") && hours > 0) parts.push(`${hours}h`);\\n    if (format.includes(\\\"m\\\") && minutes > 0) parts.push(`${minutes}m`);\\n    if (format.includes(\\\"s\\\") && seconds > 0) parts.push(`${seconds}s`);\\n    return parts.join(\\\" \\\") || \\\"0\\\";\\n  };\\n\\n  const renderTimeInput = (\\n    value: number,\\n    onChange: (value: number) => void,\\n    max: number,\\n    unit: string,\\n    show: boolean\\n  ) => {\\n    if (!show) return null;\\n\\n    return (\\n      <div className=\\\"flex flex-col space-y-1\\\">\\n        {showLabels && (\\n          <Label className=\\\"text-xs text-muted-foreground capitalize\\\">\\n            {unit}\\n          </Label>\\n        )}\\n        <Select\\n          value={value.toString()}\\n          onValueChange={(val) => onChange(parseInt(val))}\\n        >\\n          <SelectTrigger className={cn(\\\"w-20\\\", inputClassName)}>\\n            <SelectValue />\\n          </SelectTrigger>\\n          <SelectContent>\\n            {Array.from({ length: max + 1 }, (_, i) => (\\n              <SelectItem key={i} value={i.toString()}>\\n                {i.toString().padStart(2, \\\"0\\\")}\\n              </SelectItem>\\n            ))}\\n          </SelectContent>\\n        </Select>\\n      </div>\\n    );\\n  };\\n\\n  const handleManualInput = (input: string) => {\\n    const hourMatch = input.match(/(\\\\d+)h/i);\\n    const minuteMatch = input.match(/(\\\\d+)m(?!s)/i);\\n    const secondMatch = input.match(/(\\\\d+)s/i);\\n\\n    const newHours = hourMatch\\n      ? Math.min(Math.max(0, parseInt(hourMatch[1], 10)), maxHours)\\n      : 0;\\n    const newMinutes = minuteMatch\\n      ? Math.min(Math.max(0, parseInt(minuteMatch[1], 10)), maxMinutes)\\n      : 0;\\n    const newSeconds = secondMatch\\n      ? Math.min(Math.max(0, parseInt(secondMatch[1], 10)), maxSeconds)\\n      : 0;\\n\\n    setHours(newHours);\\n    setMinutes(newMinutes);\\n    setSeconds(newSeconds);\\n    updateField(newHours, newMinutes, newSeconds);\\n  };\\n\\n  return (\\n    <div className={cn(\\\"space-y-2\\\", wrapperClassName)}>\\n      {label && (\\n        <Label htmlFor={name} className={labelClassName}>\\n          {label}\\n        </Label>\\n      )}\\n\\n      {description && (\\n        <p className=\\\"text-sm text-muted-foreground\\\">{description}</p>\\n      )}\\n\\n      <div className=\\\"space-y-3\\\">\\n        {/* Dropdown selectors */}\\n        <div className=\\\"flex gap-3\\\">\\n          {renderTimeInput(\\n            hours,\\n            handleHoursChange,\\n            maxHours,\\n            \\\"hours\\\",\\n            format.includes(\\\"h\\\")\\n          )}\\n          {renderTimeInput(\\n            minutes,\\n            handleMinutesChange,\\n            maxMinutes,\\n            \\\"minutes\\\",\\n            format.includes(\\\"m\\\")\\n          )}\\n          {renderTimeInput(\\n            seconds,\\n            handleSecondsChange,\\n            maxSeconds,\\n            \\\"seconds\\\",\\n            format.includes(\\\"s\\\")\\n          )}\\n        </div>\\n\\n        {/* Manual input alternative */}\\n        <div className=\\\"space-y-2\\\">\\n          <Input\\n            id={name}\\n            value={formatDuration()}\\n            placeholder={placeholder || \\\"Enter duration (e.g., 1h 30m 45s)\\\"}\\n            className={inputClassName}\\n            onChange={(e) => handleManualInput(e.target.value)}\\n          />\\n          <div className=\\\"text-xs text-muted-foreground\\\">\\n            Format:{\\\" \\\"}\\n            {format === \\\"hms\\\"\\n              ? \\\"1h 30m 45s\\\"\\n              : format === \\\"hm\\\"\\n              ? \\\"1h 30m\\\"\\n              : format === \\\"ms\\\"\\n              ? \\\"30m 45s\\\"\\n              : `${format} only`}\\n          </div>\\n        </div>\\n\\n        {/* Duration display */}\\n        <div className=\\\"text-sm text-muted-foreground\\\">\\n          Total: {formatDuration()}\\n          {format !== \\\"seconds\\\" &&\\n            ` (${hours * 3600 + minutes * 60 + seconds} seconds)`}\\n        </div>\\n      </div>\\n\\n      {fieldApi.state?.meta?.errors &&\\n        fieldApi.state?.meta?.errors.length > 0 && (\\n          <p className=\\\"text-sm text-destructive\\\">\\n            {fieldApi.state?.meta?.errors[0]}\\n          </p>\\n        )}\\n    </div>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/field-help.tsx\": \"'use client';\\nimport React, { useState } from 'react';\\nimport { Button } from '@/components/ui/button';\\nimport { cn } from '@/lib/utils';\\nimport { HelpCircle, ExternalLink, Info } from 'lucide-react';\\n\\ninterface FieldHelpProps {\\n  help?: {\\n    text?: string;\\n    tooltip?: string;\\n    position?: 'top' | 'bottom' | 'left' | 'right';\\n    link?: { url: string; text: string };\\n  };\\n  className?: string;\\n}\\n\\nexport const FieldHelp: React.FC<FieldHelpProps> = ({\\n  help,\\n  className,\\n}) => {\\n  const [showTooltip, setShowTooltip] = useState(false);\\n\\n  if (!help || (!help.text && !help.tooltip && !help.link)) {\\n    return null;\\n  }\\n\\n  const { text, tooltip, position = 'top', link } = help;\\n\\n  return (\\n    <div className={cn(\\\"space-y-2\\\", className)}>\\n      {/* Help text */}\\n      {text && (\\n        <div className=\\\"flex items-start gap-2 text-xs text-muted-foreground\\\">\\n          <Info className=\\\"h-3 w-3 mt-0.5 flex-shrink-0\\\" />\\n          <p>{text}</p>\\n        </div>\\n      )}\\n\\n      {/* Tooltip trigger */}\\n      {tooltip && (\\n        <div className=\\\"relative inline-block\\\">\\n          <Button\\n            type=\\\"button\\\"\\n            variant=\\\"ghost\\\"\\n            size=\\\"sm\\\"\\n            className=\\\"h-6 w-6 p-0 text-muted-foreground hover:text-foreground\\\"\\n            onMouseEnter={() => setShowTooltip(true)}\\n            onMouseLeave={() => setShowTooltip(false)}\\n            onFocus={() => setShowTooltip(true)}\\n            onBlur={() => setShowTooltip(false)}\\n          >\\n            <HelpCircle className=\\\"h-3 w-3\\\" />\\n          </Button>\\n\\n          {/* Tooltip */}\\n          {showTooltip && (\\n            <div\\n              className={cn(\\n                \\\"absolute z-50 px-2 py-1 text-xs text-white bg-black rounded shadow-lg whitespace-nowrap\\\",\\n                \\\"pointer-events-none\\\",\\n                {\\n                  'bottom-full left-1/2 -translate-x-1/2 mb-1': position === 'top',\\n                  'top-full left-1/2 -translate-x-1/2 mt-1': position === 'bottom',\\n                  'right-full top-1/2 -translate-y-1/2 mr-1': position === 'left',\\n                  'left-full top-1/2 -translate-y-1/2 ml-1': position === 'right',\\n                }\\n              )}\\n            >\\n              {tooltip}\\n              {/* Tooltip arrow */}\\n              <div\\n                className={cn(\\n                  \\\"absolute w-0 h-0 border-2 border-transparent\\\",\\n                  {\\n                    'top-full left-1/2 -translate-x-1/2 border-t-black border-b-0': position === 'top',\\n                    'bottom-full left-1/2 -translate-x-1/2 border-b-black border-t-0': position === 'bottom',\\n                    'top-1/2 left-full -translate-y-1/2 border-l-black border-r-0': position === 'left',\\n                    'top-1/2 right-full -translate-y-1/2 border-r-black border-l-0': position === 'right',\\n                  }\\n                )}\\n              />\\n            </div>\\n          )}\\n        </div>\\n      )}\\n\\n      {/* Help link */}\\n      {link && (\\n        <div className=\\\"flex items-center gap-1\\\">\\n          <Button\\n            type=\\\"button\\\"\\n            variant=\\\"link\\\"\\n            size=\\\"sm\\\"\\n            className=\\\"h-auto p-0 text-xs text-primary hover:text-primary/80\\\"\\n            onClick={() => window.open(link.url, '_blank', 'noopener,noreferrer')}\\n          >\\n            {link.text}\\n            <ExternalLink className=\\\"h-3 w-3 ml-1\\\" />\\n          </Button>\\n        </div>\\n      )}\\n    </div>\\n  );\\n}; \",\n  \"/src/components/formedible/fields/field-registry.tsx\": \"'use client';\\nimport React from 'react';\\nimport type { BaseFieldProps } from '@/lib/formedible/types';\\n\\n// Import all field components\\nimport { TextField } from './text-field';\\nimport { TextareaField } from './textarea-field';\\nimport { NumberField } from './number-field';\\nimport { SelectField } from './select-field';\\nimport { MultiSelectField } from './multi-select-field';\\nimport { CheckboxField } from './checkbox-field';\\nimport { SwitchField } from './switch-field';\\nimport { RadioField } from './radio-field';\\nimport { SliderField } from './slider-field';\\nimport { DateField } from './date-field';\\nimport { RatingField } from './rating-field';\\nimport { PhoneField } from './phone-field';\\nimport { ColorPickerField } from './color-picker-field';\\nimport { FileUploadField } from './file-upload-field';\\nimport { ArrayField } from './array-field';\\nimport { AutocompleteField } from './autocomplete-field';\\nimport { DurationPickerField } from './duration-picker-field';\\nimport { LocationPickerField } from './location-picker-field';\\nimport { MaskedInputField } from './masked-input-field';\\nimport { ObjectField } from './object-field';\\n\\n// Type-safe field component registry with flexible props\\nexport interface FieldComponentProps extends BaseFieldProps {\\n  [key: string]: unknown;\\n}\\n\\nexport type FieldComponent = React.ComponentType<any>;\\n\\nexport const fieldComponents: Record<string, FieldComponent> = {\\n  text: TextField,\\n  textarea: TextareaField,\\n  number: NumberField,\\n  select: SelectField,\\n  multiselect: MultiSelectField,\\n  checkbox: CheckboxField,\\n  switch: SwitchField,\\n  radio: RadioField,\\n  slider: SliderField,\\n  date: DateField,\\n  rating: RatingField,\\n  phone: PhoneField,\\n  color: ColorPickerField,\\n  file: FileUploadField,\\n  array: ArrayField,\\n  autocomplete: AutocompleteField,\\n  duration: DurationPickerField,\\n  location: LocationPickerField,\\n  masked: MaskedInputField,\\n  object: ObjectField,\\n};\\n\\n// Helper function to get field component with type safety\\nexport const getFieldComponent = (type: string): FieldComponent | null => {\\n  return fieldComponents[type] || null;\\n};\\n\\n// Helper function to create properly typed field props\\nexport const createFieldProps = (\\n  baseProps: BaseFieldProps,\\n  additionalProps: Record<string, unknown> = {}\\n): FieldComponentProps => {\\n  return {\\n    ...baseProps,\\n    ...additionalProps,\\n  };\\n};\",\n  \"/src/components/formedible/fields/file-upload-field.tsx\": \"import React from \\\"react\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { PaperclipIcon, XIcon, UploadCloudIcon } from \\\"lucide-react\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\ninterface FileUploadFieldSpecificProps extends BaseFieldProps {\\n  accept?: string;\\n  className?: string;\\n}\\n\\nexport const FileUploadField: React.FC<FileUploadFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  accept,\\n  className,\\n}) => {\\n  const name = fieldApi.name;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors =\\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const file = fieldApi.state?.value as File | null;\\n\\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const selectedFile = e.target.files?.[0] ?? null;\\n    fieldApi.handleChange(selectedFile);\\n    fieldApi.handleBlur();\\n  };\\n\\n  const handleRemoveFile = () => {\\n    fieldApi.handleChange(null);\\n    const inputElement = document.getElementById(name) as HTMLInputElement;\\n    if (inputElement) {\\n      inputElement.value = \\\"\\\";\\n    }\\n    fieldApi.handleBlur();\\n  };\\n\\n  const triggerFileInput = () => {\\n    const inputElement = document.getElementById(name) as HTMLInputElement;\\n    inputElement?.click();\\n  };\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-1.5\\\">\\n        <Input\\n          id={name}\\n          name={name}\\n          type=\\\"file\\\"\\n          accept={accept}\\n          onChange={handleFileChange}\\n          className=\\\"hidden\\\"\\n          disabled={isDisabled}\\n        />\\n        {file ? (\\n          <div className=\\\"flex items-center justify-between p-2.5 border rounded-lg bg-muted/40 shadow-sm hover:shadow-md transition-shadow\\\">\\n            <div className=\\\"flex items-center gap-2 text-sm overflow-hidden\\\">\\n              <PaperclipIcon className=\\\"h-5 w-5 text-primary shrink-0\\\" />\\n              <span className=\\\"truncate\\\" title={file.name}>\\n                {file.name}\\n              </span>\\n              <span className=\\\"text-xs text-muted-foreground whitespace-nowrap\\\">\\n                ({(file.size / 1024).toFixed(1)} KB)\\n              </span>\\n            </div>\\n            <Button\\n              type=\\\"button\\\"\\n              variant=\\\"ghost\\\"\\n              size=\\\"icon\\\"\\n              onClick={handleRemoveFile}\\n              className=\\\"h-7 w-7 text-destructive hover:bg-destructive/10 shrink-0\\\"\\n              aria-label=\\\"Remove file\\\"\\n              disabled={isDisabled}\\n            >\\n              <XIcon className=\\\"h-4 w-4\\\" />\\n            </Button>\\n          </div>\\n        ) : (\\n          <button\\n            type=\\\"button\\\"\\n            onClick={triggerFileInput}\\n            className={cn(\\n              \\\"w-full flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-lg hover:border-primary transition-colors cursor-pointer bg-background hover:bg-muted/50\\\",\\n              className,\\n              hasErrors\\n                ? \\\"border-destructive hover:border-destructive\\\"\\n                : \\\"border-muted-foreground/50\\\",\\n              isDisabled && \\\"opacity-50 cursor-not-allowed\\\"\\n            )}\\n            disabled={isDisabled}\\n          >\\n            <UploadCloudIcon className=\\\"h-8 w-8 text-muted-foreground mb-2\\\" />\\n            <span className=\\\"text-sm font-medium text-muted-foreground\\\">\\n              Click or drag and drop a file\\n            </span>\\n            {accept && (\\n              <span className=\\\"text-xs text-muted-foreground/80 mt-1\\\">\\n                Accepted types: {accept}\\n              </span>\\n            )}\\n          </button>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/inline-validation-wrapper.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect, useCallback, useMemo } from \\\"react\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { Check, X, Loader2 } from \\\"lucide-react\\\";\\nimport type { InlineValidationWrapperProps } from \\\"@/lib/formedible/types\\\";\\n\\nexport const InlineValidationWrapper: React.FC<\\n  InlineValidationWrapperProps\\n> = ({ children, fieldApi, inlineValidation = {}, className }) => {\\n  const {\\n    enabled = true,\\n    debounceMs = 300,\\n    showSuccess = true,\\n    asyncValidator,\\n  } = inlineValidation;\\n\\n  const [validationState, setValidationState] = useState<{\\n    isValidating: boolean;\\n    isValid: boolean | null;\\n    message: string | null;\\n  }>({\\n    isValidating: false,\\n    isValid: null,\\n    message: null,\\n  });\\n\\n  const { state } = fieldApi;\\n  const value = state.value;\\n  const hasErrors = state.meta.errors.length > 0;\\n  const isTouched = state.meta.isTouched;\\n\\n  // Validation function\\n  const validateValue = useCallback(\\n    async (currentValue: unknown) => {\\n      if (!enabled || !asyncValidator) return;\\n\\n      setValidationState((prev) => ({ ...prev, isValidating: true }));\\n\\n      try {\\n        const result = await asyncValidator(currentValue);\\n\\n        setValidationState({\\n          isValidating: false,\\n          isValid: result === null,\\n          message: result,\\n        });\\n      } catch (error) {\\n        setValidationState({\\n          isValidating: false,\\n          isValid: false,\\n          message: error instanceof Error ? error.message : \\\"Validation failed\\\",\\n        });\\n      }\\n    },\\n    [enabled, asyncValidator]\\n  );\\n\\n  // Debounced validation function\\n  const debouncedValidate = useMemo(\\n    () => debounce(validateValue, debounceMs),\\n    [validateValue, debounceMs]\\n  );\\n\\n  // Trigger validation when value changes\\n  useEffect(() => {\\n    if (enabled && isTouched && value !== undefined && value !== \\\"\\\") {\\n      debouncedValidate(value);\\n    } else {\\n      setValidationState({\\n        isValidating: false,\\n        isValid: null,\\n        message: null,\\n      });\\n    }\\n  }, [value, isTouched, enabled, debouncedValidate]);\\n\\n  // Reset validation state when field is reset\\n  useEffect(() => {\\n    if (!isTouched) {\\n      setValidationState({\\n        isValidating: false,\\n        isValid: null,\\n        message: null,\\n      });\\n    }\\n  }, [isTouched]);\\n\\n  const getValidationIcon = () => {\\n    if (!enabled || !isTouched) return null;\\n\\n    if (validationState.isValidating) {\\n      return <Loader2 className=\\\"h-4 w-4 animate-spin text-muted-foreground\\\" />;\\n    }\\n\\n    if (hasErrors) {\\n      return <X className=\\\"h-4 w-4 text-destructive\\\" />;\\n    }\\n\\n    if (validationState.isValid === false) {\\n      return <X className=\\\"h-4 w-4 text-destructive\\\" />;\\n    }\\n\\n    if (showSuccess && validationState.isValid === true) {\\n      return <Check className=\\\"h-4 w-4 text-green-500\\\" />;\\n    }\\n\\n    if (showSuccess && !hasErrors && isTouched && value) {\\n      return <Check className=\\\"h-4 w-4 text-green-500\\\" />;\\n    }\\n\\n    return null;\\n  };\\n\\n  const getValidationMessage = () => {\\n    if (!enabled || !isTouched) return null;\\n\\n    // Show form validation errors first\\n    if (hasErrors) {\\n      return state.meta.errors[0];\\n    }\\n\\n    // Show async validation message\\n    if (validationState.message) {\\n      return validationState.message;\\n    }\\n\\n    return null;\\n  };\\n\\n  const validationIcon = getValidationIcon();\\n  const validationMessage = getValidationMessage();\\n\\n  return (\\n    <div className={cn(\\\"relative\\\", className)}>\\n      {/* Field with validation icon */}\\n      <div className=\\\"relative\\\">\\n        {children}\\n        {validationIcon && (\\n          <div className=\\\"absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none\\\">\\n            {validationIcon}\\n          </div>\\n        )}\\n      </div>\\n\\n      {/* Validation message */}\\n      {validationMessage && (\\n        <div\\n          className={cn(\\n            \\\"text-xs mt-1 flex items-center gap-1\\\",\\n            hasErrors || validationState.isValid === false\\n              ? \\\"text-destructive\\\"\\n              : \\\"text-muted-foreground\\\"\\n          )}\\n        >\\n          {typeof validationMessage === \\\"string\\\"\\n            ? validationMessage\\n            : (validationMessage as Error)?.message || \\\"Validation error\\\"}\\n        </div>\\n      )}\\n    </div>\\n  );\\n};\\n\\n// Debounce utility function\\nfunction debounce<T extends (...args: any[]) => any>(\\n  func: T,\\n  wait: number\\n): (...args: Parameters<T>) => void {\\n  let timeout: ReturnType<typeof setTimeout>;\\n\\n  return (...args: Parameters<T>) => {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => func(...args), wait);\\n  };\\n}\\n\",\n  \"/src/components/formedible/fields/location-picker-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect, useRef, useCallback } from \\\"react\\\";\\nimport type {\\n  BaseFieldProps,\\n  LocationConfig,\\n  LocationValue,\\n  LocationSearchResult,\\n} from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { Card } from \\\"@/components/ui/card\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport {\\n  Dialog,\\n  DialogContent,\\n  DialogDescription,\\n  DialogFooter,\\n  DialogHeader,\\n  DialogTitle,\\n  DialogTrigger,\\n} from \\\"@/components/ui/dialog\\\";\\n\\n// Built-in search providers\\nconst builtInProviders = {\\n  // OpenStreetMap/Nominatim search\\n  nominatim: async (\\n    query: string,\\n    options: any = {}\\n  ): Promise<LocationSearchResult[]> => {\\n    const endpoint =\\n      options.endpoint || \\\"https://nominatim.openstreetmap.org/search\\\";\\n    const params = new URLSearchParams({\\n      q: query,\\n      format: \\\"json\\\",\\n      limit: String(options.limit || 5),\\n      addressdetails: \\\"1\\\",\\n      ...options.searchOptions,\\n    });\\n\\n    try {\\n      const response = await fetch(`${endpoint}?${params}`);\\n      const data = await response.json();\\n\\n      return data.map((item: any, index: number) => ({\\n        id: item.place_id || index,\\n        lat: parseFloat(item.lat),\\n        lng: parseFloat(item.lon),\\n        address: item.display_name,\\n        city: item.address?.city || item.address?.town || item.address?.village,\\n        state: item.address?.state,\\n        country: item.address?.country,\\n        postalCode: item.address?.postcode,\\n        relevance: parseFloat(item.importance || 0),\\n        bounds: item.boundingbox\\n          ? {\\n              northeast: {\\n                lat: parseFloat(item.boundingbox[1]),\\n                lng: parseFloat(item.boundingbox[3]),\\n              },\\n              southwest: {\\n                lat: parseFloat(item.boundingbox[0]),\\n                lng: parseFloat(item.boundingbox[2]),\\n              },\\n            }\\n          : undefined,\\n      }));\\n    } catch (error) {\\n      console.error(\\\"Nominatim search error:\\\", error);\\n      return [];\\n    }\\n  },\\n\\n  // OpenStreetMap reverse geocoding\\n  nominatimReverse: async (\\n    lat: number,\\n    lng: number,\\n    options: any = {}\\n  ): Promise<LocationValue> => {\\n    const endpoint =\\n      options.endpoint || \\\"https://nominatim.openstreetmap.org/reverse\\\";\\n    const params = new URLSearchParams({\\n      lat: String(lat),\\n      lon: String(lng),\\n      format: \\\"json\\\",\\n      addressdetails: \\\"1\\\",\\n      ...options.searchOptions,\\n    });\\n\\n    try {\\n      const response = await fetch(`${endpoint}?${params}`);\\n      const data = await response.json();\\n\\n      return {\\n        lat,\\n        lng,\\n        address: data.display_name,\\n        city: data.address?.city || data.address?.town || data.address?.village,\\n        state: data.address?.state,\\n        country: data.address?.country,\\n        postalCode: data.address?.postcode,\\n      };\\n    } catch (error) {\\n      console.error(\\\"Nominatim reverse geocoding error:\\\", error);\\n      return { lat, lng, address: `${lat}, ${lng}` };\\n    }\\n  },\\n};\\n\\n// Proper map implementation using user-configurable tile providers\\nconst defaultMapRenderer = (params: {\\n  location: LocationValue | null;\\n  onLocationSelect: (location: LocationValue) => void;\\n  mapContainer: HTMLDivElement;\\n  zoom: number;\\n  readonly: boolean;\\n  defaultLocation?: { lat: number; lng: number };\\n}) => {\\n  const {\\n    location,\\n    onLocationSelect,\\n    mapContainer,\\n    zoom,\\n    readonly,\\n    defaultLocation,\\n  } = params;\\n\\n  // Initialize Leaflet map\\n  const leafletMap = (window as any).L.map(mapContainer, {\\n    center: [\\n      location?.lat || defaultLocation?.lat || 51.5074,\\n      location?.lng || defaultLocation?.lng || -0.1278,\\n    ],\\n    zoom: zoom || 10,\\n    zoomControl: true,\\n    dragging: !readonly,\\n    touchZoom: !readonly,\\n    scrollWheelZoom: !readonly,\\n    doubleClickZoom: !readonly,\\n    boxZoom: !readonly,\\n    keyboard: !readonly,\\n    tap: !readonly,\\n  });\\n\\n  // Default tile layer - OpenStreetMap\\n  const osmTileLayer = (window as any).L.tileLayer(\\n    \\\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\\\",\\n    {\\n      attribution:\\n        '&copy; <a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors',\\n      maxZoom: 19,\\n    }\\n  );\\n\\n  // Add default tile layer\\n  osmTileLayer.addTo(leafletMap);\\n\\n  // Current marker\\n  let currentMarker: any = null;\\n\\n  // Update marker position\\n  const updateMarker = (loc: LocationValue | null) => {\\n    if (currentMarker) {\\n      leafletMap.removeLayer(currentMarker);\\n      currentMarker = null;\\n    }\\n\\n    if (loc) {\\n      const customIcon = (window as any).L.divIcon({\\n        className: \\\"custom-div-icon\\\",\\n        html: `\\n          <div style=\\\"\\n            background-color: #ef4444;\\n            color: white;\\n            padding: 4px 8px;\\n            border-radius: 4px;\\n            font-size: 12px;\\n            box-shadow: 0 2px 4px rgba(0,0,0,0.2);\\n            white-space: nowrap;\\n            position: relative;\\n            margin-bottom: 8px;\\n          \\\">\\n            📍 ${loc.address || `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`}\\n          </div>\\n          <div style=\\\"\\n            width: 0;\\n            height: 0;\\n            border-left: 8px solid transparent;\\n            border-right: 8px solid transparent;\\n            border-top: 8px solid #ef4444;\\n            margin: 0 auto;\\n            margin-top: -4px;\\n          \\\"></div>\\n        `,\\n        iconSize: [0, 0],\\n        iconAnchor: [0, 0],\\n      });\\n\\n      currentMarker = (window as any).L.marker([loc.lat, loc.lng], {\\n        icon: customIcon,\\n      });\\n      currentMarker.addTo(leafletMap);\\n\\n      // Center map on marker\\n      leafletMap.setView([loc.lat, loc.lng], leafletMap.getZoom());\\n    }\\n  };\\n\\n  // Handle map clicks\\n  if (!readonly) {\\n    leafletMap.on(\\\"click\\\", (e: any) => {\\n      const { lat, lng } = e.latlng;\\n\\n      onLocationSelect({\\n        lat: lat,\\n        lng: lng,\\n        address: `Map Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`,\\n      });\\n    });\\n  }\\n\\n  // Initial marker update\\n  updateMarker(location);\\n\\n  return {\\n    cleanup: () => {\\n      if (leafletMap) {\\n        leafletMap.remove();\\n      }\\n    },\\n    updateLocation: (newLocation: LocationValue) => {\\n      updateMarker(newLocation);\\n    },\\n    switchTileLayer: (tileConfig: {\\n      url: string;\\n      attribution: string;\\n      maxZoom?: number;\\n      apiKey?: string;\\n    }) => {\\n      // Remove current tile layer\\n      leafletMap.eachLayer((layer: any) => {\\n        if (layer instanceof (window as any).L.TileLayer) {\\n          leafletMap.removeLayer(layer);\\n        }\\n      });\\n\\n      // Add new tile layer\\n      const newTileLayer = (window as any).L.tileLayer(tileConfig.url, {\\n        attribution: tileConfig.attribution,\\n        maxZoom: tileConfig.maxZoom || 18,\\n      });\\n\\n      newTileLayer.addTo(leafletMap);\\n    },\\n  };\\n};\\n\\n// Utility to format coordinates\\nconst formatCoordinates = (\\n  lat: number,\\n  lng: number,\\n  format: \\\"decimal\\\" | \\\"dms\\\" = \\\"decimal\\\"\\n) => {\\n  if (format === \\\"decimal\\\") {\\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\\n  } else {\\n    // Convert to degrees, minutes, seconds\\n    const latDeg = Math.floor(Math.abs(lat));\\n    const latMin = Math.floor((Math.abs(lat) - latDeg) * 60);\\n    const latSec = ((Math.abs(lat) - latDeg) * 60 - latMin) * 60;\\n    const latDir = lat >= 0 ? \\\"N\\\" : \\\"S\\\";\\n\\n    const lngDeg = Math.floor(Math.abs(lng));\\n    const lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);\\n    const lngSec = ((Math.abs(lng) - lngDeg) * 60 - lngMin) * 60;\\n    const lngDir = lng >= 0 ? \\\"E\\\" : \\\"W\\\";\\n\\n    return `${latDeg}°${latMin}'${latSec.toFixed(\\n      2\\n    )}\\\"${latDir}, ${lngDeg}°${lngMin}'${lngSec.toFixed(2)}\\\"${lngDir}`;\\n  }\\n};\\n\\n// Built-in tile providers configuration\\nconst TILE_PROVIDERS = {\\n  openstreetmap: {\\n    url: \\\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\\\",\\n    attribution:\\n      '&copy; <a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors',\\n    maxZoom: 19,\\n  },\\n  cartodb: {\\n    url: \\\"https://cartodb-basemaps-{s}.global.ssl.fastly.net/rastertiles/voyager/{z}/{x}/{y}.png\\\",\\n    attribution:\\n      '&copy; <a href=\\\"http://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors, &copy; <a href=\\\"https://carto.com/attributions\\\">CARTO</a>',\\n    maxZoom: 19,\\n  },\\n  stamen: {\\n    url: \\\"https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png\\\",\\n    attribution:\\n      'Map tiles by <a href=\\\"http://stamen.com\\\">Stamen Design</a>, <a href=\\\"http://creativecommons.org/licenses/by/3.0\\\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\\\"http://www.openstreetmap.org/copyright\\\">OpenStreetMap</a>',\\n    maxZoom: 18,\\n  },\\n  satellite: {\\n    url: \\\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\\\",\\n    attribution:\\n      \\\"Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community\\\",\\n    maxZoom: 19,\\n  },\\n};\\n\\n// Constants - prevent re-creation\\nconst DEFAULT_LOCATION = { lat: 51.5074, lng: -0.1278 };\\n\\n// Load Leaflet CSS and JS dynamically\\nconst loadLeaflet = () => {\\n  if (typeof (window as any).L !== \\\"undefined\\\") {\\n    return Promise.resolve();\\n  }\\n\\n  return new Promise<void>((resolve, reject) => {\\n    // Load CSS\\n    const link = document.createElement(\\\"link\\\");\\n    link.rel = \\\"stylesheet\\\";\\n    link.href = \\\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\\\";\\n    document.head.appendChild(link);\\n\\n    // Load JS\\n    const script = document.createElement(\\\"script\\\");\\n    script.src = \\\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\\\";\\n    script.onload = () => resolve();\\n    script.onerror = () => reject(new Error(\\\"Failed to load Leaflet\\\"));\\n    document.head.appendChild(script);\\n  });\\n};\\n\\ninterface LocationPickerFieldProps extends BaseFieldProps {\\n  locationConfig?: LocationConfig;\\n}\\n\\nexport const LocationPickerField: React.FC<LocationPickerFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  wrapperClassName,\\n  labelClassName,\\n  inputClassName,\\n  locationConfig,\\n}) => {\\n  // Extract config with defaults - NO objects created inline\\n  const config = locationConfig || {};\\n  const defaultLocation = config.defaultLocation || DEFAULT_LOCATION;\\n  const zoom = config.zoom || 10;\\n  const searchPlaceholder = config.searchPlaceholder || \\\"🔍 Search for an address or place...\\\";\\n  const enableSearch = config.enableSearch !== false;\\n  const enableGeolocation = config.enableGeolocation !== false;\\n  const enableManualEntry = config.enableManualEntry !== false;\\n  const showMap = config.showMap !== false;\\n  const mapProvider = config.mapProvider || \\\"openstreetmap\\\";\\n  const searchCallback = config.searchCallback;\\n  const reverseGeocodeCallback = config.reverseGeocodeCallback;\\n  const mapRenderCallback = config.mapRenderCallback;\\n  \\n  // Search options with defaults\\n  const searchOpts = config.searchOptions || {};\\n  const debounceMs = searchOpts.debounceMs || 300;\\n  const minQueryLength = searchOpts.minQueryLength || 2;\\n  const maxResults = searchOpts.maxResults || 5;\\n  \\n  // UI options with defaults\\n  const uiOpts = config.ui || {};\\n  const showCoordinates = uiOpts.showCoordinates !== false;\\n  const showAddress = uiOpts.showAddress !== false;\\n  const mapHeight = uiOpts.mapHeight || 400;\\n  const coordinatesFormat = uiOpts.coordinatesFormat || \\\"decimal\\\";\\n\\n  // Simple state - no complex dependencies\\n  const [searchQuery, setSearchQuery] = useState(\\\"\\\");\\n  const [isSearching, setIsSearching] = useState(false);\\n  const [searchResults, setSearchResults] = useState<LocationSearchResult[]>([]);\\n  const [showResults, setShowResults] = useState(false);\\n  const [currentLocation, setCurrentLocation] = useState<LocationValue | null>(fieldApi.state?.value || null);\\n  const [geoError, setGeoError] = useState<string | null>(null);\\n  const [manualLat, setManualLat] = useState(\\\"\\\");\\n  const [manualLng, setManualLng] = useState(\\\"\\\");\\n  const [isManualDialogOpen, setIsManualDialogOpen] = useState(false);\\n  const [leafletLoaded, setLeafletLoaded] = useState(false);\\n\\n  const mapRef = useRef<HTMLDivElement>(null);\\n  const searchTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\\n  const mapInstanceRef = useRef<any>(null);\\n\\n  // Load Leaflet on mount only if map is enabled - simple\\n  useEffect(() => {\\n    if (!showMap) {\\n      setLeafletLoaded(false);\\n      return;\\n    }\\n    \\n    loadLeaflet()\\n      .then(() => setLeafletLoaded(true))\\n      .catch(() => setGeoError(\\\"Failed to load map library\\\"));\\n  }, [showMap]);\\n\\n  // Search function - simple, no complex dependencies\\n  const performSearch = useCallback(async (query: string) => {\\n    if (!query.trim() || query.length < minQueryLength) {\\n      setSearchResults([]);\\n      setShowResults(false);\\n      return;\\n    }\\n\\n    setIsSearching(true);\\n    try {\\n      let results: LocationSearchResult[];\\n      \\n      if (searchCallback) {\\n        results = await searchCallback(query, { limit: maxResults });\\n      } else {\\n        results = await builtInProviders.nominatim(query, { \\n          limit: maxResults,\\n          ...config.openStreetMap \\n        });\\n      }\\n      \\n      setSearchResults(results);\\n      setShowResults(true);\\n    } catch (error) {\\n      console.error(\\\"Location search error:\\\", error);\\n      setSearchResults([]);\\n      setGeoError(\\\"Search failed. Please try again.\\\");\\n    } finally {\\n      setIsSearching(false);\\n    }\\n  }, [searchCallback, minQueryLength, maxResults, config.openStreetMap]);\\n\\n  // Debounced search - simple\\n  useEffect(() => {\\n    if (!enableSearch) return;\\n\\n    if (searchTimeoutRef.current) {\\n      clearTimeout(searchTimeoutRef.current);\\n    }\\n\\n    searchTimeoutRef.current = setTimeout(() => {\\n      performSearch(searchQuery);\\n    }, debounceMs);\\n\\n    return () => {\\n      if (searchTimeoutRef.current) {\\n        clearTimeout(searchTimeoutRef.current);\\n      }\\n    };\\n  }, [searchQuery, enableSearch, performSearch, debounceMs]);\\n\\n  // Location selection - simple\\n  const handleLocationSelect = useCallback(async (location: LocationValue) => {\\n    // Add address if missing\\n    if (!location.address && location.lat && location.lng) {\\n      try {\\n        let geocodedLocation: LocationValue;\\n        \\n        if (reverseGeocodeCallback) {\\n          geocodedLocation = await reverseGeocodeCallback(location.lat, location.lng);\\n        } else {\\n          geocodedLocation = await builtInProviders.nominatimReverse(\\n            location.lat, \\n            location.lng, \\n            config.openStreetMap\\n          );\\n        }\\n        \\n        location = { ...location, ...geocodedLocation };\\n      } catch (error) {\\n        console.error(\\\"Reverse geocoding error:\\\", error);\\n        location.address = `${location.lat}, ${location.lng}`;\\n      }\\n    }\\n\\n    setCurrentLocation(location);\\n    fieldApi.handleChange(location);\\n    setShowResults(false);\\n    setSearchQuery(location.address || `${location.lat}, ${location.lng}`);\\n    setGeoError(null);\\n\\n    if (mapInstanceRef.current?.updateLocation) {\\n      mapInstanceRef.current.updateLocation(location);\\n    }\\n  }, [fieldApi, reverseGeocodeCallback, config.openStreetMap]);\\n\\n  // Initialize map - simple\\n  useEffect(() => {\\n    if (!showMap || !mapRef.current || !leafletLoaded) return;\\n\\n    const mapRenderer = mapRenderCallback || defaultMapRenderer;\\n    \\n    const mapInstance = mapRenderer({\\n      location: currentLocation,\\n      onLocationSelect: handleLocationSelect,\\n      mapContainer: mapRef.current,\\n      zoom,\\n      readonly: false,\\n      defaultLocation,\\n    });\\n\\n    mapInstanceRef.current = mapInstance;\\n\\n    // Apply tile provider if not default\\n    if (mapProvider !== \\\"openstreetmap\\\") {\\n      const tileConfig = TILE_PROVIDERS[mapProvider as keyof typeof TILE_PROVIDERS];\\n      if (tileConfig && 'switchTileLayer' in mapInstance) {\\n        (mapInstance as any).switchTileLayer(tileConfig);\\n      }\\n    }\\n\\n    return () => {\\n      if (mapInstance.cleanup) {\\n        mapInstance.cleanup();\\n      }\\n    };\\n  }, [showMap, leafletLoaded, currentLocation, handleLocationSelect, mapRenderCallback, zoom, defaultLocation, mapProvider]);\\n\\n  // Simple handlers - no complex state\\n  const handleGetCurrentLocation = () => {\\n    if (!enableGeolocation || !navigator.geolocation) {\\n      setGeoError(\\\"Geolocation is not supported by your browser\\\");\\n      return;\\n    }\\n\\n    navigator.geolocation.getCurrentPosition(\\n      (position) => {\\n        const location: LocationValue = {\\n          lat: position.coords.latitude,\\n          lng: position.coords.longitude,\\n          address: \\\"Current Location\\\",\\n        };\\n        handleLocationSelect(location);\\n      },\\n      (error) => {\\n        const errorMessages: Record<number, string> = {\\n          1: \\\"Location access denied. Please enable location permissions.\\\",\\n          2: \\\"Location unavailable. Please try again.\\\",\\n          3: \\\"Location request timed out. Please try again.\\\",\\n        };\\n        setGeoError(errorMessages[error.code] || \\\"Failed to get location\\\");\\n      }\\n    );\\n  };\\n\\n  const handleManualCoordinatesSubmit = () => {\\n    const lat = parseFloat(manualLat);\\n    const lng = parseFloat(manualLng);\\n    if (!isNaN(lat) && !isNaN(lng)) {\\n      const location: LocationValue = {\\n        lat,\\n        lng,\\n        address: `${lat}, ${lng}`,\\n      };\\n      handleLocationSelect(location);\\n      setIsManualDialogOpen(false);\\n      setManualLat(\\\"\\\");\\n      setManualLng(\\\"\\\");\\n    } else {\\n      setGeoError(\\\"Invalid coordinates. Please enter valid numbers.\\\");\\n    }\\n  };\\n\\n  const handleClearLocation = () => {\\n    setCurrentLocation(null);\\n    fieldApi.handleChange(null);\\n    setSearchQuery(\\\"\\\");\\n    setGeoError(null);\\n\\n    if (mapInstanceRef.current?.updateLocation) {\\n      mapInstanceRef.current.updateLocation(null);\\n    }\\n  };\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-3\\\">\\n        {/* Address Search Input */}\\n        {enableSearch && (\\n          <div className=\\\"relative\\\">\\n            <div className=\\\"relative\\\">\\n              <Input\\n                id={fieldApi.name}\\n                value={searchQuery}\\n                onChange={(e) => setSearchQuery(e.target.value)}\\n                placeholder={placeholder || searchPlaceholder}\\n                className={cn(\\n                  \\\"pl-10 pr-4\\\",\\n                  inputClassName,\\n                  uiOpts.searchInputClassName,\\n                  isSearching && \\\"animate-pulse\\\"\\n                )}\\n                onFocus={() => searchResults.length > 0 && setShowResults(true)}\\n                onBlur={() => setTimeout(() => setShowResults(false), 200)}\\n              />\\n              <div className=\\\"absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground\\\">\\n                {isSearching ? (\\n                  <div className=\\\"w-4 h-4 border-2 border-muted-foreground border-t-transparent rounded-full animate-spin\\\" />\\n                ) : (\\n                  <span className=\\\"text-sm\\\">🔍</span>\\n                )}\\n              </div>\\n              {searchQuery && (\\n                <button\\n                  type=\\\"button\\\"\\n                  onClick={() => {\\n                    setSearchQuery(\\\"\\\");\\n                    setSearchResults([]);\\n                    setShowResults(false);\\n                  }}\\n                  className=\\\"absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground\\\"\\n                >\\n                  ✕\\n                </button>\\n              )}\\n            </div>\\n\\n            {/* Enhanced Search Results */}\\n            {showResults && searchResults.length > 0 && (\\n              <Card className=\\\"absolute top-full left-0 right-0 z-[999] mt-1 max-h-60 overflow-y-auto shadow-lg border-2\\\">\\n                <div className=\\\"p-1\\\">\\n                  {searchResults.map((result) => (\\n                    <button\\n                      key={result.id}\\n                      type=\\\"button\\\"\\n                      className=\\\"w-full text-left p-3 hover:bg-muted/80 rounded-md text-sm transition-colors border-b border-border/50 last:border-b-0\\\"\\n                      onClick={() => handleLocationSelect(result)}\\n                    >\\n                      <div className=\\\"flex items-start gap-2\\\">\\n                        <span className=\\\"text-lg mt-0.5\\\">📍</span>\\n                        <div className=\\\"flex-1 min-w-0\\\">\\n                          <div className=\\\"font-medium text-foreground truncate\\\">\\n                            {result.address}\\n                          </div>\\n                          {showCoordinates && (\\n                            <div className=\\\"text-xs text-muted-foreground mt-1\\\">\\n                              {formatCoordinates(\\n                                result.lat,\\n                                result.lng,\\n                                coordinatesFormat\\n                              )}\\n                            </div>\\n                          )}\\n                          {result.city && (\\n                            <div className=\\\"text-xs text-muted-foreground/80 mt-0.5\\\">\\n                              {[result.city, result.state, result.country]\\n                                .filter(Boolean)\\n                                .join(\\\", \\\")}\\n                            </div>\\n                          )}\\n                        </div>\\n                      </div>\\n                    </button>\\n                  ))}\\n                </div>\\n              </Card>\\n            )}\\n\\n            {/* No Results Message */}\\n            {showResults &&\\n              searchResults.length === 0 &&\\n              !isSearching &&\\n              searchQuery.length >= minQueryLength && (\\n                <Card className=\\\"absolute top-full left-0 right-0 z-[70] mt-1 shadow-lg\\\">\\n                  <div className=\\\"p-4 text-center text-muted-foreground\\\">\\n                    <div className=\\\"text-2xl mb-2\\\">🗺️</div>\\n                    <div className=\\\"text-sm\\\">\\n                      No locations found for \\\"{searchQuery}\\\"\\n                    </div>\\n                    <div className=\\\"text-xs mt-1\\\">\\n                      Try a different search term or use coordinates\\n                    </div>\\n                  </div>\\n                </Card>\\n              )}\\n          </div>\\n        )}\\n\\n        {/* Action Buttons */}\\n        <div className=\\\"flex flex-wrap gap-2\\\">\\n          {enableGeolocation && (\\n            <Button\\n              type=\\\"button\\\"\\n              variant=\\\"outline\\\"\\n              size=\\\"sm\\\"\\n              onClick={handleGetCurrentLocation}\\n            >\\n              📍 Current Location\\n            </Button>\\n          )}\\n\\n          {enableManualEntry && (\\n            <Dialog\\n              open={isManualDialogOpen}\\n              onOpenChange={setIsManualDialogOpen}\\n            >\\n              <DialogTrigger asChild>\\n                <Button type=\\\"button\\\" variant=\\\"outline\\\" size=\\\"sm\\\">\\n                  🎯 Enter Coordinates\\n                </Button>\\n              </DialogTrigger>\\n              <DialogContent className=\\\"sm:max-w-[425px]\\\">\\n                <DialogHeader>\\n                  <DialogTitle>Enter Coordinates</DialogTitle>\\n                  <DialogDescription>\\n                    Enter the latitude and longitude coordinates.\\n                  </DialogDescription>\\n                </DialogHeader>\\n                <div className=\\\"grid gap-4 py-4\\\">\\n                  <div className=\\\"grid grid-cols-4 items-center gap-4\\\">\\n                    <Label htmlFor=\\\"latitude\\\" className=\\\"text-right\\\">\\n                      Latitude\\n                    </Label>\\n                    <Input\\n                      id=\\\"latitude\\\"\\n                      value={manualLat}\\n                      onChange={(e) => setManualLat(e.target.value)}\\n                      className=\\\"col-span-3\\\"\\n                      placeholder=\\\"e.g., 40.7128\\\"\\n                    />\\n                  </div>\\n                  <div className=\\\"grid grid-cols-4 items-center gap-4\\\">\\n                    <Label htmlFor=\\\"longitude\\\" className=\\\"text-right\\\">\\n                      Longitude\\n                    </Label>\\n                    <Input\\n                      id=\\\"longitude\\\"\\n                      value={manualLng}\\n                      onChange={(e) => setManualLng(e.target.value)}\\n                      className=\\\"col-span-3\\\"\\n                      placeholder=\\\"e.g., -74.0060\\\"\\n                    />\\n                  </div>\\n                </div>\\n                <DialogFooter>\\n                  <Button\\n                    type=\\\"button\\\"\\n                    variant=\\\"outline\\\"\\n                    onClick={() => setIsManualDialogOpen(false)}\\n                  >\\n                    Cancel\\n                  </Button>\\n                  <Button type=\\\"button\\\" onClick={handleManualCoordinatesSubmit}>\\n                    Set Location\\n                  </Button>\\n                </DialogFooter>\\n              </DialogContent>\\n            </Dialog>\\n          )}\\n\\n          {currentLocation && (\\n            <Button\\n              type=\\\"button\\\"\\n              variant=\\\"outline\\\"\\n              size=\\\"sm\\\"\\n              onClick={handleClearLocation}\\n            >\\n              🗑️ Clear\\n            </Button>\\n          )}\\n        </div>\\n\\n        {/* Map */}\\n        {showMap && (\\n          <div className=\\\"relative\\\">\\n            {!leafletLoaded && (\\n              <div className=\\\"absolute inset-0 flex items-center justify-center bg-muted rounded-md\\\">\\n                <div className=\\\"text-muted-foreground\\\">Loading map...</div>\\n              </div>\\n            )}\\n            <div\\n              ref={mapRef}\\n              className={cn(\\\"w-full border rounded-md\\\", uiOpts.mapClassName)}\\n              style={{ height: `${mapHeight}px`, minHeight: \\\"300px\\\" }}\\n            />\\n          </div>\\n        )}\\n\\n        {/* Location Display */}\\n        {currentLocation && (\\n          <div className=\\\"text-sm space-y-1\\\">\\n            {showAddress && currentLocation.address && (\\n              <div className=\\\"font-medium\\\">{currentLocation.address}</div>\\n            )}\\n            {showCoordinates && (\\n              <div className=\\\"text-muted-foreground\\\">\\n                📍{\\\" \\\"}\\n                {formatCoordinates(\\n                  currentLocation.lat,\\n                  currentLocation.lng,\\n                  coordinatesFormat\\n                )}\\n              </div>\\n            )}\\n            {currentLocation.city && (\\n              <div className=\\\"text-muted-foreground text-xs\\\">\\n                {[\\n                  currentLocation.city,\\n                  currentLocation.state,\\n                  currentLocation.country,\\n                ]\\n                  .filter(Boolean)\\n                  .join(\\\", \\\")}\\n              </div>\\n            )}\\n          </div>\\n        )}\\n\\n        {/* Error Display */}\\n        {geoError && (\\n          <div className=\\\"text-sm text-destructive bg-destructive/10 p-2 rounded-md\\\">\\n            {geoError}\\n          </div>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\",\n  \"/src/components/formedible/fields/masked-input-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect, useRef } from \\\"react\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\n\\ninterface MaskedInputFieldProps extends BaseFieldProps {\\n  maskedInputConfig?: {\\n    mask: string | ((value: string) => string);\\n    placeholder?: string;\\n    showMask?: boolean;\\n    guide?: boolean;\\n    keepCharPositions?: boolean;\\n    pipe?: (\\n      conformedValue: string,\\n      config: unknown\\n    ) => false | string | { value: string; indexesOfPipedChars: number[] };\\n  };\\n}\\n\\n// Common mask patterns\\nconst MASK_PATTERNS = {\\n  phone: \\\"(000) 000-0000\\\",\\n  ssn: \\\"000-00-0000\\\",\\n  creditCard: \\\"0000 0000 0000 0000\\\",\\n  date: \\\"00/00/0000\\\",\\n  time: \\\"00:00\\\",\\n  zipCode: \\\"00000\\\",\\n  zipCodeExtended: \\\"00000-0000\\\",\\n  currency: \\\"$0,000.00\\\",\\n};\\n\\nexport const MaskedInputField: React.FC<MaskedInputFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  wrapperClassName,\\n  labelClassName,\\n  inputClassName,\\n  maskedInputConfig = {},\\n}) => {\\n  const name = fieldApi.name;\\n\\n  const {\\n    mask = \\\"\\\",\\n    showMask = false,\\n    guide = true,\\n\\n    pipe,\\n  } = maskedInputConfig;\\n\\n  const [displayValue, setDisplayValue] = useState(\\\"\\\");\\n  const [rawValue, setRawValue] = useState(\\\"\\\");\\n  const inputRef = useRef<HTMLInputElement>(null);\\n\\n  // Apply mask to value\\n  const applyMask = React.useCallback(\\n    (value: string): string => {\\n      if (!mask) return value;\\n\\n      if (typeof mask === \\\"function\\\") {\\n        return mask(value);\\n      }\\n\\n      // Handle string mask patterns\\n      let maskedValue = \\\"\\\";\\n      let digitIndex = 0;\\n      let letterIndex = 0;\\n      const cleanDigits = value.replace(/\\\\D/g, \\\"\\\"); // Extract digits\\n      const cleanLetters = value.replace(/[^a-zA-Z]/g, \\\"\\\"); // Extract letters\\n\\n      for (let i = 0; i < mask.length; i++) {\\n        const maskChar = mask[i];\\n\\n        if (maskChar === \\\"0\\\" || maskChar === \\\"9\\\") {\\n          // Digit placeholder\\n          if (digitIndex < cleanDigits.length) {\\n            maskedValue += cleanDigits[digitIndex];\\n            digitIndex++;\\n          } else if (guide && showMask) {\\n            maskedValue += \\\"_\\\";\\n          } else {\\n            break; // Stop if no more digits and not showing guide\\n          }\\n        } else if (maskChar === \\\"A\\\" || maskChar === \\\"a\\\") {\\n          // Letter placeholder\\n          if (letterIndex < cleanLetters.length) {\\n            const char = cleanLetters[letterIndex];\\n            maskedValue +=\\n              maskChar === \\\"A\\\" ? char.toUpperCase() : char.toLowerCase();\\n            letterIndex++;\\n          } else if (guide && showMask) {\\n            maskedValue += \\\"_\\\";\\n          } else {\\n            break; // Stop if no more letters and not showing guide\\n          }\\n        } else {\\n          // Literal character\\n          maskedValue += maskChar;\\n        }\\n      }\\n\\n      // Apply pipe function if provided\\n      if (pipe) {\\n        const piped = pipe(maskedValue, { mask, guide, showMask });\\n        if (piped === false) {\\n          return displayValue; // Reject the change\\n        }\\n        if (typeof piped === \\\"string\\\") {\\n          return piped;\\n        }\\n        if (piped && typeof piped === \\\"object\\\" && piped.value) {\\n          return piped.value;\\n        }\\n      }\\n\\n      return maskedValue;\\n    },\\n    [mask, guide, showMask, pipe, displayValue]\\n  );\\n\\n  // Initialize from field value\\n  useEffect(() => {\\n    const value = fieldApi.state?.value || \\\"\\\";\\n    setRawValue(value);\\n    setDisplayValue(applyMask(value));\\n  }, [fieldApi.state?.value, applyMask]);\\n\\n  // Extract raw value from masked value\\n  const extractRawValue = (maskedValue: string): string => {\\n    if (!mask || typeof mask === \\\"function\\\") {\\n      return maskedValue;\\n    }\\n\\n    // For string masks, extract only the actual input characters\\n    let rawValue = \\\"\\\";\\n    let maskIndex = 0;\\n\\n    for (let i = 0; i < maskedValue.length && maskIndex < mask.length; i++) {\\n      const char = maskedValue[i];\\n      const maskChar = mask[maskIndex];\\n\\n      if (maskChar === \\\"0\\\" || maskChar === \\\"9\\\") {\\n        if (/\\\\d/.test(char)) {\\n          rawValue += char;\\n        }\\n        maskIndex++;\\n      } else if (maskChar === \\\"A\\\" || maskChar === \\\"a\\\") {\\n        if (/[a-zA-Z]/.test(char)) {\\n          rawValue += char;\\n        }\\n        maskIndex++;\\n      } else if (char === maskChar) {\\n        // Skip literal characters\\n        maskIndex++;\\n      } else {\\n        // Character doesn't match mask, skip it\\n        continue;\\n      }\\n    }\\n\\n    return rawValue;\\n  };\\n\\n  // Handle input change\\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const inputValue = e.target.value;\\n    const newRawValue = extractRawValue(inputValue);\\n    const newDisplayValue = applyMask(newRawValue);\\n\\n    setRawValue(newRawValue);\\n    setDisplayValue(newDisplayValue);\\n    fieldApi.handleChange(newRawValue);\\n  };\\n\\n  // Handle key down for better UX\\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\\n    const input = e.target as HTMLInputElement;\\n    const { selectionStart, selectionEnd } = input;\\n\\n    // Handle backspace to skip over literal characters\\n    if (\\n      e.key === \\\"Backspace\\\" &&\\n      selectionStart !== null &&\\n      selectionEnd !== null &&\\n      selectionStart === selectionEnd &&\\n      selectionStart > 0\\n    ) {\\n      const maskChar = typeof mask === \\\"string\\\" ? mask[selectionStart - 1] : \\\"\\\";\\n\\n      // If the previous character is a literal (not a placeholder), skip it\\n      if (\\n        maskChar &&\\n        maskChar !== \\\"0\\\" &&\\n        maskChar !== \\\"9\\\" &&\\n        maskChar !== \\\"A\\\" &&\\n        maskChar !== \\\"a\\\"\\n      ) {\\n        e.preventDefault();\\n        const newCursorPos = selectionStart - 1;\\n        setTimeout(() => {\\n          if (inputRef.current) {\\n            inputRef.current.setSelectionRange(newCursorPos, newCursorPos);\\n          }\\n        }, 0);\\n      }\\n    }\\n  };\\n\\n  // Get placeholder text\\n  const getPlaceholder = (): string => {\\n    if (placeholder) return placeholder;\\n    if (maskedInputConfig.placeholder) return maskedInputConfig.placeholder;\\n    if (showMask && typeof mask === \\\"string\\\") {\\n      return mask.replace(/[09Aa]/g, \\\"_\\\");\\n    }\\n    return \\\"\\\";\\n  };\\n\\n  return (\\n    <div className={cn(\\\"space-y-2\\\", wrapperClassName)}>\\n      {label && (\\n        <Label htmlFor={name} className={labelClassName}>\\n          {label}\\n        </Label>\\n      )}\\n\\n      {description && (\\n        <p className=\\\"text-sm text-muted-foreground\\\">{description}</p>\\n      )}\\n\\n      <Input\\n        ref={inputRef}\\n        id={name}\\n        name={name}\\n        value={displayValue}\\n        onChange={handleInputChange}\\n        onKeyDown={handleKeyDown}\\n        placeholder={getPlaceholder()}\\n        className={inputClassName}\\n      />\\n\\n      {/* Show mask pattern hint */}\\n      {mask && typeof mask === \\\"string\\\" && (\\n        <div className=\\\"text-xs text-muted-foreground\\\">\\n          Format: {mask.replace(/[09]/g, \\\"#\\\").replace(/[Aa]/g, \\\"A\\\")}\\n        </div>\\n      )}\\n\\n      {/* Show raw value for debugging */}\\n      {process.env.NODE_ENV === \\\"development\\\" && rawValue !== displayValue && (\\n        <div className=\\\"text-xs text-muted-foreground\\\">\\n          Raw value: {rawValue}\\n        </div>\\n      )}\\n\\n      {fieldApi.state?.meta?.errors &&\\n        fieldApi.state?.meta?.errors.length > 0 && (\\n          <p className=\\\"text-sm text-destructive\\\">\\n            {fieldApi.state?.meta?.errors[0]}\\n          </p>\\n        )}\\n    </div>\\n  );\\n};\\n\\n// Export common mask patterns for convenience\\nexport { MASK_PATTERNS };\\n\",\n  \"/src/components/formedible/fields/multi-select-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useRef, useEffect } from \\\"react\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { Badge } from \\\"@/components/ui/badge\\\";\\n\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { X, ChevronDown, Check } from \\\"lucide-react\\\";\\nimport type { MultiSelectFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nexport const MultiSelectField: React.FC<MultiSelectFieldSpecificProps> = ({\\n  fieldApi,\\n  options = [],\\n  multiSelectConfig = {},\\n\\n  ...wrapperProps\\n}) => {\\n  const {\\n    maxSelections = Infinity,\\n    searchable = true,\\n    creatable = false,\\n    placeholder = \\\"Select options...\\\",\\n    noOptionsText = \\\"No options found\\\",\\n  } = multiSelectConfig;\\n\\n  const selectedValues = Array.isArray(fieldApi.state?.value)\\n    ? fieldApi.state?.value\\n    : [];\\n\\n  const [isOpen, setIsOpen] = useState(false);\\n  const [searchQuery, setSearchQuery] = useState(\\\"\\\");\\n  const containerRef = useRef<HTMLDivElement>(null);\\n  const inputRef = useRef<HTMLInputElement>(null);\\n\\n  const normalizedOptions = options.map((option) =>\\n    typeof option === \\\"string\\\" ? { value: option, label: option } : option\\n  );\\n\\n  // Filter options based on search query\\n  const filteredOptions = normalizedOptions.filter(\\n    (option) =>\\n      option.label.toLowerCase().includes(searchQuery.toLowerCase()) ||\\n      option.value.toLowerCase().includes(searchQuery.toLowerCase())\\n  );\\n\\n  // Add create option if enabled and query doesn't match existing options\\n  const canCreate =\\n    creatable &&\\n    searchQuery.trim() &&\\n    !normalizedOptions.some(\\n      (opt) =>\\n        opt.value.toLowerCase() === searchQuery.toLowerCase() ||\\n        opt.label.toLowerCase() === searchQuery.toLowerCase()\\n    ) &&\\n    !selectedValues.includes(searchQuery.trim());\\n\\n  const displayOptions = [...filteredOptions];\\n  if (canCreate) {\\n    displayOptions.unshift({\\n      value: searchQuery.trim(),\\n      label: `Create \\\"${searchQuery.trim()}\\\"`,\\n      isCreateOption: true,\\n    } as { value: string; label: string; isCreateOption: true });\\n  }\\n\\n  // Close dropdown when clicking outside\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (\\n        containerRef.current &&\\n        !containerRef.current.contains(event.target as Node)\\n      ) {\\n        setIsOpen(false);\\n        setSearchQuery(\\\"\\\");\\n      }\\n    };\\n\\n    document.addEventListener(\\\"mousedown\\\", handleClickOutside);\\n    return () => document.removeEventListener(\\\"mousedown\\\", handleClickOutside);\\n  }, []);\\n\\n  const handleSelect = (optionValue: string) => {\\n    if (selectedValues.includes(optionValue)) {\\n      // Remove if already selected\\n      const newValues = selectedValues.filter((v) => v !== optionValue);\\n      fieldApi.handleChange(newValues);\\n    } else if (selectedValues.length < maxSelections) {\\n      // Add if not at max selections\\n      const newValues = [...selectedValues, optionValue];\\n      fieldApi.handleChange(newValues);\\n    }\\n\\n    setSearchQuery(\\\"\\\");\\n    if (!searchable) {\\n      setIsOpen(false);\\n    }\\n    inputRef.current?.focus();\\n  };\\n\\n  const handleRemove = (valueToRemove: string) => {\\n    const newValues = selectedValues.filter((v) => v !== valueToRemove);\\n    fieldApi.handleChange(newValues);\\n    fieldApi.handleBlur();\\n  };\\n\\n  const handleKeyDown = (e: React.KeyboardEvent) => {\\n    if (e.key === \\\"Backspace\\\" && !searchQuery && selectedValues.length > 0) {\\n      // Remove last selected item on backspace\\n      handleRemove(selectedValues[selectedValues.length - 1]);\\n    } else if (e.key === \\\"Enter\\\" && canCreate) {\\n      e.preventDefault();\\n      handleSelect(searchQuery.trim());\\n    } else if (e.key === \\\"Escape\\\") {\\n      setIsOpen(false);\\n      setSearchQuery(\\\"\\\");\\n    }\\n  };\\n\\n  const getSelectedLabels = () => {\\n    return selectedValues.map((value) => {\\n      const option = normalizedOptions.find((opt) => opt.value === value);\\n      return option ? option.label : value;\\n    });\\n  };\\n\\n  const isDisabled = fieldApi.form.state.isSubmitting;\\n\\n  return (\\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\\n      <div className=\\\"space-y-2\\\" ref={containerRef}>\\n        {wrapperProps.label && maxSelections < Infinity && (\\n          <div className=\\\"text-sm text-muted-foreground\\\">\\n            ({selectedValues.length}/{maxSelections})\\n          </div>\\n        )}\\n\\n        <div className=\\\"relative\\\">\\n          {/* Selected items display */}\\n          <div\\n            className={cn(\\n              \\\"min-h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background\\\",\\n              \\\"focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2\\\",\\n              fieldApi.state?.meta?.errors.length ? \\\"border-destructive\\\" : \\\"\\\",\\n              isDisabled ? \\\"opacity-50 cursor-not-allowed\\\" : \\\"cursor-text\\\"\\n            )}\\n            onClick={() => {\\n              if (!isDisabled) {\\n                setIsOpen(true);\\n                inputRef.current?.focus();\\n              }\\n            }}\\n          >\\n            <div className=\\\"flex flex-wrap gap-1 items-center\\\">\\n              {/* Selected tags */}\\n              {selectedValues.map((value, index) => {\\n                const label = getSelectedLabels()[index];\\n                return (\\n                  <Badge\\n                    key={value}\\n                    variant=\\\"secondary\\\"\\n                    className=\\\"text-xs h-6 px-2 gap-1\\\"\\n                  >\\n                    {label}\\n                    <Button\\n                      type=\\\"button\\\"\\n                      variant=\\\"ghost\\\"\\n                      size=\\\"sm\\\"\\n                      className=\\\"h-3 w-3 p-0 hover:bg-destructive hover:text-destructive-foreground\\\"\\n                      onClick={(e) => {\\n                        e.stopPropagation();\\n                        handleRemove(value);\\n                      }}\\n                      disabled={isDisabled}\\n                    >\\n                      <X className=\\\"h-2 w-2\\\" />\\n                    </Button>\\n                  </Badge>\\n                );\\n              })}\\n\\n              {/* Search input */}\\n              {searchable && (\\n                <Input\\n                  ref={inputRef}\\n                  value={searchQuery}\\n                  onChange={(e) => setSearchQuery(e.target.value)}\\n                  onKeyDown={handleKeyDown}\\n                  onFocus={() => setIsOpen(true)}\\n                  onBlur={fieldApi.handleBlur}\\n                  placeholder={selectedValues.length === 0 ? placeholder : \\\"\\\"}\\n                  className=\\\"border-0 p-0 h-6 focus-visible:ring-0 focus-visible:ring-offset-0 bg-transparent\\\"\\n                  disabled={\\n                    isDisabled || selectedValues.length >= maxSelections\\n                  }\\n                />\\n              )}\\n\\n              {/* Dropdown indicator */}\\n              <ChevronDown\\n                className={cn(\\n                  \\\"h-4 w-4 text-muted-foreground transition-transform ml-auto\\\",\\n                  isOpen ? \\\"rotate-180\\\" : \\\"\\\"\\n                )}\\n              />\\n            </div>\\n          </div>\\n\\n          {/* Dropdown */}\\n          {isOpen && (\\n            <div className=\\\"absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto\\\">\\n              {displayOptions.length === 0 ? (\\n                <div className=\\\"p-2 text-sm text-muted-foreground text-center\\\">\\n                  {noOptionsText}\\n                </div>\\n              ) : (\\n                displayOptions.map(\\n                  (\\n                    option: {\\n                      value: string;\\n                      label: string;\\n                      isCreateOption?: boolean;\\n                    },\\n                    index\\n                  ) => {\\n                    const isSelected = selectedValues.includes(option.value);\\n                    const isDisabled =\\n                      !isSelected && selectedValues.length >= maxSelections;\\n\\n                    return (\\n                      <button\\n                        key={`${option.value}-${index}`}\\n                        type=\\\"button\\\"\\n                        className={cn(\\n                          \\\"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\\\",\\n                          \\\"flex items-center justify-between\\\",\\n                          isSelected ? \\\"bg-accent\\\" : \\\"\\\",\\n                          isDisabled ? \\\"opacity-50 cursor-not-allowed\\\" : \\\"\\\",\\n                          option.isCreateOption\\n                            ? \\\"font-medium text-primary\\\"\\n                            : \\\"\\\"\\n                        )}\\n                        onClick={() =>\\n                          !isDisabled && handleSelect(option.value)\\n                        }\\n                        disabled={isDisabled}\\n                      >\\n                        <span>{option.label}</span>\\n                        {isSelected && <Check className=\\\"h-4 w-4\\\" />}\\n                      </button>\\n                    );\\n                  }\\n                )\\n              )}\\n            </div>\\n          )}\\n        </div>\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/number-field.tsx\": \"'use client';\\nimport React from 'react';\\nimport { Input } from '@/components/ui/input';\\nimport { cn } from '@/lib/utils';\\nimport type { NumberFieldSpecificProps } from '@/lib/formedible/types';\\nimport { FieldWrapper } from './base-field-wrapper';\\n\\n\\nexport const NumberField: React.FC<NumberFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  min,\\n  max,\\n  step,\\n}) => {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state?.value as number | string | undefined;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const val = e.target.value;\\n    let parsedValue: number | string | undefined;\\n    \\n    if (val === '') {\\n      parsedValue = undefined;\\n    } else {\\n      const num = parseFloat(val);\\n      parsedValue = isNaN(num) ? val : num;\\n    }\\n    \\n    fieldApi.handleChange(parsedValue);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  let displayValue: string | number = '';\\n  if (typeof value === 'number') {\\n    displayValue = value;\\n  } else if (typeof value === 'string') {\\n    displayValue = value;\\n  }\\n\\n  const computedInputClassName = cn(\\n    inputClassName,\\n    hasErrors ? \\\"border-destructive\\\" : \\\"\\\"\\n  );\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <Input\\n        id={name}\\n        name={name}\\n        type=\\\"number\\\"\\n        value={displayValue}\\n        onBlur={onBlur}\\n        onChange={onChange}\\n        placeholder={placeholder}\\n        className={computedInputClassName}\\n        disabled={isDisabled}\\n        min={min}\\n        max={max}\\n        step={step}\\n      />\\n    </FieldWrapper>\\n  );\\n};\",\n  \"/src/components/formedible/fields/object-field.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { Card, CardContent, CardHeader, CardTitle } from \\\"@/components/ui/card\\\";\\nimport type { BaseFieldProps, ObjectFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\nimport { NestedFieldRenderer } from \\\"./shared-field-renderer\\\";\\nimport { resolveDynamicText } from \\\"@/lib/formedible/template-interpolation\\\";\\n\\nexport const ObjectField: React.FC<ObjectFieldProps> = ({\\n  fieldApi,\\n  objectConfig,\\n  disabled,\\n  form,\\n  ...wrapperProps\\n}) => {\\n  const [isExpanded, setIsExpanded] = React.useState(\\n    objectConfig?.defaultExpanded !== false\\n  );\\n\\n  // Subscribe to form values for dynamic text resolution\\n  const [subscribedValues, setSubscribedValues] = React.useState(\\n    fieldApi.form?.state?.values || {}\\n  );\\n\\n  React.useEffect(() => {\\n    if (!fieldApi.form) return;\\n    const unsubscribe = fieldApi.form.store.subscribe((state) => {\\n      setSubscribedValues((state as any).values);\\n    });\\n    return unsubscribe;\\n  }, [fieldApi.form]);\\n\\n  // Create a properly typed mockFieldApi that includes the form property\\n  const createMockFieldApi = (fieldName: string, fieldValue: unknown) => {\\n    return {\\n      name: `${fieldApi.name}.${fieldName}`,\\n      form: fieldApi.form, // Include the form property to fix the bug\\n      state: {\\n        ...fieldApi.state,\\n        value: fieldValue,\\n        meta: {\\n          ...fieldApi.state.meta,\\n          errors: [], // Reset errors for subfield\\n          isTouched: false, // Reset touched state for subfield\\n        },\\n      },\\n      handleChange: (value: unknown) => {\\n        const currentValue = fieldApi.state?.value || {};\\n        fieldApi.handleChange({\\n          ...currentValue,\\n          [fieldName]: value,\\n        });\\n      },\\n      handleBlur: fieldApi.handleBlur,\\n    };\\n  };\\n\\n  const renderField = (subFieldConfig: any) => {\\n    const fieldValue = fieldApi.state?.value?.[subFieldConfig.name] || \\\"\\\";\\n    const mockFieldApi = createMockFieldApi(\\n      subFieldConfig.name,\\n      fieldValue\\n    ) as unknown as BaseFieldProps[\\\"fieldApi\\\"];\\n\\n    return (\\n      <div key={subFieldConfig.name}>\\n        <NestedFieldRenderer\\n          fieldConfig={subFieldConfig}\\n          fieldApi={mockFieldApi}\\n          form={form}\\n          currentValues={\\n            (fieldApi.state?.value || {}) as Record<string, unknown>\\n          }\\n        />\\n      </div>\\n    );\\n  };\\n\\n  const getLayoutClasses = () => {\\n    const layout = objectConfig?.layout || \\\"vertical\\\";\\n    const columns = objectConfig?.columns || 2;\\n\\n    switch (layout) {\\n      case \\\"horizontal\\\":\\n        return \\\"flex flex-wrap gap-4\\\";\\n      case \\\"grid\\\":\\n        return `grid grid-cols-1 md:grid-cols-${columns} gap-4`;\\n      default:\\n        return \\\"space-y-4\\\";\\n    }\\n  };\\n\\n  const content = (\\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\\n      <div className=\\\"space-y-4\\\">\\n        {/* Object title and description */}\\n        {(objectConfig?.title || objectConfig?.description) && (\\n          <div className=\\\"space-y-1\\\">\\n            {objectConfig?.title && (\\n              <div className=\\\"flex items-center justify-between\\\">\\n                <h4 className=\\\"text-sm font-medium text-muted-foreground\\\">\\n                  {resolveDynamicText(objectConfig.title, subscribedValues)}\\n                </h4>\\n                {objectConfig?.collapsible && (\\n                  <button\\n                    type=\\\"button\\\"\\n                    onClick={() => setIsExpanded(!isExpanded)}\\n                    className=\\\"text-xs text-muted-foreground hover:text-foreground\\\"\\n                  >\\n                    {isExpanded\\n                      ? resolveDynamicText(\\n                          objectConfig?.collapseLabel || \\\"Collapse\\\",\\n                          subscribedValues\\n                        )\\n                      : resolveDynamicText(\\n                          objectConfig?.expandLabel || \\\"Expand\\\",\\n                          subscribedValues\\n                        )}\\n                  </button>\\n                )}\\n              </div>\\n            )}\\n            {objectConfig?.description && (\\n              <p className=\\\"text-xs text-muted-foreground\\\">\\n                {resolveDynamicText(objectConfig.description, subscribedValues)}\\n              </p>\\n            )}\\n          </div>\\n        )}\\n\\n        {/* Fields */}\\n        {(!objectConfig?.collapsible || isExpanded) && (\\n          <>\\n            {objectConfig?.title && <div className=\\\"border-t my-4\\\" />}\\n            <div className={getLayoutClasses()}>\\n              {objectConfig?.fields?.map(renderField)}\\n            </div>\\n          </>\\n        )}\\n\\n        {/* Show field errors */}\\n        {fieldApi.state?.meta?.errors &&\\n          fieldApi.state?.meta?.errors.length > 0 && (\\n            <div className=\\\"text-sm text-destructive\\\">\\n              {fieldApi.state?.meta?.errors.join(\\\", \\\")}\\n            </div>\\n          )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n\\n  // Wrap in card if specified\\n  if (objectConfig?.showCard) {\\n    return (\\n      <Card className=\\\"w-full\\\">\\n        {(objectConfig?.title || objectConfig?.description) && (\\n          <CardHeader className=\\\"pb-3\\\">\\n            {objectConfig?.title && (\\n              <div className=\\\"flex items-center justify-between\\\">\\n                <CardTitle className=\\\"text-base\\\">\\n                  {resolveDynamicText(objectConfig.title, subscribedValues)}\\n                </CardTitle>\\n                {objectConfig?.collapsible && (\\n                  <button\\n                    type=\\\"button\\\"\\n                    onClick={() => setIsExpanded(!isExpanded)}\\n                    className=\\\"text-xs text-muted-foreground hover:text-foreground\\\"\\n                  >\\n                    {isExpanded\\n                      ? resolveDynamicText(\\n                          objectConfig?.collapseLabel || \\\"Collapse\\\",\\n                          subscribedValues\\n                        )\\n                      : resolveDynamicText(\\n                          objectConfig?.expandLabel || \\\"Expand\\\",\\n                          subscribedValues\\n                        )}\\n                  </button>\\n                )}\\n              </div>\\n            )}\\n            {objectConfig?.description && (\\n              <p className=\\\"text-sm text-muted-foreground mt-1\\\">\\n                {resolveDynamicText(objectConfig.description, subscribedValues)}\\n              </p>\\n            )}\\n          </CardHeader>\\n        )}\\n        <CardContent className=\\\"pt-0\\\">\\n          {(!objectConfig?.collapsible || isExpanded) && (\\n            <>\\n              <div className={getLayoutClasses()}>\\n                {objectConfig?.fields?.map(renderField)}\\n              </div>\\n            </>\\n          )}\\n\\n          {/* Show field errors */}\\n          {fieldApi.state?.meta?.errors &&\\n            fieldApi.state?.meta?.errors.length > 0 && (\\n              <div className=\\\"text-sm text-destructive mt-4\\\">\\n                {fieldApi.state?.meta?.errors.join(\\\", \\\")}\\n              </div>\\n            )}\\n        </CardContent>\\n      </Card>\\n    );\\n  }\\n\\n  return content;\\n};\\n\",\n  \"/src/components/formedible/fields/phone-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect } from \\\"react\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { ChevronDown, Phone } from \\\"lucide-react\\\";\\nimport type { PhoneFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\n// Common country codes and their formatting\\nconst COUNTRY_CODES = {\\n  US: {\\n    code: \\\"+1\\\",\\n    name: \\\"United States\\\",\\n    flag: \\\"🇺🇸\\\",\\n    format: \\\"(###) ###-####\\\",\\n  },\\n  CA: { code: \\\"+1\\\", name: \\\"Canada\\\", flag: \\\"🇨🇦\\\", format: \\\"(###) ###-####\\\" },\\n  GB: {\\n    code: \\\"+44\\\",\\n    name: \\\"United Kingdom\\\",\\n    flag: \\\"🇬🇧\\\",\\n    format: \\\"#### ### ####\\\",\\n  },\\n  FR: { code: \\\"+33\\\", name: \\\"France\\\", flag: \\\"🇫🇷\\\", format: \\\"## ## ## ## ##\\\" },\\n  DE: { code: \\\"+49\\\", name: \\\"Germany\\\", flag: \\\"🇩🇪\\\", format: \\\"### ### ####\\\" },\\n  IT: { code: \\\"+39\\\", name: \\\"Italy\\\", flag: \\\"🇮🇹\\\", format: \\\"### ### ####\\\" },\\n  ES: { code: \\\"+34\\\", name: \\\"Spain\\\", flag: \\\"🇪🇸\\\", format: \\\"### ### ###\\\" },\\n  AU: { code: \\\"+61\\\", name: \\\"Australia\\\", flag: \\\"🇦🇺\\\", format: \\\"#### ### ###\\\" },\\n  JP: { code: \\\"+81\\\", name: \\\"Japan\\\", flag: \\\"🇯🇵\\\", format: \\\"##-####-####\\\" },\\n  CN: { code: \\\"+86\\\", name: \\\"China\\\", flag: \\\"🇨🇳\\\", format: \\\"### #### ####\\\" },\\n  IN: { code: \\\"+91\\\", name: \\\"India\\\", flag: \\\"🇮🇳\\\", format: \\\"##### #####\\\" },\\n  BR: { code: \\\"+55\\\", name: \\\"Brazil\\\", flag: \\\"🇧🇷\\\", format: \\\"(##) #####-####\\\" },\\n  MX: { code: \\\"+52\\\", name: \\\"Mexico\\\", flag: \\\"🇲🇽\\\", format: \\\"## #### ####\\\" },\\n  RU: { code: \\\"+7\\\", name: \\\"Russia\\\", flag: \\\"🇷🇺\\\", format: \\\"### ###-##-##\\\" },\\n  KR: { code: \\\"+82\\\", name: \\\"South Korea\\\", flag: \\\"🇰🇷\\\", format: \\\"##-####-####\\\" },\\n};\\n\\nconst formatPhoneNumber = (value: string, format: string): string => {\\n  // Remove all non-digits\\n  const digits = value.replace(/\\\\D/g, \\\"\\\");\\n\\n  // Apply format pattern\\n  let formatted = \\\"\\\";\\n  let digitIndex = 0;\\n\\n  for (const char of format) {\\n    if (char === \\\"#\\\" && digitIndex < digits.length) {\\n      formatted += digits[digitIndex];\\n      digitIndex++;\\n    } else if (char !== \\\"#\\\") {\\n      formatted += char;\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  return formatted;\\n};\\n\\nconst extractDigits = (value: string): string => {\\n  return value.replace(/\\\\D/g, \\\"\\\");\\n};\\n\\nexport const PhoneField: React.FC<PhoneFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  phoneConfig = {},\\n}) => {\\n  const {\\n    defaultCountry = \\\"US\\\",\\n    format = \\\"national\\\",\\n    allowedCountries,\\n    placeholder,\\n  } = phoneConfig;\\n\\n  const value = (fieldApi.state?.value as string) || \\\"\\\";\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors =\\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const [selectedCountry, setSelectedCountry] = useState(defaultCountry);\\n  const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);\\n  const [phoneNumber, setPhoneNumber] = useState(\\\"\\\");\\n\\n  const availableCountries = allowedCountries\\n    ? Object.entries(COUNTRY_CODES).filter(([code]) =>\\n        allowedCountries.includes(code)\\n      )\\n    : Object.entries(COUNTRY_CODES);\\n\\n  const currentCountry =\\n    COUNTRY_CODES[selectedCountry as keyof typeof COUNTRY_CODES];\\n\\n  // Parse existing value on mount\\n  useEffect(() => {\\n    if (value) {\\n      // Try to extract country code and phone number\\n      const digits = extractDigits(value);\\n\\n      // Find matching country code\\n      const matchingCountry = Object.entries(COUNTRY_CODES).find(\\n        ([_, country]) => {\\n          const countryDigits = extractDigits(country.code);\\n          return digits.startsWith(countryDigits);\\n        }\\n      );\\n\\n      if (matchingCountry) {\\n        const [countryCode, countryData] = matchingCountry;\\n        setSelectedCountry(countryCode);\\n\\n        const countryCodeDigits = extractDigits(countryData.code);\\n        const phoneDigits = digits.slice(countryCodeDigits.length);\\n        setPhoneNumber(formatPhoneNumber(phoneDigits, countryData.format));\\n      } else {\\n        setPhoneNumber(value);\\n      }\\n    }\\n  }, [value]);\\n\\n  const handlePhoneNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const inputValue = e.target.value;\\n    const digits = extractDigits(inputValue);\\n\\n    // Format the phone number according to country format\\n    const formatted = formatPhoneNumber(digits, currentCountry.format);\\n    setPhoneNumber(formatted);\\n\\n    // Create the final value based on format preference\\n    const finalValue =\\n      format === \\\"international\\\"\\n        ? `${currentCountry.code} ${formatted}`.trim()\\n        : formatted;\\n\\n    fieldApi.handleChange(finalValue);\\n  };\\n\\n  const handleCountryChange = (countryCode: string) => {\\n    setSelectedCountry(countryCode);\\n    setIsCountryDropdownOpen(false);\\n\\n    // Update the value with new country code\\n    const newCountry = COUNTRY_CODES[countryCode as keyof typeof COUNTRY_CODES];\\n    const digits = extractDigits(phoneNumber);\\n    const formatted = formatPhoneNumber(digits, newCountry.format);\\n\\n    const finalValue =\\n      format === \\\"international\\\"\\n        ? `${newCountry.code} ${formatted}`.trim()\\n        : formatted;\\n\\n    fieldApi.handleChange(finalValue);\\n  };\\n\\n  const getPlaceholder = (): string => {\\n    if (placeholder) return placeholder;\\n\\n    const exampleNumber = formatPhoneNumber(\\n      \\\"1234567890\\\",\\n      currentCountry.format\\n    );\\n    return format === \\\"international\\\"\\n      ? `${currentCountry.code} ${exampleNumber}`\\n      : exampleNumber;\\n  };\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-2\\\">\\n        <div className=\\\"flex\\\">\\n          {/* Country selector */}\\n          <div className=\\\"relative\\\">\\n            <Button\\n              type=\\\"button\\\"\\n              variant=\\\"outline\\\"\\n              className={cn(\\n                \\\"rounded-r-none border-r-0 px-3 h-10 min-w-[80px]\\\",\\n                hasErrors ? \\\"border-destructive\\\" : \\\"\\\"\\n              )}\\n              onClick={() => setIsCountryDropdownOpen(!isCountryDropdownOpen)}\\n              disabled={isDisabled}\\n            >\\n              <span className=\\\"flex items-center gap-2\\\">\\n                <span className=\\\"text-base\\\">{currentCountry.flag}</span>\\n                {format === \\\"international\\\" && (\\n                  <span className=\\\"text-xs text-muted-foreground\\\">\\n                    {currentCountry.code}\\n                  </span>\\n                )}\\n                <ChevronDown className=\\\"h-3 w-3\\\" />\\n              </span>\\n            </Button>\\n\\n            {/* Country dropdown */}\\n            {isCountryDropdownOpen && (\\n              <div className=\\\"absolute z-50 top-full left-0 mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto min-w-[200px]\\\">\\n                {availableCountries.map(([code, country]) => (\\n                  <button\\n                    key={code}\\n                    type=\\\"button\\\"\\n                    className={cn(\\n                      \\\"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\\\",\\n                      \\\"flex items-center gap-3\\\",\\n                      selectedCountry === code ? \\\"bg-accent\\\" : \\\"\\\"\\n                    )}\\n                    onClick={() => handleCountryChange(code)}\\n                  >\\n                    <span className=\\\"text-base\\\">{country.flag}</span>\\n                    <div className=\\\"flex-1\\\">\\n                      <div className=\\\"font-medium\\\">{country.name}</div>\\n                      <div className=\\\"text-xs text-muted-foreground\\\">\\n                        {country.code}\\n                      </div>\\n                    </div>\\n                  </button>\\n                ))}\\n              </div>\\n            )}\\n          </div>\\n\\n          {/* Phone number input */}\\n          <Input\\n            value={phoneNumber}\\n            onChange={handlePhoneNumberChange}\\n            onBlur={() => fieldApi.handleBlur()}\\n            placeholder={getPlaceholder()}\\n            className={cn(\\n              \\\"rounded-l-none flex-1\\\",\\n              hasErrors ? \\\"border-destructive\\\" : \\\"\\\",\\n              inputClassName\\n            )}\\n            disabled={isDisabled}\\n          />\\n        </div>\\n\\n        {/* Format hint */}\\n        <div className=\\\"flex items-center gap-2 text-xs text-muted-foreground\\\">\\n          <Phone className=\\\"h-3 w-3\\\" />\\n          <span>\\n            Format: {currentCountry.format.replace(/#/g, \\\"0\\\")}\\n            {format === \\\"international\\\" && ` (${currentCountry.code})`}\\n          </span>\\n        </div>\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/radio-field.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { RadioGroup, RadioGroupItem } from \\\"@/components/ui/radio-group\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { RadioFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nexport const RadioField: React.FC<RadioFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  options = [],\\n  direction = \\\"vertical\\\",\\n}) => {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state?.value as string | undefined;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors =\\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const normalizedOptions = options.map((option) =>\\n    typeof option === \\\"string\\\" ? { value: option, label: option } : option\\n  );\\n\\n  const onValueChange = (value: string) => {\\n    fieldApi.handleChange(value);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <RadioGroup\\n        value={value || \\\"\\\"}\\n        onValueChange={onValueChange}\\n        onBlur={onBlur}\\n        disabled={isDisabled}\\n        className={cn(\\n          direction === \\\"horizontal\\\"\\n            ? \\\"flex flex-wrap gap-6\\\"\\n            : \\\"flex flex-col space-y-2\\\",\\n          inputClassName\\n        )}\\n      >\\n        {normalizedOptions.map((option, index) => (\\n          <div\\n            key={`${option.value}-${index}`}\\n            className=\\\"flex items-center space-x-2\\\"\\n          >\\n            <RadioGroupItem\\n              value={option.value}\\n              id={`${name}-${option.value}`}\\n              className={cn(hasErrors ? \\\"border-destructive\\\" : \\\"\\\")}\\n            />\\n            <Label\\n              htmlFor={`${name}-${option.value}`}\\n              className=\\\"text-sm font-normal cursor-pointer\\\"\\n            >\\n              {option.label}\\n            </Label>\\n          </div>\\n        ))}\\n      </RadioGroup>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/rating-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState } from \\\"react\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport { Star, Heart, ThumbsUp } from \\\"lucide-react\\\";\\nimport type { RatingFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nconst ICON_COMPONENTS = {\\n  star: Star,\\n  heart: Heart,\\n  thumbs: ThumbsUp,\\n};\\n\\nconst SIZE_CLASSES = {\\n  sm: \\\"h-4 w-4\\\",\\n  md: \\\"h-6 w-6\\\",\\n  lg: \\\"h-8 w-8\\\",\\n};\\n\\nexport const RatingField: React.FC<RatingFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  ratingConfig = {},\\n}) => {\\n  const {\\n    max = 5,\\n    allowHalf = false,\\n    icon = \\\"star\\\",\\n    size = \\\"md\\\",\\n    showValue = false,\\n  } = ratingConfig;\\n\\n  const value = (fieldApi.state?.value as number) || 0;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n\\n  const [hoverValue, setHoverValue] = useState<number | null>(null);\\n  const IconComponent = ICON_COMPONENTS[icon];\\n  const iconSizeClass = SIZE_CLASSES[size];\\n\\n  const handleRatingClick = (rating: number) => {\\n    fieldApi.handleChange(rating);\\n    fieldApi.handleBlur();\\n  };\\n\\n  const handleMouseEnter = (rating: number) => {\\n    if (!fieldApi.form.state.isSubmitting) {\\n      setHoverValue(rating);\\n    }\\n  };\\n\\n  const handleMouseLeave = () => {\\n    setHoverValue(null);\\n  };\\n\\n  const getRatingValue = (index: number, isHalf: boolean = false): number => {\\n    return isHalf ? index + 0.5 : index + 1;\\n  };\\n\\n  const shouldShowFilled = (\\n    index: number,\\n    isHalf: boolean = false\\n  ): boolean => {\\n    const ratingValue = getRatingValue(index, isHalf);\\n    const currentValue = hoverValue !== null ? hoverValue : value;\\n\\n    if (isHalf) {\\n      return currentValue >= ratingValue;\\n    } else {\\n      return (\\n        currentValue >= ratingValue ||\\n        (allowHalf && currentValue >= ratingValue - 0.5)\\n      );\\n    }\\n  };\\n\\n  const shouldShowHalfFilled = (index: number): boolean => {\\n    if (!allowHalf) return false;\\n\\n    const currentValue = hoverValue !== null ? hoverValue : value;\\n    const fullRating = index + 1;\\n    const halfRating = index + 0.5;\\n\\n    return currentValue >= halfRating && currentValue < fullRating;\\n  };\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-2\\\">\\n        {showValue && (\\n          <div className=\\\"text-xs text-muted-foreground\\\">\\n            ({value}/{max})\\n          </div>\\n        )}\\n\\n        <div className=\\\"flex items-center gap-1\\\">\\n          {Array.from({ length: max }, (_, index) => (\\n            <div key={index} className=\\\"relative\\\">\\n              {/* Full star/icon button */}\\n              <button\\n                type=\\\"button\\\"\\n                className={cn(\\n                  \\\"relative transition-all duration-150 hover:scale-110\\\",\\n                  isDisabled\\n                    ? \\\"cursor-not-allowed opacity-50\\\"\\n                    : \\\"cursor-pointer\\\"\\n                )}\\n                onClick={() =>\\n                  !isDisabled && handleRatingClick(getRatingValue(index, false))\\n                }\\n                onMouseEnter={() =>\\n                  !isDisabled && handleMouseEnter(getRatingValue(index, false))\\n                }\\n                onMouseLeave={handleMouseLeave}\\n                onBlur={() => fieldApi.handleBlur()}\\n                disabled={isDisabled}\\n                title={`Rate ${getRatingValue(index, false)} ${icon}${\\n                  getRatingValue(index, false) !== 1 ? \\\"s\\\" : \\\"\\\"\\n                }`}\\n              >\\n                <IconComponent\\n                  className={cn(\\n                    iconSizeClass,\\n                    \\\"transition-colors duration-150\\\",\\n                    shouldShowFilled(index, false)\\n                      ? icon === \\\"star\\\"\\n                        ? \\\"fill-yellow-400 text-yellow-400\\\"\\n                        : icon === \\\"heart\\\"\\n                        ? \\\"fill-red-500 text-red-500\\\"\\n                        : \\\"fill-blue-500 text-blue-500\\\"\\n                      : \\\"text-muted-foreground hover:text-muted-foreground/80\\\"\\n                  )}\\n                />\\n\\n                {/* Half-fill overlay for half ratings */}\\n                {allowHalf && shouldShowHalfFilled(index) && (\\n                  <div\\n                    className=\\\"absolute inset-0 overflow-hidden\\\"\\n                    style={{ width: \\\"50%\\\" }}\\n                  >\\n                    <IconComponent\\n                      className={cn(\\n                        iconSizeClass,\\n                        icon === \\\"star\\\"\\n                          ? \\\"fill-yellow-400 text-yellow-400\\\"\\n                          : icon === \\\"heart\\\"\\n                          ? \\\"fill-red-500 text-red-500\\\"\\n                          : \\\"fill-blue-500 text-blue-500\\\"\\n                      )}\\n                    />\\n                  </div>\\n                )}\\n              </button>\\n\\n              {/* Half star/icon button (if half ratings allowed) */}\\n              {allowHalf && (\\n                <button\\n                  type=\\\"button\\\"\\n                  className={cn(\\n                    \\\"absolute inset-0 w-1/2 transition-all duration-150\\\",\\n                    isDisabled ? \\\"cursor-not-allowed\\\" : \\\"cursor-pointer\\\"\\n                  )}\\n                  onClick={() =>\\n                    !isDisabled &&\\n                    handleRatingClick(getRatingValue(index, true))\\n                  }\\n                  onMouseEnter={() =>\\n                    !isDisabled && handleMouseEnter(getRatingValue(index, true))\\n                  }\\n                  onMouseLeave={handleMouseLeave}\\n                  disabled={isDisabled}\\n                  title={`Rate ${getRatingValue(index, true)} ${icon}s`}\\n                />\\n              )}\\n            </div>\\n          ))}\\n\\n          {/* Clear rating button */}\\n          {value > 0 && (\\n            <button\\n              type=\\\"button\\\"\\n              className={cn(\\n                \\\"ml-2 text-xs text-muted-foreground hover:text-foreground transition-colors\\\",\\n                isDisabled ? \\\"cursor-not-allowed opacity-50\\\" : \\\"cursor-pointer\\\"\\n              )}\\n              onClick={() => !isDisabled && handleRatingClick(0)}\\n              disabled={isDisabled}\\n              title=\\\"Clear rating\\\"\\n            >\\n              Clear\\n            </button>\\n          )}\\n        </div>\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/select-field.tsx\": \"import React from 'react';\\nimport {\\n  Select,\\n  SelectContent,\\n  SelectItem,\\n  SelectTrigger,\\n  SelectValue,\\n} from '@/components/ui/select';\\nimport { cn } from '@/lib/utils';\\nimport type { BaseFieldProps } from '@/lib/formedible/types';\\nimport { FieldWrapper } from './base-field-wrapper';\\n\\ninterface SelectFieldSpecificProps extends BaseFieldProps {\\n  options: Array<{ value: string; label: string }> | string[];\\n}\\n\\nexport const SelectField: React.FC<SelectFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  options = [],\\n}) => {\\n  const name = fieldApi.name;\\n  const value = (fieldApi.state?.value as string) || '';\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const onValueChange = (value: string) => {\\n    fieldApi.handleChange(value);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  const computedInputClassName = cn(\\n    inputClassName,\\n    hasErrors ? \\\"border-destructive\\\" : \\\"\\\"\\n  );\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <Select\\n        value={value}\\n        onValueChange={onValueChange}\\n        disabled={isDisabled}\\n      >\\n        <SelectTrigger\\n          id={name + \\\"-trigger\\\"}\\n          onBlur={onBlur}\\n          className={computedInputClassName}\\n        >\\n          <SelectValue placeholder={placeholder || \\\"Select an option\\\"} />\\n        </SelectTrigger>\\n        <SelectContent>\\n          {options.map((option, index) => {\\n            const optionValue = typeof option === 'string' ? option : option.value;\\n            const optionLabel = typeof option === 'string' ? option : option.label;\\n            return (\\n              <SelectItem key={optionValue + index} value={optionValue}>\\n                {optionLabel}\\n              </SelectItem>\\n            );\\n          })}\\n        </SelectContent>\\n      </Select>\\n    </FieldWrapper>\\n  );\\n};\",\n  \"/src/components/formedible/fields/shared-field-renderer.tsx\": \"\\\"use client\\\";\\nimport type { AnyFieldApi, AnyFormApi } from \\\"@tanstack/react-form\\\";\\nimport React from \\\"react\\\";\\nimport type { FieldComponentProps, FieldConfig } from \\\"@/lib/formedible/types\\\";\\nimport { resolveDynamicText } from \\\"@/lib/formedible/template-interpolation\\\";\\nimport { TextField } from \\\"./text-field\\\";\\nimport { TextareaField } from \\\"./textarea-field\\\";\\nimport { SelectField } from \\\"./select-field\\\";\\nimport { CheckboxField } from \\\"./checkbox-field\\\";\\nimport { SwitchField } from \\\"./switch-field\\\";\\nimport { NumberField } from \\\"./number-field\\\";\\nimport { DateField } from \\\"./date-field\\\";\\nimport { SliderField } from \\\"./slider-field\\\";\\nimport { FileUploadField } from \\\"./file-upload-field\\\";\\nimport { RadioField } from \\\"./radio-field\\\";\\nimport { MultiSelectField } from \\\"./multi-select-field\\\";\\nimport { ColorPickerField } from \\\"./color-picker-field\\\";\\nimport { RatingField } from \\\"./rating-field\\\";\\nimport { PhoneField } from \\\"./phone-field\\\";\\nimport { LocationPickerField } from \\\"./location-picker-field\\\";\\nimport { DurationPickerField } from \\\"./duration-picker-field\\\";\\nimport { AutocompleteField } from \\\"./autocomplete-field\\\";\\nimport { MaskedInputField } from \\\"./masked-input-field\\\";\\n\\nexport const FIELD_TYPE_COMPONENTS: Record<string, React.ComponentType<any>> = {\\n  text: TextField,\\n  email: TextField,\\n  password: TextField,\\n  url: TextField,\\n  tel: TextField,\\n  textarea: TextareaField,\\n  select: SelectField,\\n  checkbox: CheckboxField,\\n  switch: SwitchField,\\n  number: NumberField,\\n  date: DateField,\\n  slider: SliderField,\\n  file: FileUploadField,\\n  radio: RadioField,\\n  multiSelect: MultiSelectField,\\n  colorPicker: ColorPickerField,\\n  rating: RatingField,\\n  phone: PhoneField,\\n  location: LocationPickerField,\\n  duration: DurationPickerField,\\n  autocomplete: AutocompleteField,\\n  masked: MaskedInputField,\\n};\\n\\nexport const NestedFieldRenderer = <\\n  TFormValues extends Record<string, unknown>\\n>({\\n  fieldConfig,\\n  fieldApi,\\n  form,\\n  currentValues,\\n  resolveOptions,\\n}: SharedFieldRendererProps<TFormValues>) => {\\n  const formState = form?.state;\\n  const safeValues: TFormValues = (currentValues ??\\n    formState?.values ??\\n    {}) as TFormValues;\\n\\n  const [subscribedValues, setSubscribedValues] =\\n    React.useState<TFormValues>(safeValues);\\n\\n  React.useEffect(() => {\\n    if (!form) return;\\n    const unsubscribe = form.store.subscribe((state) => {\\n      setSubscribedValues((state as any).values as TFormValues);\\n    });\\n    return unsubscribe;\\n  }, [form]);\\n\\n  const {\\n    type,\\n    label: rawLabel,\\n    placeholder: rawPlaceholder,\\n    description: rawDescription,\\n    options,\\n    component: CustomComponent,\\n    conditional,\\n    arrayConfig,\\n    datalist,\\n    ratingConfig,\\n    phoneConfig,\\n    colorConfig,\\n    multiSelectConfig,\\n    locationConfig,\\n    durationConfig,\\n    autocompleteConfig,\\n    maskedInputConfig,\\n    objectConfig,\\n    sliderConfig,\\n    numberConfig,\\n    dateConfig,\\n    fileConfig,\\n    textareaConfig,\\n    passwordConfig,\\n    emailConfig,\\n    min,\\n    max,\\n    step,\\n    accept,\\n    multiple,\\n  } = fieldConfig;\\n\\n  const resolvedLabel = rawLabel\\n    ? resolveDynamicText(rawLabel, subscribedValues)\\n    : undefined;\\n  const resolvedPlaceholder = rawPlaceholder\\n    ? resolveDynamicText(rawPlaceholder, subscribedValues)\\n    : undefined;\\n  const resolvedDescription = rawDescription\\n    ? resolveDynamicText(rawDescription, subscribedValues)\\n    : undefined;\\n\\n  if (conditional && !conditional(currentValues || subscribedValues)) {\\n    return null;\\n  }\\n\\n  function renderActualField() {\\n    if (type === \\\"array\\\") {\\n      const ArrayField = require(\\\"./array-field\\\").ArrayField;\\n      return (\\n        <ArrayField\\n          fieldApi={fieldApi}\\n          label={resolvedLabel}\\n          description={resolvedDescription}\\n          placeholder={resolvedPlaceholder}\\n          arrayConfig={arrayConfig}\\n        />\\n      );\\n    }\\n\\n    if (type === \\\"object\\\") {\\n      const ObjectField = require(\\\"./object-field\\\").ObjectField;\\n      return (\\n        <ObjectField\\n          fieldApi={fieldApi}\\n          objectConfig={objectConfig}\\n          form={form}\\n          label={resolvedLabel}\\n          description={resolvedDescription}\\n          placeholder={resolvedPlaceholder}\\n        />\\n      );\\n    }\\n\\n    const FieldComponent =\\n      CustomComponent || FIELD_TYPE_COMPONENTS[type] || TextField;\\n\\n    const resolvedOptionsList =\\n      options && resolveOptions\\n        ? resolveOptions(options, subscribedValues)\\n        : Array.isArray(options)\\n        ? options.map((opt) =>\\n            typeof opt === \\\"string\\\" ? { value: opt, label: opt } : opt\\n          )\\n        : [];\\n\\n    const baseProps: FieldComponentProps = {\\n      fieldApi,\\n      label: resolvedLabel,\\n      placeholder: resolvedPlaceholder,\\n      description: resolvedDescription,\\n      min,\\n      max,\\n      step,\\n      accept,\\n      multiple,\\n    };\\n\\n    let props: FieldComponentProps = { ...baseProps };\\n\\n    if (type === \\\"select\\\" || type === \\\"radio\\\" || type === \\\"multiSelect\\\") {\\n      props.options = resolvedOptionsList;\\n    }\\n\\n    if ([\\\"text\\\", \\\"email\\\", \\\"password\\\", \\\"url\\\", \\\"tel\\\"].includes(type)) {\\n      props.type = type as any;\\n      props.datalist = datalist?.options;\\n    }\\n\\n    if (type === \\\"rating\\\") props.ratingConfig = ratingConfig;\\n    if (type === \\\"phone\\\") props.phoneConfig = phoneConfig;\\n    if (type === \\\"colorPicker\\\") props.colorConfig = colorConfig;\\n    if (type === \\\"multiSelect\\\") props.multiSelectConfig = multiSelectConfig;\\n    if (type === \\\"location\\\") props.locationConfig = locationConfig;\\n    if (type === \\\"duration\\\") props.durationConfig = durationConfig;\\n    if (type === \\\"autocomplete\\\") {\\n      props.autocompleteConfig =\\n        autocompleteConfig && resolveOptions\\n          ? {\\n              ...autocompleteConfig,\\n              options: resolveOptions(\\n                autocompleteConfig.options,\\n                subscribedValues\\n              ),\\n            }\\n          : autocompleteConfig;\\n    }\\n    if (type === \\\"masked\\\") props.maskedInputConfig = maskedInputConfig;\\n    if (type === \\\"slider\\\") props.sliderConfig = sliderConfig;\\n    if (type === \\\"number\\\") props.numberConfig = numberConfig;\\n    if (type === \\\"date\\\") props.dateConfig = dateConfig;\\n    if (type === \\\"file\\\") props.fileConfig = fileConfig;\\n    if (type === \\\"textarea\\\") props.textareaConfig = textareaConfig;\\n    if (type === \\\"password\\\") props.passwordConfig = passwordConfig;\\n    if (type === \\\"email\\\") props.emailConfig = emailConfig;\\n\\n    return <FieldComponent {...props} />;\\n  }\\n\\n  return renderActualField();\\n};\\n\\nexport interface SharedFieldRendererProps<\\n  TFormValues extends Record<string, unknown>\\n> {\\n  fieldConfig: FieldConfig & {\\n    crossFieldError?: string;\\n    asyncValidationState?: any;\\n    wrapperClassName?: string;\\n    labelClassName?: string;\\n    disabled?: boolean;\\n  };\\n  fieldApi: AnyFieldApi;\\n  form?: AnyFormApi;\\n  currentValues?: TFormValues;\\n  resolveOptions?: (\\n    options: FieldConfig[\\\"options\\\"],\\n    currentValues: TFormValues\\n  ) => { value: string; label: string }[];\\n}\\n\\nexport const SharedFieldRenderer = <\\n  TFormValues extends Record<string, unknown>\\n>({\\n  fieldConfig,\\n  fieldApi,\\n  form,\\n  currentValues,\\n  resolveOptions,\\n}: SharedFieldRendererProps<TFormValues>) => {\\n  const formState = form?.state;\\n  const safeValues: TFormValues = (currentValues ??\\n    formState?.values ??\\n    {}) as TFormValues;\\n\\n  const [subscribedValues, setSubscribedValues] =\\n    React.useState<TFormValues>(safeValues);\\n\\n  React.useEffect(() => {\\n    if (!form) return;\\n    const unsubscribe = form.store.subscribe((state) => {\\n      setSubscribedValues((state as any).values as TFormValues);\\n    });\\n    return unsubscribe;\\n  }, [form]);\\n\\n  const {\\n    type,\\n    label: rawLabel,\\n    placeholder: rawPlaceholder,\\n    description: rawDescription,\\n    options,\\n    component: CustomComponent,\\n    conditional,\\n    datalist,\\n    ratingConfig,\\n    phoneConfig,\\n    colorConfig,\\n    multiSelectConfig,\\n    locationConfig,\\n    durationConfig,\\n    autocompleteConfig,\\n    maskedInputConfig,\\n    sliderConfig,\\n    numberConfig,\\n    dateConfig,\\n    fileConfig,\\n    textareaConfig,\\n    passwordConfig,\\n    emailConfig,\\n    min,\\n    max,\\n    step,\\n    accept,\\n    multiple,\\n  } = fieldConfig;\\n\\n  const resolvedLabel = rawLabel\\n    ? resolveDynamicText(rawLabel, subscribedValues)\\n    : undefined;\\n  const resolvedPlaceholder = rawPlaceholder\\n    ? resolveDynamicText(rawPlaceholder, subscribedValues)\\n    : undefined;\\n  const resolvedDescription = rawDescription\\n    ? resolveDynamicText(rawDescription, subscribedValues)\\n    : undefined;\\n\\n  if (conditional && !conditional(currentValues || subscribedValues)) {\\n    return null;\\n  }\\n\\n  if (type === \\\"array\\\" || type === \\\"object\\\") {\\n    console.warn(\\n      `SharedFieldRenderer: ${type} fields should handle their own rendering to avoid circular dependencies`\\n    );\\n    return null;\\n  }\\n\\n  const FieldComponent =\\n    CustomComponent || FIELD_TYPE_COMPONENTS[type] || TextField;\\n\\n  const resolvedOptionsList =\\n    options && resolveOptions\\n      ? resolveOptions(options, subscribedValues)\\n      : Array.isArray(options)\\n      ? options.map((opt) =>\\n          typeof opt === \\\"string\\\" ? { value: opt, label: opt } : opt\\n        )\\n      : [];\\n\\n  const baseProps: FieldComponentProps = {\\n    fieldApi,\\n    label: resolvedLabel,\\n    placeholder: resolvedPlaceholder,\\n    description: resolvedDescription,\\n    min,\\n    max,\\n    step,\\n    accept,\\n    multiple,\\n  };\\n\\n  let props: FieldComponentProps = { ...baseProps };\\n\\n  if (type === \\\"select\\\" || type === \\\"radio\\\" || type === \\\"multiSelect\\\") {\\n    props.options = resolvedOptionsList;\\n  }\\n\\n  if ([\\\"text\\\", \\\"email\\\", \\\"password\\\", \\\"url\\\", \\\"tel\\\"].includes(type)) {\\n    props.type = type as any;\\n    props.datalist = datalist?.options;\\n  }\\n\\n  if (type === \\\"rating\\\") props.ratingConfig = ratingConfig;\\n  if (type === \\\"phone\\\") props.phoneConfig = phoneConfig;\\n  if (type === \\\"colorPicker\\\") props.colorConfig = colorConfig;\\n  if (type === \\\"multiSelect\\\") props.multiSelectConfig = multiSelectConfig;\\n  if (type === \\\"location\\\") props.locationConfig = locationConfig;\\n  if (type === \\\"duration\\\") props.durationConfig = durationConfig;\\n  if (type === \\\"autocomplete\\\") {\\n    props.autocompleteConfig =\\n      autocompleteConfig && resolveOptions\\n        ? {\\n            ...autocompleteConfig,\\n            options: resolveOptions(\\n              autocompleteConfig.options,\\n              subscribedValues\\n            ),\\n          }\\n        : autocompleteConfig;\\n  }\\n  if (type === \\\"masked\\\") props.maskedInputConfig = maskedInputConfig;\\n  if (type === \\\"slider\\\") props.sliderConfig = sliderConfig;\\n  if (type === \\\"number\\\") props.numberConfig = numberConfig;\\n  if (type === \\\"date\\\") props.dateConfig = dateConfig;\\n  if (type === \\\"file\\\") props.fileConfig = fileConfig;\\n  if (type === \\\"textarea\\\") props.textareaConfig = textareaConfig;\\n  if (type === \\\"password\\\") props.passwordConfig = passwordConfig;\\n  if (type === \\\"email\\\") props.emailConfig = emailConfig;\\n\\n  return <FieldComponent {...props} />;\\n};\\n\",\n  \"/src/components/formedible/fields/slider-field.tsx\": \"import React from \\\"react\\\";\\nimport { Slider } from \\\"@/components/ui/slider\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { SliderFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\n\\nexport const SliderField: React.FC<SliderFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  sliderConfig,\\n  // Backwards compatibility props\\n  min: directMin = 0,\\n  max: directMax = 100,\\n  step: directStep = 1,\\n  valueLabelPrefix: directPrefix = \\\"\\\",\\n  valueLabelSuffix: directSuffix = \\\"\\\",\\n  valueDisplayPrecision: directPrecision = 0,\\n  showRawValue: directShowRaw = false,\\n}) => {\\n  const name = fieldApi.name;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n\\n  // Use sliderConfig if provided, otherwise use direct props\\n  const config = sliderConfig || {\\n    min: directMin,\\n    max: directMax,\\n    step: directStep,\\n    valueLabelPrefix: directPrefix,\\n    valueLabelSuffix: directSuffix,\\n    valueDisplayPrecision: directPrecision,\\n    showRawValue: directShowRaw,\\n  };\\n\\n  const {\\n    min = 0,\\n    max = 100,\\n    step = 1,\\n    valueMapping,\\n    gradientColors,\\n    visualizationComponent: VisualizationComponent,\\n    valueLabelPrefix = \\\"\\\",\\n    valueLabelSuffix = \\\"\\\",\\n    valueDisplayPrecision = 0,\\n    showRawValue = false,\\n    showValue = true,\\n    marks = [],\\n  } = config;\\n\\n  const fieldValue =\\n    typeof fieldApi.state?.value === \\\"number\\\" ? fieldApi.state?.value : min;\\n\\n  // Get display value from mapping or calculate it\\n  const getDisplayValue = (sliderValue: number) => {\\n    if (valueMapping) {\\n      const mapping = valueMapping.find((m) => m.sliderValue === sliderValue);\\n      return mapping ? mapping.displayValue : sliderValue;\\n    }\\n    return sliderValue.toFixed(valueDisplayPrecision);\\n  };\\n\\n  const displayValue = getDisplayValue(fieldValue);\\n  const mappingItem = valueMapping?.find((m) => m.sliderValue === fieldValue);\\n\\n  const onValueChange = (valueArray: number[]) => {\\n    const newValue = valueArray[0];\\n    fieldApi.handleChange(newValue);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  // Custom label with value display\\n  const customLabel =\\n    label && showValue\\n      ? `${label} (${valueLabelPrefix}${displayValue}${valueLabelSuffix})`\\n      : label;\\n\\n  // Generate unique ID for this slider instance\\n  const sliderId = `slider-${name}-${Math.random().toString(36).substring(2, 9)}`;\\n  \\n  // Calculate current color based on slider value\\n  const getCurrentColor = () => {\\n    if (!gradientColors) return null;\\n    \\n    const percentage = ((fieldValue - min) / (max - min)) * 100;\\n    \\n    // Parse hex colors\\n    const startColor = gradientColors.start;\\n    const endColor = gradientColors.end;\\n    \\n    // Convert hex to RGB\\n    const hexToRgb = (hex: string) => {\\n      const result = /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(hex);\\n      return result ? {\\n        r: parseInt(result[1], 16),\\n        g: parseInt(result[2], 16),\\n        b: parseInt(result[3], 16)\\n      } : null;\\n    };\\n    \\n    const startRgb = hexToRgb(startColor);\\n    const endRgb = hexToRgb(endColor);\\n    \\n    if (!startRgb || !endRgb) return startColor;\\n    \\n    // Interpolate between start and end colors\\n    const r = Math.round(startRgb.r + (endRgb.r - startRgb.r) * (percentage / 100));\\n    const g = Math.round(startRgb.g + (endRgb.g - startRgb.g) * (percentage / 100));\\n    const b = Math.round(startRgb.b + (endRgb.b - startRgb.b) * (percentage / 100));\\n    \\n    return `rgb(${r}, ${g}, ${b})`;\\n  };\\n  \\n  const currentColor = getCurrentColor();\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={customLabel}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"space-y-4\\\">\\n        {showRawValue && (\\n          <div className=\\\"text-xs text-muted-foreground\\\">\\n            Raw: {fieldApi.state?.value}\\n          </div>\\n        )}\\n\\n        {/* Custom visualization component if provided */}\\n        {VisualizationComponent && valueMapping && (\\n          <div className=\\\"flex justify-between items-center mb-2\\\">\\n            {valueMapping.map((mapping, index) => (\\n              <div\\n                key={index}\\n                className=\\\"cursor-pointer\\\"\\n                onClick={() => fieldApi.handleChange(mapping.sliderValue)}\\n              >\\n                <VisualizationComponent\\n                  value={mapping.sliderValue}\\n                  displayValue={mapping.displayValue}\\n                  label={mapping.label}\\n                  isActive={fieldValue === mapping.sliderValue}\\n                />\\n              </div>\\n            ))}\\n          </div>\\n        )}\\n\\n        <div className=\\\"relative\\\">\\n          {gradientColors && currentColor && (\\n            <style>{`\\n              .${sliderId} [data-slot=\\\"slider-range\\\"] {\\n                background: ${currentColor} !important;\\n              }\\n            `}</style>\\n          )}\\n          <Slider\\n            id={name}\\n            name={name}\\n            value={[fieldValue]}\\n            onValueChange={onValueChange}\\n            onBlur={onBlur}\\n            disabled={isDisabled}\\n            min={min}\\n            max={max}\\n            step={step}\\n            className={cn(inputClassName, gradientColors && sliderId)}\\n          />\\n\\n          {/* Marks display */}\\n          {marks.length > 0 && (\\n            <div className=\\\"flex justify-between text-xs text-muted-foreground mt-2\\\">\\n              {marks.map((mark, index) => (\\n                <span key={index} className=\\\"text-center\\\">\\n                  {mark.label}\\n                </span>\\n              ))}\\n            </div>\\n          )}\\n        </div>\\n\\n        {/* Display current mapping info */}\\n        {mappingItem?.label && (\\n          <div className=\\\"text-sm text-muted-foreground text-center\\\">\\n            {mappingItem.label}\\n          </div>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\",\n  \"/src/components/formedible/fields/switch-field.tsx\": \"import React from \\\"react\\\";\\nimport { Switch } from \\\"@/components/ui/switch\\\";\\nimport { Label } from \\\"@/components/ui/label\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { BaseFieldProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\nexport const SwitchField: React.FC<BaseFieldProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n}) => {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state?.value as boolean | undefined;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n\\n  const onCheckedChange = (checked: boolean) => {\\n    fieldApi.handleChange(checked);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  return (\\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\\n    // because Switch components need the label positioned next to (not above) the control\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={undefined}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"flex items-center space-x-2\\\">\\n        <Switch\\n          id={name}\\n          checked={!!value}\\n          onCheckedChange={onCheckedChange}\\n          onBlur={onBlur}\\n          disabled={isDisabled}\\n          aria-describedby={description ? `${name}-description` : undefined}\\n        />\\n        {label && (\\n          <Label\\n            htmlFor={name}\\n            className={cn(\\n              \\\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\\\",\\n              labelClassName\\n            )}\\n          >\\n            {label}\\n          </Label>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/text-field.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useEffect, useCallback, useMemo } from \\\"react\\\";\\nimport { Input } from \\\"@/components/ui/input\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { TextFieldSpecificProps } from \\\"@/lib/formedible/types\\\";\\nimport { FieldWrapper } from \\\"./base-field-wrapper\\\";\\n\\n\\nexport const TextField: React.FC<TextFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  type = \\\"text\\\",\\n  datalist,\\n}) => {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state?.value as string | number | undefined;\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  // Datalist state\\n  const [datalistOptions, setDatalistOptions] = useState<string[]>(\\n    datalist?.options || []\\n  );\\n  const [isLoadingOptions, setIsLoadingOptions] = useState(false);\\n  const [lastQuery, setLastQuery] = useState(\\\"\\\");\\n\\n  // Debounced async options fetching\\n  const fetchAsyncOptions = useCallback(\\n    async (query: string) => {\\n      if (!datalist?.asyncOptions) return;\\n\\n      const minChars = datalist.minChars || 1;\\n      if (query.length < minChars) {\\n        setDatalistOptions(datalist.options || []);\\n        return;\\n      }\\n\\n      if (query === lastQuery) return;\\n\\n      setIsLoadingOptions(true);\\n      setLastQuery(query);\\n\\n      try {\\n        const results = await datalist.asyncOptions(query);\\n        const maxResults = datalist.maxResults || 10;\\n        const limitedResults = results.slice(0, maxResults);\\n\\n        // Combine static options with async results\\n        const staticOptions = datalist.options || [];\\n        const combinedOptions = [...staticOptions, ...limitedResults];\\n\\n        // Remove duplicates\\n        const uniqueOptions = Array.from(new Set(combinedOptions));\\n\\n        setDatalistOptions(uniqueOptions);\\n      } catch (error) {\\n        console.error(\\\"Error fetching datalist options:\\\", error);\\n        // Fallback to static options on error\\n        setDatalistOptions(datalist.options || []);\\n      } finally {\\n        setIsLoadingOptions(false);\\n      }\\n    },\\n    [datalist, lastQuery]\\n  );\\n\\n  // Debounced effect for async options\\n  useEffect(() => {\\n    if (!datalist?.asyncOptions) return;\\n\\n    const debounceMs = datalist.debounceMs || 300;\\n    const currentValue = String(value || \\\"\\\");\\n\\n    const timeoutId = setTimeout(() => {\\n      fetchAsyncOptions(currentValue);\\n    }, debounceMs);\\n\\n    return () => clearTimeout(timeoutId);\\n  }, [value, fetchAsyncOptions, datalist]);\\n\\n  // Generate unique datalist id\\n  const datalistId = useMemo(\\n    () => (datalist ? `${name}-datalist` : undefined),\\n    [name, datalist]\\n  );\\n\\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    fieldApi.handleChange(e.target.value);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  const computedInputClassName = cn(\\n    inputClassName,\\n    hasErrors ? \\\"border-destructive\\\" : \\\"\\\",\\n    isLoadingOptions ? \\\"pr-8\\\" : \\\"\\\"\\n  );\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <div className=\\\"relative\\\">\\n        <Input\\n          id={name}\\n          name={name}\\n          type={type}\\n          value={value === undefined || value === null ? \\\"\\\" : String(value)}\\n          onBlur={onBlur}\\n          onChange={onChange}\\n          placeholder={placeholder}\\n          className={computedInputClassName}\\n          disabled={isDisabled}\\n          list={datalistId}\\n          autoComplete={datalist ? \\\"off\\\" : undefined}\\n        />\\n        {isLoadingOptions && (\\n          <div className=\\\"absolute right-2 top-1/2 transform -translate-y-1/2\\\">\\n            <span className=\\\"text-xs text-muted-foreground\\\">Loading...</span>\\n          </div>\\n        )}\\n        {datalist && datalistOptions.length > 0 && (\\n          <datalist id={datalistId}>\\n            {datalistOptions.map((option, index) => (\\n              <option key={`${option}-${index}`} value={option} />\\n            ))}\\n          </datalist>\\n        )}\\n      </div>\\n    </FieldWrapper>\\n  );\\n};\\n\",\n  \"/src/components/formedible/fields/textarea-field.tsx\": \"import React from 'react';\\nimport { Textarea } from '@/components/ui/textarea';\\nimport { cn } from '@/lib/utils';\\nimport type { TextareaFieldSpecificProps } from '@/lib/formedible/types';\\nimport { FieldWrapper } from './base-field-wrapper';\\n\\n\\nexport const TextareaField: React.FC<TextareaFieldSpecificProps> = ({\\n  fieldApi,\\n  label,\\n  description,\\n  placeholder,\\n  inputClassName,\\n  labelClassName,\\n  wrapperClassName,\\n  rows = 3,\\n}) => {\\n  const name = fieldApi.name;\\n  const value = (fieldApi.state?.value as string) || '';\\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\\n\\n  const onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\\n    fieldApi.handleChange(e.target.value);\\n  };\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  const computedInputClassName = cn(\\n    inputClassName,\\n    hasErrors ? \\\"border-destructive\\\" : \\\"\\\"\\n  );\\n\\n  return (\\n    <FieldWrapper\\n      fieldApi={fieldApi}\\n      label={label}\\n      description={description}\\n      inputClassName={inputClassName}\\n      labelClassName={labelClassName}\\n      wrapperClassName={wrapperClassName}\\n    >\\n      <Textarea\\n        id={name}\\n        name={name}\\n        value={value}\\n        onBlur={onBlur}\\n        onChange={onChange}\\n        placeholder={placeholder}\\n        rows={rows}\\n        className={computedInputClassName}\\n        disabled={isDisabled}\\n      />\\n    </FieldWrapper>\\n  );\\n};\",\n  \"/src/components/formedible/layout/form-accordion.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from \\\"@/components/ui/accordion\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { FormAccordionProps } from \\\"@/lib/formedible/types\\\";\\n\\n\\nexport const FormAccordion: React.FC<FormAccordionProps> = ({\\n  children,\\n  sections,\\n  type = 'single',\\n  className,\\n}) => {\\n  return (\\n    <div className={cn(\\\"space-y-4\\\", className)}>\\n      {children}\\n      \\n      {type === 'single' ? (\\n        <Accordion \\n          type=\\\"single\\\" \\n          defaultValue={sections.find(s => s.defaultOpen)?.id}\\n          collapsible\\n        >\\n          {sections.map((section) => (\\n            <AccordionItem key={section.id} value={section.id}>\\n              <AccordionTrigger>{section.title}</AccordionTrigger>\\n              <AccordionContent>\\n                <div className=\\\"space-y-4\\\">\\n                  {section.content}\\n                </div>\\n              </AccordionContent>\\n            </AccordionItem>\\n          ))}\\n        </Accordion>\\n      ) : (\\n        <Accordion \\n          type=\\\"multiple\\\" \\n          defaultValue={sections.filter(s => s.defaultOpen).map(s => s.id)}\\n        >\\n          {sections.map((section) => (\\n            <AccordionItem key={section.id} value={section.id}>\\n              <AccordionTrigger>{section.title}</AccordionTrigger>\\n              <AccordionContent>\\n                <div className=\\\"space-y-4\\\">\\n                  {section.content}\\n                </div>\\n              </AccordionContent>\\n            </AccordionItem>\\n          ))}\\n        </Accordion>\\n      )}\\n    </div>\\n  );\\n};\",\n  \"/src/components/formedible/layout/form-grid.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { FormGridProps } from \\\"@/lib/formedible/types\\\";\\n\\nexport interface GridItemProps {\\n  gridColumn?: number;\\n  gridRow?: number;\\n  gridColumnSpan?: number;\\n  gridRowSpan?: number;\\n  gridArea?: string;\\n  children: React.ReactNode;\\n}\\n\\nexport const GridItem: React.FC<GridItemProps> = ({\\n  gridColumn,\\n  gridRow,\\n  gridColumnSpan,\\n  gridRowSpan,\\n  gridArea,\\n  children,\\n}) => {\\n  const gridStyles: React.CSSProperties = {};\\n  \\n  if (gridArea) {\\n    gridStyles.gridArea = gridArea;\\n  } else {\\n    if (gridColumn) {\\n      if (gridColumnSpan) {\\n        gridStyles.gridColumn = `${gridColumn} / span ${gridColumnSpan}`;\\n      } else {\\n        gridStyles.gridColumnStart = gridColumn;\\n      }\\n    }\\n    if (gridRow) {\\n      if (gridRowSpan) {\\n        gridStyles.gridRow = `${gridRow} / span ${gridRowSpan}`;\\n      } else {\\n        gridStyles.gridRowStart = gridRow;\\n      }\\n    }\\n    if (gridColumnSpan && !gridColumn) {\\n      gridStyles.gridColumn = `span ${gridColumnSpan}`;\\n    }\\n    if (gridRowSpan && !gridRow) {\\n      gridStyles.gridRow = `span ${gridRowSpan}`;\\n    }\\n  }\\n\\n  return (\\n    <div style={gridStyles}>\\n      {children}\\n    </div>\\n  );\\n};\\n\\nexport const FormGrid: React.FC<FormGridProps> = ({\\n  children,\\n  columns = 2,\\n  gap = \\\"4\\\",\\n  responsive = false,\\n  className,\\n}) => {\\n  // Filter out null, undefined, and false children to prevent empty grid cells\\n  const validChildren = React.Children.toArray(children).filter(\\n    // @ts-expect-error raf de ta mr2\\n    (child) => child !== null && child !== undefined && child !== false\\n  );\\n  // If no valid children, render nothing\\n  if (validChildren.length === 0) {\\n    return null;\\n  }\\n\\n  // Use the requested columns, capped at 12 for sanity\\n  const actualColumns = Math.min(columns, 12);\\n  const gapClasses = {\\n    \\\"0\\\": \\\"gap-0\\\",\\n    \\\"1\\\": \\\"gap-1\\\",\\n    \\\"2\\\": \\\"gap-2\\\",\\n    \\\"3\\\": \\\"gap-3\\\",\\n    \\\"4\\\": \\\"gap-4\\\",\\n    \\\"5\\\": \\\"gap-5\\\",\\n    \\\"6\\\": \\\"gap-6\\\",\\n    \\\"7\\\": \\\"gap-7\\\",\\n    \\\"8\\\": \\\"gap-8\\\",\\n    \\\"9\\\": \\\"gap-9\\\",\\n    \\\"10\\\": \\\"gap-10\\\",\\n    \\\"11\\\": \\\"gap-11\\\",\\n    \\\"12\\\": \\\"gap-12\\\",\\n    \\\"sm\\\": \\\"gap-2\\\",\\n    \\\"md\\\": \\\"gap-4\\\",\\n    \\\"lg\\\": \\\"gap-6\\\",\\n    \\\"xl\\\": \\\"gap-8\\\",\\n  };\\n\\n  const gridColsClasses = {\\n    1: \\\"grid-cols-1\\\",\\n    2: \\\"grid-cols-2\\\",\\n    3: \\\"grid-cols-3\\\",\\n    4: \\\"grid-cols-4\\\",\\n    5: \\\"grid-cols-5\\\",\\n    6: \\\"grid-cols-6\\\",\\n    7: \\\"grid-cols-7\\\",\\n    8: \\\"grid-cols-8\\\",\\n    9: \\\"grid-cols-9\\\",\\n    10: \\\"grid-cols-10\\\",\\n    11: \\\"grid-cols-11\\\",\\n    12: \\\"grid-cols-12\\\",\\n  };\\n\\n  const gridClasses = cn(\\n    \\\"grid\\\",\\n    gapClasses[gap as keyof typeof gapClasses],\\n    responsive\\n      ? {\\n          \\\"grid-cols-1\\\": actualColumns >= 2, // Start with 1 column on small screens when we have 2+ columns\\n          \\\"sm:grid-cols-2\\\": actualColumns >= 2,\\n          \\\"md:grid-cols-3\\\": actualColumns >= 3,\\n          \\\"lg:grid-cols-4\\\": actualColumns >= 4 && columns >= 4,\\n        }\\n      : gridColsClasses[actualColumns as keyof typeof gridColsClasses],\\n    className\\n  );\\n\\n  return <div className={gridClasses}>{validChildren}</div>;\\n};\\n\",\n  \"/src/components/formedible/layout/form-stepper.tsx\": \"\\\"use client\\\";\\nimport React, { useState } from \\\"react\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { FormStepperProps } from \\\"@/lib/formedible/types\\\";\\n\\nexport const FormStepper: React.FC<FormStepperProps> = ({\\n  children,\\n  steps,\\n  currentStep = 0,\\n  onStepChange,\\n  onComplete,\\n  className,\\n  allowSkip = false,\\n  showStepNumbers = true,\\n}) => {\\n  const [activeStep, setActiveStep] = useState(currentStep);\\n  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());\\n\\n  const handleStepChange = (stepIndex: number) => {\\n    setActiveStep(stepIndex);\\n    onStepChange?.(stepIndex);\\n  };\\n\\n  const markStepComplete = (stepIndex: number) => {\\n    setCompletedSteps((prev) => new Set(prev).add(stepIndex));\\n  };\\n\\n  const handleNext = () => {\\n    // Mark current step as completed when moving to next\\n    markStepComplete(activeStep);\\n\\n    if (activeStep < steps.length - 1) {\\n      handleStepChange(activeStep + 1);\\n    } else {\\n      onComplete?.();\\n    }\\n  };\\n\\n  const handlePrevious = () => {\\n    if (activeStep > 0) {\\n      handleStepChange(activeStep - 1);\\n    }\\n  };\\n\\n  const handleSkip = () => {\\n    if (allowSkip && steps[activeStep]?.optional) {\\n      handleNext();\\n    }\\n  };\\n\\n  const canGoToStep = (stepIndex: number) => {\\n    // Can go to current step, previous steps, or next step if current is completed\\n    return stepIndex <= activeStep || completedSteps.has(stepIndex - 1);\\n  };\\n\\n  const isStepCompleted = (stepIndex: number) => {\\n    return completedSteps.has(stepIndex);\\n  };\\n\\n  const isStepActive = (stepIndex: number) => {\\n    return stepIndex === activeStep;\\n  };\\n\\n  return (\\n    <div className={cn(\\\"space-y-6\\\", className)}>\\n      {children}\\n\\n      {/* Step indicator */}\\n      <div className=\\\"flex items-center justify-between\\\">\\n        {steps.map((step, index) => (\\n          <React.Fragment key={step.id}>\\n            <div className=\\\"flex flex-col items-center\\\">\\n              <button\\n                type=\\\"button\\\"\\n                onClick={() => canGoToStep(index) && handleStepChange(index)}\\n                disabled={!canGoToStep(index)}\\n                aria-label={`Go to step ${index + 1}: ${step.title}`}\\n                aria-current={isStepActive(index) ? \\\"step\\\" : undefined}\\n                tabIndex={canGoToStep(index) ? 0 : -1}\\n                className={cn(\\n                  \\\"w-10 h-10 rounded-full border-2 flex items-center justify-center text-sm font-medium transition-colors\\\",\\n                  isStepActive(index) &&\\n                    \\\"border-primary bg-primary text-primary-foreground\\\",\\n                  isStepCompleted(index) &&\\n                    !isStepActive(index) &&\\n                    \\\"border-primary bg-primary text-primary-foreground\\\",\\n                  !isStepActive(index) &&\\n                    !isStepCompleted(index) &&\\n                    \\\"border-muted-foreground text-muted-foreground\\\",\\n                  canGoToStep(index) && \\\"cursor-pointer hover:border-primary\\\",\\n                  !canGoToStep(index) && \\\"cursor-not-allowed opacity-50\\\"\\n                )}\\n              >\\n                {isStepCompleted(index)\\n                  ? \\\"✓\\\"\\n                  : showStepNumbers\\n                  ? index + 1\\n                  : \\\"○\\\"}\\n              </button>\\n\\n              <div className=\\\"mt-2 text-center\\\">\\n                <div\\n                  className={cn(\\n                    \\\"text-sm font-medium\\\",\\n                    isStepActive(index) && \\\"text-primary\\\",\\n                    !isStepActive(index) && \\\"text-muted-foreground\\\"\\n                  )}\\n                >\\n                  {step.title}\\n                  {step.optional && (\\n                    <span className=\\\"text-xs text-muted-foreground ml-1\\\">\\n                      (optional)\\n                    </span>\\n                  )}\\n                </div>\\n                {step.description && (\\n                  <div className=\\\"text-xs text-muted-foreground mt-1\\\">\\n                    {step.description}\\n                  </div>\\n                )}\\n              </div>\\n            </div>\\n\\n            {/* Connector line */}\\n            {index < steps.length - 1 && (\\n              <div\\n                className={cn(\\n                  \\\"flex-1 h-0.5 mx-4\\\",\\n                  isStepCompleted(index) ? \\\"bg-primary\\\" : \\\"bg-muted\\\"\\n                )}\\n              />\\n            )}\\n          </React.Fragment>\\n        ))}\\n      </div>\\n\\n      {/* Step content */}\\n      <div className=\\\"min-h-[200px]\\\">{steps[activeStep]?.content}</div>\\n\\n      {/* Navigation buttons */}\\n      <div className=\\\"flex justify-between\\\">\\n        <Button\\n          type=\\\"button\\\"\\n          variant=\\\"outline\\\"\\n          onClick={handlePrevious}\\n          disabled={activeStep === 0}\\n        >\\n          Previous\\n        </Button>\\n\\n        <div className=\\\"flex gap-2\\\">\\n          {allowSkip && steps[activeStep]?.optional && (\\n            <Button type=\\\"button\\\" variant=\\\"ghost\\\" onClick={handleSkip}>\\n              Skip\\n            </Button>\\n          )}\\n\\n          <Button type=\\\"button\\\" onClick={handleNext}>\\n            {activeStep === steps.length - 1 ? \\\"Complete\\\" : \\\"Next\\\"}\\n          </Button>\\n        </div>\\n      </div>\\n    </div>\\n  );\\n};\\n\",\n  \"/src/components/formedible/layout/form-tabs.tsx\": \"\\\"use client\\\";\\nimport React from \\\"react\\\";\\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \\\"@/components/ui/tabs\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type { FormTabsProps, DynamicText } from \\\"@/lib/formedible/types\\\";\\nimport type { FormedibleFormApi } from \\\"@/lib/formedible/types\\\";\\nimport { resolveDynamicText } from \\\"@/lib/formedible/template-interpolation\\\";\\nimport type { TemplateOptions } from \\\"@/lib/formedible/template-interpolation\\\";\\n\\n\\n// Enhanced FormTabs props to support dynamic labels\\nexport interface EnhancedFormTabsProps<TFormValues extends Record<string, unknown>> {\\n  children?: React.ReactNode;\\n  tabs: {\\n    id: string;\\n    label: DynamicText;\\n    content: React.ReactNode;\\n  }[];\\n  activeTab: string;\\n  className?: string;\\n  onTabChange: (tabId: string) => void;\\n  form?: FormedibleFormApi<TFormValues>;\\n  templateOptions?: TemplateOptions;\\n}\\n\\n// PURE DISPLAY COMPONENT - NO STATE, NO RERENDERS\\nexport const FormTabs: React.FC<FormTabsProps> = ({\\n  children,\\n  tabs,\\n  activeTab,\\n  className,\\n  onTabChange,\\n}) => {\\n  return (\\n    <div className={cn(\\\"space-y-4\\\", className)}>\\n      {children}\\n      \\n      <Tabs value={activeTab} onValueChange={onTabChange}>\\n        <TabsList className=\\\"grid w-full\\\" style={{ gridTemplateColumns: `repeat(${tabs.length}, 1fr)` }}>\\n          {tabs.map((tab) => (\\n            <TabsTrigger key={tab.id} value={tab.id}>\\n              {tab.label}\\n            </TabsTrigger>\\n          ))}\\n        </TabsList>\\n        \\n        {tabs.map((tab) => (\\n          <TabsContent key={tab.id} value={tab.id} className=\\\"space-y-4\\\">\\n            {tab.content}\\n          </TabsContent>\\n        ))}\\n      </Tabs>\\n    </div>\\n  );\\n};\\n\\n// Enhanced FormTabs component that supports dynamic labels\\nexport const EnhancedFormTabs = <TFormValues extends Record<string, unknown>>({\\n  children,\\n  tabs,\\n  activeTab,\\n  className,\\n  onTabChange,\\n  form,\\n  templateOptions,\\n}: EnhancedFormTabsProps<TFormValues>) => {\\n  const [formValues, setFormValues] = React.useState<TFormValues>(\\n    (form?.state?.values || {}) as TFormValues\\n  );\\n\\n  React.useEffect(() => {\\n    if (!form) return;\\n    const unsubscribe = form.store.subscribe((state) => {\\n      setFormValues((state as any).values as TFormValues);\\n    });\\n    return unsubscribe;\\n  }, [form]);\\n\\n  return (\\n    <div className={cn(\\\"space-y-4\\\", className)}>\\n      {children}\\n      \\n      <Tabs value={activeTab} onValueChange={onTabChange}>\\n        <TabsList className=\\\"grid w-full\\\" style={{ gridTemplateColumns: `repeat(${tabs.length}, 1fr)` }}>\\n          {tabs.map((tab) => (\\n            <TabsTrigger key={tab.id} value={tab.id}>\\n              {form ? \\n                resolveDynamicText(tab.label, formValues as Record<string, unknown>, templateOptions) || ''\\n              : (\\n                typeof tab.label === 'string' ? tab.label : ''\\n              )}\\n            </TabsTrigger>\\n          ))}\\n        </TabsList>\\n        \\n        {tabs.map((tab) => (\\n          <TabsContent key={tab.id} value={tab.id} className=\\\"space-y-4\\\">\\n            {tab.content}\\n          </TabsContent>\\n        ))}\\n      </Tabs>\\n    </div>\\n  );\\n};\",\n  \"/src/components/ui/accordion.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as AccordionPrimitive from \\\"@radix-ui/react-accordion\\\"\\nimport { ChevronDown } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Accordion = AccordionPrimitive.Root\\n\\nconst AccordionItem = React.forwardRef<\\n  React.ElementRef<typeof AccordionPrimitive.Item>,\\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\\n>(({ className, ...props }, ref) => (\\n  <AccordionPrimitive.Item\\n    ref={ref}\\n    className={cn(\\\"border-b\\\", className)}\\n    {...props}\\n  />\\n))\\nAccordionItem.displayName = \\\"AccordionItem\\\"\\n\\nconst AccordionTrigger = React.forwardRef<\\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\\n>(({ className, children, ...props }, ref) => (\\n  <AccordionPrimitive.Header className=\\\"flex\\\">\\n    <AccordionPrimitive.Trigger\\n      ref={ref}\\n      className={cn(\\n        \\\"flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180\\\",\\n        className\\n      )}\\n      {...props}\\n    >\\n      {children}\\n      <ChevronDown className=\\\"h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200\\\" />\\n    </AccordionPrimitive.Trigger>\\n  </AccordionPrimitive.Header>\\n))\\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\\n\\nconst AccordionContent = React.forwardRef<\\n  React.ElementRef<typeof AccordionPrimitive.Content>,\\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\\n>(({ className, children, ...props }, ref) => (\\n  <AccordionPrimitive.Content\\n    ref={ref}\\n    className=\\\"overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\\\"\\n    {...props}\\n  >\\n    <div className={cn(\\\"pb-4 pt-0\\\", className)}>{children}</div>\\n  </AccordionPrimitive.Content>\\n))\\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\\n\\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\\n\",\n  \"/src/components/ui/alert.tsx\": \"import * as React from \\\"react\\\"\\nimport { cva, type VariantProps } from \\\"class-variance-authority\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst alertVariants = cva(\\n  \\\"relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7\\\",\\n  {\\n    variants: {\\n      variant: {\\n        default: \\\"bg-background text-foreground\\\",\\n        destructive:\\n          \\\"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\\\",\\n      },\\n    },\\n    defaultVariants: {\\n      variant: \\\"default\\\",\\n    },\\n  }\\n)\\n\\nconst Alert = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\\n>(({ className, variant, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    role=\\\"alert\\\"\\n    className={cn(alertVariants({ variant }), className)}\\n    {...props}\\n  />\\n))\\nAlert.displayName = \\\"Alert\\\"\\n\\nconst AlertTitle = React.forwardRef<\\n  HTMLParagraphElement,\\n  React.HTMLAttributes<HTMLHeadingElement>\\n>(({ className, ...props }, ref) => (\\n  <h5\\n    ref={ref}\\n    className={cn(\\\"mb-1 font-medium leading-none tracking-tight\\\", className)}\\n    {...props}\\n  />\\n))\\nAlertTitle.displayName = \\\"AlertTitle\\\"\\n\\nconst AlertDescription = React.forwardRef<\\n  HTMLParagraphElement,\\n  React.HTMLAttributes<HTMLParagraphElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\\"text-sm [&_p]:leading-relaxed\\\", className)}\\n    {...props}\\n  />\\n))\\nAlertDescription.displayName = \\\"AlertDescription\\\"\\n\\nexport { Alert, AlertTitle, AlertDescription }\\n\",\n  \"/src/components/ui/badge.tsx\": \"import * as React from \\\"react\\\"\\nimport { cva, type VariantProps } from \\\"class-variance-authority\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst badgeVariants = cva(\\n  \\\"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\\\",\\n  {\\n    variants: {\\n      variant: {\\n        default:\\n          \\\"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\\\",\\n        secondary:\\n          \\\"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\\\",\\n        destructive:\\n          \\\"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\\\",\\n        outline: \\\"text-foreground\\\",\\n      },\\n    },\\n    defaultVariants: {\\n      variant: \\\"default\\\",\\n    },\\n  }\\n)\\n\\nexport interface BadgeProps\\n  extends React.HTMLAttributes<HTMLDivElement>,\\n    VariantProps<typeof badgeVariants> {}\\n\\nfunction Badge({ className, variant, ...props }: BadgeProps) {\\n  return (\\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\\n  )\\n}\\n\\nexport { Badge, badgeVariants }\\n\",\n  \"/src/components/ui/button.tsx\": \"import * as React from \\\"react\\\"\\nimport { Slot } from \\\"@radix-ui/react-slot\\\"\\nimport { cva, type VariantProps } from \\\"class-variance-authority\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst buttonVariants = cva(\\n  \\\"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\\\",\\n  {\\n    variants: {\\n      variant: {\\n        default:\\n          \\\"bg-primary text-primary-foreground shadow hover:bg-primary/90\\\",\\n        destructive:\\n          \\\"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\\\",\\n        outline:\\n          \\\"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\\\",\\n        secondary:\\n          \\\"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\\\",\\n        ghost: \\\"hover:bg-accent hover:text-accent-foreground\\\",\\n        link: \\\"text-primary underline-offset-4 hover:underline\\\",\\n      },\\n      size: {\\n        default: \\\"h-9 px-4 py-2\\\",\\n        sm: \\\"h-8 rounded-md px-3 text-xs\\\",\\n        lg: \\\"h-10 rounded-md px-8\\\",\\n        icon: \\\"h-9 w-9\\\",\\n      },\\n    },\\n    defaultVariants: {\\n      variant: \\\"default\\\",\\n      size: \\\"default\\\",\\n    },\\n  }\\n)\\n\\nexport interface ButtonProps\\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\\n    VariantProps<typeof buttonVariants> {\\n  asChild?: boolean\\n}\\n\\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\\n    const Comp = asChild ? Slot : \\\"button\\\"\\n    return (\\n      <Comp\\n        className={cn(buttonVariants({ variant, size, className }))}\\n        ref={ref}\\n        {...props}\\n      />\\n    )\\n  }\\n)\\nButton.displayName = \\\"Button\\\"\\n\\nexport { Button, buttonVariants }\\n\",\n  \"/src/components/ui/calendar.tsx\": \"import * as React from \\\"react\\\"\\nimport {\\n  ChevronDownIcon,\\n  ChevronLeftIcon,\\n  ChevronRightIcon,\\n} from \\\"lucide-react\\\"\\nimport { DayButton, DayPicker, getDefaultClassNames } from \\\"react-day-picker\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\nimport { Button, buttonVariants } from \\\"@/components/ui/button\\\"\\n\\nfunction Calendar({\\n  className,\\n  classNames,\\n  showOutsideDays = true,\\n  captionLayout = \\\"label\\\",\\n  buttonVariant = \\\"ghost\\\",\\n  formatters,\\n  components,\\n  ...props\\n}: React.ComponentProps<typeof DayPicker> & {\\n  buttonVariant?: React.ComponentProps<typeof Button>[\\\"variant\\\"]\\n}) {\\n  const defaultClassNames = getDefaultClassNames()\\n\\n  return (\\n    <DayPicker\\n      showOutsideDays={showOutsideDays}\\n      className={cn(\\n        \\\"bg-background group/calendar p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent\\\",\\n        String.raw`rtl:**:[.rdp-button\\\\_next>svg]:rotate-180`,\\n        String.raw`rtl:**:[.rdp-button\\\\_previous>svg]:rotate-180`,\\n        className\\n      )}\\n      captionLayout={captionLayout}\\n      formatters={{\\n        formatMonthDropdown: (date) =>\\n          date.toLocaleString(\\\"default\\\", { month: \\\"short\\\" }),\\n        ...formatters,\\n      }}\\n      classNames={{\\n        root: cn(\\\"w-fit\\\", defaultClassNames.root),\\n        months: cn(\\n          \\\"relative flex flex-col gap-4 md:flex-row\\\",\\n          defaultClassNames.months\\n        ),\\n        month: cn(\\\"flex w-full flex-col gap-4\\\", defaultClassNames.month),\\n        nav: cn(\\n          \\\"absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1\\\",\\n          defaultClassNames.nav\\n        ),\\n        button_previous: cn(\\n          buttonVariants({ variant: buttonVariant }),\\n          \\\"h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50\\\",\\n          defaultClassNames.button_previous\\n        ),\\n        button_next: cn(\\n          buttonVariants({ variant: buttonVariant }),\\n          \\\"h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50\\\",\\n          defaultClassNames.button_next\\n        ),\\n        month_caption: cn(\\n          \\\"flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]\\\",\\n          defaultClassNames.month_caption\\n        ),\\n        dropdowns: cn(\\n          \\\"flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium\\\",\\n          defaultClassNames.dropdowns\\n        ),\\n        dropdown_root: cn(\\n          \\\"has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border\\\",\\n          defaultClassNames.dropdown_root\\n        ),\\n        dropdown: cn(\\n          \\\"bg-popover absolute inset-0 opacity-0\\\",\\n          defaultClassNames.dropdown\\n        ),\\n        caption_label: cn(\\n          \\\"select-none font-medium\\\",\\n          captionLayout === \\\"label\\\"\\n            ? \\\"text-sm\\\"\\n            : \\\"[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5\\\",\\n          defaultClassNames.caption_label\\n        ),\\n        table: \\\"w-full border-collapse\\\",\\n        weekdays: cn(\\\"flex\\\", defaultClassNames.weekdays),\\n        weekday: cn(\\n          \\\"text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal\\\",\\n          defaultClassNames.weekday\\n        ),\\n        week: cn(\\\"mt-2 flex w-full\\\", defaultClassNames.week),\\n        week_number_header: cn(\\n          \\\"w-[--cell-size] select-none\\\",\\n          defaultClassNames.week_number_header\\n        ),\\n        week_number: cn(\\n          \\\"text-muted-foreground select-none text-[0.8rem]\\\",\\n          defaultClassNames.week_number\\n        ),\\n        day: cn(\\n          \\\"group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md\\\",\\n          defaultClassNames.day\\n        ),\\n        range_start: cn(\\n          \\\"bg-accent rounded-l-md\\\",\\n          defaultClassNames.range_start\\n        ),\\n        range_middle: cn(\\\"rounded-none\\\", defaultClassNames.range_middle),\\n        range_end: cn(\\\"bg-accent rounded-r-md\\\", defaultClassNames.range_end),\\n        today: cn(\\n          \\\"bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none\\\",\\n          defaultClassNames.today\\n        ),\\n        outside: cn(\\n          \\\"text-muted-foreground aria-selected:text-muted-foreground\\\",\\n          defaultClassNames.outside\\n        ),\\n        disabled: cn(\\n          \\\"text-muted-foreground opacity-50\\\",\\n          defaultClassNames.disabled\\n        ),\\n        hidden: cn(\\\"invisible\\\", defaultClassNames.hidden),\\n        ...classNames,\\n      }}\\n      components={{\\n        Root: ({ className, rootRef, ...props }) => {\\n          return (\\n            <div\\n              data-slot=\\\"calendar\\\"\\n              ref={rootRef}\\n              className={cn(className)}\\n              {...props}\\n            />\\n          )\\n        },\\n        Chevron: ({ className, orientation, ...props }) => {\\n          if (orientation === \\\"left\\\") {\\n            return (\\n              <ChevronLeftIcon className={cn(\\\"size-4\\\", className)} {...props} />\\n            )\\n          }\\n\\n          if (orientation === \\\"right\\\") {\\n            return (\\n              <ChevronRightIcon\\n                className={cn(\\\"size-4\\\", className)}\\n                {...props}\\n              />\\n            )\\n          }\\n\\n          return (\\n            <ChevronDownIcon className={cn(\\\"size-4\\\", className)} {...props} />\\n          )\\n        },\\n        DayButton: CalendarDayButton,\\n        WeekNumber: ({ children, ...props }) => {\\n          return (\\n            <td {...props}>\\n              <div className=\\\"flex size-[--cell-size] items-center justify-center text-center\\\">\\n                {children}\\n              </div>\\n            </td>\\n          )\\n        },\\n        ...components,\\n      }}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction CalendarDayButton({\\n  className,\\n  day,\\n  modifiers,\\n  ...props\\n}: React.ComponentProps<typeof DayButton>) {\\n  const defaultClassNames = getDefaultClassNames()\\n\\n  const ref = React.useRef<HTMLButtonElement>(null)\\n  React.useEffect(() => {\\n    if (modifiers.focused) ref.current?.focus()\\n  }, [modifiers.focused])\\n\\n  return (\\n    <Button\\n      ref={ref}\\n      variant=\\\"ghost\\\"\\n      size=\\\"icon\\\"\\n      data-day={day.date.toLocaleDateString()}\\n      data-selected-single={\\n        modifiers.selected &&\\n        !modifiers.range_start &&\\n        !modifiers.range_end &&\\n        !modifiers.range_middle\\n      }\\n      data-range-start={modifiers.range_start}\\n      data-range-end={modifiers.range_end}\\n      data-range-middle={modifiers.range_middle}\\n      className={cn(\\n        \\\"data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] [&>span]:text-xs [&>span]:opacity-70\\\",\\n        defaultClassNames.day,\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport { Calendar, CalendarDayButton }\\n\",\n  \"/src/components/ui/card.tsx\": \"import * as React from \\\"react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Card = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\n      \\\"rounded-xl border bg-card text-card-foreground shadow\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nCard.displayName = \\\"Card\\\"\\n\\nconst CardHeader = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\\"flex flex-col space-y-1.5 p-6\\\", className)}\\n    {...props}\\n  />\\n))\\nCardHeader.displayName = \\\"CardHeader\\\"\\n\\nconst CardTitle = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\\"font-semibold leading-none tracking-tight\\\", className)}\\n    {...props}\\n  />\\n))\\nCardTitle.displayName = \\\"CardTitle\\\"\\n\\nconst CardDescription = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\\"text-sm text-muted-foreground\\\", className)}\\n    {...props}\\n  />\\n))\\nCardDescription.displayName = \\\"CardDescription\\\"\\n\\nconst CardContent = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div ref={ref} className={cn(\\\"p-6 pt-0\\\", className)} {...props} />\\n))\\nCardContent.displayName = \\\"CardContent\\\"\\n\\nconst CardFooter = React.forwardRef<\\n  HTMLDivElement,\\n  React.HTMLAttributes<HTMLDivElement>\\n>(({ className, ...props }, ref) => (\\n  <div\\n    ref={ref}\\n    className={cn(\\\"flex items-center p-6 pt-0\\\", className)}\\n    {...props}\\n  />\\n))\\nCardFooter.displayName = \\\"CardFooter\\\"\\n\\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\\n\",\n  \"/src/components/ui/checkbox.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as CheckboxPrimitive from \\\"@radix-ui/react-checkbox\\\"\\nimport { Check } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Checkbox = React.forwardRef<\\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\\n>(({ className, ...props }, ref) => (\\n  <CheckboxPrimitive.Root\\n    ref={ref}\\n    className={cn(\\n      \\\"peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <CheckboxPrimitive.Indicator\\n      className={cn(\\\"flex items-center justify-center text-current\\\")}\\n    >\\n      <Check className=\\\"h-4 w-4\\\" />\\n    </CheckboxPrimitive.Indicator>\\n  </CheckboxPrimitive.Root>\\n))\\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\\n\\nexport { Checkbox }\\n\",\n  \"/src/components/ui/dialog.tsx\": \"import * as React from \\\"react\\\"\\nimport * as DialogPrimitive from \\\"@radix-ui/react-dialog\\\"\\nimport { X } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Dialog = DialogPrimitive.Root\\n\\nconst DialogTrigger = DialogPrimitive.Trigger\\n\\nconst DialogPortal = DialogPrimitive.Portal\\n\\nconst DialogClose = DialogPrimitive.Close\\n\\nconst DialogOverlay = React.forwardRef<\\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\\n>(({ className, ...props }, ref) => (\\n  <DialogPrimitive.Overlay\\n    ref={ref}\\n    className={cn(\\n      \\\"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\\n\\nconst DialogContent = React.forwardRef<\\n  React.ElementRef<typeof DialogPrimitive.Content>,\\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\\n>(({ className, children, ...props }, ref) => (\\n  <DialogPortal>\\n    <DialogOverlay />\\n    <DialogPrimitive.Content\\n      ref={ref}\\n      className={cn(\\n        \\\"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\\\",\\n        className\\n      )}\\n      {...props}\\n    >\\n      {children}\\n      <DialogPrimitive.Close className=\\\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\\\">\\n        <X className=\\\"h-4 w-4\\\" />\\n        <span className=\\\"sr-only\\\">Close</span>\\n      </DialogPrimitive.Close>\\n    </DialogPrimitive.Content>\\n  </DialogPortal>\\n))\\nDialogContent.displayName = DialogPrimitive.Content.displayName\\n\\nconst DialogHeader = ({\\n  className,\\n  ...props\\n}: React.HTMLAttributes<HTMLDivElement>) => (\\n  <div\\n    className={cn(\\n      \\\"flex flex-col space-y-1.5 text-center sm:text-left\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n)\\nDialogHeader.displayName = \\\"DialogHeader\\\"\\n\\nconst DialogFooter = ({\\n  className,\\n  ...props\\n}: React.HTMLAttributes<HTMLDivElement>) => (\\n  <div\\n    className={cn(\\n      \\\"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n)\\nDialogFooter.displayName = \\\"DialogFooter\\\"\\n\\nconst DialogTitle = React.forwardRef<\\n  React.ElementRef<typeof DialogPrimitive.Title>,\\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\\n>(({ className, ...props }, ref) => (\\n  <DialogPrimitive.Title\\n    ref={ref}\\n    className={cn(\\n      \\\"text-lg font-semibold leading-none tracking-tight\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nDialogTitle.displayName = DialogPrimitive.Title.displayName\\n\\nconst DialogDescription = React.forwardRef<\\n  React.ElementRef<typeof DialogPrimitive.Description>,\\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\\n>(({ className, ...props }, ref) => (\\n  <DialogPrimitive.Description\\n    ref={ref}\\n    className={cn(\\\"text-sm text-muted-foreground\\\", className)}\\n    {...props}\\n  />\\n))\\nDialogDescription.displayName = DialogPrimitive.Description.displayName\\n\\nexport {\\n  Dialog,\\n  DialogPortal,\\n  DialogOverlay,\\n  DialogTrigger,\\n  DialogClose,\\n  DialogContent,\\n  DialogHeader,\\n  DialogFooter,\\n  DialogTitle,\\n  DialogDescription,\\n}\\n\",\n  \"/src/components/ui/input.tsx\": \"import * as React from \\\"react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\\\"input\\\">>(\\n  ({ className, type, ...props }, ref) => {\\n    return (\\n      <input\\n        type={type}\\n        className={cn(\\n          \\\"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\\\",\\n          className\\n        )}\\n        ref={ref}\\n        {...props}\\n      />\\n    )\\n  }\\n)\\nInput.displayName = \\\"Input\\\"\\n\\nexport { Input }\\n\",\n  \"/src/components/ui/label.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as LabelPrimitive from \\\"@radix-ui/react-label\\\"\\nimport { cva, type VariantProps } from \\\"class-variance-authority\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst labelVariants = cva(\\n  \\\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\\\"\\n)\\n\\nconst Label = React.forwardRef<\\n  React.ElementRef<typeof LabelPrimitive.Root>,\\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\\n    VariantProps<typeof labelVariants>\\n>(({ className, ...props }, ref) => (\\n  <LabelPrimitive.Root\\n    ref={ref}\\n    className={cn(labelVariants(), className)}\\n    {...props}\\n  />\\n))\\nLabel.displayName = LabelPrimitive.Root.displayName\\n\\nexport { Label }\\n\",\n  \"/src/components/ui/popover.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as PopoverPrimitive from \\\"@radix-ui/react-popover\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Popover = PopoverPrimitive.Root\\n\\nconst PopoverTrigger = PopoverPrimitive.Trigger\\n\\nconst PopoverAnchor = PopoverPrimitive.Anchor\\n\\nconst PopoverContent = React.forwardRef<\\n  React.ElementRef<typeof PopoverPrimitive.Content>,\\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\\n>(({ className, align = \\\"center\\\", sideOffset = 4, ...props }, ref) => (\\n  <PopoverPrimitive.Portal>\\n    <PopoverPrimitive.Content\\n      ref={ref}\\n      align={align}\\n      sideOffset={sideOffset}\\n      className={cn(\\n        \\\"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  </PopoverPrimitive.Portal>\\n))\\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\\n\\nexport { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }\\n\",\n  \"/src/components/ui/progress.tsx\": \"import * as React from \\\"react\\\"\\nimport * as ProgressPrimitive from \\\"@radix-ui/react-progress\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Progress = React.forwardRef<\\n  React.ElementRef<typeof ProgressPrimitive.Root>,\\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\\n>(({ className, value, ...props }, ref) => (\\n  <ProgressPrimitive.Root\\n    ref={ref}\\n    className={cn(\\n      \\\"relative h-2 w-full overflow-hidden rounded-full bg-primary/20\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <ProgressPrimitive.Indicator\\n      className=\\\"h-full w-full flex-1 bg-primary transition-all\\\"\\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\\n    />\\n  </ProgressPrimitive.Root>\\n))\\nProgress.displayName = ProgressPrimitive.Root.displayName\\n\\nexport { Progress }\\n\",\n  \"/src/components/ui/radio-group.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as RadioGroupPrimitive from \\\"@radix-ui/react-radio-group\\\"\\nimport { Circle } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst RadioGroup = React.forwardRef<\\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\\n>(({ className, ...props }, ref) => {\\n  return (\\n    <RadioGroupPrimitive.Root\\n      className={cn(\\\"grid gap-2\\\", className)}\\n      {...props}\\n      ref={ref}\\n    />\\n  )\\n})\\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\\n\\nconst RadioGroupItem = React.forwardRef<\\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\\n>(({ className, ...props }, ref) => {\\n  return (\\n    <RadioGroupPrimitive.Item\\n      ref={ref}\\n      className={cn(\\n        \\\"aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50\\\",\\n        className\\n      )}\\n      {...props}\\n    >\\n      <RadioGroupPrimitive.Indicator className=\\\"flex items-center justify-center\\\">\\n        <Circle className=\\\"h-3.5 w-3.5 fill-primary\\\" />\\n      </RadioGroupPrimitive.Indicator>\\n    </RadioGroupPrimitive.Item>\\n  )\\n})\\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\\n\\nexport { RadioGroup, RadioGroupItem }\\n\",\n  \"/src/components/ui/select.tsx\": \"import * as React from \\\"react\\\"\\nimport * as SelectPrimitive from \\\"@radix-ui/react-select\\\"\\nimport { Check, ChevronDown, ChevronUp } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Select = SelectPrimitive.Root\\n\\nconst SelectGroup = SelectPrimitive.Group\\n\\nconst SelectValue = SelectPrimitive.Value\\n\\nconst SelectTrigger = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\\n>(({ className, children, ...props }, ref) => (\\n  <SelectPrimitive.Trigger\\n    ref={ref}\\n    className={cn(\\n      \\\"flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    {children}\\n    <SelectPrimitive.Icon asChild>\\n      <ChevronDown className=\\\"h-4 w-4 opacity-50\\\" />\\n    </SelectPrimitive.Icon>\\n  </SelectPrimitive.Trigger>\\n))\\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\\n\\nconst SelectScrollUpButton = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\\n>(({ className, ...props }, ref) => (\\n  <SelectPrimitive.ScrollUpButton\\n    ref={ref}\\n    className={cn(\\n      \\\"flex cursor-default items-center justify-center py-1\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <ChevronUp className=\\\"h-4 w-4\\\" />\\n  </SelectPrimitive.ScrollUpButton>\\n))\\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\\n\\nconst SelectScrollDownButton = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\\n>(({ className, ...props }, ref) => (\\n  <SelectPrimitive.ScrollDownButton\\n    ref={ref}\\n    className={cn(\\n      \\\"flex cursor-default items-center justify-center py-1\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <ChevronDown className=\\\"h-4 w-4\\\" />\\n  </SelectPrimitive.ScrollDownButton>\\n))\\nSelectScrollDownButton.displayName =\\n  SelectPrimitive.ScrollDownButton.displayName\\n\\nconst SelectContent = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.Content>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\\n>(({ className, children, position = \\\"popper\\\", ...props }, ref) => (\\n  <SelectPrimitive.Portal>\\n    <SelectPrimitive.Content\\n      ref={ref}\\n      className={cn(\\n        \\\"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\\\",\\n        position === \\\"popper\\\" &&\\n          \\\"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\\\",\\n        className\\n      )}\\n      position={position}\\n      {...props}\\n    >\\n      <SelectScrollUpButton />\\n      <SelectPrimitive.Viewport\\n        className={cn(\\n          \\\"p-1\\\",\\n          position === \\\"popper\\\" &&\\n            \\\"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\\\"\\n        )}\\n      >\\n        {children}\\n      </SelectPrimitive.Viewport>\\n      <SelectScrollDownButton />\\n    </SelectPrimitive.Content>\\n  </SelectPrimitive.Portal>\\n))\\nSelectContent.displayName = SelectPrimitive.Content.displayName\\n\\nconst SelectLabel = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.Label>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\\n>(({ className, ...props }, ref) => (\\n  <SelectPrimitive.Label\\n    ref={ref}\\n    className={cn(\\\"px-2 py-1.5 text-sm font-semibold\\\", className)}\\n    {...props}\\n  />\\n))\\nSelectLabel.displayName = SelectPrimitive.Label.displayName\\n\\nconst SelectItem = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.Item>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\\n>(({ className, children, ...props }, ref) => (\\n  <SelectPrimitive.Item\\n    ref={ref}\\n    className={cn(\\n      \\\"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <span className=\\\"absolute right-2 flex h-3.5 w-3.5 items-center justify-center\\\">\\n      <SelectPrimitive.ItemIndicator>\\n        <Check className=\\\"h-4 w-4\\\" />\\n      </SelectPrimitive.ItemIndicator>\\n    </span>\\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\\n  </SelectPrimitive.Item>\\n))\\nSelectItem.displayName = SelectPrimitive.Item.displayName\\n\\nconst SelectSeparator = React.forwardRef<\\n  React.ElementRef<typeof SelectPrimitive.Separator>,\\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\\n>(({ className, ...props }, ref) => (\\n  <SelectPrimitive.Separator\\n    ref={ref}\\n    className={cn(\\\"-mx-1 my-1 h-px bg-muted\\\", className)}\\n    {...props}\\n  />\\n))\\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\\n\\nexport {\\n  Select,\\n  SelectGroup,\\n  SelectValue,\\n  SelectTrigger,\\n  SelectContent,\\n  SelectLabel,\\n  SelectItem,\\n  SelectSeparator,\\n  SelectScrollUpButton,\\n  SelectScrollDownButton,\\n}\\n\",\n  \"/src/components/ui/slider.tsx\": \"import * as React from \\\"react\\\"\\nimport * as SliderPrimitive from \\\"@radix-ui/react-slider\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Slider = React.forwardRef<\\n  React.ElementRef<typeof SliderPrimitive.Root>,\\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\\n>(({ className, ...props }, ref) => (\\n  <SliderPrimitive.Root\\n    ref={ref}\\n    className={cn(\\n      \\\"relative flex w-full touch-none select-none items-center\\\",\\n      className\\n    )}\\n    {...props}\\n  >\\n    <SliderPrimitive.Track className=\\\"relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20\\\">\\n      <SliderPrimitive.Range className=\\\"absolute h-full bg-primary\\\" />\\n    </SliderPrimitive.Track>\\n    <SliderPrimitive.Thumb className=\\\"block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\\\" />\\n  </SliderPrimitive.Root>\\n))\\nSlider.displayName = SliderPrimitive.Root.displayName\\n\\nexport { Slider }\\n\",\n  \"/src/components/ui/sonner.tsx\": \"\\\"use client\\\"\\n\\nimport { useTheme } from \\\"next-themes\\\"\\nimport { Toaster as Sonner } from \\\"sonner\\\"\\n\\ntype ToasterProps = React.ComponentProps<typeof Sonner>\\n\\nconst Toaster = ({ ...props }: ToasterProps) => {\\n  const { theme = \\\"system\\\" } = useTheme()\\n\\n  return (\\n    <Sonner\\n      theme={theme as ToasterProps[\\\"theme\\\"]}\\n      className=\\\"toaster group\\\"\\n      toastOptions={{\\n        classNames: {\\n          toast:\\n            \\\"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\\\",\\n          description: \\\"group-[.toast]:text-muted-foreground\\\",\\n          actionButton:\\n            \\\"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\\\",\\n          cancelButton:\\n            \\\"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\\\",\\n        },\\n      }}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport { Toaster }\\n\",\n  \"/src/components/ui/switch.tsx\": \"import * as React from \\\"react\\\"\\nimport * as SwitchPrimitives from \\\"@radix-ui/react-switch\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Switch = React.forwardRef<\\n  React.ElementRef<typeof SwitchPrimitives.Root>,\\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\\n>(({ className, ...props }, ref) => (\\n  <SwitchPrimitives.Root\\n    className={cn(\\n      \\\"peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\\\",\\n      className\\n    )}\\n    {...props}\\n    ref={ref}\\n  >\\n    <SwitchPrimitives.Thumb\\n      className={cn(\\n        \\\"pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0\\\"\\n      )}\\n    />\\n  </SwitchPrimitives.Root>\\n))\\nSwitch.displayName = SwitchPrimitives.Root.displayName\\n\\nexport { Switch }\\n\",\n  \"/src/components/ui/tabs.tsx\": \"import * as React from \\\"react\\\"\\nimport * as TabsPrimitive from \\\"@radix-ui/react-tabs\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Tabs = TabsPrimitive.Root\\n\\nconst TabsList = React.forwardRef<\\n  React.ElementRef<typeof TabsPrimitive.List>,\\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\\n>(({ className, ...props }, ref) => (\\n  <TabsPrimitive.List\\n    ref={ref}\\n    className={cn(\\n      \\\"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nTabsList.displayName = TabsPrimitive.List.displayName\\n\\nconst TabsTrigger = React.forwardRef<\\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\\n>(({ className, ...props }, ref) => (\\n  <TabsPrimitive.Trigger\\n    ref={ref}\\n    className={cn(\\n      \\\"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\\n\\nconst TabsContent = React.forwardRef<\\n  React.ElementRef<typeof TabsPrimitive.Content>,\\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\\n>(({ className, ...props }, ref) => (\\n  <TabsPrimitive.Content\\n    ref={ref}\\n    className={cn(\\n      \\\"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\\\",\\n      className\\n    )}\\n    {...props}\\n  />\\n))\\nTabsContent.displayName = TabsPrimitive.Content.displayName\\n\\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\\n\",\n  \"/src/components/ui/textarea.tsx\": \"import * as React from \\\"react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nconst Textarea = React.forwardRef<\\n  HTMLTextAreaElement,\\n  React.ComponentProps<\\\"textarea\\\">\\n>(({ className, ...props }, ref) => {\\n  return (\\n    <textarea\\n      className={cn(\\n        \\\"flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\\\",\\n        className\\n      )}\\n      ref={ref}\\n      {...props}\\n    />\\n  )\\n})\\nTextarea.displayName = \\\"Textarea\\\"\\n\\nexport { Textarea }\\n\",\n  \"/src/hooks/use-dropdown.ts\": \"import { useEffect, useRef, useState } from \\\"react\\\";\\n\\nexport interface UseDropdownReturn {\\n  isOpen: boolean;\\n  setIsOpen: (open: boolean) => void;\\n  containerRef: React.RefObject<HTMLDivElement | null>;\\n  toggle: () => void;\\n  close: () => void;\\n  open: () => void;\\n}\\n\\nexport function useDropdown(initialOpen = false): UseDropdownReturn {\\n  const [isOpen, setIsOpen] = useState(initialOpen);\\n  const containerRef = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (\\n        containerRef.current &&\\n        !containerRef.current.contains(event.target as Node)\\n      ) {\\n        setIsOpen(false);\\n      }\\n    };\\n\\n    if (isOpen) {\\n      document.addEventListener(\\\"mousedown\\\", handleClickOutside);\\n      return () => document.removeEventListener(\\\"mousedown\\\", handleClickOutside);\\n    }\\n  }, [isOpen]);\\n\\n  const toggle = () => setIsOpen(!isOpen);\\n  const close = () => setIsOpen(false);\\n  const open = () => setIsOpen(true);\\n\\n  return {\\n    isOpen,\\n    setIsOpen,\\n    containerRef,\\n    toggle,\\n    close,\\n    open,\\n  };\\n}\",\n  \"/src/hooks/use-field-state.ts\": \"import type { AnyFieldApi } from \\\"@tanstack/react-form\\\";\\n\\nexport interface UseFieldStateReturn {\\n  name: string;\\n  value: unknown;\\n  isDisabled: boolean;\\n  hasErrors: boolean;\\n  errors: string[];\\n  onBlur: () => void;\\n  onChange: (value: unknown) => void;\\n}\\n\\nexport function useFieldState(fieldApi: AnyFieldApi): UseFieldStateReturn {\\n  const name = fieldApi.name;\\n  const value = fieldApi.state.value;\\n  const isDisabled = fieldApi.form.state.isSubmitting;\\n  const isTouched = fieldApi.state.meta.isTouched;\\n  const errors = fieldApi.state.meta.errors || [];\\n  const hasErrors = isTouched && errors.length > 0;\\n\\n  const onBlur = () => {\\n    fieldApi.handleBlur();\\n  };\\n\\n  const onChange = (newValue: unknown) => {\\n    fieldApi.handleChange(newValue);\\n  };\\n\\n  return {\\n    name,\\n    value,\\n    isDisabled,\\n    hasErrors,\\n    errors,\\n    onBlur,\\n    onChange,\\n  };\\n}\\n\",\n  \"/src/hooks/use-formedible.tsx\": \"\\\"use client\\\";\\nimport React, { useState, useMemo, memo, useRef } from \\\"react\\\";\\nimport { useForm } from \\\"@tanstack/react-form\\\";\\nimport type { AnyFormApi, AnyFieldApi } from \\\"@tanstack/react-form\\\";\\nimport { cn } from \\\"@/lib/utils\\\";\\nimport type {\\n  FormedibleFormApi,\\n  FieldComponentProps,\\n  BaseFieldProps,\\n  FieldConfig,\\n  FormProps,\\n  ConditionalFieldsSubscriptionProps,\\n  FieldConditionalRendererProps,\\n  UseFormedibleOptions,\\n  SectionRendererProps,\\n  LayoutConfig,\\n  FormGridProps,\\n  AnalyticsContext,\\n} from \\\"@/lib/formedible/types\\\";\\nimport { Button } from \\\"@/components/ui/button\\\";\\nimport { Progress } from \\\"@/components/ui/progress\\\";\\nimport { TextField } from \\\"@/components/formedible/fields/text-field\\\";\\nimport { TextareaField } from \\\"@/components/formedible/fields/textarea-field\\\";\\nimport { SelectField } from \\\"@/components/formedible/fields/select-field\\\";\\nimport { CheckboxField } from \\\"@/components/formedible/fields/checkbox-field\\\";\\nimport { SwitchField } from \\\"@/components/formedible/fields/switch-field\\\";\\nimport { NumberField } from \\\"@/components/formedible/fields/number-field\\\";\\nimport { DateField } from \\\"@/components/formedible/fields/date-field\\\";\\nimport { SliderField } from \\\"@/components/formedible/fields/slider-field\\\";\\nimport { FileUploadField } from \\\"@/components/formedible/fields/file-upload-field\\\";\\nimport { ArrayField } from \\\"@/components/formedible/fields/array-field\\\";\\nimport { RadioField } from \\\"@/components/formedible/fields/radio-field\\\";\\nimport { FormTabs } from \\\"@/components/formedible/layout/form-tabs\\\";\\nimport { MultiSelectField } from \\\"@/components/formedible/fields/multi-select-field\\\";\\nimport { ColorPickerField } from \\\"@/components/formedible/fields/color-picker-field\\\";\\nimport { RatingField } from \\\"@/components/formedible/fields/rating-field\\\";\\nimport { PhoneField } from \\\"@/components/formedible/fields/phone-field\\\";\\nimport { LocationPickerField } from \\\"@/components/formedible/fields/location-picker-field\\\";\\nimport { DurationPickerField } from \\\"@/components/formedible/fields/duration-picker-field\\\";\\nimport { AutocompleteField } from \\\"@/components/formedible/fields/autocomplete-field\\\";\\nimport { MaskedInputField } from \\\"@/components/formedible/fields/masked-input-field\\\";\\nimport { ObjectField } from \\\"@/components/formedible/fields/object-field\\\";\\nimport { InlineValidationWrapper } from \\\"@/components/formedible/fields/inline-validation-wrapper\\\";\\nimport { FieldHelp } from \\\"@/components/formedible/fields/field-help\\\";\\nimport { FormGrid, GridItem } from \\\"@/components/formedible/layout/form-grid\\\";\\nimport { resolveDynamicText } from \\\"@/lib/formedible/template-interpolation\\\";\\n\\n// Utility function to scroll to top of a specific form\\nconst scrollToTop = (\\n  htmlFormRef: React.RefObject<HTMLFormElement | null>,\\n  smooth = true,\\n  enabled = true\\n) => {\\n  if (typeof window !== \\\"undefined\\\" && htmlFormRef.current && enabled) {\\n    // Check if form is already in view to prevent unnecessary jumping\\n    const rect = htmlFormRef.current.getBoundingClientRect();\\n    const isInView = rect.top >= 0 && rect.top <= window.innerHeight * 0.3;\\n\\n    if (!isInView) {\\n      htmlFormRef.current.scrollIntoView({\\n        behavior: smooth ? \\\"smooth\\\" : \\\"auto\\\",\\n        block: \\\"start\\\",\\n      });\\n    }\\n  }\\n};\\n\\n// TanStack Form Best Practice: Reusable subscription component for conditional fields\\n\\nconst ConditionalFieldsSubscription = <\\n  TFormValues extends Record<string, unknown> = Record<string, unknown>\\n>({\\n  form,\\n  fields: _fields,\\n  conditionalSections: _conditionalSections,\\n  children,\\n}: ConditionalFieldsSubscriptionProps<TFormValues>) => {\\n  // For now, subscribe to all form values since we don't have explicit dependencies\\n  // This could be optimized further by analyzing the condition functions\\n  return (\\n    <form.Subscribe selector={(state: { values: TFormValues }) => state.values}>\\n      {(values: TFormValues) => children(values as Record<string, unknown>)}\\n    </form.Subscribe>\\n  );\\n};\\n\\n// TanStack Form Best Practice: Individual field conditional renderer\\n\\nconst FieldConditionalRenderer = ({\\n  form,\\n  fieldConfig,\\n  children,\\n}: FieldConditionalRendererProps) => {\\n  const { conditional } = fieldConfig;\\n\\n  // If no conditional logic, always render\\n  if (!conditional) {\\n    return <>{children(true)}</>;\\n  }\\n\\n  // TanStack Form Best Practice: Use subscription with minimal selector\\n  // This prevents parent re-renders by only subscribing to form state changes\\n  return (\\n    <form.Subscribe selector={(state: any) => state.values}>\\n      {(values: any) => children(conditional(values))}\\n    </form.Subscribe>\\n  );\\n};\\n\\n// Field components with proper typing - each component accepts FieldComponentProps\\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\\n  text: TextField,\\n  email: TextField,\\n  password: TextField,\\n  url: TextField,\\n  textarea: TextareaField,\\n  select: SelectField,\\n  checkbox: CheckboxField,\\n  switch: SwitchField,\\n  number: NumberField,\\n  date: DateField,\\n  slider: SliderField,\\n  file: FileUploadField,\\n  array: ArrayField,\\n  radio: RadioField,\\n  multiSelect: MultiSelectField,\\n  colorPicker: ColorPickerField,\\n  rating: RatingField,\\n  phone: PhoneField,\\n  location: LocationPickerField,\\n  duration: DurationPickerField,\\n  autocomplete: AutocompleteField,\\n  masked: MaskedInputField,\\n  object: ObjectField,\\n};\\n\\nconst DefaultProgressComponent: React.FC<{\\n  value: number;\\n  currentPage: number;\\n  totalPages: number;\\n  className?: string;\\n  showSteps?: boolean;\\n  showPercentage?: boolean;\\n}> = memo(\\n  ({\\n    value,\\n    currentPage,\\n    totalPages,\\n    className,\\n    showSteps = true,\\n    showPercentage = true,\\n  }) => (\\n    <div className={cn(\\\"space-y-2\\\", className)}>\\n      {(showSteps || showPercentage) && (\\n        <div className=\\\"flex justify-between text-sm text-muted-foreground\\\">\\n          {showSteps && (\\n            <span>\\n              Step {currentPage} of {totalPages}\\n            </span>\\n          )}\\n          {showPercentage && <span>{Math.round(value)}%</span>}\\n        </div>\\n      )}\\n      <Progress value={value} className=\\\"h-2\\\" />\\n    </div>\\n  )\\n);\\n\\nDefaultProgressComponent.displayName = \\\"DefaultProgressComponent\\\";\\n\\nconst DefaultPageComponent: React.FC<{\\n  children: React.ReactNode;\\n  title?: string;\\n  description?: string;\\n  page: number;\\n  totalPages: number;\\n}> = ({ children, title, description }) => (\\n  <div className=\\\"space-y-6\\\">\\n    {(title || description) && (\\n      <div className=\\\"space-y-2\\\">\\n        {title && <h3 className=\\\"text-lg font-semibold\\\">{title}</h3>}\\n        {description && <p className=\\\"text-muted-foreground\\\">{description}</p>}\\n      </div>\\n    )}\\n    <div className=\\\"space-y-4\\\">{children}</div>\\n  </div>\\n);\\n\\nconst SectionRenderer: React.FC<\\n  SectionRendererProps & {\\n    collapseLabel?: string;\\n    expandLabel?: string;\\n    form?: AnyFormApi;\\n    layout?: LayoutConfig;\\n  }\\n> = ({\\n  sectionKey,\\n  sectionData,\\n  renderField,\\n  collapseLabel = \\\"Collapse\\\",\\n  expandLabel = \\\"Expand\\\",\\n  form,\\n  layout,\\n}) => {\\n  const { section, groups } = sectionData;\\n  const [isExpanded, setIsExpanded] = React.useState(\\n    section?.defaultExpanded !== false\\n  );\\n\\n  // Subscribe to form values for dynamic text resolution - always at top level\\n  const [subscribedValues, setSubscribedValues] = React.useState<\\n    Record<string, unknown>\\n  >(form?.state?.values || {});\\n\\n  React.useEffect(() => {\\n    if (!form) return;\\n    const unsubscribe = form.store.subscribe((state) => {\\n      setSubscribedValues((state as any).values);\\n    });\\n    return unsubscribe;\\n  }, [form]);\\n\\n  // Check if any fields in this section will actually render\\n  const hasVisibleFields = React.useMemo(() => {\\n    if (!form) return true; // Fallback to showing section if form is not available\\n\\n    const currentValues = form.state.values;\\n    return Object.values(groups).some((groupFields) =>\\n      (groupFields as FieldConfig[]).some((field) => {\\n        // Check individual field conditional\\n        if (field.conditional && !field.conditional(currentValues)) {\\n          return false;\\n        }\\n        return true;\\n      })\\n    );\\n  }, [groups, form]);\\n\\n  const renderSectionContent = () => {\\n    const allVisibleFields = Object.entries(groups).flatMap(\\n      ([groupKey, groupFields]) => {\\n        // Filter out fields that won't render due to conditionals\\n        const visibleGroupFields = (groupFields as FieldConfig[]).filter(\\n          (field) => {\\n            if (!form) return true;\\n            const currentValues = form.state.values;\\n            return !field.conditional || field.conditional(currentValues);\\n          }\\n        );\\n\\n        return visibleGroupFields.map((field) => ({ ...field, groupKey }));\\n      }\\n    );\\n\\n    // If layout is specified and is grid, use FormGrid\\n    if (layout && layout.type === \\\"grid\\\") {\\n      return (\\n        <FormGrid\\n          columns={layout.columns as FormGridProps[\\\"columns\\\"]}\\n          gap={layout.gap as FormGridProps[\\\"gap\\\"]}\\n          responsive={layout.responsive}\\n          className={layout.className}\\n        >\\n          {allVisibleFields.map((field) => (\\n            <GridItem\\n              key={field.name}\\n              gridColumn={field.gridColumn}\\n              gridRow={field.gridRow}\\n              gridColumnSpan={field.gridColumnSpan}\\n              gridRowSpan={field.gridRowSpan}\\n              gridArea={field.gridArea}\\n            >\\n              {renderField(field)}\\n            </GridItem>\\n          ))}\\n        </FormGrid>\\n      );\\n    }\\n\\n    // For flex layouts, use simple flex wrapper\\n    if (layout && layout.type === \\\"flex\\\") {\\n      return (\\n        <div\\n          className={cn(\\n            \\\"flex flex-wrap\\\",\\n            layout.gap ? `gap-${layout.gap}` : \\\"gap-4\\\",\\n            layout.className\\n          )}\\n        >\\n          {allVisibleFields.map((field) => (\\n            <div key={field.name}>{renderField(field)}</div>\\n          ))}\\n        </div>\\n      );\\n    }\\n\\n    // For vertical layouts or no layout, use the original group structure\\n    return (\\n      <div className=\\\"space-y-4\\\">\\n        {Object.entries(groups).map(([groupKey, groupFields]) => {\\n          // Filter out fields that won't render due to conditionals\\n          const visibleGroupFields = (groupFields as FieldConfig[]).filter(\\n            (field) => {\\n              if (!form) return true;\\n              const currentValues = form.state.values;\\n              return !field.conditional || field.conditional(currentValues);\\n            }\\n          );\\n\\n          // Don't render empty groups\\n          if (visibleGroupFields.length === 0) return null;\\n\\n          return (\\n            <div\\n              key={groupKey}\\n              className={cn(\\n                groupKey !== \\\"default\\\"\\n                  ? \\\"p-4 border rounded-lg bg-muted/20\\\"\\n                  : \\\"\\\"\\n              )}\\n            >\\n              {groupKey !== \\\"default\\\" && (\\n                <h4 className=\\\"font-medium text-sm text-muted-foreground mb-3 uppercase tracking-wide\\\">\\n                  {groupKey}\\n                </h4>\\n              )}\\n              <div\\n                className={groupKey !== \\\"default\\\" ? \\\"space-y-3\\\" : \\\"space-y-4\\\"}\\n              >\\n                {visibleGroupFields.map((field) => renderField(field))}\\n              </div>\\n            </div>\\n          );\\n        })}\\n      </div>\\n    );\\n  };\\n\\n  const sectionContent = renderSectionContent();\\n\\n  if (section && sectionKey !== \\\"default\\\") {\\n    // Don't render section if no fields are visible\\n    if (!hasVisibleFields) {\\n      return null;\\n    }\\n\\n    return (\\n      <div key={sectionKey} className=\\\"space-y-4\\\">\\n        <div className=\\\"space-y-2\\\">\\n          <div className=\\\"flex items-center justify-between\\\">\\n            {section.title && (\\n              <h3 className=\\\"text-lg font-semibold\\\">\\n                {resolveDynamicText(section.title, subscribedValues)}\\n              </h3>\\n            )}\\n            {section.collapsible && (\\n              <Button\\n                type=\\\"button\\\"\\n                variant=\\\"ghost\\\"\\n                size=\\\"sm\\\"\\n                onClick={() => setIsExpanded(!isExpanded)}\\n                className=\\\"text-muted-foreground hover:text-foreground\\\"\\n              >\\n                {isExpanded\\n                  ? resolveDynamicText(collapseLabel, subscribedValues)\\n                  : resolveDynamicText(expandLabel, subscribedValues)}\\n              </Button>\\n            )}\\n          </div>\\n          {section.description && (\\n            <p className=\\\"text-muted-foreground text-sm\\\">\\n              {resolveDynamicText(section.description, subscribedValues)}\\n            </p>\\n          )}\\n        </div>\\n\\n        {(!section.collapsible || isExpanded) && sectionContent}\\n      </div>\\n    );\\n  }\\n\\n  return sectionContent;\\n};\\n\\nexport function useFormedible<TFormValues extends Record<string, unknown>>(\\n  options: UseFormedibleOptions<TFormValues>\\n) {\\n  const {\\n    fields = [],\\n\\n    submitLabel = \\\"Submit\\\",\\n    nextLabel = \\\"Next\\\",\\n    previousLabel = \\\"Previous\\\",\\n    collapseLabel = \\\"Collapse\\\",\\n    expandLabel = \\\"Expand\\\",\\n    formClassName,\\n    fieldClassName,\\n    labelClassName,\\n    buttonClassName,\\n    submitButtonClassName,\\n    submitButton,\\n    pages,\\n    progress,\\n    tabs,\\n    defaultComponents,\\n    globalWrapper,\\n    formOptions,\\n    onPageChange,\\n    autoSubmitOnChange,\\n    autoSubmitDebounceMs,\\n    disabled,\\n    loading,\\n    resetOnSubmitSuccess,\\n    showSubmitButton = true,\\n    autoScroll = false,\\n    onFormReset,\\n    onFormInput,\\n    onFormInvalid,\\n    onFormKeyDown,\\n    onFormKeyUp,\\n    onFormFocus,\\n    onFormBlur,\\n    // Advanced features\\n    crossFieldValidation = [],\\n    asyncValidation = {},\\n    analytics,\\n    conditionalSections = [],\\n    persistence,\\n    layout,\\n  } = options;\\n\\n  const htmlFormRef = useRef<HTMLFormElement>(null);\\n  const [currentPage, setCurrentPage] = useState(1);\\n\\n  // Advanced features state\\n  const [crossFieldErrors, setCrossFieldErrors] = useState<\\n    Record<string, string>\\n  >({});\\n  const [asyncValidationStates, setAsyncValidationStates] = useState<\\n    Record<string, { loading: boolean; error?: string }>\\n  >({});\\n\\n  // Enhanced analytics state management\\n  const analyticsContextRef = React.useRef<AnalyticsContext>({\\n    sessionId: `session_${Date.now()}_${Math.random()\\n      .toString(36)\\n      .substring(2, 15)}`,\\n    formId: `form_${Date.now()}`,\\n    userId: undefined,\\n    currentPage: 1,\\n    currentTab: undefined,\\n    startTime: Date.now(),\\n    pageStates: {},\\n    tabStates: {},\\n    performanceMetrics: {\\n      renderCount: 0,\\n      lastRenderTime: 0,\\n      averageRenderTime: 0,\\n      validationDurations: {},\\n      submissionMetrics: {\\n        totalTime: 0,\\n        validationTime: 0,\\n        processingTime: 0,\\n      },\\n    },\\n    fieldInteractions: {},\\n  });\\n\\n  // Form completion tracking to prevent incorrect abandonment analytics\\n  const formCompletedRef = React.useRef(false);\\n\\n  // Legacy refs for backward compatibility\\n  const fieldFocusTimes = React.useRef<Record<string, number>>({});\\n  const pageStartTime = React.useRef<number>(Date.now());\\n  const tabStartTime = React.useRef<Record<string, number>>({});\\n  const tabVisitHistory = React.useRef<Set<string>>(new Set());\\n\\n  // Track previous values to detect actual field changes\\n  const previousValues = React.useRef<Record<string, unknown>>({});\\n\\n  // Combine default components with user overrides\\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\\n\\n  // Group fields by pages\\n  const fieldsByPage = useMemo(() => {\\n    const grouped: { [page: number]: FieldConfig[] } = {};\\n\\n    fields.forEach((field) => {\\n      const page = field.page || 1;\\n      if (!grouped[page]) grouped[page] = [];\\n      grouped[page].push(field);\\n    });\\n\\n    return grouped;\\n  }, [fields]);\\n\\n  // Function to check if a page should be visible based on conditions\\n  const getVisiblePages = React.useCallback(\\n    (currentValues: Record<string, unknown>) => {\\n      const allPageNumbers = Object.keys(fieldsByPage)\\n        .map(Number)\\n        .sort((a, b) => a - b);\\n\\n      return allPageNumbers.filter((pageNumber) => {\\n        // Check if the page itself has a condition\\n        const pageConfig = pages?.find((p) => p.page === pageNumber);\\n        if (pageConfig?.conditional && !pageConfig.conditional(currentValues)) {\\n          return false;\\n        }\\n\\n        // Check if page has any visible fields\\n        const pageFields = fieldsByPage[pageNumber] || [];\\n        const hasVisibleFields = pageFields.some((field) => {\\n          // Check field's own conditional\\n          if (field.conditional && !field.conditional(currentValues)) {\\n            return false;\\n          }\\n\\n          // Check conditional sections\\n          const conditionalSection = conditionalSections.find((section) =>\\n            section.fields.includes(field.name)\\n          );\\n\\n          if (conditionalSection) {\\n            return conditionalSection.condition(currentValues as TFormValues);\\n          }\\n\\n          return true;\\n        });\\n\\n        return hasVisibleFields;\\n      });\\n    },\\n    [fieldsByPage, pages, conditionalSections]\\n  );\\n\\n  // Group fields by tabs\\n  const fieldsByTab = useMemo(() => {\\n    const grouped: { [tab: string]: FieldConfig[] } = {};\\n\\n    fields.forEach((field) => {\\n      const tab = field.tab || \\\"default\\\";\\n      if (!grouped[tab]) grouped[tab] = [];\\n      grouped[tab].push(field);\\n    });\\n\\n    return grouped;\\n  }, [fields]);\\n\\n  // State to track visible pages based on current form values\\n  const [visiblePages, setVisiblePages] = useState<number[]>(() => {\\n    // Initialize with all possible pages\\n    return Object.keys(fieldsByPage)\\n      .map(Number)\\n      .sort((a, b) => a - b);\\n  });\\n\\n  const totalPages = Math.max(visiblePages.length, 1);\\n  const hasPages = totalPages > 1;\\n  const hasTabs = tabs && tabs.length > 0;\\n\\n  // Calculate progress\\n  const progressValue = hasPages\\n    ? ((currentPage - 1) / (totalPages - 1)) * 100\\n    : 100;\\n\\n  // Create a ref to store the form instance for the onSubmit callback\\n  const formRef = React.useRef<FormedibleFormApi<TFormValues> | null>(null);\\n\\n  // Refs for async validation debouncing\\n  const asyncValidationTimeouts = React.useRef<\\n    Record<string, ReturnType<typeof setTimeout>>\\n  >({});\\n\\n  // Keep track of AbortControllers for async validations\\n  const asyncValidationAbortControllers = React.useRef<\\n    Record<string, AbortController>\\n  >({});\\n\\n  // Cross-field validation function\\n  const validateCrossFields = React.useCallback(\\n    (values: Partial<TFormValues>) => {\\n      const errors: Record<string, string> = {};\\n\\n      crossFieldValidation.forEach((validation) => {\\n        const relevantValues = validation.fields.reduce((acc, field) => {\\n          acc[field] = values[field];\\n          return acc;\\n        }, {} as Partial<TFormValues>);\\n\\n        const error = validation.validator(relevantValues);\\n        if (error) {\\n          validation.fields.forEach((field) => {\\n            errors[field as string] = validation.message;\\n          });\\n        }\\n      });\\n\\n      setCrossFieldErrors(errors);\\n      return errors;\\n    },\\n    [crossFieldValidation]\\n  );\\n\\n  // Async validation function\\n  const validateFieldAsync = React.useCallback(\\n    async (fieldName: string, value: unknown) => {\\n      const asyncConfig = asyncValidation[fieldName];\\n      if (!asyncConfig) return;\\n\\n      // Cancel any existing validation for this field\\n      if (asyncValidationAbortControllers.current[fieldName]) {\\n        asyncValidationAbortControllers.current[fieldName].abort();\\n      }\\n\\n      // Create new abort controller\\n      const abortController = new AbortController();\\n      asyncValidationAbortControllers.current[fieldName] = abortController;\\n\\n      // Clear existing timeout\\n      if (asyncValidationTimeouts.current[fieldName]) {\\n        clearTimeout(asyncValidationTimeouts.current[fieldName]);\\n      }\\n\\n      // Set loading state\\n      setAsyncValidationStates((prev) => ({\\n        ...prev,\\n        [fieldName]: { loading: true },\\n      }));\\n\\n      // Debounce the validation\\n      asyncValidationTimeouts.current[fieldName] = setTimeout(async () => {\\n        try {\\n          if (abortController.signal.aborted) return;\\n\\n          const error = await asyncConfig.validator(value);\\n\\n          if (abortController.signal.aborted) return;\\n\\n          setAsyncValidationStates((prev) => ({\\n            ...prev,\\n            [fieldName]: { loading: false, error: error || undefined },\\n          }));\\n\\n          // Update form field error if needed\\n          if (formRef.current) {\\n            formRef.current?.setFieldMeta(fieldName, (prev) => ({\\n              ...prev,\\n              errors: error ? [error] : [],\\n            }));\\n          }\\n        } catch {\\n          setAsyncValidationStates((prev) => ({\\n            ...prev,\\n            [fieldName]: { loading: false, error: \\\"Validation failed\\\" },\\n          }));\\n        }\\n      }, asyncConfig.debounceMs || 500);\\n    },\\n    [asyncValidation]\\n  );\\n\\n  // Setup form with schema validation if provided\\n  const formConfig = {\\n    ...formOptions,\\n    ...(resetOnSubmitSuccess &&\\n      formOptions?.onSubmit && {\\n        onSubmit: async (props: {\\n          value: TFormValues;\\n          formApi: FormedibleFormApi<TFormValues>;\\n        }) => {\\n          // Run cross-field validation before submit\\n          const crossFieldErrors = validateCrossFields(\\n            props.value as Partial<TFormValues>\\n          );\\n          if (Object.keys(crossFieldErrors).length > 0) {\\n            throw new Error(\\\"Cross-field validation failed\\\");\\n          }\\n\\n          // Track submission start time for performance metrics\\n          const submissionStartTime = Date.now();\\n\\n          // Enhanced analytics tracking for form completion\\n          if (analytics) {\\n            const context = analyticsContextRef.current;\\n            const timeSpent = Date.now() - context.startTime;\\n\\n            // Update performance metrics\\n            context.performanceMetrics.submissionMetrics.totalTime = timeSpent;\\n\\n            // Call enhanced completion analytics\\n            analytics.onFormComplete?.(timeSpent, props.value);\\n          }\\n\\n          let result: unknown;\\n          if (formOptions.onSubmit) {\\n            try {\\n              result = await formOptions.onSubmit(props);\\n\\n              // Mark form as completed to prevent abandonment tracking\\n              formCompletedRef.current = true;\\n\\n              // Track submission performance after successful completion\\n              if (analytics) {\\n                const processingTime = Date.now() - submissionStartTime;\\n                const context = analyticsContextRef.current;\\n                context.performanceMetrics.submissionMetrics.processingTime =\\n                  processingTime;\\n                analytics.onSubmissionPerformance?.(\\n                  Date.now() - context.startTime,\\n                  context.performanceMetrics.submissionMetrics.validationTime,\\n                  processingTime\\n                );\\n              }\\n            } catch (error) {\\n              // Re-throw the error after analytics\\n              throw error;\\n            }\\n          }\\n\\n          // Clear storage on successful submit\\n          clearStorage();\\n\\n          // Reset form on successful submit if option is enabled\\n          if (formRef.current) {\\n            formRef.current?.reset();\\n          }\\n          return result;\\n        },\\n      }),\\n  };\\n\\n  const form = useForm(formConfig);\\n\\n  // Store form reference for the onSubmit callback\\n  React.useEffect(() => {\\n    formRef.current = form;\\n  }, [form]);\\n\\n  // Enhanced analytics helper functions with performance optimization\\n  const trackFieldInteraction = React.useCallback(\\n    (\\n      fieldName: string,\\n      action: \\\"focus\\\" | \\\"blur\\\" | \\\"change\\\" | \\\"error\\\" | \\\"complete\\\",\\n      additionalData?: {\\n        timeSpent?: number;\\n        value?: unknown;\\n        errors?: string[];\\n        isValid?: boolean;\\n      }\\n    ) => {\\n      const context = analyticsContextRef.current;\\n      const timestamp = Date.now();\\n\\n      // Initialize field tracking if not exists\\n      if (!context.fieldInteractions[fieldName]) {\\n        context.fieldInteractions[fieldName] = {\\n          focusCount: 0,\\n          totalTimeSpent: 0,\\n          changeCount: 0,\\n          errorCount: 0,\\n          isCompleted: false,\\n        };\\n      }\\n\\n      const fieldData = context.fieldInteractions[fieldName];\\n\\n      switch (action) {\\n        case \\\"focus\\\":\\n          fieldData.focusCount++;\\n          fieldFocusTimes.current[fieldName] = timestamp;\\n          analytics?.onFieldFocus?.(fieldName, timestamp);\\n          break;\\n\\n        case \\\"blur\\\":\\n          if (additionalData?.timeSpent !== undefined) {\\n            fieldData.totalTimeSpent += additionalData.timeSpent;\\n            analytics?.onFieldBlur?.(fieldName, additionalData.timeSpent);\\n          }\\n          break;\\n\\n        case \\\"change\\\":\\n          fieldData.changeCount++;\\n          analytics?.onFieldChange?.(\\n            fieldName,\\n            additionalData?.value,\\n            timestamp\\n          );\\n          break;\\n\\n        case \\\"error\\\":\\n          if (additionalData?.errors?.length) {\\n            fieldData.errorCount++;\\n            analytics?.onFieldError?.(\\n              fieldName,\\n              additionalData.errors,\\n              timestamp\\n            );\\n          }\\n          break;\\n\\n        case \\\"complete\\\":\\n          if (\\n            additionalData?.isValid !== undefined &&\\n            additionalData?.timeSpent !== undefined\\n          ) {\\n            fieldData.isCompleted = additionalData.isValid;\\n            analytics?.onFieldComplete?.(\\n              fieldName,\\n              additionalData.isValid,\\n              additionalData.timeSpent\\n            );\\n          }\\n          break;\\n      }\\n    },\\n    [analytics]\\n  );\\n\\n  const trackTabChange = React.useCallback(\\n    (fromTab: string, toTab: string) => {\\n      const context = analyticsContextRef.current;\\n      const timestamp = Date.now();\\n      const timeSpent = tabStartTime.current[fromTab]\\n        ? timestamp - tabStartTime.current[fromTab]\\n        : 0;\\n\\n      // Track tab visit\\n      if (!tabVisitHistory.current.has(toTab)) {\\n        tabVisitHistory.current.add(toTab);\\n        analytics?.onTabFirstVisit?.(toTab, timestamp);\\n      }\\n\\n      // Initialize tab states if not exists\\n      if (!context.tabStates[fromTab]) {\\n        context.tabStates[fromTab] = {\\n          tabId: fromTab,\\n          startTime: tabStartTime.current[fromTab] || timestamp,\\n          visitCount: 0,\\n          fieldsCompleted: 0,\\n          totalFields: 0,\\n          hasErrors: false,\\n          completionPercentage: 0,\\n        };\\n      }\\n\\n      if (!context.tabStates[toTab]) {\\n        context.tabStates[toTab] = {\\n          tabId: toTab,\\n          startTime: timestamp,\\n          visitCount: 0,\\n          fieldsCompleted: 0,\\n          totalFields: 0,\\n          hasErrors: false,\\n          completionPercentage: 0,\\n        };\\n      }\\n\\n      // Update tab states\\n      const fromTabState = context.tabStates[fromTab];\\n      const toTabState = context.tabStates[toTab];\\n\\n      toTabState.visitCount++;\\n      tabStartTime.current[toTab] = timestamp;\\n\\n      // Calculate completion state for from tab\\n      const tabFields = fieldsByTab[fromTab] || [];\\n      fromTabState.totalFields = tabFields.length;\\n      fromTabState.fieldsCompleted = tabFields.filter(\\n        (field) => context.fieldInteractions[field.name]?.isCompleted\\n      ).length;\\n      fromTabState.completionPercentage =\\n        fromTabState.totalFields > 0\\n          ? (fromTabState.fieldsCompleted / fromTabState.totalFields) * 100\\n          : 0;\\n\\n      // Check for validation errors in from tab\\n      const formState = form.state;\\n      fromTabState.hasErrors = tabFields.some((field) => {\\n        const fieldState =\\n          formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\\n        return fieldState && fieldState.errors && fieldState.errors.length > 0;\\n      });\\n\\n      analytics?.onTabChange?.(fromTab, toTab, timeSpent, {\\n        completionPercentage: fromTabState.completionPercentage,\\n        hasErrors: fromTabState.hasErrors,\\n      });\\n    },\\n    [analytics, fieldsByTab, form]\\n  );\\n\\n  const trackPageChange = React.useCallback(\\n    (fromPage: number, toPage: number) => {\\n      const context = analyticsContextRef.current;\\n      const timestamp = Date.now();\\n      const timeSpent = timestamp - pageStartTime.current;\\n\\n      // Initialize page states if not exists\\n      if (!context.pageStates[fromPage]) {\\n        context.pageStates[fromPage] = {\\n          pageNumber: fromPage,\\n          startTime: pageStartTime.current,\\n          visitCount: 0,\\n          fieldsCompleted: 0,\\n          totalFields: 0,\\n          hasErrors: false,\\n          completionPercentage: 0,\\n          validationErrors: {},\\n          lastActiveField: undefined,\\n        };\\n      }\\n\\n      const pageState = context.pageStates[fromPage];\\n      const pageFields = fieldsByPage[fromPage] || [];\\n\\n      // Update page completion metrics\\n      pageState.totalFields = pageFields.length;\\n      pageState.fieldsCompleted = pageFields.filter(\\n        (field) => context.fieldInteractions[field.name]?.isCompleted\\n      ).length;\\n      pageState.completionPercentage =\\n        pageState.totalFields > 0\\n          ? (pageState.fieldsCompleted / pageState.totalFields) * 100\\n          : 0;\\n\\n      // Check for validation errors\\n      const formState = form.state;\\n      const validationErrors: Record<string, string[]> = {};\\n      pageState.hasErrors = pageFields.some((field) => {\\n        const fieldState =\\n          formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\\n        const hasErrors =\\n          fieldState && fieldState.errors && fieldState.errors.length > 0;\\n        if (hasErrors) {\\n          validationErrors[field.name] = fieldState.errors;\\n        }\\n        return hasErrors;\\n      });\\n      pageState.validationErrors = validationErrors;\\n\\n      pageStartTime.current = timestamp;\\n\\n      analytics?.onPageChange?.(fromPage, toPage, timeSpent, {\\n        hasErrors: pageState.hasErrors,\\n        completionPercentage: pageState.completionPercentage,\\n      });\\n    },\\n    [analytics, fieldsByPage, form]\\n  );\\n\\n  // Track visible pages using a ref to avoid circular dependencies\\n  const visiblePagesRef = React.useRef<number[]>(\\n    Object.keys(fieldsByPage)\\n      .map(Number)\\n      .sort((a, b) => a - b)\\n  );\\n\\n  // Update visible pages when form values change (without causing re-renders)\\n  React.useEffect(() => {\\n    const updateVisiblePages = () => {\\n      const currentValues = form.state.values as Record<string, unknown>;\\n      const newVisiblePages = getVisiblePages(currentValues);\\n\\n      // Only update if actually changed\\n      if (\\n        JSON.stringify(visiblePagesRef.current) !==\\n        JSON.stringify(newVisiblePages)\\n      ) {\\n        visiblePagesRef.current = newVisiblePages;\\n\\n        // Update state only when necessary\\n        setVisiblePages(newVisiblePages);\\n\\n        // Check if current page is still visible using setCurrentPage callback\\n        setCurrentPage((prevCurrentPage) => {\\n          const currentActualPage = newVisiblePages[prevCurrentPage - 1];\\n          if (\\n            !currentActualPage &&\\n            prevCurrentPage > 1 &&\\n            newVisiblePages.length > 0\\n          ) {\\n            return 1; // Navigate to first visible page\\n          }\\n          return prevCurrentPage; // Keep current page\\n        });\\n      }\\n    };\\n\\n    // Set up subscription\\n    const unsubscribe = form.store.subscribe(updateVisiblePages);\\n\\n    // Initialize on mount\\n    updateVisiblePages();\\n\\n    return unsubscribe;\\n  }, [form, getVisiblePages]);\\n\\n  // Form persistence logic\\n  const persistenceTimeout = React.useRef<\\n    ReturnType<typeof setTimeout> | undefined\\n  >(undefined);\\n\\n  const saveToStorage = React.useCallback(\\n    (values: Partial<TFormValues>) => {\\n      if (!persistence) return;\\n\\n      try {\\n        const storage =\\n          persistence.storage === \\\"localStorage\\\"\\n            ? localStorage\\n            : sessionStorage;\\n        const filteredValues = persistence.exclude\\n          ? Object.fromEntries(\\n              Object.entries(values as Record<string, unknown>).filter(\\n                ([key]) =>\\n                  !(persistence.exclude && persistence.exclude.includes(key))\\n              )\\n            )\\n          : values;\\n\\n        storage.setItem(\\n          persistence.key,\\n          JSON.stringify({\\n            values: filteredValues,\\n            timestamp: Date.now(),\\n            currentPage,\\n          })\\n        );\\n      } catch (error) {\\n        console.warn(\\\"Failed to save form data to storage:\\\", error);\\n      }\\n    },\\n    [persistence, currentPage]\\n  );\\n\\n  const clearStorage = React.useCallback(() => {\\n    if (!persistence) return;\\n\\n    try {\\n      const storage =\\n        persistence.storage === \\\"localStorage\\\" ? localStorage : sessionStorage;\\n      storage.removeItem(persistence.key);\\n    } catch (error) {\\n      console.warn(\\\"Failed to clear form data from storage:\\\", error);\\n    }\\n  }, [persistence]);\\n\\n  const loadFromStorage = React.useCallback(() => {\\n    if (!persistence?.restoreOnMount) return null;\\n\\n    try {\\n      const storage =\\n        persistence.storage === \\\"localStorage\\\" ? localStorage : sessionStorage;\\n      const saved = storage.getItem(persistence.key);\\n      if (saved) {\\n        const parsed = JSON.parse(saved);\\n        return parsed;\\n      }\\n    } catch (error) {\\n      console.warn(\\\"Failed to load form data from storage:\\\", error);\\n    }\\n    return null;\\n  }, [persistence]);\\n\\n  // Restore form data on mount\\n  React.useEffect(() => {\\n    const savedData = loadFromStorage();\\n    if (savedData && savedData.values) {\\n      // Restore form values\\n      Object.entries(savedData.values as Record<string, unknown>).forEach(\\n        ([key, value]) => {\\n          try {\\n            form.setFieldValue(key as keyof TFormValues & string, value as any);\\n          } catch (error) {\\n            console.warn(`Failed to restore field value for ${key}:`, error);\\n          }\\n        }\\n      );\\n\\n      // Restore current page if it was saved\\n      if (savedData.currentPage && savedData.currentPage <= totalPages) {\\n        setCurrentPage(savedData.currentPage);\\n      }\\n    }\\n  }, [loadFromStorage, form, totalPages]);\\n\\n  // Set up form event listeners if provided\\n  React.useEffect(() => {\\n    const unsubscribers: (() => void)[] = [];\\n    let autoSubmitTimeout: ReturnType<typeof setTimeout>;\\n    let onChangeTimeout: ReturnType<typeof setTimeout>;\\n    let onBlurTimeout: ReturnType<typeof setTimeout>;\\n\\n    // Enhanced form start analytics\\n    if (analytics?.onFormStart) {\\n      analytics.onFormStart(analyticsContextRef.current.startTime);\\n    }\\n\\n    if (\\n      formOptions?.onChange ||\\n      autoSubmitOnChange ||\\n      crossFieldValidation.length > 0 ||\\n      analytics ||\\n      persistence\\n    ) {\\n      const unsubscribe = form.store.subscribe(() => {\\n        const formApi = form;\\n        const values = formApi.state.values;\\n\\n        // Run cross-field validation on change\\n        if (crossFieldValidation.length > 0) {\\n          validateCrossFields(values as Partial<TFormValues>);\\n        }\\n\\n        // Save to storage (debounced)\\n        if (persistence) {\\n          clearTimeout(persistenceTimeout.current);\\n          persistenceTimeout.current = setTimeout(() => {\\n            saveToStorage(values as Partial<TFormValues>);\\n          }, persistence.debounceMs || 1000);\\n        }\\n\\n        // Call user's onChange handler only if form is valid (debounced)\\n        if (formOptions?.onChange && formApi.state.isValid) {\\n          clearTimeout(onChangeTimeout);\\n          onChangeTimeout = setTimeout(() => {\\n            if (!formOptions.onChange) return;\\n            formOptions.onChange({ value: values as TFormValues, formApi });\\n          }, 300); // 300ms debounce\\n        }\\n\\n        // Handle auto-submit on change\\n        if (autoSubmitOnChange && !disabled && !loading) {\\n          clearTimeout(autoSubmitTimeout);\\n          autoSubmitTimeout = setTimeout(() => {\\n            if (form.state.canSubmit) {\\n              form.handleSubmit();\\n            }\\n          }, autoSubmitDebounceMs);\\n        }\\n      });\\n      unsubscribers.push(unsubscribe);\\n    }\\n\\n    // Enhanced analytics using TanStack Form subscriptions instead of document event listeners\\n    if (analytics) {\\n      // Subscribe to form state changes for field validation analytics\\n      const fieldValidationUnsubscribe = form.store.subscribe(() => {\\n        const formState = form.state;\\n        const fieldMeta = formState.fieldMeta;\\n\\n        // Track field validation errors\\n        Object.entries(fieldMeta).forEach(([fieldName, meta]) => {\\n          if (\\n            meta &&\\n            typeof meta === \\\"object\\\" &&\\n            \\\"errors\\\" in meta &&\\n            Array.isArray(meta.errors) &&\\n            meta.errors.length > 0\\n          ) {\\n            trackFieldInteraction(fieldName, \\\"error\\\", { errors: meta.errors });\\n          }\\n        });\\n      });\\n      unsubscribers.push(fieldValidationUnsubscribe);\\n\\n      // Subscribe to field changes with optimized tracking\\n      const fieldChangeUnsubscribe = form.store.subscribe(() => {\\n        const values = form.state.values;\\n        const context = analyticsContextRef.current;\\n\\n        Object.entries(values as Record<string, unknown>).forEach(\\n          ([fieldName, value]) => {\\n            // Only process if the value actually changed\\n            if (previousValues.current[fieldName] !== value) {\\n              // Initialize field tracking if needed\\n              if (!context.fieldInteractions[fieldName]) {\\n                context.fieldInteractions[fieldName] = {\\n                  focusCount: 0,\\n                  totalTimeSpent: 0,\\n                  changeCount: 0,\\n                  errorCount: 0,\\n                  isCompleted: false,\\n                };\\n              }\\n\\n              // Track the change\\n              trackFieldInteraction(fieldName, \\\"change\\\", { value });\\n\\n              // Trigger async validation if configured\\n              if (asyncValidation[fieldName]) {\\n                validateFieldAsync(fieldName, value);\\n              }\\n\\n              // Update previous value\\n              previousValues.current[fieldName] = value;\\n            }\\n          }\\n        );\\n      });\\n      unsubscribers.push(fieldChangeUnsubscribe);\\n\\n      // User's onBlur handler using subscription\\n      if (formOptions?.onBlur) {\\n        const blurUnsubscribe = form.store.subscribe(() => {\\n          clearTimeout(onBlurTimeout);\\n          onBlurTimeout = setTimeout(() => {\\n            if (!formOptions.onBlur) return;\\n            const formApi = form;\\n            const values = formApi.state.values;\\n            formOptions.onBlur({ value: values as TFormValues, formApi });\\n          }, 100); // 100ms debounce for blur\\n        });\\n        unsubscribers.push(blurUnsubscribe);\\n      }\\n    }\\n\\n    // Enhanced cleanup - only handle timeouts and cancellations\\n    unsubscribers.push(() => {\\n      clearTimeout(autoSubmitTimeout);\\n      clearTimeout(onChangeTimeout);\\n      clearTimeout(onBlurTimeout);\\n      clearTimeout(persistenceTimeout.current);\\n      // Clear async validation timeouts\\n      Object.values(asyncValidationTimeouts.current).forEach((timeout) => {\\n        clearTimeout(timeout);\\n      });\\n\\n      // Cancel all in-flight async validations\\n      Object.values(asyncValidationAbortControllers.current).forEach(\\n        (controller) => {\\n          controller.abort();\\n        }\\n      );\\n    });\\n\\n    return () => {\\n      unsubscribers.forEach((unsub) => unsub());\\n    };\\n  }, [\\n    form,\\n    autoSubmitOnChange,\\n    autoSubmitDebounceMs,\\n    disabled,\\n    loading,\\n    formOptions,\\n    crossFieldValidation,\\n    analytics,\\n    asyncValidation,\\n    validateFieldAsync,\\n    persistence,\\n    saveToStorage,\\n    validateCrossFields,\\n    fields.length,\\n    trackFieldInteraction,\\n  ]);\\n\\n  // Separate useEffect for form abandonment tracking - only runs on component unmount\\n  React.useEffect(() => {\\n    const analyticsContextSnapshot = analyticsContextRef.current;\\n    const fieldsLength = fields.length;\\n    const onFormAbandon = analytics?.onFormAbandon;\\n\\n    return () => {\\n      // Track form abandonment only on component unmount if analytics is enabled and form wasn't completed\\n      if (\\n        onFormAbandon &&\\n        !formCompletedRef.current &&\\n        analyticsContextSnapshot\\n      ) {\\n        const context = analyticsContextSnapshot;\\n\\n        // Ensure context properties exist before accessing\\n        if (!context.fieldInteractions) return;\\n\\n        const totalFields = fieldsLength;\\n        const completedFields = Object.values(context.fieldInteractions).filter(\\n          (field) => field && field.isCompleted\\n        ).length;\\n        const completionPercentage =\\n          totalFields > 0 ? (completedFields / totalFields) * 100 : 0;\\n\\n        // Only track abandonment if form had some interaction\\n        if (\\n          completedFields > 0 ||\\n          Object.keys(context.fieldInteractions).length > 0\\n        ) {\\n          onFormAbandon(completionPercentage, {\\n            currentPage: context.currentPage,\\n            currentTab: context.currentTab,\\n            lastActiveField: Object.keys(context.fieldInteractions).pop(),\\n          });\\n        }\\n      }\\n    };\\n  }, [analytics?.onFormAbandon, fields.length]); // Include dependencies\\n\\n  const getCurrentPageFields = () => {\\n    if (hasTabs) {\\n      // When using tabs, return all fields (tabs handle their own filtering)\\n      return fields;\\n    }\\n    // Get the actual page number from visible pages array\\n    const actualPageNumber = visiblePages[currentPage - 1];\\n    return actualPageNumber ? fieldsByPage[actualPageNumber] || [] : [];\\n  };\\n\\n  const getCurrentPageConfig = () => {\\n    const actualPageNumber = visiblePages[currentPage - 1];\\n    return actualPageNumber\\n      ? pages?.find((p) => p.page === actualPageNumber)\\n      : undefined;\\n  };\\n\\n  const goToNextPage = () => {\\n    if (currentPage < totalPages) {\\n      // Check if current page has validation errors\\n      const currentPageFields = getCurrentPageFields();\\n      const formState = form.state;\\n\\n      const hasPageErrors = currentPageFields.some((field) => {\\n        const fieldState =\\n          formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\\n        return fieldState && fieldState.errors && fieldState.errors.length > 0;\\n      });\\n\\n      if (hasPageErrors) {\\n        // Mark all fields on current page as touched to show validation errors\\n        currentPageFields.forEach((field) => {\\n          form.setFieldMeta(field.name, (prev) => ({\\n            ...prev,\\n            isTouched: true,\\n          }));\\n        });\\n        return; // Don't navigate if there are errors\\n      }\\n\\n      const newPage = currentPage + 1;\\n\\n      // Enhanced analytics tracking with validation state\\n      if (analytics) {\\n        trackPageChange(currentPage, newPage);\\n      }\\n\\n      setCurrentPage(newPage);\\n      analyticsContextRef.current.currentPage = newPage;\\n      pageStartTime.current = Date.now();\\n      onPageChange?.(newPage, \\\"next\\\");\\n      scrollToTop(htmlFormRef, true, autoScroll);\\n    }\\n  };\\n\\n  const goToPreviousPage = () => {\\n    if (currentPage > 1) {\\n      const newPage = currentPage - 1;\\n\\n      // Enhanced analytics tracking with validation state\\n      if (analytics) {\\n        trackPageChange(currentPage, newPage);\\n      }\\n\\n      setCurrentPage(newPage);\\n      analyticsContextRef.current.currentPage = newPage;\\n      pageStartTime.current = Date.now();\\n      onPageChange?.(newPage, \\\"previous\\\");\\n      scrollToTop(htmlFormRef, true, autoScroll);\\n    }\\n  };\\n\\n  const isLastPage = currentPage === totalPages;\\n  const isFirstPage = currentPage === 1;\\n\\n  // Validated setCurrentPage that checks all pages between current and target\\n  const setCurrentPageWithValidation = (targetPage: number) => {\\n    if (\\n      targetPage < 1 ||\\n      targetPage > totalPages ||\\n      targetPage === currentPage\\n    ) {\\n      return;\\n    }\\n\\n    // If going forward, validate all pages between current and target\\n    if (targetPage > currentPage) {\\n      for (\\n        let pageIndex = currentPage - 1;\\n        pageIndex < targetPage - 1;\\n        pageIndex++\\n      ) {\\n        const actualPageNumber = visiblePages[pageIndex];\\n        if (!actualPageNumber) continue;\\n\\n        const pageFields = fieldsByPage[actualPageNumber] || [];\\n        const formState = form.state;\\n\\n        const hasPageErrors = pageFields.some((field) => {\\n          const fieldState =\\n            formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\\n          return (\\n            fieldState && fieldState.errors && fieldState.errors.length > 0\\n          );\\n        });\\n\\n        if (hasPageErrors) {\\n          // Mark all fields on this page as touched to show validation errors\\n          pageFields.forEach((field) => {\\n            form.setFieldMeta(field.name, (prev) => ({\\n              ...prev,\\n              isTouched: true,\\n            }));\\n          });\\n          return; // Don't navigate if there are errors\\n        }\\n      }\\n    }\\n\\n    // If validation passes or going backward, allow navigation\\n    setCurrentPage(targetPage);\\n    analyticsContextRef.current.currentPage = targetPage;\\n    onPageChange?.(targetPage, targetPage > currentPage ? \\\"next\\\" : \\\"previous\\\");\\n    scrollToTop(htmlFormRef, true, autoScroll);\\n  };\\n\\n  const Form: React.FC<FormProps> = ({\\n    className,\\n    children,\\n    onSubmit,\\n    // HTML form attributes\\n    action,\\n    method,\\n    encType,\\n    target,\\n    autoComplete,\\n    noValidate,\\n    acceptCharset,\\n    // Event handlers\\n    onReset,\\n    onInput,\\n    onInvalid,\\n    onKeyDown,\\n    onKeyUp,\\n\\n    onFocus,\\n    onBlur,\\n    // Accessibility\\n    role,\\n    \\\"aria-label\\\": ariaLabel,\\n    \\\"aria-labelledby\\\": ariaLabelledby,\\n    \\\"aria-describedby\\\": ariaDescribedby,\\n    tabIndex,\\n  }) => {\\n    const handleSubmit = (e: React.FormEvent) => {\\n      e.preventDefault();\\n      e.stopPropagation();\\n\\n      if (onSubmit) {\\n        onSubmit(e);\\n      } else if (isLastPage) {\\n        form.handleSubmit();\\n      } else {\\n        goToNextPage();\\n      }\\n    };\\n\\n    const handleReset = (e: React.FormEvent) => {\\n      if (onReset) {\\n        onReset(e);\\n      }\\n      if (onFormReset) {\\n        onFormReset(e, form);\\n      }\\n      form.reset();\\n    };\\n\\n    const handleInput = (e: React.FormEvent) => {\\n      if (onInput) {\\n        onInput(e);\\n      }\\n      if (onFormInput) {\\n        onFormInput(e, form);\\n      }\\n    };\\n\\n    const handleInvalid = (e: React.FormEvent) => {\\n      if (onInvalid) {\\n        onInvalid(e);\\n      }\\n      if (onFormInvalid) {\\n        onFormInvalid(e, form);\\n      }\\n    };\\n\\n    const handleKeyDown = (e: React.KeyboardEvent) => {\\n      if (onKeyDown) {\\n        onKeyDown(e);\\n      }\\n      if (onFormKeyDown) {\\n        onFormKeyDown(e, form);\\n      }\\n    };\\n\\n    const handleKeyUp = (e: React.KeyboardEvent) => {\\n      if (onKeyUp) {\\n        onKeyUp(e);\\n      }\\n      if (onFormKeyUp) {\\n        onFormKeyUp(e, form);\\n      }\\n    };\\n\\n    // Tab state for controlled FormTabs component with analytics\\n    const [activeTab, setActiveTab] = useState(() => {\\n      if (tabs && tabs.length > 0) return tabs[0].id;\\n      return \\\"\\\";\\n    });\\n\\n    // Enhanced tab change handler with analytics\\n    const handleTabChange = React.useCallback(\\n      (newTabId: string) => {\\n        const previousTab = activeTab;\\n\\n        // Track tab change if analytics is enabled\\n        if (analytics && previousTab && previousTab !== newTabId) {\\n          trackTabChange(previousTab, newTabId);\\n        }\\n\\n        // Initialize tab start time for new tab\\n        if (newTabId && !tabStartTime.current[newTabId]) {\\n          tabStartTime.current[newTabId] = Date.now();\\n        }\\n\\n        setActiveTab(newTabId);\\n        analyticsContextRef.current.currentTab = newTabId;\\n      },\\n      [activeTab]\\n    );\\n\\n    // Initialize first tab start time\\n    React.useEffect(() => {\\n      if (activeTab && !tabStartTime.current[activeTab]) {\\n        tabStartTime.current[activeTab] = Date.now();\\n        // Track first tab visit\\n        if (analytics?.onTabFirstVisit) {\\n          analytics.onTabFirstVisit(activeTab, Date.now());\\n        }\\n      }\\n    }, [activeTab]);\\n\\n    const handleFocus = (e: React.FocusEvent) => {\\n      if (onFocus) {\\n        onFocus(e);\\n      }\\n      if (onFormFocus) {\\n        onFormFocus(e, form);\\n      }\\n    };\\n\\n    const handleBlur = (e: React.FocusEvent) => {\\n      if (onBlur) {\\n        onBlur(e);\\n      }\\n      if (onFormBlur) {\\n        onFormBlur(e, form);\\n      }\\n    };\\n\\n    const formClass = cn(\\\"space-y-6\\\", formClassName, className);\\n\\n    // Helper function to resolve options (static or dynamic)\\n    const resolveOptions = React.useCallback(\\n      (\\n        options: FieldConfig[\\\"options\\\"],\\n        currentValues: Record<string, unknown>\\n      ) => {\\n        if (typeof options === \\\"function\\\") {\\n          return options(currentValues);\\n        }\\n        return options;\\n      },\\n      []\\n    );\\n\\n    const renderField = React.useCallback(\\n      (fieldConfig: FieldConfig) => {\\n        const {\\n          name,\\n          type,\\n          label,\\n          placeholder,\\n          description,\\n          options,\\n          min,\\n          max,\\n          step,\\n          accept,\\n          multiple,\\n          component: CustomComponent,\\n          wrapper: CustomWrapper,\\n          validation,\\n          arrayConfig,\\n          datalist,\\n          help,\\n          inlineValidation,\\n\\n          ratingConfig,\\n          phoneConfig,\\n          colorConfig,\\n          multiSelectConfig,\\n          locationConfig,\\n          durationConfig,\\n          autocompleteConfig,\\n          maskedInputConfig,\\n          objectConfig,\\n          sliderConfig,\\n          numberConfig,\\n          dateConfig,\\n          fileConfig,\\n          textareaConfig,\\n          passwordConfig,\\n          emailConfig,\\n        } = fieldConfig;\\n\\n        return (\\n          <form.Field\\n            key={name}\\n            name={name as keyof TFormValues & string}\\n            validators={\\n              validation\\n                ? {\\n                    onChange: ({ value }) => {\\n                      const result = validation.safeParse(value);\\n                      return result.success\\n                        ? undefined\\n                        : result.error.issues[0]?.message || \\\"Invalid value\\\";\\n                    },\\n                  }\\n                : undefined\\n            }\\n          >\\n            {(field) => {\\n              // TanStack Form Best Practice: Use FieldConditionalRenderer to prevent parent re-renders\\n              return (\\n                <FieldConditionalRenderer form={form} fieldConfig={fieldConfig}>\\n                  {(shouldRender) => {\\n                    if (!shouldRender) {\\n                      return null;\\n                    }\\n\\n                    // Subscribe to form values for dynamic options\\n                    return (\\n                      <form.Subscribe selector={(state: any) => state.values}>\\n                        {(currentValues: any) => {\\n                          // Check for cross-field validation errors\\n                          const crossFieldError = crossFieldErrors[name];\\n                          const asyncValidationState =\\n                            asyncValidationStates[name];\\n\\n                          // Resolve options (static or dynamic)\\n                          const resolvedOptions = resolveOptions(\\n                            options,\\n                            currentValues\\n                          );\\n\\n                          // Resolve dynamic text properties\\n                          const resolvedLabel = resolveDynamicText(\\n                            label,\\n                            currentValues\\n                          );\\n                          const resolvedPlaceholder = resolveDynamicText(\\n                            placeholder,\\n                            currentValues\\n                          );\\n                          const resolvedDescription = resolveDynamicText(\\n                            description,\\n                            currentValues\\n                          );\\n\\n                          // Debug log for description\\n                          // if (description && typeof description === 'string' && description.includes('{{')) {\\n                          //   console.log('DEBUG - Field:', name, 'Original description:', description, 'Resolved:', resolvedDescription, 'Values:', currentValues);\\n                          // }\\n\\n                          const baseProps = {\\n                            fieldApi: field as unknown as AnyFieldApi,\\n                            label: resolvedLabel,\\n                            placeholder: resolvedPlaceholder,\\n                            description: resolvedDescription,\\n                            wrapperClassName: fieldClassName,\\n                            labelClassName,\\n                            min,\\n                            max,\\n                            step,\\n                            accept,\\n                            multiple,\\n                            disabled:\\n                              disabled ||\\n                              loading ||\\n                              field.form.state.isSubmitting,\\n                            crossFieldError,\\n                            asyncValidationState,\\n                          };\\n\\n                          // Select the component to use\\n                          const FieldComponent =\\n                            CustomComponent ||\\n                            fieldComponents[type] ||\\n                            TextField;\\n\\n                          // Add type-specific props\\n                          let props: FieldComponentProps = { ...baseProps };\\n\\n                          // Normalize options to the expected format\\n                          const normalizedOptions = resolvedOptions\\n                            ? resolvedOptions.map((opt) =>\\n                                typeof opt === \\\"string\\\"\\n                                  ? { value: opt, label: opt }\\n                                  : opt\\n                              )\\n                            : [];\\n\\n                          if (type === \\\"select\\\") {\\n                            props = { ...props, options: normalizedOptions };\\n                          } else if (type === \\\"array\\\") {\\n                            const mappedArrayConfig = arrayConfig\\n                              ? {\\n                                  itemType: arrayConfig.itemType || \\\"text\\\",\\n                                  itemLabel: arrayConfig.itemLabel,\\n                                  itemPlaceholder: arrayConfig.itemPlaceholder,\\n                                  minItems: arrayConfig.minItems,\\n                                  maxItems: arrayConfig.maxItems,\\n                                  itemValidation: arrayConfig.itemValidation,\\n                                  itemComponent:\\n                                    arrayConfig.itemComponent as React.ComponentType<BaseFieldProps>,\\n                                  addButtonLabel: arrayConfig.addButtonLabel,\\n                                  removeButtonLabel:\\n                                    arrayConfig.removeButtonLabel,\\n                                  sortable: arrayConfig.sortable,\\n                                  defaultValue: arrayConfig.defaultValue,\\n                                  objectConfig: arrayConfig.objectConfig,\\n                                }\\n                              : undefined;\\n                            props = {\\n                              ...props,\\n                              arrayConfig: mappedArrayConfig,\\n                            };\\n                          } else if (\\n                            [\\n                              \\\"text\\\",\\n                              \\\"email\\\",\\n                              \\\"password\\\",\\n                              \\\"url\\\",\\n                              \\\"tel\\\",\\n                            ].includes(type)\\n                          ) {\\n                            props = {\\n                              ...props,\\n                              type: type as\\n                                | \\\"text\\\"\\n                                | \\\"email\\\"\\n                                | \\\"password\\\"\\n                                | \\\"url\\\"\\n                                | \\\"tel\\\",\\n                              datalist: datalist?.options,\\n                            };\\n                          } else if (type === \\\"radio\\\") {\\n                            props = { ...props, options: normalizedOptions };\\n                          } else if (type === \\\"multiSelect\\\") {\\n                            props = {\\n                              ...props,\\n                              options: normalizedOptions,\\n                              multiSelectConfig,\\n                            };\\n                          } else if (type === \\\"colorPicker\\\") {\\n                            props = { ...props, colorConfig };\\n                          } else if (type === \\\"rating\\\") {\\n                            props = { ...props, ratingConfig };\\n                          } else if (type === \\\"phone\\\") {\\n                            props = { ...props, phoneConfig };\\n                          } else if (type === \\\"location\\\") {\\n                            props = { ...props, locationConfig };\\n                          } else if (type === \\\"duration\\\") {\\n                            props = { ...props, durationConfig };\\n                          } else if (type === \\\"autocomplete\\\") {\\n                            // Handle dynamic options for autocomplete\\n                            const resolvedAutocompleteConfig =\\n                              autocompleteConfig\\n                                ? {\\n                                    ...autocompleteConfig,\\n                                    options: resolveOptions(\\n                                      autocompleteConfig.options,\\n                                      currentValues\\n                                    ),\\n                                  }\\n                                : undefined;\\n                            props = {\\n                              ...props,\\n                              autocompleteConfig: resolvedAutocompleteConfig,\\n                            };\\n                          } else if (type === \\\"masked\\\") {\\n                            props = { ...props, maskedInputConfig };\\n                          } else if (type === \\\"object\\\") {\\n                            props = { ...props, objectConfig, form };\\n                          } else if (type === \\\"slider\\\") {\\n                            props = { ...props, sliderConfig };\\n                          } else if (type === \\\"number\\\") {\\n                            props = { ...props, numberConfig };\\n                          } else if (type === \\\"date\\\") {\\n                            props = { ...props, dateConfig };\\n                          } else if (type === \\\"file\\\") {\\n                            props = { ...props, fileConfig };\\n                          } else if (type === \\\"textarea\\\") {\\n                            props = { ...props, textareaConfig };\\n                          } else if (type === \\\"password\\\") {\\n                            props = { ...props, passwordConfig };\\n                          } else if (type === \\\"email\\\") {\\n                            props = { ...props, emailConfig };\\n                          }\\n\\n                          // Render the field component\\n                          const fieldElement = <FieldComponent {...props} />;\\n\\n                          // Apply inline validation wrapper if enabled\\n                          const wrappedFieldElement =\\n                            inlineValidation?.enabled ? (\\n                              <InlineValidationWrapper\\n                                fieldApi={field as unknown as AnyFieldApi}\\n                                inlineValidation={inlineValidation}\\n                              >\\n                                {fieldElement}\\n                              </InlineValidationWrapper>\\n                            ) : (\\n                              fieldElement\\n                            );\\n\\n                          // Add field help if provided\\n                          const fieldWithHelp = help ? (\\n                            <div className=\\\"space-y-2\\\">\\n                              {wrappedFieldElement}\\n                              <FieldHelp help={help} />\\n                            </div>\\n                          ) : (\\n                            wrappedFieldElement\\n                          );\\n\\n                          // Apply custom wrapper or global wrapper\\n                          const Wrapper = CustomWrapper || globalWrapper;\\n\\n                          return Wrapper ? (\\n                            <Wrapper field={fieldConfig}>\\n                              {fieldWithHelp}\\n                            </Wrapper>\\n                          ) : (\\n                            fieldWithHelp\\n                          );\\n                        }}\\n                      </form.Subscribe>\\n                    );\\n                  }}\\n                </FieldConditionalRenderer>\\n              );\\n            }}\\n          </form.Field>\\n        );\\n      },\\n      [resolveOptions]\\n    );\\n\\n    const renderTabContent = React.useCallback(\\n      (tabFields: FieldConfig[]) => {\\n        // TanStack Form Best Practice: Use reusable subscription component\\n        return (\\n          <ConditionalFieldsSubscription\\n            form={form}\\n            fields={tabFields}\\n            conditionalSections={conditionalSections}\\n          >\\n            {(currentValues) => {\\n              // Filter fields based on conditional sections using subscribed values\\n              const visibleFields = tabFields.filter((field) => {\\n                const conditionalSection = conditionalSections.find((section) =>\\n                  section.fields.includes(field.name)\\n                );\\n\\n                if (conditionalSection) {\\n                  return conditionalSection.condition(\\n                    currentValues as TFormValues\\n                  );\\n                }\\n\\n                return true;\\n              });\\n\\n              // Group fields by section and group\\n              const groupedFields = visibleFields.reduce((acc, field) => {\\n                const sectionKey = field.section?.title || \\\"default\\\";\\n                const groupKey = field.group || \\\"default\\\";\\n\\n                if (!acc[sectionKey]) {\\n                  acc[sectionKey] = {\\n                    section: field.section,\\n                    groups: {},\\n                  };\\n                }\\n\\n                if (!acc[sectionKey].groups[groupKey]) {\\n                  acc[sectionKey].groups[groupKey] = [];\\n                }\\n\\n                acc[sectionKey].groups[groupKey].push(field);\\n                return acc;\\n              }, {} as Record<string, { section?: { title?: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\\n\\n              const renderSection = (\\n                sectionKey: string,\\n                sectionData: {\\n                  section?: {\\n                    title?: string;\\n                    description?: string;\\n                    collapsible?: boolean;\\n                    defaultExpanded?: boolean;\\n                  };\\n                  groups: Record<string, FieldConfig[]>;\\n                }\\n              ) => (\\n                <SectionRenderer\\n                  key={sectionKey}\\n                  sectionKey={sectionKey}\\n                  sectionData={sectionData}\\n                  renderField={renderField}\\n                  collapseLabel={collapseLabel}\\n                  expandLabel={expandLabel}\\n                  form={form as unknown as AnyFormApi}\\n                  layout={layout}\\n                />\\n              );\\n\\n              const sectionsToRender = Object.entries(groupedFields);\\n\\n              return sectionsToRender.length === 1 &&\\n                sectionsToRender[0][0] === \\\"default\\\"\\n                ? sectionsToRender[0][1].groups.default?.map(\\n                    (field: FieldConfig) => renderField(field)\\n                  )\\n                : sectionsToRender.map(([sectionKey, sectionData]) =>\\n                    renderSection(sectionKey, sectionData)\\n                  );\\n            }}\\n          </ConditionalFieldsSubscription>\\n        );\\n      },\\n      [renderField]\\n    );\\n\\n    const renderPageContent = React.useCallback(() => {\\n      if (hasTabs) {\\n        // Render tabs - memoize tab content to prevent rerenders\\n        const tabsToRender = tabs!.map((tab) => ({\\n          id: tab.id,\\n          label: tab.label,\\n          content: renderTabContent(fieldsByTab[tab.id] || []),\\n        }));\\n\\n        return (\\n          <FormTabs\\n            tabs={tabsToRender}\\n            activeTab={activeTab}\\n            onTabChange={handleTabChange}\\n          />\\n        );\\n      }\\n\\n      // Original page rendering logic with TanStack Form best practices\\n      const currentFields = getCurrentPageFields();\\n      const pageConfig = getCurrentPageConfig();\\n\\n      // For now, subscribe to all form values since we don't have explicit dependencies\\n      // This could be optimized further by analyzing the condition functions\\n\\n      // TanStack Form Best Practice: Use targeted selector for minimal re-renders\\n      return (\\n        <form.Subscribe selector={(state: any) => state.values}>\\n          {(currentValues: any) => {\\n            // Filter fields based on conditional sections using subscribed values\\n            const visibleFields = currentFields.filter((field) => {\\n              const conditionalSection = conditionalSections.find((section) =>\\n                section.fields.includes(field.name)\\n              );\\n\\n              if (conditionalSection) {\\n                return conditionalSection.condition(\\n                  currentValues as TFormValues\\n                );\\n              }\\n\\n              return true;\\n            });\\n\\n            // Group fields by section and group\\n            const groupedFields = visibleFields.reduce((acc, field) => {\\n              const sectionKey = field.section?.title || \\\"default\\\";\\n              const groupKey = field.group || \\\"default\\\";\\n\\n              if (!acc[sectionKey]) {\\n                acc[sectionKey] = {\\n                  section: field.section,\\n                  groups: {},\\n                };\\n              }\\n\\n              if (!acc[sectionKey].groups[groupKey]) {\\n                acc[sectionKey].groups[groupKey] = [];\\n              }\\n\\n              acc[sectionKey].groups[groupKey].push(field);\\n              return acc;\\n            }, {} as Record<string, { section?: { title?: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\\n\\n            const renderSection = (\\n              sectionKey: string,\\n              sectionData: {\\n                section?: {\\n                  title?: string;\\n                  description?: string;\\n                  collapsible?: boolean;\\n                  defaultExpanded?: boolean;\\n                };\\n                groups: Record<string, FieldConfig[]>;\\n              }\\n            ) => (\\n              <SectionRenderer\\n                key={sectionKey}\\n                sectionKey={sectionKey}\\n                sectionData={sectionData}\\n                renderField={renderField}\\n                collapseLabel={collapseLabel}\\n                expandLabel={expandLabel}\\n                form={form as unknown as AnyFormApi}\\n                layout={layout}\\n              />\\n            );\\n\\n            const sectionsToRender = Object.entries(groupedFields);\\n\\n            const PageComponent = pageConfig?.component || DefaultPageComponent;\\n\\n            // Debug logging for page description\\n            // if (\\n            //   pageConfig?.description &&\\n            //   pageConfig.description.includes(\\\"{{\\\")\\n            // ) {\\n            //   console.log(\\\"DEBUG - Page description:\\\", pageConfig.description);\\n            //   console.log(\\\"DEBUG - Current values:\\\", currentValues);\\n            //   console.log(\\n            //     \\\"DEBUG - Resolved description:\\\",\\n            //     resolveDynamicText(pageConfig.description, currentValues)\\n            //   );\\n            // }\\n\\n            return (\\n              <PageComponent\\n                title={\\n                  pageConfig?.title\\n                    ? resolveDynamicText(pageConfig.title, currentValues)\\n                    : undefined\\n                }\\n                description={\\n                  pageConfig?.description\\n                    ? resolveDynamicText(pageConfig.description, currentValues)\\n                    : undefined\\n                }\\n                page={currentPage}\\n                totalPages={totalPages}\\n              >\\n                {sectionsToRender.length === 1 &&\\n                sectionsToRender[0][0] === \\\"default\\\"\\n                  ? sectionsToRender[0][1].groups.default?.map(\\n                      (field: FieldConfig) => renderField(field)\\n                    )\\n                  : sectionsToRender.map(([sectionKey, sectionData]) =>\\n                      renderSection(sectionKey, sectionData)\\n                    )}\\n              </PageComponent>\\n            );\\n          }}\\n        </form.Subscribe>\\n      );\\n    }, [renderTabContent, renderField, activeTab, handleTabChange]);\\n\\n    const renderProgress = () => {\\n      if (!hasPages || !progress) return null;\\n\\n      const ProgressComponent = progress.component || DefaultProgressComponent;\\n\\n      return (\\n        <ProgressComponent\\n          value={progressValue}\\n          currentPage={currentPage}\\n          totalPages={totalPages}\\n          className={progress.className}\\n          showSteps={progress.showSteps}\\n          showPercentage={progress.showPercentage}\\n        />\\n      );\\n    };\\n\\n    const renderNavigation = () => {\\n      if (!showSubmitButton) return null;\\n      if (!hasPages) {\\n        return (\\n          <form.Subscribe\\n            selector={(state) => ({\\n              canSubmit: state.canSubmit,\\n              isSubmitting: state.isSubmitting,\\n            })}\\n          >\\n            {(state) => {\\n              const { canSubmit, isSubmitting } = state as {\\n                canSubmit: boolean;\\n                isSubmitting: boolean;\\n              };\\n\\n              const SubmitButton = submitButton || Button;\\n\\n              return (\\n                <div className=\\\"flex justify-end\\\">\\n                  <SubmitButton\\n                    type=\\\"submit\\\"\\n                    disabled={!canSubmit || isSubmitting || disabled || loading}\\n                    className={cn(\\\"px-8\\\", submitButtonClassName)}\\n                  >\\n                    {loading\\n                      ? \\\"Loading...\\\"\\n                      : isSubmitting\\n                      ? \\\"Submitting...\\\"\\n                      : submitLabel}\\n                  </SubmitButton>\\n                </div>\\n              );\\n            }}\\n          </form.Subscribe>\\n        );\\n      }\\n\\n      return (\\n        <form.Subscribe\\n          selector={(state) => ({\\n            canSubmit: state.canSubmit,\\n            isSubmitting: state.isSubmitting,\\n          })}\\n        >\\n          {(state) => {\\n            const { canSubmit, isSubmitting } = state as {\\n              canSubmit: boolean;\\n              isSubmitting: boolean;\\n            };\\n\\n            const SubmitButton = submitButton || Button;\\n\\n            return (\\n              <div className=\\\"flex justify-between gap-4\\\">\\n                <Button\\n                  type=\\\"button\\\"\\n                  variant=\\\"outline\\\"\\n                  onClick={goToPreviousPage}\\n                  disabled={isFirstPage || disabled || loading}\\n                  className={cn(\\n                    isFirstPage ? \\\"invisible\\\" : \\\"\\\",\\n                    buttonClassName\\n                  )}\\n                >\\n                  {previousLabel}\\n                </Button>\\n\\n                <SubmitButton\\n                  type=\\\"submit\\\"\\n                  disabled={\\n                    (!canSubmit || isSubmitting || disabled || loading) &&\\n                    isLastPage\\n                  }\\n                  className={cn(\\n                    \\\"px-8\\\",\\n                    isLastPage ? submitButtonClassName : buttonClassName\\n                  )}\\n                >\\n                  {loading && isLastPage\\n                    ? \\\"Loading...\\\"\\n                    : isSubmitting && isLastPage\\n                    ? \\\"Submitting...\\\"\\n                    : isLastPage\\n                    ? submitLabel\\n                    : nextLabel}\\n                </SubmitButton>\\n              </div>\\n            );\\n          }}\\n        </form.Subscribe>\\n      );\\n    };\\n\\n    return (\\n      <form\\n        ref={htmlFormRef}\\n        onSubmit={handleSubmit}\\n        className={formClass}\\n        action={action}\\n        method={method}\\n        encType={encType}\\n        target={target}\\n        autoComplete={autoComplete}\\n        noValidate={noValidate}\\n        acceptCharset={acceptCharset}\\n        onReset={handleReset}\\n        onInput={handleInput}\\n        onInvalid={handleInvalid}\\n        onKeyDown={handleKeyDown}\\n        onKeyUp={handleKeyUp}\\n        onFocus={handleFocus}\\n        onBlur={handleBlur}\\n        role={role}\\n        aria-label={ariaLabel}\\n        aria-labelledby={ariaLabelledby}\\n        aria-describedby={ariaDescribedby}\\n        tabIndex={tabIndex}\\n      >\\n        {children || (\\n          <>\\n            {renderProgress()}\\n            {renderPageContent()}\\n            {renderNavigation()}\\n          </>\\n        )}\\n      </form>\\n    );\\n  };\\n\\n  return {\\n    form,\\n    Form,\\n    currentPage,\\n    totalPages,\\n    visiblePages,\\n    goToNextPage,\\n    goToPreviousPage,\\n    setCurrentPage: setCurrentPageWithValidation,\\n    isFirstPage,\\n    isLastPage,\\n    progressValue,\\n    // Advanced features\\n    crossFieldErrors,\\n    asyncValidationStates,\\n    validateCrossFields,\\n    validateFieldAsync,\\n    saveToStorage,\\n    loadFromStorage,\\n    clearStorage,\\n  };\\n}\\n\",\n  \"/src/index.ts\": \"// Field components\\nexport * from '@/components/formedible/fields/text-field';\\nexport * from '@/components/formedible/fields/textarea-field';\\nexport * from '@/components/formedible/fields/number-field';\\nexport * from '@/components/formedible/fields/select-field';\\nexport * from '@/components/formedible/fields/checkbox-field';\\nexport * from '@/components/formedible/fields/switch-field';\\nexport * from '@/components/formedible/fields/date-field';\\nexport * from '@/components/formedible/fields/slider-field';\\nexport * from '@/components/formedible/fields/file-upload-field';\\nexport * from '@/components/formedible/fields/array-field';\\nexport * from '@/components/formedible/fields/radio-field';\\nexport * from '@/components/formedible/fields/multi-select-field';\\nexport * from '@/components/formedible/fields/color-picker-field';\\nexport * from '@/components/formedible/fields/rating-field';\\nexport * from '@/components/formedible/fields/phone-field';\\nexport * from '@/components/formedible/fields/location-picker-field';\\nexport * from '@/components/formedible/fields/duration-picker-field';\\nexport * from '@/components/formedible/fields/autocomplete-field';\\nexport * from '@/components/formedible/fields/masked-input-field';\\n\\n// Layout components\\nexport * from '@/components/formedible/layout/form-grid';\\nexport * from '@/components/formedible/layout/form-tabs';\\nexport * from '@/components/formedible/layout/form-accordion';\\nexport * from '@/components/formedible/layout/form-stepper';\\n\\n// UI components\\nexport * from '@/components/ui/accordion';\\n\\n// Utility components\\nexport * from '@/components/formedible/fields/inline-validation-wrapper';\\nexport * from '@/components/formedible/fields/field-help';\\nexport { SharedFieldRenderer, NestedFieldRenderer, FIELD_TYPE_COMPONENTS } from '@/components/formedible/fields/shared-field-renderer';\\n\\n// Core types and hook\\nexport type { \\n  BaseFieldProps, \\n  FieldConfig, \\n  PageConfig, \\n  ProgressConfig,\\n  FieldComponentProps,\\n  ObjectConfig,\\n} from '@/lib/formedible/types';\\nexport { useFormedible } from '@/hooks/use-formedible';\\n\\n// Testing utilities\\nexport * from './testing';\\n\",\n  \"/src/lib/formedible/colors.ts\": \"export const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\\n  const result = /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(hex);\\n  return result ? {\\n    r: parseInt(result[1], 16),\\n    g: parseInt(result[2], 16),\\n    b: parseInt(result[3], 16)\\n  } : null;\\n};\\n\\nexport const hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {\\n  const rgb = hexToRgb(hex);\\n  if (!rgb) return null;\\n  \\n  const { r, g, b } = rgb;\\n  const rNorm = r / 255;\\n  const gNorm = g / 255;\\n  const bNorm = b / 255;\\n  \\n  const max = Math.max(rNorm, gNorm, bNorm);\\n  const min = Math.min(rNorm, gNorm, bNorm);\\n  const diff = max - min;\\n  \\n  let h = 0;\\n  let s = 0;\\n  const l = (max + min) / 2;\\n  \\n  if (diff !== 0) {\\n    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);\\n    \\n    switch (max) {\\n      case rNorm: h = (gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0); break;\\n      case gNorm: h = (bNorm - rNorm) / diff + 2; break;\\n      case bNorm: h = (rNorm - gNorm) / diff + 4; break;\\n    }\\n    h /= 6;\\n  }\\n  \\n  return {\\n    h: Math.round(h * 360),\\n    s: Math.round(s * 100),\\n    l: Math.round(l * 100)\\n  };\\n};\",\n  \"/src/lib/formedible/template-interpolation.ts\": \"/**\\n * Template interpolation utilities for dynamic form titles, labels, and descriptions\\n * Supports {{fieldName}}, {{fieldName.property}}, {{fieldName[index]}}, and {{fieldName|formatter}} syntax\\n */\\n\\n// Supported formatters for template interpolation\\nexport type TemplateFormatter = \\n  | 'uppercase' \\n  | 'lowercase' \\n  | 'capitalize' \\n  | 'titlecase'\\n  | 'pluralize'\\n  | 'number'\\n  | 'currency'\\n  | 'date'\\n  | 'time'\\n  | 'datetime';\\n\\n// Configuration for formatters\\nexport interface FormatterConfig {\\n  currency?: {\\n    currency?: string;\\n    locale?: string;\\n  };\\n  date?: {\\n    locale?: string;\\n    format?: 'short' | 'medium' | 'long' | 'full';\\n  };\\n  pluralize?: {\\n    singular?: string;\\n    plural?: string;\\n  };\\n}\\n\\n// Template interpolation options\\nexport interface TemplateOptions {\\n  formatters?: FormatterConfig;\\n  fallbackValue?: string;\\n  strict?: boolean; // If true, throw errors for missing values\\n}\\n\\n/**\\n * Extract field dependencies from a template string\\n * @param template Template string with {{fieldName}} syntax\\n * @returns Array of field names that the template depends on\\n */\\nexport function extractTemplateDependencies(template: string): string[] {\\n  const regex = /\\\\{\\\\{([^}|]+)(?:\\\\|[^}]+)?\\\\}\\\\}/g;\\n  const dependencies = new Set<string>();\\n  let match;\\n\\n  while ((match = regex.exec(template)) !== null) {\\n    const fieldPath = match[1].trim();\\n    // Extract root field name (before dots or brackets)\\n    const rootField = fieldPath.split(/[.\\\\[]/, 1)[0];\\n    if (rootField) {\\n      dependencies.add(rootField);\\n    }\\n  }\\n\\n  return Array.from(dependencies);\\n}\\n\\n/**\\n * Get nested value from an object using dot notation or bracket notation\\n * @param obj Source object\\n * @param path Path string like \\\"user.name\\\" or \\\"items[0].title\\\"\\n * @returns The value at the path or undefined\\n */\\nfunction getNestedValue(obj: Record<string, unknown>, path: string): unknown {\\n  try {\\n    // Handle array indexing and property access\\n    const keys = path.split(/[.\\\\[]/).map(key => key.replace(/\\\\]$/, ''));\\n    let current: any = obj;\\n\\n    for (const key of keys) {\\n      if (current == null) return undefined;\\n      \\n      // Handle numeric array indices\\n      if (/^\\\\d+$/.test(key)) {\\n        current = current[parseInt(key, 10)];\\n      } else if (key) {\\n        current = current[key];\\n      }\\n    }\\n\\n    return current;\\n  } catch {\\n    return undefined;\\n  }\\n}\\n\\n/**\\n * Apply formatter to a value\\n * @param value The value to format\\n * @param formatter The formatter name\\n * @param config Optional formatter configuration\\n * @returns Formatted value\\n */\\nfunction applyFormatter(\\n  value: unknown, \\n  formatter: string, \\n  config?: FormatterConfig\\n): string {\\n  if (value == null) return '';\\n  \\n  const stringValue = String(value);\\n\\n  switch (formatter) {\\n    case 'uppercase':\\n      return stringValue.toUpperCase();\\n      \\n    case 'lowercase':\\n      return stringValue.toLowerCase();\\n      \\n    case 'capitalize':\\n      return stringValue.charAt(0).toUpperCase() + stringValue.slice(1).toLowerCase();\\n      \\n    case 'titlecase':\\n      return stringValue.replace(/\\\\w\\\\S*/g, (txt: string) => \\n        txt.charAt(0).toUpperCase() + txt.slice(1).toLowerCase()\\n      );\\n      \\n    case 'pluralize':\\n      const num = typeof value === 'number' ? value : parseInt(stringValue, 10);\\n      if (isNaN(num)) return stringValue;\\n      \\n      const { singular = '', plural = stringValue + 's' } = config?.pluralize || {};\\n      return num === 1 ? singular || stringValue : plural;\\n      \\n    case 'number':\\n      const numValue = typeof value === 'number' ? value : parseFloat(stringValue);\\n      return isNaN(numValue) ? stringValue : numValue.toLocaleString();\\n      \\n    case 'currency':\\n      const currencyValue = typeof value === 'number' ? value : parseFloat(stringValue);\\n      if (isNaN(currencyValue)) return stringValue;\\n      \\n      const { currency = 'USD', locale = 'en-US' } = config?.currency || {};\\n      return new Intl.NumberFormat(locale, {\\n        style: 'currency',\\n        currency,\\n      }).format(currencyValue);\\n      \\n    case 'date':\\n      const dateValue = value instanceof Date ? value : new Date(stringValue);\\n      if (isNaN(dateValue.getTime())) return stringValue;\\n      \\n      const { locale: dateLocale = 'en-US', format = 'medium' } = config?.date || {};\\n      const formatOptions: Intl.DateTimeFormatOptions = {\\n        short: { dateStyle: 'short' as const },\\n        medium: { dateStyle: 'medium' as const },\\n        long: { dateStyle: 'long' as const },\\n        full: { dateStyle: 'full' as const },\\n      }[format] || { dateStyle: 'medium' as const };\\n      \\n      return new Intl.DateTimeFormat(dateLocale, formatOptions).format(dateValue);\\n      \\n    case 'time':\\n      const timeValue = value instanceof Date ? value : new Date(stringValue);\\n      if (isNaN(timeValue.getTime())) return stringValue;\\n      \\n      return timeValue.toLocaleTimeString();\\n      \\n    case 'datetime':\\n      const datetimeValue = value instanceof Date ? value : new Date(stringValue);\\n      if (isNaN(datetimeValue.getTime())) return stringValue;\\n      \\n      return datetimeValue.toLocaleString();\\n      \\n    default:\\n      return stringValue;\\n  }\\n}\\n\\n/**\\n * Interpolate template string with form values\\n * @param template Template string with {{fieldName}} syntax\\n * @param values Form values object\\n * @param options Template interpolation options\\n * @returns Interpolated string\\n */\\nexport function interpolateTemplate(\\n  template: string,\\n  values: Record<string, unknown>,\\n  options: TemplateOptions = {}\\n): string {\\n  const { formatters, fallbackValue = '', strict = false } = options;\\n\\n  return template.replace(/\\\\{\\\\{([^}]+)\\\\}\\\\}/g, (match, content) => {\\n    try {\\n      const trimmedContent = content.trim();\\n      \\n      // Split by pipe to separate field path from formatter\\n      const [fieldPath, formatterName] = trimmedContent.split('|').map((s: string) => s.trim());\\n      \\n      // Get the value from the form values\\n      const value = getNestedValue(values, fieldPath);\\n      \\n      if (value == null) {\\n        if (strict) {\\n          throw new Error(`Template field '${fieldPath}' not found in form values`);\\n        }\\n        return fallbackValue;\\n      }\\n      \\n      // Apply formatter if specified\\n      if (formatterName) {\\n        return applyFormatter(value, formatterName, formatters);\\n      }\\n      \\n      return String(value);\\n    } catch (error) {\\n      if (strict) {\\n        throw error;\\n      }\\n      console.warn(`Template interpolation error for '${match}':`, error);\\n      return fallbackValue;\\n    }\\n  });\\n}\\n\\n/**\\n * Check if a string contains template syntax\\n * @param str String to check\\n * @returns True if string contains {{}} template syntax\\n */\\nexport function isTemplate(str: string): boolean {\\n  return /\\\\{\\\\{[^}]+\\\\}\\\\}/.test(str);\\n}\\n\\n/**\\n * Resolve a dynamic text value (string or function) to a string\\n * @param value String template or function that returns string\\n * @param formValues Current form values\\n * @param options Template interpolation options\\n * @returns Resolved string value\\n */\\nexport function resolveDynamicText(\\n  value: string | ((values: Record<string, unknown>) => string) | undefined,\\n  formValues: Record<string, unknown>,\\n  options?: TemplateOptions\\n): string | undefined {\\n  if (!value) return undefined;\\n  \\n  if (typeof value === 'function') {\\n    try {\\n      return value(formValues);\\n    } catch (error) {\\n      console.warn('Error executing dynamic text function:', error);\\n      return options?.fallbackValue || '';\\n    }\\n  }\\n  \\n  if (typeof value === 'string') {\\n    if (isTemplate(value)) {\\n      return interpolateTemplate(value, formValues, options);\\n    }\\n    return value;\\n  }\\n  \\n  return undefined;\\n}\\n\\n/**\\n * Get all field dependencies for a dynamic text value\\n * @param value String template or function\\n * @returns Array of field names that this value depends on\\n */\\nexport function getDynamicTextDependencies(\\n  value: string | ((values: Record<string, unknown>) => string) | undefined\\n): string[] {\\n  if (!value) return [];\\n  \\n  if (typeof value === 'string' && isTemplate(value)) {\\n    return extractTemplateDependencies(value);\\n  }\\n  \\n  // For functions, we can't easily determine dependencies\\n  // Return empty array and rely on broader form subscription\\n  return [];\\n}\",\n  \"/src/lib/formedible/types.ts\": \"import React from \\\"react\\\";\\nimport type { AnyFieldApi } from \\\"@tanstack/react-form\\\";\\nimport type {\\n  FormApi,\\n  ValidationError,\\n  FormState,\\n  AnyFormApi,\\n} from \\\"@tanstack/form-core\\\";\\nimport { z } from \\\"zod\\\";\\n\\n// Strict type definitions for better type safety\\nexport interface StrictFieldApi<T = unknown> {\\n  name: string;\\n  value: T;\\n  errors: ValidationError[];\\n  touched: boolean;\\n  setValue: (value: T) => void;\\n  setTouched: (touched: boolean) => void;\\n  validate: () => Promise<ValidationError[]>;\\n}\\n\\nexport interface TypedFormState<TFormData = Record<string, unknown>> {\\n  values: TFormData;\\n  errors: Record<keyof TFormData, ValidationError[]>;\\n  touched: Record<keyof TFormData, boolean>;\\n  isSubmitting: boolean;\\n  isValidating: boolean;\\n  canSubmit: boolean;\\n}\\n\\nexport interface TypedFormSubscriptionSelector<\\n  TFormData = Record<string, unknown>,\\n  TSelected = unknown\\n> {\\n  (\\n    state: FormState<\\n      TFormData,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined,\\n      undefined\\n    >\\n  ): TSelected;\\n}\\n\\n// Validation error types based on TanStack Form\\nexport type FormedibleValidationError = ValidationError;\\n\\n// Validation error that can be a string, Error object, or custom validation result\\nexport type FieldValidationError = string | Error | ValidationError;\\n\\n// Array of validation errors for a field\\nexport type FieldValidationErrors = FieldValidationError[];\\n\\n// Dynamic text types for template interpolation\\nexport type DynamicText =\\n  | string\\n  | ((values: Record<string, unknown>) => string);\\nexport type OptionalDynamicText = DynamicText | undefined;\\n\\n// Type alias for our FormApi - use the core FormApi type which is what useForm actually returns\\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\\n  TFormData,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  undefined,\\n  never\\n>;\\n\\n// Option types for select, radio, and multi-select fields\\nexport type FieldOption = {\\n  value: string;\\n  label: string;\\n  disabled?: boolean;\\n  description?: string;\\n};\\n\\nexport type FieldOptions = string[] | FieldOption[];\\n\\n// Normalize options to consistent format\\nexport type NormalizedFieldOption = FieldOption;\\n\\n// Props that all basic field components rendered by FormedibleRoot will receive\\nexport interface BaseFieldProps {\\n  fieldApi: AnyFieldApi;\\n  label?: string;\\n  description?: string;\\n  placeholder?: string;\\n  inputClassName?: string; // For the <Input /> component itself\\n  labelClassName?: string; // For the <Label /> component\\n  wrapperClassName?: string; // For the div wrapping label and input\\n}\\n\\n// Specific field component prop types\\nexport interface SelectFieldProps extends BaseFieldProps {\\n  options: FieldOptions;\\n  placeholder?: string;\\n}\\n\\nexport interface RadioFieldProps extends BaseFieldProps {\\n  options: FieldOptions;\\n}\\n\\nexport interface MultiSelectFieldProps extends BaseFieldProps {\\n  options: FieldOptions;\\n  placeholder?: string;\\n  maxSelections?: number;\\n}\\n\\n// Shared object configuration interface - DRY!\\nexport interface ObjectConfig {\\n  title?: string;\\n  description?: string;\\n  fields: Array<{\\n    name: string;\\n    type: string;\\n    label?: DynamicText;\\n    placeholder?: DynamicText;\\n    description?: DynamicText;\\n    options?:\\n      | string[]\\n      | Array<{ value: string; label: string }>\\n      | ((\\n          values: Record<string, unknown>\\n        ) => string[] | Array<{ value: string; label: string }>);\\n    min?: number;\\n    max?: number;\\n    step?: number;\\n    [key: string]: unknown;\\n  }>;\\n  collapsible?: boolean;\\n  defaultExpanded?: boolean;\\n  showCard?: boolean;\\n  layout?: \\\"grid\\\" | \\\"vertical\\\" | \\\"horizontal\\\" | (string & {});\\n  columns?: number;\\n  collapseLabel?: string;\\n  expandLabel?: string;\\n}\\n\\nexport interface ArrayFieldProps extends BaseFieldProps {\\n  arrayConfig: {\\n    itemType: string;\\n    itemLabel?: string;\\n    itemPlaceholder?: string;\\n    itemValidation?: unknown;\\n    minItems?: number;\\n    maxItems?: number;\\n    addButtonLabel?: string;\\n    removeButtonLabel?: string;\\n    sortable?: boolean;\\n    defaultValue?: unknown;\\n    itemComponent?: React.ComponentType<BaseFieldProps>;\\n    itemProps?: Record<string, unknown>;\\n    // Use the shared ObjectConfig - DRY!\\n    objectConfig?: ObjectConfig;\\n  };\\n}\\n\\nexport interface TextFieldProps extends BaseFieldProps {\\n  type?: \\\"text\\\" | \\\"email\\\" | \\\"password\\\" | \\\"url\\\" | \\\"tel\\\";\\n  datalist?: string[];\\n  maxLength?: number;\\n  minLength?: number;\\n  pattern?: string;\\n  autoComplete?: string;\\n}\\n\\nexport interface NumberFieldProps extends BaseFieldProps {\\n  min?: number;\\n  max?: number;\\n  step?: number;\\n  precision?: number;\\n}\\n\\nexport interface DateFieldProps extends BaseFieldProps {\\n  dateConfig?: {\\n    format?: string;\\n    minDate?: Date;\\n    maxDate?: Date;\\n    disabledDates?: Date[];\\n    showTime?: boolean;\\n    timeFormat?: string;\\n  };\\n}\\n\\nexport interface SliderFieldProps extends BaseFieldProps {\\n  sliderConfig?: {\\n    min?: number;\\n    max?: number;\\n    step?: number;\\n    // Value mapping between slider value (int) and display value (arbitrary)\\n    valueMapping?: Array<{\\n      sliderValue: number;\\n      displayValue: string | number;\\n      label?: string;\\n    }>;\\n    // Gradient colors for the slider\\n    gradientColors?: {\\n      start: string;\\n      end: string;\\n      direction?: \\\"horizontal\\\" | \\\"vertical\\\";\\n    };\\n    // Custom visualization component for each step\\n    visualizationComponent?: React.ComponentType<{\\n      value: number;\\n      displayValue: string | number;\\n      label?: string;\\n      isActive: boolean;\\n    }>;\\n    // Legacy and additional config\\n    valueLabelPrefix?: string;\\n    valueLabelSuffix?: string;\\n    valueDisplayPrecision?: number;\\n    showRawValue?: boolean;\\n    showValue?: boolean;\\n    showTooltip?: boolean;\\n    showTicks?: boolean;\\n    orientation?: \\\"horizontal\\\" | \\\"vertical\\\";\\n    marks?: Array<{ value: number; label: string }>;\\n  };\\n}\\n\\nexport interface FileUploadFieldProps extends BaseFieldProps {\\n  fileConfig?: {\\n    accept?: string;\\n    multiple?: boolean;\\n    maxSize?: number;\\n    maxFiles?: number;\\n    allowedTypes?: string[];\\n    uploadUrl?: string;\\n    onUpload?: (files: File[]) => Promise<string[]>;\\n  };\\n}\\n\\nexport interface LocationPickerFieldProps extends BaseFieldProps {\\n  locationConfig?: LocationConfig;\\n}\\n\\nexport interface DurationPickerFieldProps extends BaseFieldProps {\\n  durationConfig?: DurationConfig;\\n}\\n\\nexport interface AutocompleteFieldProps extends BaseFieldProps {\\n  autocompleteConfig?: AutocompleteConfig;\\n}\\n\\nexport interface MaskedInputFieldProps extends BaseFieldProps {\\n  maskedConfig?: MaskedInputConfig;\\n}\\n\\nexport interface ColorPickerFieldProps extends BaseFieldProps {\\n  colorConfig?: {\\n    format?: \\\"hex\\\" | \\\"rgb\\\" | \\\"hsl\\\";\\n    showPreview?: boolean; // Show color preview\\n    showAlpha?: boolean;\\n    presetColors?: string[];\\n    allowCustom?: boolean;\\n  };\\n}\\n\\nexport interface RatingFieldProps extends BaseFieldProps {\\n  ratingConfig?: {\\n    max?: number;\\n    allowHalf?: boolean;\\n    allowClear?: boolean;\\n    icon?: \\\"star\\\" | \\\"heart\\\" | \\\"thumbs\\\" | React.ComponentType;\\n    size?: \\\"sm\\\" | \\\"md\\\" | \\\"lg\\\" | \\\"small\\\" | \\\"medium\\\" | \\\"large\\\";\\n    showValue?: boolean;\\n  };\\n}\\n\\nexport interface PhoneFieldProps extends BaseFieldProps {\\n  phoneConfig?: {\\n    defaultCountry?: string;\\n    preferredCountries?: string[];\\n    onlyCountries?: string[];\\n    excludeCountries?: string[];\\n    format?: \\\"national\\\" | \\\"international\\\";\\n  };\\n}\\n\\nexport interface ObjectFieldProps extends BaseFieldProps {\\n  objectConfig?: ObjectConfig;\\n  disabled?: boolean;\\n  form?: AnyFormApi;\\n}\\n\\n// Field-specific interfaces moved from field components for centralization\\nexport interface TextFieldSpecificProps extends BaseFieldProps {\\n  type?: \\\"text\\\" | \\\"email\\\" | \\\"password\\\" | \\\"url\\\" | \\\"tel\\\" | \\\"datetime-local\\\";\\n  datalist?: {\\n    options?: string[];\\n    asyncOptions?: (query: string) => Promise<string[]>;\\n    debounceMs?: number;\\n    minChars?: number;\\n    maxResults?: number;\\n  };\\n}\\n\\nexport interface NumberFieldSpecificProps extends BaseFieldProps {\\n  min?: number;\\n  max?: number;\\n  step?: number;\\n}\\n\\nexport interface TextareaFieldSpecificProps extends BaseFieldProps {\\n  rows?: number;\\n}\\n\\nexport interface RadioFieldSpecificProps extends BaseFieldProps {\\n  options: Array<{ value: string; label: string }> | string[];\\n  direction?: \\\"horizontal\\\" | \\\"vertical\\\";\\n}\\n\\nexport interface PhoneFieldSpecificProps extends BaseFieldProps {\\n  phoneConfig?: {\\n    defaultCountry?: string;\\n    format?: \\\"national\\\" | \\\"international\\\";\\n    allowedCountries?: string[];\\n    placeholder?: string;\\n    excludedCountries?: string[];\\n  };\\n}\\n\\nexport interface MultiSelectFieldSpecificProps extends BaseFieldProps {\\n  options: Array<{ value: string; label: string }> | string[];\\n  multiSelectConfig?: {\\n    maxSelections?: number;\\n    searchable?: boolean;\\n    creatable?: boolean;\\n    placeholder?: string;\\n    noOptionsText?: string;\\n    loadingText?: string;\\n  };\\n}\\n\\nexport interface ColorPickerFieldSpecificProps extends BaseFieldProps {\\n  colorConfig?: {\\n    format?: \\\"hex\\\" | \\\"rgb\\\" | \\\"hsl\\\";\\n    showPreview?: boolean;\\n    presetColors?: string[];\\n    allowCustom?: boolean;\\n    showAlpha?: boolean;\\n  };\\n}\\n\\nexport interface RatingFieldSpecificProps extends BaseFieldProps {\\n  ratingConfig?: {\\n    max?: number;\\n    allowHalf?: boolean;\\n    icon?: \\\"star\\\" | \\\"heart\\\" | \\\"thumbs\\\";\\n    size?: \\\"sm\\\" | \\\"md\\\" | \\\"lg\\\";\\n    allowClear?: boolean;\\n    showValue?: boolean;\\n  };\\n}\\n\\nexport interface SliderFieldSpecificProps extends BaseFieldProps {\\n  sliderConfig?: {\\n    min?: number;\\n    max?: number;\\n    step?: number;\\n    // Value mapping between slider value (int) and display value (arbitrary)\\n    valueMapping?: Array<{\\n      sliderValue: number;\\n      displayValue: string | number;\\n      label?: string;\\n    }>;\\n    // Gradient colors for the slider\\n    gradientColors?: {\\n      start: string;\\n      end: string;\\n      direction?: \\\"horizontal\\\" | \\\"vertical\\\";\\n    };\\n    // Custom visualization component for each step\\n    visualizationComponent?: React.ComponentType<{\\n      value: number;\\n      displayValue: string | number;\\n      label?: string;\\n      isActive: boolean;\\n    }>;\\n    // Legacy support\\n    valueLabelPrefix?: string;\\n    valueLabelSuffix?: string;\\n    valueDisplayPrecision?: number;\\n    showRawValue?: boolean;\\n    showValue?: boolean;\\n    showTooltip?: boolean;\\n    orientation?: \\\"horizontal\\\" | \\\"vertical\\\";\\n    marks?: Array<{ value: number; label: string }>;\\n  };\\n  // Direct props for backwards compatibility\\n  min?: number;\\n  max?: number;\\n  step?: number;\\n  valueLabelPrefix?: string;\\n  valueLabelSuffix?: string;\\n  valueDisplayPrecision?: number;\\n  showRawValue?: boolean;\\n}\\n\\n// Layout component interfaces moved from layout components for centralization\\nexport interface FormGridProps {\\n  children: React.ReactNode;\\n  columns?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\\n  gap?:\\n    | \\\"0\\\"\\n    | \\\"1\\\"\\n    | \\\"2\\\"\\n    | \\\"3\\\"\\n    | \\\"4\\\"\\n    | \\\"5\\\"\\n    | \\\"6\\\"\\n    | \\\"7\\\"\\n    | \\\"8\\\"\\n    | \\\"9\\\"\\n    | \\\"10\\\"\\n    | \\\"11\\\"\\n    | \\\"12\\\";\\n  responsive?: boolean;\\n  className?: string;\\n}\\n\\nexport interface FormTabsProps {\\n  children?: React.ReactNode;\\n  tabs: {\\n    id: string;\\n    label: string;\\n    content: React.ReactNode;\\n  }[];\\n  activeTab: string; // CONTROLLED - NO INTERNAL STATE\\n  className?: string;\\n  onTabChange: (tabId: string) => void; // REQUIRED - PARENT CONTROLS STATE\\n}\\n\\nexport interface FormAccordionProps {\\n  children?: React.ReactNode;\\n  sections: {\\n    id: string;\\n    title: string;\\n    content: React.ReactNode;\\n    defaultOpen?: boolean;\\n  }[];\\n  type?: \\\"single\\\" | \\\"multiple\\\";\\n  className?: string;\\n}\\n\\nexport interface FormStepperStep {\\n  id: string;\\n  title: string;\\n  description?: string;\\n  content: React.ReactNode;\\n  optional?: boolean;\\n}\\n\\nexport interface FormStepperProps {\\n  children?: React.ReactNode;\\n  steps: FormStepperStep[];\\n  currentStep?: number;\\n  onStepChange?: (stepIndex: number) => void;\\n  onComplete?: () => void;\\n  className?: string;\\n  allowSkip?: boolean;\\n  showStepNumbers?: boolean;\\n}\\n\\n// Wrapper component interfaces moved from field components for centralization\\nexport interface FieldWrapperProps extends BaseFieldProps {\\n  children: React.ReactNode;\\n  htmlFor?: string;\\n  showErrors?: boolean;\\n}\\n\\nexport interface InlineValidationWrapperProps {\\n  children: React.ReactNode;\\n  fieldApi: AnyFieldApi;\\n  inlineValidation?: {\\n    enabled?: boolean;\\n    debounceMs?: number;\\n    showSuccess?: boolean;\\n    asyncValidator?: (value: unknown) => Promise<string | null>;\\n  };\\n  className?: string;\\n}\\n\\n// Union type for all possible field component props - using intersection for flexibility\\nexport type FieldComponentProps = BaseFieldProps & {\\n  // Optional props that specific field types might need\\n  options?: FieldOptions;\\n  arrayConfig?: ArrayFieldProps[\\\"arrayConfig\\\"];\\n  objectConfig?: ObjectConfig;\\n  type?: TextFieldProps[\\\"type\\\"];\\n  datalist?: string[];\\n  dateConfig?: DateFieldProps[\\\"dateConfig\\\"];\\n  sliderConfig?: SliderFieldProps[\\\"sliderConfig\\\"];\\n  fileConfig?: FileUploadFieldProps[\\\"fileConfig\\\"];\\n  locationConfig?: LocationPickerFieldProps[\\\"locationConfig\\\"];\\n  durationConfig?: DurationPickerFieldProps[\\\"durationConfig\\\"];\\n  autocompleteConfig?: AutocompleteFieldProps[\\\"autocompleteConfig\\\"];\\n  maskedConfig?: MaskedInputFieldProps[\\\"maskedConfig\\\"];\\n  colorConfig?: ColorPickerFieldProps[\\\"colorConfig\\\"];\\n  ratingConfig?: RatingFieldProps[\\\"ratingConfig\\\"];\\n  phoneConfig?: PhoneFieldProps[\\\"phoneConfig\\\"];\\n  // Legacy support for existing configurations\\n  multiSelectConfig?: {\\n    maxSelections?: number;\\n    searchable?: boolean;\\n    creatable?: boolean;\\n    placeholder?: string;\\n    noOptionsText?: string;\\n    loadingText?: string;\\n  };\\n  maskedInputConfig?: MaskedInputConfig;\\n  // Allow additional props for extensibility\\n  [key: string]: unknown;\\n};\\n\\n// Cross-field validation configuration\\nexport interface CrossFieldValidation<TFormValues = Record<string, unknown>> {\\n  fields: (keyof TFormValues)[];\\n  validator: (values: Partial<TFormValues>) => string | null;\\n  message: string;\\n}\\n\\n// Async validation configuration\\nexport interface AsyncValidation {\\n  validator: (value: unknown) => Promise<string | null>;\\n  debounceMs?: number;\\n  loadingMessage?: string;\\n}\\n\\n// Enhanced form analytics and tracking configuration\\nexport interface FormAnalytics {\\n  // Field-level analytics\\n  onFieldFocus?: (fieldName: string, timestamp: number) => void;\\n  onFieldBlur?: (fieldName: string, timeSpent: number) => void;\\n  onFieldChange?: (\\n    fieldName: string,\\n    value: unknown,\\n    timestamp: number\\n  ) => void;\\n  onFieldComplete?: (\\n    fieldName: string,\\n    isValid: boolean,\\n    timeSpent: number\\n  ) => void;\\n  onFieldError?: (\\n    fieldName: string,\\n    errors: string[],\\n    timestamp: number\\n  ) => void;\\n\\n  // Form-level analytics\\n  onFormStart?: (timestamp: number) => void;\\n  onFormComplete?: (timeSpent: number, formData: unknown) => void;\\n  onFormAbandon?: (\\n    completionPercentage: number,\\n    context?: {\\n      currentPage?: number;\\n      currentTab?: string;\\n      lastActiveField?: string;\\n    }\\n  ) => void;\\n  onFormReset?: (timestamp: number, reason?: string) => void;\\n\\n  // Page-level analytics (for multi-page forms)\\n  onPageChange?: (\\n    fromPage: number,\\n    toPage: number,\\n    timeSpent: number,\\n    pageValidationState?: { hasErrors: boolean; completionPercentage: number }\\n  ) => void;\\n  onPageComplete?: (\\n    pageNumber: number,\\n    timeSpent: number,\\n    fieldsCompleted: number,\\n    totalFields: number\\n  ) => void;\\n  onPageAbandon?: (\\n    pageNumber: number,\\n    completionPercentage: number,\\n    timeSpent: number\\n  ) => void;\\n  onPageValidationError?: (\\n    pageNumber: number,\\n    errors: Record<string, string[]>,\\n    timestamp: number\\n  ) => void;\\n\\n  // Tab-level analytics (for tabbed forms)\\n  onTabChange?: (\\n    fromTab: string,\\n    toTab: string,\\n    timeSpent: number,\\n    tabCompletionState?: { completionPercentage: number; hasErrors: boolean }\\n  ) => void;\\n  onTabComplete?: (\\n    tabId: string,\\n    timeSpent: number,\\n    fieldsCompleted: number,\\n    totalFields: number\\n  ) => void;\\n  onTabAbandon?: (\\n    tabId: string,\\n    completionPercentage: number,\\n    timeSpent: number\\n  ) => void;\\n  onTabValidationError?: (\\n    tabId: string,\\n    errors: Record<string, string[]>,\\n    timestamp: number\\n  ) => void;\\n  onTabFirstVisit?: (tabId: string, timestamp: number) => void;\\n\\n  // Performance analytics\\n  onRenderPerformance?: (\\n    componentName: string,\\n    renderTime: number,\\n    rerenderCount: number\\n  ) => void;\\n  onValidationPerformance?: (\\n    fieldName: string,\\n    validationType: \\\"sync\\\" | \\\"async\\\",\\n    duration: number\\n  ) => void;\\n  onSubmissionPerformance?: (\\n    submissionTime: number,\\n    validationTime: number,\\n    processingTime: number\\n  ) => void;\\n}\\n\\n// Tab analytics state tracking\\nexport interface TabAnalyticsState {\\n  tabId: string;\\n  startTime: number;\\n  visitCount: number;\\n  fieldsCompleted: number;\\n  totalFields: number;\\n  hasErrors: boolean;\\n  lastActiveField?: string;\\n  completionPercentage: number;\\n}\\n\\n// Page analytics state tracking\\nexport interface PageAnalyticsState {\\n  pageNumber: number;\\n  startTime: number;\\n  visitCount: number;\\n  fieldsCompleted: number;\\n  totalFields: number;\\n  hasErrors: boolean;\\n  lastActiveField?: string;\\n  completionPercentage: number;\\n  validationErrors: Record<string, string[]>;\\n}\\n\\n// Performance tracking metrics\\nexport interface PerformanceMetrics {\\n  renderCount: number;\\n  lastRenderTime: number;\\n  averageRenderTime: number;\\n  validationDurations: Record<string, number[]>;\\n  submissionMetrics: {\\n    totalTime: number;\\n    validationTime: number;\\n    processingTime: number;\\n  };\\n}\\n\\n// Analytics context for tracking form interaction patterns\\nexport interface AnalyticsContext {\\n  sessionId: string;\\n  formId: string;\\n  userId?: string;\\n  currentPage?: number;\\n  currentTab?: string;\\n  startTime: number;\\n  pageStates: Record<number, PageAnalyticsState>;\\n  tabStates: Record<string, TabAnalyticsState>;\\n  performanceMetrics: PerformanceMetrics;\\n  fieldInteractions: Record<\\n    string,\\n    {\\n      focusCount: number;\\n      totalTimeSpent: number;\\n      changeCount: number;\\n      errorCount: number;\\n      isCompleted: boolean;\\n    }\\n  >;\\n}\\n\\n// Layout configuration for forms\\nexport interface LayoutConfig {\\n  type: \\\"grid\\\" | \\\"flex\\\" | \\\"tabs\\\" | \\\"accordion\\\" | \\\"stepper\\\";\\n  columns?: number;\\n  gap?: string;\\n  responsive?: boolean;\\n  className?: string;\\n}\\n\\n// Conditional sections configuration\\nexport interface ConditionalSection<TFormValues = Record<string, unknown>> {\\n  condition: (values: TFormValues) => boolean;\\n  fields: string[];\\n  layout?: LayoutConfig;\\n}\\n\\n// Location picker configuration\\nexport interface LocationValue {\\n  lat: number;\\n  lng: number;\\n  address?: string;\\n  country?: string;\\n  city?: string;\\n  state?: string;\\n  postalCode?: string;\\n  [key: string]: any; // Allow additional properties from different services\\n}\\n\\nexport interface LocationSearchResult extends LocationValue {\\n  id: string | number;\\n  relevance?: number;\\n  bounds?: {\\n    northeast: { lat: number; lng: number };\\n    southwest: { lat: number; lng: number };\\n  };\\n}\\n\\nexport interface LocationConfig {\\n  // Basic configuration\\n  defaultLocation?: { lat: number; lng: number };\\n  zoom?: number;\\n  searchPlaceholder?: string;\\n  enableSearch?: boolean;\\n  enableGeolocation?: boolean;\\n  enableManualEntry?: boolean;\\n  showMap?: boolean;\\n\\n  // Map provider - determines which map component to render\\n  mapProvider?:\\n    | \\\"google\\\"\\n    | \\\"openstreetmap\\\"\\n    | \\\"bing\\\"\\n    | \\\"custom\\\"\\n    | \\\"cartodb\\\"\\n    | \\\"stamen\\\"\\n    | \\\"satellite\\\";\\n\\n  // User-defined search function\\n  // This function should handle the API calls to your preferred geocoding service\\n  searchCallback?: (\\n    query: string,\\n    options?: {\\n      // Optional parameters that can be passed to the search\\n      limit?: number;\\n      countryCode?: string;\\n      bounds?: {\\n        northeast: { lat: number; lng: number };\\n        southwest: { lat: number; lng: number };\\n      };\\n      [key: string]: any;\\n    }\\n  ) => Promise<LocationSearchResult[]>;\\n\\n  // User-defined reverse geocoding function\\n  // This function should convert coordinates back to an address\\n  reverseGeocodeCallback?: (lat: number, lng: number) => Promise<LocationValue>;\\n\\n  // Map rendering callback - allows complete customization of map display\\n  mapRenderCallback?: (params: {\\n    location: LocationValue | null;\\n    onLocationSelect: (location: LocationValue) => void;\\n    mapContainer: HTMLDivElement;\\n    zoom: number;\\n    readonly: boolean;\\n    defaultLocation?: { lat: number; lng: number };\\n  }) => {\\n    // Return cleanup function\\n    cleanup?: () => void;\\n    // Update location on map\\n    updateLocation?: (location: LocationValue) => void;\\n  };\\n\\n  // Provider-specific configuration\\n  googleMaps?: {\\n    apiKey: string;\\n    libraries?: string[];\\n    mapOptions?: any; // Google Maps MapOptions\\n    searchOptions?: any; // Google Places search options\\n  };\\n\\n  openStreetMap?: {\\n    tileServer?: string; // Custom tile server URL\\n    attribution?: string;\\n    nominatimEndpoint?: string; // Custom Nominatim endpoint\\n    searchOptions?: {\\n      countrycodes?: string;\\n      addressdetails?: boolean;\\n      limit?: number;\\n      [key: string]: any;\\n    };\\n  };\\n\\n  bingMaps?: {\\n    apiKey: string;\\n    mapOptions?: any; // Bing Maps options\\n    searchOptions?: any; // Bing geocoding options\\n  };\\n\\n  // Custom provider configuration\\n  custom?: {\\n    [key: string]: any;\\n  };\\n\\n  // Search behavior\\n  searchOptions?: {\\n    debounceMs?: number;\\n    minQueryLength?: number;\\n    maxResults?: number;\\n    countryCode?: string; // ISO country code to restrict search\\n    bounds?: {\\n      northeast: { lat: number; lng: number };\\n      southwest: { lat: number; lng: number };\\n    };\\n    [key: string]: any;\\n  };\\n\\n  // UI customization\\n  ui?: {\\n    showCoordinates?: boolean;\\n    showAddress?: boolean;\\n    mapHeight?: number;\\n    searchInputClassName?: string;\\n    mapClassName?: string;\\n    coordinatesFormat?: \\\"decimal\\\" | \\\"dms\\\"; // Decimal degrees or degrees/minutes/seconds\\n    [key: string]: any;\\n  };\\n}\\n\\n// Duration picker configuration\\nexport interface DurationValue {\\n  hours?: number;\\n  minutes?: number;\\n  seconds?: number;\\n  totalSeconds?: number;\\n}\\n\\nexport interface DurationConfig {\\n  format?: \\\"hms\\\" | \\\"hm\\\" | \\\"ms\\\" | \\\"hours\\\" | \\\"minutes\\\" | \\\"seconds\\\";\\n  maxHours?: number;\\n  maxMinutes?: number;\\n  maxSeconds?: number;\\n  showLabels?: boolean;\\n  allowNegative?: boolean;\\n}\\n\\n// Autocomplete configuration\\nexport interface AutocompleteConfig {\\n  options?: string[] | { value: string; label: string }[];\\n  asyncOptions?: (\\n    query: string\\n  ) => Promise<string[] | { value: string; label: string }[]>;\\n  debounceMs?: number;\\n  minChars?: number;\\n  maxResults?: number;\\n  allowCustom?: boolean;\\n  placeholder?: string;\\n  noOptionsText?: string;\\n  loadingText?: string;\\n}\\n\\n// Masked input configuration\\nexport interface MaskedInputConfig {\\n  mask: string | ((value: string) => string);\\n  placeholder?: string;\\n  showMask?: boolean;\\n  guide?: boolean;\\n  keepCharPositions?: boolean;\\n  pipe?: (\\n    conformedValue: string,\\n    config: unknown\\n  ) => false | string | { value: string; indexesOfPipedChars: number[] };\\n}\\n\\n// Field validation configuration\\nexport interface FieldValidationConfig {\\n  min?: number;\\n  max?: number;\\n  minLength?: number;\\n  maxLength?: number;\\n  pattern?: string;\\n  custom?: string;\\n  includes?: string;\\n  startsWith?: string;\\n  endsWith?: string;\\n  email?: boolean;\\n  url?: boolean;\\n  uuid?: boolean;\\n  transform?: string;\\n  refine?: string;\\n  customMessages?: Record<string, string>;\\n}\\n\\n// Help configuration for fields\\nexport interface FieldHelpConfig {\\n  text?: string;\\n  tooltip?: string;\\n  position?: \\\"top\\\" | \\\"bottom\\\" | \\\"left\\\" | \\\"right\\\";\\n  link?: { url: string; text: string };\\n}\\n\\n// Inline validation configuration\\nexport interface InlineValidationConfig {\\n  enabled?: boolean;\\n  debounceMs?: number;\\n  showSuccess?: boolean;\\n  asyncValidator?: (value: unknown) => Promise<string | null>;\\n}\\n\\n// Section configuration\\nexport interface SectionConfig {\\n  title?: string;\\n  description?: string;\\n  collapsible?: boolean;\\n  defaultExpanded?: boolean;\\n}\\n\\n// Datalist configuration\\nexport interface DatalistConfig {\\n  options?: string[];\\n  asyncOptions?: (query: string) => Promise<string[]>;\\n  debounceMs?: number;\\n  minChars?: number;\\n  maxResults?: number;\\n}\\n\\n// Textarea configuration\\nexport interface TextareaConfig {\\n  rows?: number;\\n  cols?: number;\\n  resize?: \\\"none\\\" | \\\"vertical\\\" | \\\"horizontal\\\" | \\\"both\\\";\\n  maxLength?: number;\\n  showWordCount?: boolean;\\n}\\n\\n// Password configuration\\nexport interface PasswordConfig {\\n  showToggle?: boolean;\\n  strengthMeter?: boolean;\\n  minStrength?: number;\\n  requirements?: {\\n    minLength?: number;\\n    requireUppercase?: boolean;\\n    requireLowercase?: boolean;\\n    requireNumbers?: boolean;\\n    requireSymbols?: boolean;\\n  };\\n}\\n\\n// Email configuration\\nexport interface EmailConfig {\\n  allowedDomains?: string | string[];\\n  blockedDomains?: string | string[];\\n  suggestions?: string | string[];\\n  validateMX?: boolean;\\n}\\n\\n// Number configuration\\nexport interface NumberConfig {\\n  min?: number;\\n  max?: number;\\n  step?: number;\\n  precision?: number;\\n  allowNegative?: boolean;\\n  showSpinButtons?: boolean;\\n}\\n\\n// Multi-select configuration\\nexport interface MultiSelectConfig {\\n  maxSelections?: number;\\n  searchable?: boolean;\\n  creatable?: boolean;\\n  placeholder?: string;\\n  noOptionsText?: string;\\n  loadingText?: string;\\n}\\n\\n// Hook interfaces moved from use-formedible.tsx for centralization\\nexport interface FormProps {\\n  className?: string;\\n  children?: React.ReactNode;\\n  onSubmit?: (e: React.FormEvent) => void;\\n  // HTML form attributes\\n  action?: string;\\n  method?: \\\"GET\\\" | \\\"POST\\\" | \\\"PUT\\\" | \\\"DELETE\\\" | \\\"PATCH\\\";\\n  encType?:\\n    | \\\"application/x-www-form-urlencoded\\\"\\n    | \\\"multipart/form-data\\\"\\n    | \\\"text/plain\\\";\\n  target?: \\\"_blank\\\" | \\\"_self\\\" | \\\"_parent\\\" | \\\"_top\\\" | string;\\n  autoComplete?: \\\"on\\\" | \\\"off\\\";\\n  noValidate?: boolean;\\n  acceptCharset?: string;\\n  // Event handlers\\n  onReset?: (e: React.FormEvent) => void;\\n  onInput?: (e: React.FormEvent) => void;\\n  onInvalid?: (e: React.FormEvent) => void;\\n  onKeyDown?: (e: React.KeyboardEvent) => void;\\n  onKeyUp?: (e: React.KeyboardEvent) => void;\\n  onFocus?: (e: React.FocusEvent) => void;\\n  onBlur?: (e: React.FocusEvent) => void;\\n  // Accessibility\\n  role?: string;\\n  \\\"aria-label\\\"?: string;\\n  \\\"aria-labelledby\\\"?: string;\\n  \\\"aria-describedby\\\"?: string;\\n  tabIndex?: number;\\n}\\n\\nexport interface ConditionalFieldsSubscriptionProps<\\n  TFormValues extends Record<string, unknown> = Record<string, unknown>\\n> {\\n  form: any;\\n  fields: FieldConfig[];\\n  conditionalSections: Array<{\\n    condition: (values: TFormValues) => boolean;\\n    fields: string[];\\n    layout?: {\\n      type: \\\"grid\\\" | \\\"flex\\\" | \\\"tabs\\\" | \\\"accordion\\\" | \\\"stepper\\\";\\n      columns?: number;\\n      gap?: string;\\n      responsive?: boolean;\\n      className?: string;\\n    };\\n  }>;\\n  children: (currentValues: Record<string, unknown>) => React.ReactNode;\\n}\\n\\nexport interface FieldConditionalRendererProps {\\n  form: any;\\n  fieldConfig: FieldConfig;\\n  children: (shouldRender: boolean) => React.ReactNode;\\n}\\n\\nexport interface SectionRendererProps {\\n  sectionKey: string;\\n  sectionData: {\\n    section?: {\\n      title?: string;\\n      description?: string;\\n      collapsible?: boolean;\\n      defaultExpanded?: boolean;\\n    };\\n    groups: Record<string, FieldConfig[]>;\\n  };\\n  renderField: (field: FieldConfig) => React.ReactNode;\\n}\\n\\nexport interface UseFormedibleOptions<TFormValues> {\\n  fields?: FieldConfig[];\\n  schema?: z.ZodSchema<TFormValues>;\\n  title?: string;\\n  description?: string;\\n  submitLabel?: string;\\n  nextLabel?: string;\\n  previousLabel?: string;\\n  // Translation support for section buttons\\n  collapseLabel?: string;\\n  expandLabel?: string;\\n  formClassName?: string;\\n  fieldClassName?: string;\\n  labelClassName?: string;\\n  buttonClassName?: string;\\n  submitButtonClassName?: string;\\n  // Auto scroll configuration\\n  autoScroll?: boolean;\\n  submitButton?: React.ComponentType<\\n    React.ButtonHTMLAttributes<HTMLButtonElement> & {\\n      children?: React.ReactNode;\\n    }\\n  >;\\n  pages?: PageConfig[];\\n  progress?: ProgressConfig;\\n  tabs?: {\\n    id: string;\\n    label: string;\\n    description?: string;\\n  }[];\\n  defaultComponents?: {\\n    [key: string]: React.ComponentType<FieldComponentProps>;\\n  };\\n  globalWrapper?: React.ComponentType<{\\n    children: React.ReactNode;\\n    field: FieldConfig;\\n  }>;\\n  formOptions?: Partial<{\\n    defaultValues: TFormValues;\\n    onSubmit: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => unknown | Promise<unknown>;\\n    onSubmitInvalid: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => void;\\n    onChange?: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => void;\\n    onBlur?: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => void;\\n    onFocus?: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => void;\\n    onReset?: (props: {\\n      value: TFormValues;\\n      formApi: FormedibleFormApi<TFormValues>;\\n    }) => void;\\n    asyncDebounceMs: number;\\n    canSubmitWhenInvalid: boolean;\\n  }>;\\n  onPageChange?: (page: number, direction: \\\"next\\\" | \\\"previous\\\") => void;\\n  autoSubmitOnChange?: boolean;\\n  autoSubmitDebounceMs?: number;\\n  disabled?: boolean;\\n  loading?: boolean;\\n  resetOnSubmitSuccess?: boolean;\\n  showSubmitButton?: boolean;\\n  // Form-level event handlers\\n  onFormReset?: (\\n    e: React.FormEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormInput?: (\\n    e: React.FormEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormInvalid?: (\\n    e: React.FormEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormKeyDown?: (\\n    e: React.KeyboardEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormKeyUp?: (\\n    e: React.KeyboardEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormFocus?: (\\n    e: React.FocusEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  onFormBlur?: (\\n    e: React.FocusEvent,\\n    formApi: FormedibleFormApi<TFormValues>\\n  ) => void;\\n  // Advanced validation features\\n  crossFieldValidation?: {\\n    fields: (keyof TFormValues)[];\\n    validator: (values: Partial<TFormValues>) => string | null;\\n    message: string;\\n  }[];\\n  asyncValidation?: {\\n    [fieldName: string]: {\\n      validator: (value: unknown) => Promise<string | null>;\\n      debounceMs?: number;\\n      loadingMessage?: string;\\n    };\\n  };\\n  // Form analytics and tracking\\n  analytics?: FormAnalytics;\\n  // Layout configuration\\n  layout?: {\\n    type: \\\"grid\\\" | \\\"flex\\\" | \\\"tabs\\\" | \\\"accordion\\\" | \\\"stepper\\\";\\n    columns?: number;\\n    gap?: string;\\n    responsive?: boolean;\\n    className?: string;\\n  };\\n  // Conditional sections\\n  conditionalSections?: {\\n    condition: (values: TFormValues) => boolean;\\n    fields: string[];\\n    layout?: {\\n      type: \\\"grid\\\" | \\\"flex\\\" | \\\"tabs\\\" | \\\"accordion\\\" | \\\"stepper\\\";\\n      columns?: number;\\n      gap?: string;\\n      responsive?: boolean;\\n      className?: string;\\n    };\\n  }[];\\n  // Form persistence\\n  persistence?: {\\n    key: string;\\n    storage: \\\"localStorage\\\" | \\\"sessionStorage\\\";\\n    debounceMs?: number;\\n    exclude?: string[];\\n    restoreOnMount?: boolean;\\n  };\\n}\\n\\n// Main FieldConfig interface - DRY version using existing types\\nexport interface FieldConfig {\\n  name: string;\\n  type: string;\\n  label?: DynamicText;\\n  placeholder?: DynamicText;\\n  description?: DynamicText;\\n  required?: boolean;\\n  defaultValue?: unknown;\\n  options?:\\n    | string[]\\n    | { value: string; label: string }[]\\n    | ((\\n        values: Record<string, unknown>\\n      ) => string[] | { value: string; label: string }[]);\\n  min?: number;\\n  max?: number;\\n  step?: number;\\n  accept?: string;\\n  multiple?: boolean;\\n  component?: React.ComponentType<FieldComponentProps>;\\n  wrapper?: React.ComponentType<{\\n    children: React.ReactNode;\\n    field: FieldConfig;\\n  }>;\\n  page?: number;\\n  tab?: string;\\n  validation?: z.ZodSchema<unknown>;\\n  dependencies?: string[];\\n  conditional?: (values: Record<string, unknown>) => boolean;\\n  group?: string;\\n\\n  // Grid positioning properties\\n  gridColumn?: number; // Specific column to place this field (1-based)\\n  gridRow?: number; // Specific row to place this field (1-based)\\n  gridColumnSpan?: number; // How many columns this field should span\\n  gridRowSpan?: number; // How many rows this field should span\\n  gridArea?: string; // CSS grid-area value for advanced positioning\\n\\n  // Configuration objects using existing types\\n  arrayConfig?: ArrayFieldProps[\\\"arrayConfig\\\"];\\n  ratingConfig?: RatingFieldProps[\\\"ratingConfig\\\"];\\n  phoneConfig?: PhoneFieldProps[\\\"phoneConfig\\\"];\\n  colorConfig?: ColorPickerFieldProps[\\\"colorConfig\\\"];\\n  multiSelectConfig?: MultiSelectConfig;\\n  locationConfig?: LocationConfig;\\n  durationConfig?: DurationConfig;\\n  autocompleteConfig?: AutocompleteConfig;\\n  maskedInputConfig?: MaskedInputConfig;\\n  objectConfig?: ObjectConfig;\\n  sliderConfig?: SliderFieldProps[\\\"sliderConfig\\\"];\\n  numberConfig?: NumberConfig;\\n  dateConfig?: DateFieldProps[\\\"dateConfig\\\"];\\n  fileConfig?: FileUploadFieldProps[\\\"fileConfig\\\"];\\n  textareaConfig?: TextareaConfig;\\n  passwordConfig?: PasswordConfig;\\n  emailConfig?: EmailConfig;\\n\\n  // Additional configurations\\n  datalist?: DatalistConfig;\\n  help?: FieldHelpConfig;\\n  inlineValidation?: InlineValidationConfig;\\n  section?: SectionConfig;\\n  validationConfig?: FieldValidationConfig;\\n\\n  // Allow additional unknown configurations for extensibility\\n  [key: string]: unknown;\\n}\\n\\n// Page configuration for multi-page forms\\nexport interface PageConfig {\\n  page: number;\\n  title?: string;\\n  description?: string;\\n  component?: React.ComponentType<{\\n    children: React.ReactNode;\\n    title?: string;\\n    description?: string;\\n    page: number;\\n    totalPages: number;\\n  }>;\\n  conditional?: (values: Record<string, unknown>) => boolean;\\n}\\n\\n// Progress configuration for multi-page forms\\nexport interface ProgressConfig {\\n  component?: React.ComponentType<{\\n    value: number;\\n    currentPage: number;\\n    totalPages: number;\\n    className?: string;\\n  }>;\\n  showSteps?: boolean;\\n  showPercentage?: boolean;\\n  className?: string;\\n}\\n\",\n  \"/src/lib/location.ts\": \"import type {\\n  LocationSearchResult,\\n  LocationValue,\\n} from \\\"@/lib/formedible/types\\\";\\n\\nexport const builtInProviders = {\\n  nominatim: async (\\n    query: string,\\n    options: any = {}\\n  ): Promise<LocationSearchResult[]> => {\\n    const endpoint =\\n      options.endpoint || \\\"https://nominatim.openstreetmap.org/search\\\";\\n    const params = new URLSearchParams({\\n      q: query,\\n      format: \\\"json\\\",\\n      limit: String(options.limit || 5),\\n      addressdetails: \\\"1\\\",\\n      ...options.searchOptions,\\n    });\\n\\n    try {\\n      const response = await fetch(`${endpoint}?${params}`);\\n      const data = await response.json();\\n\\n      return data.map((item: any, index: number) => ({\\n        id: item.place_id || index,\\n        lat: parseFloat(item.lat),\\n        lng: parseFloat(item.lon),\\n        address: item.display_name,\\n        city: item.address?.city || item.address?.town || item.address?.village,\\n        state: item.address?.state,\\n        country: item.address?.country,\\n        postalCode: item.address?.postcode,\\n        relevance: parseFloat(item.importance || 0),\\n        bounds: item.boundingbox\\n          ? {\\n              northeast: {\\n                lat: parseFloat(item.boundingbox[1]),\\n                lng: parseFloat(item.boundingbox[3]),\\n              },\\n              southwest: {\\n                lat: parseFloat(item.boundingbox[0]),\\n                lng: parseFloat(item.boundingbox[2]),\\n              },\\n            }\\n          : undefined,\\n      }));\\n    } catch (error) {\\n      console.error(\\\"Nominatim search error:\\\", error);\\n      return [];\\n    }\\n  },\\n\\n  nominatimReverse: async (\\n    lat: number,\\n    lng: number,\\n    options: any = {}\\n  ): Promise<LocationValue> => {\\n    const endpoint =\\n      options.endpoint || \\\"https://nominatim.openstreetmap.org/reverse\\\";\\n    const params = new URLSearchParams({\\n      lat: String(lat),\\n      lon: String(lng),\\n      format: \\\"json\\\",\\n      addressdetails: \\\"1\\\",\\n      ...options.searchOptions,\\n    });\\n\\n    try {\\n      const response = await fetch(`${endpoint}?${params}`);\\n      const data = await response.json();\\n\\n      return {\\n        lat,\\n        lng,\\n        address: data.display_name,\\n        city: data.address?.city || data.address?.town || data.address?.village,\\n        state: data.address?.state,\\n        country: data.address?.country,\\n        postalCode: data.address?.postcode,\\n      };\\n    } catch (error) {\\n      console.error(\\\"Nominatim reverse geocoding error:\\\", error);\\n      return { lat, lng, address: `${lat}, ${lng}` };\\n    }\\n  },\\n};\\n\\nexport function formatCoordinates(\\n  lat: number,\\n  lng: number,\\n  format: \\\"decimal\\\" | \\\"dms\\\" = \\\"decimal\\\"\\n): string {\\n  if (format === \\\"decimal\\\") {\\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\\n  } else {\\n    const latDeg = Math.floor(Math.abs(lat));\\n    const latMin = Math.floor((Math.abs(lat) - latDeg) * 60);\\n    const latSec = ((Math.abs(lat) - latDeg) * 60 - latMin) * 60;\\n    const latDir = lat >= 0 ? \\\"N\\\" : \\\"S\\\";\\n\\n    const lngDeg = Math.floor(Math.abs(lng));\\n    const lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);\\n    const lngSec = ((Math.abs(lng) - lngDeg) * 60 - lngMin) * 60;\\n    const lngDir = lng >= 0 ? \\\"E\\\" : \\\"W\\\";\\n\\n    return `${latDeg}°${latMin}'${latSec.toFixed(\\n      2\\n    )}\\\"${latDir} ${lngDeg}°${lngMin}'${lngSec.toFixed(2)}\\\"${lngDir}`;\\n  }\\n}\\n\\nexport const defaultMapRenderer = (params: {\\n  location: LocationValue | null;\\n  onLocationSelect: (location: LocationValue) => void;\\n  mapContainer: HTMLDivElement;\\n  zoom: number;\\n  readonly: boolean;\\n  defaultLocation?: { lat: number; lng: number };\\n}) => {\\n  const {\\n    location,\\n    onLocationSelect,\\n    mapContainer,\\n    zoom,\\n    readonly,\\n    defaultLocation,\\n  } = params;\\n\\n  const leafletMap = (window as any).L.map(mapContainer, {\\n    center: [\\n      location?.lat || defaultLocation?.lat || 51.5074,\\n      location?.lng || defaultLocation?.lng || -0.1278,\\n    ],\\n    zoom: zoom || 10,\\n    zoomControl: true,\\n    dragging: !readonly,\\n    touchZoom: !readonly,\\n    scrollWheelZoom: !readonly,\\n    doubleClickZoom: !readonly,\\n    boxZoom: !readonly,\\n    keyboard: !readonly,\\n    tap: !readonly,\\n  });\\n\\n  const osmTileLayer = (window as any).L.tileLayer(\\n    \\\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\\\",\\n    {\\n      attribution:\\n        '&copy; <a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors',\\n      maxZoom: 19,\\n    }\\n  );\\n\\n  osmTileLayer.addTo(leafletMap);\\n\\n  let currentMarker: any = null;\\n\\n  const updateMarker = (loc: LocationValue | null) => {\\n    if (currentMarker) {\\n      leafletMap.removeLayer(currentMarker);\\n      currentMarker = null;\\n    }\\n\\n    if (loc) {\\n      const customIcon = (window as any).L.divIcon({\\n        className: \\\"custom-div-icon\\\",\\n        html: `\\n          <div style=\\\"\\n            background-color: #ef4444;\\n            color: white;\\n            padding: 4px 8px;\\n            border-radius: 4px;\\n            font-size: 12px;\\n            box-shadow: 0 2px 4px rgba(0,0,0,0.2);\\n            white-space: nowrap;\\n            position: relative;\\n            margin-bottom: 8px;\\n          \\\">\\n            📍 ${loc.address || `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`}\\n          </div>\\n          <div style=\\\"\\n            width: 0;\\n            height: 0;\\n            border-left: 8px solid transparent;\\n            border-right: 8px solid transparent;\\n            border-top: 8px solid #ef4444;\\n            margin: 0 auto;\\n            margin-top: -4px;\\n          \\\"></div>\\n        `,\\n        iconSize: [0, 0],\\n        iconAnchor: [0, 0],\\n      });\\n\\n      currentMarker = (window as any).L.marker([loc.lat, loc.lng], {\\n        icon: customIcon,\\n      });\\n      currentMarker.addTo(leafletMap);\\n\\n      leafletMap.setView([loc.lat, loc.lng], leafletMap.getZoom());\\n    }\\n  };\\n\\n  if (!readonly) {\\n    leafletMap.on(\\\"click\\\", (e: any) => {\\n      const { lat, lng } = e.latlng;\\n\\n      onLocationSelect({\\n        lat: lat,\\n        lng: lng,\\n        address: `Map Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`,\\n      });\\n    });\\n  }\\n\\n  updateMarker(location);\\n\\n  return {\\n    updateMarker,\\n    destroy: () => {\\n      leafletMap.remove();\\n    },\\n    setTileLayer: (tileConfig: {\\n      url: string;\\n      attribution: string;\\n      maxZoom?: number;\\n    }) => {\\n      const newTileLayer = (window as any).L.tileLayer(tileConfig.url, {\\n        attribution: tileConfig.attribution,\\n        maxZoom: tileConfig.maxZoom || 18,\\n      });\\n\\n      newTileLayer.addTo(leafletMap);\\n    },\\n  };\\n};\",\n  \"/src/lib/utils.ts\": \"import { type ClassValue, clsx } from \\\"clsx\\\";\\nimport { twMerge } from \\\"tailwind-merge\\\";\\n\\nexport function cn(...inputs: ClassValue[]) {\\n  return twMerge(clsx(inputs));\\n}\",\n  \"/src/testing/index.ts\": \"// Testing utilities for Formedible forms\\n\\nexport interface FormTesterConfig<T extends Record<string, unknown>> {\\n  fields?: Array<{\\n    name: string;\\n    type: string;\\n    label?: string;\\n    page?: number;\\n  }>;\\n  schema?: unknown;\\n  crossFieldValidation?: Array<{\\n    fields: (keyof T)[];\\n    validator: (values: Partial<T>) => string | null;\\n    message: string;\\n  }>;\\n  asyncValidation?: {\\n    [fieldName: string]: {\\n      validator: (value: unknown) => Promise<string | null>;\\n      debounceMs?: number;\\n      loadingMessage?: string;\\n    };\\n  };\\n}\\n\\nexport interface FormTesterOptions<T extends Record<string, unknown>> {\\n  config: FormTesterConfig<T>;\\n  container?: HTMLElement;\\n}\\n\\nexport interface FormTesterActions<T extends Record<string, unknown>> {\\n  fillField: (name: keyof T, value: unknown) => Promise<void>;\\n  fillFields: (values: Partial<T>) => Promise<void>;\\n  submitForm: () => Promise<void>;\\n  resetForm: () => Promise<void>;\\n  goToPage: (page: number) => Promise<void>;\\n  nextPage: () => Promise<void>;\\n  previousPage: () => Promise<void>;\\n  expectError: (fieldName: keyof T, message?: string) => void;\\n  expectNoError: (fieldName: keyof T) => void;\\n  expectValid: () => void;\\n  expectInvalid: () => void;\\n  expectFieldValue: (fieldName: keyof T, value: unknown) => void;\\n  expectCurrentPage: (page: number) => void;\\n  waitForAsyncValidation: (fieldName: keyof T) => Promise<void>;\\n  triggerFieldFocus: (fieldName: keyof T) => Promise<void>;\\n  triggerFieldBlur: (fieldName: keyof T) => Promise<void>;\\n  getFormData: () => T;\\n}\\n\\nexport class FormTester<T extends Record<string, unknown>> {\\n\\n  private container: HTMLElement;\\n  private formInstance: {\\n    form?: { state?: unknown };\\n    currentPage?: number;\\n    asyncValidationStates?: Record<string, { loading?: boolean }>;\\n    setCurrentPage?: (page: number) => void;\\n  } = {};\\n\\n  constructor(options: FormTesterOptions<T>) {\\n\\n    this.container = options.container || document.body;\\n  }\\n\\n  private getFieldElement(fieldName: keyof T): HTMLElement | null {\\n    return this.container.querySelector(`[name=\\\"${String(fieldName)}\\\"]`)?.closest('.field-wrapper, .form-field') as HTMLElement || null;\\n  }\\n\\n  private getSubmitButton(): HTMLElement | null {\\n    return this.container.querySelector('button[type=\\\"submit\\\"]') as HTMLElement || null;\\n  }\\n\\n  private getNextButton(): HTMLElement | null {\\n    return this.container.querySelector('button:contains(\\\"Next\\\"), button[data-testid=\\\"next-button\\\"]') as HTMLElement || null;\\n  }\\n\\n  private getPreviousButton(): HTMLElement | null {\\n    return this.container.querySelector('button:contains(\\\"Previous\\\"), button[data-testid=\\\"previous-button\\\"]') as HTMLElement || null;\\n  }\\n\\n  async render(): Promise<FormTesterActions<T>> {\\n    const actions: FormTesterActions<T> = {\\n      fillField: async (name: keyof T, value: unknown) => {\\n        const field = this.getFieldElement(name);\\n        if (field) {\\n          const input = field.querySelector('input, select, textarea') as HTMLInputElement;\\n          if (input) {\\n            input.value = String(value);\\n            input.dispatchEvent(new Event('input', { bubbles: true }));\\n            input.dispatchEvent(new Event('change', { bubbles: true }));\\n          }\\n        }\\n      },\\n\\n      fillFields: async (values: Partial<T>) => {\\n        for (const [name, value] of Object.entries(values)) {\\n          await actions.fillField(name as keyof T, value);\\n        }\\n      },\\n\\n      submitForm: async () => {\\n        const submitButton = this.getSubmitButton();\\n        if (submitButton) {\\n          submitButton.click();\\n        } else {\\n          const form = this.container.querySelector('form');\\n          if (form) {\\n            form.dispatchEvent(new Event('submit', { bubbles: true }));\\n          }\\n        }\\n      },\\n\\n      resetForm: async () => {\\n        const form = this.container.querySelector('form');\\n        if (form) {\\n          form.reset();\\n        }\\n      },\\n\\n      goToPage: async (page: number) => {\\n        if (this.formInstance && 'setCurrentPage' in this.formInstance && typeof this.formInstance.setCurrentPage === 'function') {\\n          this.formInstance.setCurrentPage(page);\\n        }\\n      },\\n\\n      nextPage: async () => {\\n        const nextButton = this.getNextButton();\\n        if (nextButton) {\\n          nextButton.click();\\n        }\\n      },\\n\\n      previousPage: async () => {\\n        const prevButton = this.getPreviousButton();\\n        if (prevButton) {\\n          prevButton.click();\\n        }\\n      },\\n\\n      expectError: (fieldName: keyof T, message?: string) => {\\n        const field = this.getFieldElement(fieldName);\\n        if (!field) {\\n          throw new Error(`Field ${String(fieldName)} not found`);\\n        }\\n        \\n        const errorElement = field.querySelector('[role=\\\"alert\\\"], .error-message, .text-destructive');\\n        if (!errorElement) {\\n          throw new Error(`No error found for field ${String(fieldName)}`);\\n        }\\n        \\n        if (message && !errorElement.textContent?.includes(message)) {\\n          throw new Error(`Expected error message \\\"${message}\\\" but got \\\"${errorElement.textContent}\\\"`);\\n        }\\n      },\\n\\n      expectNoError: (fieldName: keyof T) => {\\n        const field = this.getFieldElement(fieldName);\\n        if (!field) {\\n          throw new Error(`Field ${String(fieldName)} not found`);\\n        }\\n        \\n        const errorElement = field.querySelector('[role=\\\"alert\\\"], .error-message, .text-destructive');\\n        if (errorElement && errorElement.textContent?.trim()) {\\n          throw new Error(`Expected no error for field ${String(fieldName)} but found: ${errorElement.textContent}`);\\n        }\\n      },\\n\\n      expectValid: () => {\\n        if (this.formInstance && this.formInstance.form) {\\n          const state = this.formInstance.form.state as { isValid: boolean };\\n          if (!state.isValid) {\\n            throw new Error('Expected form to be valid');\\n          }\\n        }\\n      },\\n\\n      expectInvalid: () => {\\n        if (this.formInstance && this.formInstance.form) {\\n          const state = this.formInstance.form.state as { isValid: boolean };\\n          if (state.isValid) {\\n            throw new Error('Expected form to be invalid');\\n          }\\n        }\\n      },\\n\\n      expectFieldValue: (fieldName: keyof T, value: unknown) => {\\n        const field = this.getFieldElement(fieldName);\\n        if (!field) {\\n          throw new Error(`Field ${String(fieldName)} not found`);\\n        }\\n        \\n        const input = field.querySelector('input, select, textarea') as HTMLInputElement;\\n        if (!input) {\\n          throw new Error(`Input element not found for field ${String(fieldName)}`);\\n        }\\n        \\n        if (input.value !== String(value)) {\\n          throw new Error(`Expected field ${String(fieldName)} to have value \\\"${value}\\\" but got \\\"${input.value}\\\"`);\\n        }\\n      },\\n\\n      expectCurrentPage: (page: number) => {\\n        if (this.formInstance && this.formInstance.currentPage !== page) {\\n          throw new Error(`Expected to be on page ${page} but on page ${this.formInstance.currentPage}`);\\n        }\\n      },\\n\\n      waitForAsyncValidation: async (fieldName: keyof T) => {\\n        return new Promise<void>((resolve) => {\\n          const checkValidation = () => {\\n            if (this.formInstance && this.formInstance.asyncValidationStates) {\\n              const state = this.formInstance.asyncValidationStates[String(fieldName)];\\n              if (!state || !state.loading) {\\n                resolve();\\n                return;\\n              }\\n            }\\n            setTimeout(checkValidation, 100);\\n          };\\n          checkValidation();\\n        });\\n      },\\n\\n      triggerFieldFocus: async (fieldName: keyof T) => {\\n        const field = this.getFieldElement(fieldName);\\n        if (field) {\\n          const input = field.querySelector('input, select, textarea') as HTMLInputElement;\\n          if (input) {\\n            input.focus();\\n            input.dispatchEvent(new Event('focus', { bubbles: true }));\\n          }\\n        }\\n      },\\n\\n      triggerFieldBlur: async (fieldName: keyof T) => {\\n        const field = this.getFieldElement(fieldName);\\n        if (field) {\\n          const input = field.querySelector('input, select, textarea') as HTMLInputElement;\\n          if (input) {\\n            input.blur();\\n            input.dispatchEvent(new Event('blur', { bubbles: true }));\\n          }\\n        }\\n      },\\n\\n      getFormData: () => {\\n        if (this.formInstance && this.formInstance.form) {\\n          const state = this.formInstance.form.state as { values: T };\\n          return state.values;\\n        }\\n        return {} as T;\\n      }\\n    };\\n\\n    return actions;\\n  }\\n\\n  setFormInstance(instance: {\\n    form?: { state?: unknown };\\n    currentPage?: number;\\n    asyncValidationStates?: Record<string, { loading?: boolean }>;\\n    setCurrentPage?: (page: number) => void;\\n  }) {\\n    this.formInstance = instance;\\n  }\\n}\\n\\n// Factory function for creating form testers\\nexport function createFormTester<T extends Record<string, unknown>>(\\n  config: FormTesterConfig<T>,\\n  container?: HTMLElement\\n): FormTester<T> {\\n  return new FormTester({ config, container });\\n}\\n\\n// Jest/Vitest matcher extensions\\nexport const formMatchers = {\\n  toHaveError<T extends Record<string, unknown>>(this: unknown, tester: FormTester<T>, fieldName: keyof T, message?: string) {\\n    try {\\n      const actions = tester.render();\\n      actions.then(a => a.expectError(fieldName, message));\\n      return { pass: true, message: () => `Expected field ${String(fieldName)} to have error` };\\n    } catch (error) {\\n      return { pass: false, message: () => (error as Error).message };\\n    }\\n  },\\n\\n  toHaveNoError<T extends Record<string, unknown>>(this: unknown, tester: FormTester<T>, fieldName: keyof T) {\\n    try {\\n      const actions = tester.render();\\n      actions.then(a => a.expectNoError(fieldName));\\n      return { pass: true, message: () => `Expected field ${String(fieldName)} to have no error` };\\n    } catch (error) {\\n      return { pass: false, message: () => (error as Error).message };\\n    }\\n  },\\n\\n  toBeValid<T extends Record<string, unknown>>(this: unknown, tester: FormTester<T>) {\\n    try {\\n      const actions = tester.render();\\n      actions.then(a => a.expectValid());\\n      return { pass: true, message: () => 'Expected form to be valid' };\\n    } catch (error) {\\n      return { pass: false, message: () => (error as Error).message };\\n    }\\n  },\\n\\n  toBeInvalid<T extends Record<string, unknown>>(this: unknown, tester: FormTester<T>) {\\n    try {\\n      const actions = tester.render();\\n      actions.then(a => a.expectInvalid());\\n      return { pass: true, message: () => 'Expected form to be invalid' };\\n    } catch (error) {\\n      return { pass: false, message: () => (error as Error).message };\\n    }\\n  }\\n};\\n\\n// Example usage and documentation\\nexport const examples = {\\n  basicUsage: `\\n    import { createFormTester } from '@formedible/testing';\\n\\n    const config = {\\n      fields: [\\n        { name: 'email', type: 'email', label: 'Email' },\\n        { name: 'password', type: 'password', label: 'Password' },\\n      ],\\n    };\\n\\n    test('form validation', async () => {\\n      const tester = createFormTester(config);\\n      const actions = await tester.render();\\n\\n      // Fill invalid email\\n      await actions.fillField('email', 'invalid-email');\\n      actions.expectError('email', 'Invalid email');\\n\\n      // Fill valid email\\n      await actions.fillField('email', 'test@example.com');\\n      actions.expectNoError('email');\\n\\n      // Submit form\\n      await actions.submitForm();\\n    });\\n  `,\\n\\n  crossFieldValidation: `\\n    test('cross-field validation', async () => {\\n      const config = {\\n        fields: [\\n          { name: 'password', type: 'password', label: 'Password' },\\n          { name: 'confirmPassword', type: 'password', label: 'Confirm Password' },\\n        ],\\n        crossFieldValidation: [{\\n          fields: ['password', 'confirmPassword'],\\n          validator: (values) => \\n            values.password !== values.confirmPassword ? 'Passwords must match' : null,\\n          message: 'Passwords must match'\\n        }]\\n      };\\n\\n      const tester = createFormTester(config);\\n      const actions = await tester.render();\\n\\n      await actions.fillField('password', 'password123');\\n      await actions.fillField('confirmPassword', 'different');\\n      \\n      actions.expectError('password', 'Passwords must match');\\n      actions.expectError('confirmPassword', 'Passwords must match');\\n    });\\n  `,\\n\\n  asyncValidation: `\\n    test('async validation', async () => {\\n      const config = {\\n        fields: [\\n          { name: 'username', type: 'text', label: 'Username' },\\n        ],\\n        asyncValidation: {\\n          username: {\\n            validator: async (value) => {\\n              // Simulate API call\\n              await new Promise(resolve => setTimeout(resolve, 100));\\n              return value === 'taken' ? 'Username is taken' : null;\\n            },\\n            debounceMs: 300\\n          }\\n        }\\n      };\\n\\n      const tester = createFormTester(config);\\n      const actions = await tester.render();\\n\\n      await actions.fillField('username', 'taken');\\n      await actions.waitForAsyncValidation('username');\\n      \\n      actions.expectError('username', 'Username is taken');\\n    });\\n  `,\\n\\n  multiPageForm: `\\n    test('multi-page form navigation', async () => {\\n      const config = {\\n        fields: [\\n          { name: 'firstName', type: 'text', label: 'First Name', page: 1 },\\n          { name: 'lastName', type: 'text', label: 'Last Name', page: 1 },\\n          { name: 'email', type: 'email', label: 'Email', page: 2 },\\n        ],\\n      };\\n\\n      const tester = createFormTester(config);\\n      const actions = await tester.render();\\n\\n      actions.expectCurrentPage(1);\\n      \\n      await actions.fillField('firstName', 'John');\\n      await actions.fillField('lastName', 'Doe');\\n      await actions.nextPage();\\n      \\n      actions.expectCurrentPage(2);\\n      \\n      await actions.fillField('email', 'john@example.com');\\n      await actions.submitForm();\\n    });\\n  `\\n};\",\n  \"/src/components/ui/code-block.tsx\": \"\\\"use client\\\";\\n\\nimport React, { useState, useEffect } from \\\"react\\\";\\nimport { Highlight, themes } from \\\"prism-react-renderer\\\";\\nimport { motion, AnimatePresence } from \\\"motion/react\\\";\\nimport { Copy, Check } from \\\"lucide-react\\\";\\nimport { toast } from \\\"sonner\\\";\\n\\n/**\\n * Unified CodeBlock component with syntax highlighting, copy functionality, and package manager tabs\\n * \\n * Features:\\n * - Syntax highlighting using Prism.js with oneDark theme\\n * - Floating copy button with animation feedback\\n * - Optional line numbers\\n * - Package manager tabs for installation commands (npx, pnpm, yarn, bunx)\\n * - Optional title header\\n * - Responsive design with proper overflow handling\\n */\\n\\ninterface CodeBlockProps {\\n  code: string;\\n  language?: string;\\n  showLineNumbers?: boolean;\\n  showCopyButton?: boolean;\\n  showPackageManagerTabs?: boolean;\\n  className?: string;\\n  title?: string;\\n  darkMode?: boolean;\\n  scrollable?: boolean;\\n  maxHeight?: string;\\n}\\n\\n// Copy Button Component\\nconst CopyButton: React.FC<{ text: string; className?: string }> = ({\\n  text,\\n  className = \\\"\\\",\\n}) => {\\n  const [copied, setCopied] = useState(false);\\n\\n  const copyToClipboard = async () => {\\n    try {\\n      await navigator.clipboard.writeText(text);\\n      setCopied(true);\\n      toast.success(\\\"Copied to clipboard!\\\");\\n      setTimeout(() => setCopied(false), 2000);\\n    } catch (err) {\\n      toast.error(\\\"Failed to copy\\\");\\n    }\\n  };\\n\\n  return (\\n    <motion.button\\n      onClick={copyToClipboard}\\n      className={`relative inline-flex items-center justify-center p-2 rounded-md bg-muted/80 hover:bg-muted text-muted-foreground hover:text-foreground backdrop-blur-sm transition-colors shadow-lg ${className}`}\\n      whileHover={{ scale: 1.05 }}\\n      whileTap={{ scale: 0.95 }}\\n    >\\n      <AnimatePresence mode=\\\"wait\\\">\\n        {copied ? (\\n          <motion.div\\n            key=\\\"check\\\"\\n            initial={{ scale: 0 }}\\n            animate={{ scale: 1 }}\\n            exit={{ scale: 0 }}\\n          >\\n            <Check className=\\\"w-4 h-4 text-accent\\\" />\\n          </motion.div>\\n        ) : (\\n          <motion.div\\n            key=\\\"copy\\\"\\n            initial={{ scale: 0 }}\\n            animate={{ scale: 1 }}\\n            exit={{ scale: 0 }}\\n          >\\n            <Copy className=\\\"w-4 h-4\\\" />\\n          </motion.div>\\n        )}\\n      </AnimatePresence>\\n    </motion.button>\\n  );\\n};\\n\\n// Function to load external CSS theme\\nconst loadPrismTheme = (themeUrl: string, themeId: string) => {\\n  // Remove existing theme if present\\n  const existingLink = document.getElementById(themeId);\\n  if (existingLink) {\\n    existingLink.remove();\\n  }\\n  \\n  // Add new theme\\n  const link = document.createElement('link');\\n  link.id = themeId;\\n  link.rel = 'stylesheet';\\n  link.href = themeUrl;\\n  document.head.appendChild(link);\\n};\\n\\n// Empty theme object to disable built-in styling and let external CSS take control\\nconst emptyTheme = { plain: {}, styles: [] };\\n\\nexport const CodeBlock: React.FC<CodeBlockProps> = ({\\n  code,\\n  language = \\\"tsx\\\",\\n  showLineNumbers = false,\\n  showCopyButton = true,\\n  showPackageManagerTabs = false,\\n  className = \\\"\\\",\\n  title,\\n  darkMode = false,\\n  scrollable = false,\\n  maxHeight,\\n}) => {\\n  const [selectedPM, setSelectedPM] = useState(\\\"npx\\\");\\n  \\n  // Load appropriate Gruvbox theme based on darkMode prop\\n  useEffect(() => {\\n    if (darkMode) {\\n      loadPrismTheme(\\n        'https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-gruvbox-dark.min.css',\\n        'prism-gruvbox-theme'\\n      );\\n    } else {\\n      loadPrismTheme(\\n        'https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-gruvbox-light.min.css',\\n        'prism-gruvbox-theme'\\n      );\\n    }\\n  }, [darkMode]);\\n  \\n  const packageManagers = {\\n    npx: code,\\n    pnpm: code.replace(\\\"npx shadcn@latest\\\", \\\"pnpm dlx shadcn@latest\\\"),\\n    yarn: code.replace(\\\"npx shadcn@latest\\\", \\\"yarn dlx shadcn@latest\\\"),\\n    bunx: code.replace(\\\"npx shadcn@latest\\\", \\\"bunx --bun shadcn@latest\\\"),\\n  };\\n\\n  const currentCode = showPackageManagerTabs ? packageManagers[selectedPM as keyof typeof packageManagers] : code;\\n\\n  return (\\n    <div className={`relative ${className}`}>\\n      {title && (\\n        <div className=\\\"bg-muted text-muted-foreground px-4 py-2 text-sm font-medium rounded-t-lg border-b\\\">\\n          {title}\\n        </div>\\n      )}\\n      \\n      {showPackageManagerTabs && (\\n        <div className=\\\"flex gap-1 mb-2\\\">\\n          {Object.keys(packageManagers).map((pm) => (\\n            <button\\n              key={pm}\\n              onClick={() => setSelectedPM(pm)}\\n              className={`px-3 py-1 text-xs rounded-t-md transition-colors ${\\n                selectedPM === pm\\n                  ? \\\"bg-primary text-primary-foreground\\\"\\n                  : \\\"bg-secondary text-secondary-foreground hover:bg-secondary/80\\\"\\n              }`}\\n            >\\n              {pm}\\n            </button>\\n          ))}\\n        </div>\\n      )}\\n      \\n      <div className=\\\"relative group\\\">\\n        <Highlight\\n          theme={emptyTheme}\\n          code={currentCode.trim()}\\n          language={language as any}\\n        >\\n          {({ className: highlightClassName, style, tokens, getLineProps, getTokenProps }) => (\\n            <pre \\n              className={`${highlightClassName} p-4 rounded-lg font-mono text-sm overflow-x-auto ${\\n                showPackageManagerTabs ? 'rounded-tl-none' : ''\\n              } ${title ? 'rounded-t-none' : ''} ${\\n                scrollable ? 'overflow-y-auto' : ''\\n              }`}\\n              style={{\\n                ...style,\\n                ...(scrollable && maxHeight && { maxHeight })\\n              }}\\n            >\\n              {tokens.map((line, i) => (\\n                <div key={i} {...getLineProps({ line })} className={showLineNumbers ? \\\"table-row\\\" : \\\"\\\"}>\\n                  {showLineNumbers && (\\n                     <span className=\\\"table-cell text-right pr-4 text-muted-foreground select-none text-xs\\\">                      {i + 1}\\n                    </span>\\n                  )}\\n                  <span className={showLineNumbers ? \\\"table-cell\\\" : \\\"\\\"}>\\n                    {line.map((token, key) => (\\n                      <span key={key} {...getTokenProps({ token })} />\\n                    ))}\\n                  </span>\\n                </div>\\n              ))}\\n            </pre>\\n          )}\\n        </Highlight>\\n        \\n        {showCopyButton && (\\n          <div className=\\\"absolute top-3 right-3 opacity-0 group-hover:opacity-100 transition-opacity duration-200\\\">\\n            <CopyButton text={currentCode} />\\n          </div>\\n        )}\\n      </div>\\n    </div>\\n  );\\n};\",\n  \"/src/components/ui/separator.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as SeparatorPrimitive from \\\"@radix-ui/react-separator\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nfunction Separator({\\n  className,\\n  orientation = \\\"horizontal\\\",\\n  decorative = true,\\n  ...props\\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\\n  return (\\n    <SeparatorPrimitive.Root\\n      data-slot=\\\"separator\\\"\\n      decorative={decorative}\\n      orientation={orientation}\\n      className={cn(\\n        \\\"bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport { Separator }\\n\",\n  \"/src/components/ui/sheet.tsx\": \"import * as React from \\\"react\\\"\\nimport * as SheetPrimitive from \\\"@radix-ui/react-dialog\\\"\\nimport { XIcon } from \\\"lucide-react\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\\n  return <SheetPrimitive.Root data-slot=\\\"sheet\\\" {...props} />\\n}\\n\\nfunction SheetTrigger({\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\\n  return <SheetPrimitive.Trigger data-slot=\\\"sheet-trigger\\\" {...props} />\\n}\\n\\nfunction SheetClose({\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Close>) {\\n  return <SheetPrimitive.Close data-slot=\\\"sheet-close\\\" {...props} />\\n}\\n\\nfunction SheetPortal({\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Portal>) {\\n  return <SheetPrimitive.Portal data-slot=\\\"sheet-portal\\\" {...props} />\\n}\\n\\nfunction SheetOverlay({\\n  className,\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\\n  return (\\n    <SheetPrimitive.Overlay\\n      data-slot=\\\"sheet-overlay\\\"\\n      className={cn(\\n        \\\"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SheetContent({\\n  className,\\n  children,\\n  side = \\\"right\\\",\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\\n  side?: \\\"top\\\" | \\\"right\\\" | \\\"bottom\\\" | \\\"left\\\"\\n}) {\\n  return (\\n    <SheetPortal>\\n      <SheetOverlay />\\n      <SheetPrimitive.Content\\n        data-slot=\\\"sheet-content\\\"\\n        className={cn(\\n          \\\"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500\\\",\\n          side === \\\"right\\\" &&\\n            \\\"data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm\\\",\\n          side === \\\"left\\\" &&\\n            \\\"data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm\\\",\\n          side === \\\"top\\\" &&\\n            \\\"data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b\\\",\\n          side === \\\"bottom\\\" &&\\n            \\\"data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t\\\",\\n          className\\n        )}\\n        {...props}\\n      >\\n        {children}\\n        <SheetPrimitive.Close className=\\\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none\\\">\\n          <XIcon className=\\\"size-4\\\" />\\n          <span className=\\\"sr-only\\\">Close</span>\\n        </SheetPrimitive.Close>\\n      </SheetPrimitive.Content>\\n    </SheetPortal>\\n  )\\n}\\n\\nfunction SheetHeader({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sheet-header\\\"\\n      className={cn(\\\"flex flex-col gap-1.5 p-4\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SheetFooter({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sheet-footer\\\"\\n      className={cn(\\\"mt-auto flex flex-col gap-2 p-4\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SheetTitle({\\n  className,\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Title>) {\\n  return (\\n    <SheetPrimitive.Title\\n      data-slot=\\\"sheet-title\\\"\\n      className={cn(\\\"text-foreground font-semibold\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SheetDescription({\\n  className,\\n  ...props\\n}: React.ComponentProps<typeof SheetPrimitive.Description>) {\\n  return (\\n    <SheetPrimitive.Description\\n      data-slot=\\\"sheet-description\\\"\\n      className={cn(\\\"text-muted-foreground text-sm\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport {\\n  Sheet,\\n  SheetTrigger,\\n  SheetClose,\\n  SheetContent,\\n  SheetHeader,\\n  SheetFooter,\\n  SheetTitle,\\n  SheetDescription,\\n}\\n\",\n  \"/src/components/ui/sidebar.tsx\": \"import * as React from \\\"react\\\"\\nimport { Slot } from \\\"@radix-ui/react-slot\\\"\\nimport { cva, VariantProps } from \\\"class-variance-authority\\\"\\nimport { PanelLeftIcon } from \\\"lucide-react\\\"\\n\\nimport { useIsMobile } from \\\"@/hooks/use-mobile\\\"\\nimport { cn } from \\\"@/lib/utils\\\"\\nimport { Button } from \\\"@/components/ui/button\\\"\\nimport { Input } from \\\"@/components/ui/input\\\"\\nimport { Separator } from \\\"@/components/ui/separator\\\"\\nimport {\\n  Sheet,\\n  SheetContent,\\n  SheetDescription,\\n  SheetHeader,\\n  SheetTitle,\\n} from \\\"@/components/ui/sheet\\\"\\nimport { Skeleton } from \\\"@/components/ui/skeleton\\\"\\nimport {\\n  Tooltip,\\n  TooltipContent,\\n  TooltipProvider,\\n  TooltipTrigger,\\n} from \\\"@/components/ui/tooltip\\\"\\n\\nconst SIDEBAR_COOKIE_NAME = \\\"sidebar_state\\\"\\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\\nconst SIDEBAR_WIDTH = \\\"16rem\\\"\\nconst SIDEBAR_WIDTH_MOBILE = \\\"18rem\\\"\\nconst SIDEBAR_WIDTH_ICON = \\\"3rem\\\"\\nconst SIDEBAR_KEYBOARD_SHORTCUT = \\\"b\\\"\\n\\ntype SidebarContextProps = {\\n  state: \\\"expanded\\\" | \\\"collapsed\\\"\\n  open: boolean\\n  setOpen: (open: boolean) => void\\n  openMobile: boolean\\n  setOpenMobile: (open: boolean) => void\\n  isMobile: boolean\\n  toggleSidebar: () => void\\n}\\n\\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\\n\\nfunction useSidebar() {\\n  const context = React.useContext(SidebarContext)\\n  if (!context) {\\n    throw new Error(\\\"useSidebar must be used within a SidebarProvider.\\\")\\n  }\\n\\n  return context\\n}\\n\\nfunction SidebarProvider({\\n  defaultOpen = true,\\n  open: openProp,\\n  onOpenChange: setOpenProp,\\n  className,\\n  style,\\n  children,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\"> & {\\n  defaultOpen?: boolean\\n  open?: boolean\\n  onOpenChange?: (open: boolean) => void\\n}) {\\n  const isMobile = useIsMobile()\\n  const [openMobile, setOpenMobile] = React.useState(false)\\n\\n  // This is the internal state of the sidebar.\\n  // We use openProp and setOpenProp for control from outside the component.\\n  const [_open, _setOpen] = React.useState(defaultOpen)\\n  const open = openProp ?? _open\\n  const setOpen = React.useCallback(\\n    (value: boolean | ((value: boolean) => boolean)) => {\\n      const openState = typeof value === \\\"function\\\" ? value(open) : value\\n      if (setOpenProp) {\\n        setOpenProp(openState)\\n      } else {\\n        _setOpen(openState)\\n      }\\n\\n      // This sets the cookie to keep the sidebar state.\\n      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\\n    },\\n    [setOpenProp, open]\\n  )\\n\\n  // Helper to toggle the sidebar.\\n  const toggleSidebar = React.useCallback(() => {\\n    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)\\n  }, [isMobile, setOpen, setOpenMobile])\\n\\n  // Adds a keyboard shortcut to toggle the sidebar.\\n  React.useEffect(() => {\\n    const handleKeyDown = (event: KeyboardEvent) => {\\n      if (\\n        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\\n        (event.metaKey || event.ctrlKey)\\n      ) {\\n        event.preventDefault()\\n        toggleSidebar()\\n      }\\n    }\\n\\n    window.addEventListener(\\\"keydown\\\", handleKeyDown)\\n    return () => window.removeEventListener(\\\"keydown\\\", handleKeyDown)\\n  }, [toggleSidebar])\\n\\n  // We add a state so that we can do data-state=\\\"expanded\\\" or \\\"collapsed\\\".\\n  // This makes it easier to style the sidebar with Tailwind classes.\\n  const state = open ? \\\"expanded\\\" : \\\"collapsed\\\"\\n\\n  const contextValue = React.useMemo<SidebarContextProps>(\\n    () => ({\\n      state,\\n      open,\\n      setOpen,\\n      isMobile,\\n      openMobile,\\n      setOpenMobile,\\n      toggleSidebar,\\n    }),\\n    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\\n  )\\n\\n  return (\\n    <SidebarContext.Provider value={contextValue}>\\n      <TooltipProvider delayDuration={0}>\\n        <div\\n          data-slot=\\\"sidebar-wrapper\\\"\\n          style={\\n            {\\n              \\\"--sidebar-width\\\": SIDEBAR_WIDTH,\\n              \\\"--sidebar-width-icon\\\": SIDEBAR_WIDTH_ICON,\\n              ...style,\\n            } as React.CSSProperties\\n          }\\n          className={cn(\\n            \\\"group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full\\\",\\n            className\\n          )}\\n          {...props}\\n        >\\n          {children}\\n        </div>\\n      </TooltipProvider>\\n    </SidebarContext.Provider>\\n  )\\n}\\n\\nfunction Sidebar({\\n  side = \\\"left\\\",\\n  variant = \\\"sidebar\\\",\\n  collapsible = \\\"offcanvas\\\",\\n  className,\\n  children,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\"> & {\\n  side?: \\\"left\\\" | \\\"right\\\"\\n  variant?: \\\"sidebar\\\" | \\\"floating\\\" | \\\"inset\\\"\\n  collapsible?: \\\"offcanvas\\\" | \\\"icon\\\" | \\\"none\\\"\\n}) {\\n  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\\n\\n  if (collapsible === \\\"none\\\") {\\n    return (\\n      <div\\n        data-slot=\\\"sidebar\\\"\\n        className={cn(\\n          \\\"bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col\\\",\\n          className\\n        )}\\n        {...props}\\n      >\\n        {children}\\n      </div>\\n    )\\n  }\\n\\n  if (isMobile) {\\n    return (\\n      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\\n        <SheetContent\\n          data-sidebar=\\\"sidebar\\\"\\n          data-slot=\\\"sidebar\\\"\\n          data-mobile=\\\"true\\\"\\n          className=\\\"bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden\\\"\\n          style={\\n            {\\n              \\\"--sidebar-width\\\": SIDEBAR_WIDTH_MOBILE,\\n            } as React.CSSProperties\\n          }\\n          side={side}\\n        >\\n          <SheetHeader className=\\\"sr-only\\\">\\n            <SheetTitle>Sidebar</SheetTitle>\\n            <SheetDescription>Displays the mobile sidebar.</SheetDescription>\\n          </SheetHeader>\\n          <div className=\\\"flex h-full w-full flex-col\\\">{children}</div>\\n        </SheetContent>\\n      </Sheet>\\n    )\\n  }\\n\\n  return (\\n    <div\\n      className=\\\"group peer text-sidebar-foreground hidden md:block\\\"\\n      data-state={state}\\n      data-collapsible={state === \\\"collapsed\\\" ? collapsible : \\\"\\\"}\\n      data-variant={variant}\\n      data-side={side}\\n      data-slot=\\\"sidebar\\\"\\n    >\\n      {/* This is what handles the sidebar gap on desktop */}\\n      <div\\n        data-slot=\\\"sidebar-gap\\\"\\n        className={cn(\\n          \\\"relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear\\\",\\n          \\\"group-data-[collapsible=offcanvas]:w-0\\\",\\n          \\\"group-data-[side=right]:rotate-180\\\",\\n          variant === \\\"floating\\\" || variant === \\\"inset\\\"\\n            ? \\\"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]\\\"\\n            : \\\"group-data-[collapsible=icon]:w-(--sidebar-width-icon)\\\"\\n        )}\\n      />\\n      <div\\n        data-slot=\\\"sidebar-container\\\"\\n        className={cn(\\n          \\\"fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex\\\",\\n          side === \\\"left\\\"\\n            ? \\\"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\\\"\\n            : \\\"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\\\",\\n          // Adjust the padding for floating and inset variants.\\n          variant === \\\"floating\\\" || variant === \\\"inset\\\"\\n            ? \\\"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]\\\"\\n            : \\\"group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l\\\",\\n          className\\n        )}\\n        {...props}\\n      >\\n        <div\\n          data-sidebar=\\\"sidebar\\\"\\n          data-slot=\\\"sidebar-inner\\\"\\n          className=\\\"bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm\\\"\\n        >\\n          {children}\\n        </div>\\n      </div>\\n    </div>\\n  )\\n}\\n\\nfunction SidebarTrigger({\\n  className,\\n  onClick,\\n  ...props\\n}: React.ComponentProps<typeof Button>) {\\n  const { toggleSidebar } = useSidebar()\\n\\n  return (\\n    <Button\\n      data-sidebar=\\\"trigger\\\"\\n      data-slot=\\\"sidebar-trigger\\\"\\n      variant=\\\"ghost\\\"\\n      size=\\\"icon\\\"\\n      className={cn(\\\"size-7\\\", className)}\\n      onClick={(event) => {\\n        onClick?.(event)\\n        toggleSidebar()\\n      }}\\n      {...props}\\n    >\\n      <PanelLeftIcon />\\n      <span className=\\\"sr-only\\\">Toggle Sidebar</span>\\n    </Button>\\n  )\\n}\\n\\nfunction SidebarRail({ className, ...props }: React.ComponentProps<\\\"button\\\">) {\\n  const { toggleSidebar } = useSidebar()\\n\\n  return (\\n    <button\\n      data-sidebar=\\\"rail\\\"\\n      data-slot=\\\"sidebar-rail\\\"\\n      aria-label=\\\"Toggle Sidebar\\\"\\n      tabIndex={-1}\\n      onClick={toggleSidebar}\\n      title=\\\"Toggle Sidebar\\\"\\n      className={cn(\\n        \\\"hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex\\\",\\n        \\\"in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize\\\",\\n        \\\"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\\\",\\n        \\\"hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full\\\",\\n        \\\"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\\\",\\n        \\\"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarInset({ className, ...props }: React.ComponentProps<\\\"main\\\">) {\\n  return (\\n    <main\\n      data-slot=\\\"sidebar-inset\\\"\\n      className={cn(\\n        \\\"bg-background relative flex w-full flex-1 flex-col\\\",\\n        \\\"md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarInput({\\n  className,\\n  ...props\\n}: React.ComponentProps<typeof Input>) {\\n  return (\\n    <Input\\n      data-slot=\\\"sidebar-input\\\"\\n      data-sidebar=\\\"input\\\"\\n      className={cn(\\\"bg-background h-8 w-full shadow-none\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarHeader({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-header\\\"\\n      data-sidebar=\\\"header\\\"\\n      className={cn(\\\"flex flex-col gap-2 p-2\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarFooter({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-footer\\\"\\n      data-sidebar=\\\"footer\\\"\\n      className={cn(\\\"flex flex-col gap-2 p-2\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarSeparator({\\n  className,\\n  ...props\\n}: React.ComponentProps<typeof Separator>) {\\n  return (\\n    <Separator\\n      data-slot=\\\"sidebar-separator\\\"\\n      data-sidebar=\\\"separator\\\"\\n      className={cn(\\\"bg-sidebar-border mx-2 w-auto\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarContent({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-content\\\"\\n      data-sidebar=\\\"content\\\"\\n      className={cn(\\n        \\\"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarGroup({ className, ...props }: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-group\\\"\\n      data-sidebar=\\\"group\\\"\\n      className={cn(\\\"relative flex w-full min-w-0 flex-col p-2\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarGroupLabel({\\n  className,\\n  asChild = false,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\"> & { asChild?: boolean }) {\\n  const Comp = asChild ? Slot : \\\"div\\\"\\n\\n  return (\\n    <Comp\\n      data-slot=\\\"sidebar-group-label\\\"\\n      data-sidebar=\\\"group-label\\\"\\n      className={cn(\\n        \\\"text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\\\",\\n        \\\"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarGroupAction({\\n  className,\\n  asChild = false,\\n  ...props\\n}: React.ComponentProps<\\\"button\\\"> & { asChild?: boolean }) {\\n  const Comp = asChild ? Slot : \\\"button\\\"\\n\\n  return (\\n    <Comp\\n      data-slot=\\\"sidebar-group-action\\\"\\n      data-sidebar=\\\"group-action\\\"\\n      className={cn(\\n        \\\"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\\\",\\n        // Increases the hit area of the button on mobile.\\n        \\\"after:absolute after:-inset-2 md:after:hidden\\\",\\n        \\\"group-data-[collapsible=icon]:hidden\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarGroupContent({\\n  className,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-group-content\\\"\\n      data-sidebar=\\\"group-content\\\"\\n      className={cn(\\\"w-full text-sm\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenu({ className, ...props }: React.ComponentProps<\\\"ul\\\">) {\\n  return (\\n    <ul\\n      data-slot=\\\"sidebar-menu\\\"\\n      data-sidebar=\\\"menu\\\"\\n      className={cn(\\\"flex w-full min-w-0 flex-col gap-1\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenuItem({ className, ...props }: React.ComponentProps<\\\"li\\\">) {\\n  return (\\n    <li\\n      data-slot=\\\"sidebar-menu-item\\\"\\n      data-sidebar=\\\"menu-item\\\"\\n      className={cn(\\\"group/menu-item relative\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nconst sidebarMenuButtonVariants = cva(\\n  \\\"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\\\",\\n  {\\n    variants: {\\n      variant: {\\n        default: \\\"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\\\",\\n        outline:\\n          \\\"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\\\",\\n      },\\n      size: {\\n        default: \\\"h-8 text-sm\\\",\\n        sm: \\\"h-7 text-xs\\\",\\n        lg: \\\"h-12 text-sm group-data-[collapsible=icon]:p-0!\\\",\\n      },\\n    },\\n    defaultVariants: {\\n      variant: \\\"default\\\",\\n      size: \\\"default\\\",\\n    },\\n  }\\n)\\n\\nfunction SidebarMenuButton({\\n  asChild = false,\\n  isActive = false,\\n  variant = \\\"default\\\",\\n  size = \\\"default\\\",\\n  tooltip,\\n  className,\\n  ...props\\n}: React.ComponentProps<\\\"button\\\"> & {\\n  asChild?: boolean\\n  isActive?: boolean\\n  tooltip?: string | React.ComponentProps<typeof TooltipContent>\\n} & VariantProps<typeof sidebarMenuButtonVariants>) {\\n  const Comp = asChild ? Slot : \\\"button\\\"\\n  const { isMobile, state } = useSidebar()\\n\\n  const button = (\\n    <Comp\\n      data-slot=\\\"sidebar-menu-button\\\"\\n      data-sidebar=\\\"menu-button\\\"\\n      data-size={size}\\n      data-active={isActive}\\n      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\\n      {...props}\\n    />\\n  )\\n\\n  if (!tooltip) {\\n    return button\\n  }\\n\\n  if (typeof tooltip === \\\"string\\\") {\\n    tooltip = {\\n      children: tooltip,\\n    }\\n  }\\n\\n  return (\\n    <Tooltip>\\n      <TooltipTrigger asChild>{button}</TooltipTrigger>\\n      <TooltipContent\\n        side=\\\"right\\\"\\n        align=\\\"center\\\"\\n        hidden={state !== \\\"collapsed\\\" || isMobile}\\n        {...tooltip}\\n      />\\n    </Tooltip>\\n  )\\n}\\n\\nfunction SidebarMenuAction({\\n  className,\\n  asChild = false,\\n  showOnHover = false,\\n  ...props\\n}: React.ComponentProps<\\\"button\\\"> & {\\n  asChild?: boolean\\n  showOnHover?: boolean\\n}) {\\n  const Comp = asChild ? Slot : \\\"button\\\"\\n\\n  return (\\n    <Comp\\n      data-slot=\\\"sidebar-menu-action\\\"\\n      data-sidebar=\\\"menu-action\\\"\\n      className={cn(\\n        \\\"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\\\",\\n        // Increases the hit area of the button on mobile.\\n        \\\"after:absolute after:-inset-2 md:after:hidden\\\",\\n        \\\"peer-data-[size=sm]/menu-button:top-1\\\",\\n        \\\"peer-data-[size=default]/menu-button:top-1.5\\\",\\n        \\\"peer-data-[size=lg]/menu-button:top-2.5\\\",\\n        \\\"group-data-[collapsible=icon]:hidden\\\",\\n        showOnHover &&\\n          \\\"peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenuBadge({\\n  className,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\">) {\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-menu-badge\\\"\\n      data-sidebar=\\\"menu-badge\\\"\\n      className={cn(\\n        \\\"text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none\\\",\\n        \\\"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\\\",\\n        \\\"peer-data-[size=sm]/menu-button:top-1\\\",\\n        \\\"peer-data-[size=default]/menu-button:top-1.5\\\",\\n        \\\"peer-data-[size=lg]/menu-button:top-2.5\\\",\\n        \\\"group-data-[collapsible=icon]:hidden\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenuSkeleton({\\n  className,\\n  showIcon = false,\\n  ...props\\n}: React.ComponentProps<\\\"div\\\"> & {\\n  showIcon?: boolean\\n}) {\\n  // Random width between 50 to 90%.\\n  const width = React.useMemo(() => {\\n    return `${Math.floor(Math.random() * 40) + 50}%`\\n  }, [])\\n\\n  return (\\n    <div\\n      data-slot=\\\"sidebar-menu-skeleton\\\"\\n      data-sidebar=\\\"menu-skeleton\\\"\\n      className={cn(\\\"flex h-8 items-center gap-2 rounded-md px-2\\\", className)}\\n      {...props}\\n    >\\n      {showIcon && (\\n        <Skeleton\\n          className=\\\"size-4 rounded-md\\\"\\n          data-sidebar=\\\"menu-skeleton-icon\\\"\\n        />\\n      )}\\n      <Skeleton\\n        className=\\\"h-4 max-w-(--skeleton-width) flex-1\\\"\\n        data-sidebar=\\\"menu-skeleton-text\\\"\\n        style={\\n          {\\n            \\\"--skeleton-width\\\": width,\\n          } as React.CSSProperties\\n        }\\n      />\\n    </div>\\n  )\\n}\\n\\nfunction SidebarMenuSub({ className, ...props }: React.ComponentProps<\\\"ul\\\">) {\\n  return (\\n    <ul\\n      data-slot=\\\"sidebar-menu-sub\\\"\\n      data-sidebar=\\\"menu-sub\\\"\\n      className={cn(\\n        \\\"border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5\\\",\\n        \\\"group-data-[collapsible=icon]:hidden\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenuSubItem({\\n  className,\\n  ...props\\n}: React.ComponentProps<\\\"li\\\">) {\\n  return (\\n    <li\\n      data-slot=\\\"sidebar-menu-sub-item\\\"\\n      data-sidebar=\\\"menu-sub-item\\\"\\n      className={cn(\\\"group/menu-sub-item relative\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction SidebarMenuSubButton({\\n  asChild = false,\\n  size = \\\"md\\\",\\n  isActive = false,\\n  className,\\n  ...props\\n}: React.ComponentProps<\\\"a\\\"> & {\\n  asChild?: boolean\\n  size?: \\\"sm\\\" | \\\"md\\\"\\n  isActive?: boolean\\n}) {\\n  const Comp = asChild ? Slot : \\\"a\\\"\\n\\n  return (\\n    <Comp\\n      data-slot=\\\"sidebar-menu-sub-button\\\"\\n      data-sidebar=\\\"menu-sub-button\\\"\\n      data-size={size}\\n      data-active={isActive}\\n      className={cn(\\n        \\\"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\\\",\\n        \\\"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\\\",\\n        size === \\\"sm\\\" && \\\"text-xs\\\",\\n        size === \\\"md\\\" && \\\"text-sm\\\",\\n        \\\"group-data-[collapsible=icon]:hidden\\\",\\n        className\\n      )}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport {\\n  Sidebar,\\n  SidebarContent,\\n  SidebarFooter,\\n  SidebarGroup,\\n  SidebarGroupAction,\\n  SidebarGroupContent,\\n  SidebarGroupLabel,\\n  SidebarHeader,\\n  SidebarInput,\\n  SidebarInset,\\n  SidebarMenu,\\n  SidebarMenuAction,\\n  SidebarMenuBadge,\\n  SidebarMenuButton,\\n  SidebarMenuItem,\\n  SidebarMenuSkeleton,\\n  SidebarMenuSub,\\n  SidebarMenuSubButton,\\n  SidebarMenuSubItem,\\n  SidebarProvider,\\n  SidebarRail,\\n  SidebarSeparator,\\n  SidebarTrigger,\\n  useSidebar,\\n}\\n\",\n  \"/src/components/ui/skeleton.tsx\": \"import { cn } from \\\"@/lib/utils\\\"\\n\\nfunction Skeleton({\\n  className,\\n  ...props\\n}: React.HTMLAttributes<HTMLDivElement>) {\\n  return (\\n    <div\\n      className={cn(\\\"animate-pulse rounded-md bg-primary/10\\\", className)}\\n      {...props}\\n    />\\n  )\\n}\\n\\nexport { Skeleton }\\n\",\n  \"/src/components/ui/tooltip.tsx\": \"\\\"use client\\\"\\n\\nimport * as React from \\\"react\\\"\\nimport * as TooltipPrimitive from \\\"@radix-ui/react-tooltip\\\"\\n\\nimport { cn } from \\\"@/lib/utils\\\"\\n\\nfunction TooltipProvider({\\n  delayDuration = 0,\\n  ...props\\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\\n  return (\\n    <TooltipPrimitive.Provider\\n      data-slot=\\\"tooltip-provider\\\"\\n      delayDuration={delayDuration}\\n      {...props}\\n    />\\n  )\\n}\\n\\nfunction Tooltip({\\n  ...props\\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\\n  return (\\n    <TooltipProvider>\\n      <TooltipPrimitive.Root data-slot=\\\"tooltip\\\" {...props} />\\n    </TooltipProvider>\\n  )\\n}\\n\\nfunction TooltipTrigger({\\n  ...props\\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\\n  return <TooltipPrimitive.Trigger data-slot=\\\"tooltip-trigger\\\" {...props} />\\n}\\n\\nfunction TooltipContent({\\n  className,\\n  sideOffset = 0,\\n  children,\\n  ...props\\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\\n  return (\\n    <TooltipPrimitive.Portal>\\n      <TooltipPrimitive.Content\\n        data-slot=\\\"tooltip-content\\\"\\n        sideOffset={sideOffset}\\n        className={cn(\\n          \\\"bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance\\\",\\n          className\\n        )}\\n        {...props}\\n      >\\n        {children}\\n        <TooltipPrimitive.Arrow className=\\\"bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]\\\" />\\n      </TooltipPrimitive.Content>\\n    </TooltipPrimitive.Portal>\\n  )\\n}\\n\\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\\n\",\n  \"/src/App.tsx\": \"import \\\"./App.css\\\";\\nimport { GeneratedFormComponent } from \\\"./GeneratedFormComponent\\\";\\n\\nfunction App() {\\n  return (\\n    <>\\n      <GeneratedFormComponent />\\n    </>\\n  );\\n}\\n\\nexport default App;\",\n  \"/src/App.css\": \"#root {\\n  max-width: 1280px;\\n  margin: 0 auto;\\n  padding: 2rem;\\n  text-align: center;\\n}\"\n}",
      "type": "registry:lib",
      "target": "lib/sandbox-templates.json"
    }
  ]
}