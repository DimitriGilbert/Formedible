{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "formedible-parser",
  "type": "registry:block",
  "title": "Formedible Parser",
  "description": "Safe parser for Formedible form definitions - handles JSON, JavaScript object literals, and Zod schema expressions",
  "dependencies": [
    "react",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "textarea",
    "label",
    "card"
  ],
  "files": [
    {
      "path": "src/components/formedible/parser/formedible-parser.tsx",
      "content": "\"use client\";\n\nimport type { \n  ParsedFieldConfig, \n  ParsedFormConfig, \n  ParserOptions, \n  ObjectConfig,\n  ParserError,\n  PageConfig,\n  EnhancedParserOptions,\n  EnhancedParserError,\n  SchemaInferenceOptions,\n  SchemaInferenceResult,\n  ValidationWithSuggestionsResult\n} from './types';\n\n/**\n * FormedibleParser - A safe parser for Formedible form definitions\n * \n * This parser can handle:\n * - Pure JSON format\n * - JavaScript object literals (unquoted keys)\n * - Zod schema expressions (z.string(), z.number(), etc.)\n * - Nested and chained Zod validations (z.string().min(1).max(50))\n * \n * Features:\n * - Sanitizes dangerous code patterns\n * - Validates field types and structure\n * - Removes unknown/dangerous keys\n * - Handles balanced parentheses in Zod expressions\n * - Supports all 24 field types\n * - 100% backward compatibility with existing parser\n * \n * Usage:\n *   const parsed = FormedibleParser.parse(codeString);\n * \n * @version 2.0.0\n * @standalone-ready This class is designed as a standalone package\n */\nexport class FormedibleParser {\n  // All 24 supported field types in formedible\n  private static readonly ALLOWED_FIELD_TYPES = [\n    'text', 'email', 'password', 'url', 'tel', 'textarea', 'select', \n    'checkbox', 'switch', 'number', 'date', 'slider', 'file', 'rating',\n    'phone', 'colorPicker', 'location', 'duration', 'multiSelect',\n    'autocomplete', 'masked', 'object', 'array', 'radio'\n  ] as const;\n\n  // Allowed top-level keys in form definitions\n  private static readonly ALLOWED_KEYS = [\n    'schema', 'fields', 'pages', 'progress', 'submitLabel', 'nextLabel', \n    'previousLabel', 'formClassName', 'fieldClassName', 'formOptions',\n    'title', 'description'\n  ] as const;\n\n  // Configuration for parser behavior\n  private static CONFIG = {\n    ZOD_PLACEHOLDER: '__ZOD_SCHEMA__',\n    MAX_RECURSION_DEPTH: 10,\n    ENABLE_STRICT_VALIDATION: true,\n    MAX_CODE_LENGTH: 1000000, // 1MB limit\n    MAX_NESTING_DEPTH: 50\n  };\n\n  /**\n   * Main parser method - parses formedible form definition code\n   * @param code - The form definition code (JSON or JS object literal)\n   * @param options - Optional parsing configuration\n   * @returns Parsed and validated form definition\n   * @throws {ParserError} When parsing fails with detailed error information\n   */\n  static parse(code: string, options?: ParserOptions | EnhancedParserOptions): ParsedFormConfig {\n    if (!code || typeof code !== 'string') {\n      throw this.createParserError('Input code must be a non-empty string', 'INVALID_INPUT');\n    }\n\n    if (code.length > this.CONFIG.MAX_CODE_LENGTH) {\n      throw this.createParserError(\n        `Code length exceeds maximum allowed size of ${this.CONFIG.MAX_CODE_LENGTH} characters`,\n        'CODE_TOO_LARGE'\n      );\n    }\n\n    try {\n      // Apply configuration overrides\n      if (options?.strictValidation !== undefined) {\n        this.CONFIG.ENABLE_STRICT_VALIDATION = options.strictValidation;\n      }\n\n      // Remove any potential function calls or dangerous patterns\n      const sanitizedCode = this.sanitizeCode(code);\n      \n      // Parse the JSON-like structure\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n      \n      // Validate and sanitize the parsed object\n      return this.validateAndSanitize(parsed);\n    } catch (error) {\n      if (error instanceof Error && error.name === 'ParserError') {\n        throw error;\n      }\n      \n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw this.createParserError(\n        `Failed to parse form definition - ${errorMessage}`,\n        'PARSE_ERROR',\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Validates if a field type is supported\n   * @param type - The field type to validate\n   * @returns True if the field type is valid\n   */\n  static isValidFieldType(type: string): boolean {\n    return this.ALLOWED_FIELD_TYPES.includes(type as any);\n  }\n\n  /**\n   * Gets all supported field types\n   * @returns Array of supported field types\n   */\n  static getSupportedFieldTypes(): readonly string[] {\n    return [...this.ALLOWED_FIELD_TYPES];\n  }\n\n  /**\n   * Validates a form configuration without parsing code\n   * @param config - The form configuration to validate\n   * @returns Validation result with errors if any\n   */\n  static validateConfig(config: unknown): { isValid: boolean; errors: string[] } {\n    try {\n      this.validateAndSanitize(config as Record<string, unknown>);\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  }\n\n  /**\n   * Creates a standardized parser error with additional metadata\n   * @private\n   */\n  private static createParserError(\n    message: string, \n    code: string, \n    metadata?: Record<string, unknown>\n  ): ParserError {\n    const error = new Error(message) as ParserError;\n    error.name = 'ParserError';\n    error.code = code;\n    \n    if (metadata) {\n      Object.assign(error, metadata);\n    }\n    \n    return error;\n  }\n\n  /**\n   * Enhanced code sanitization with better security measures\n   * @private\n   */\n  private static sanitizeCode(code: string): string {\n    // Remove comments first\n    let sanitized = code\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // Block comments\n      .replace(/\\/\\/.*$/gm, ''); // Line comments\n    \n    // Remove dangerous patterns more aggressively\n    const dangerousPatterns = [\n      /\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g,\n      /\\b(document|window|global|process)\\b/g,\n      /\\b__proto__\\b/g,\n      /\\bconstructor\\b/g,\n      /\\bprototype\\b/g\n    ];\n    \n    dangerousPatterns.forEach(pattern => {\n      sanitized = sanitized.replace(pattern, '\"\"');\n    });\n    \n    // Remove any arrow functions or function expressions more thoroughly\n    sanitized = sanitized.replace(/=>\\s*[\\{]?[^}]*[\\}]?/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n    \n    // Handle Date objects more safely\n    sanitized = sanitized.replace(\n      /new\\s+Date\\(\\)\\.toISOString\\(\\)\\.split\\('[^']*'\\)\\[0\\]/g, \n      '\"2024-01-01\"'\n    );\n    sanitized = sanitized.replace(/new\\s+Date\\(\\)/g, '\"2024-01-01T00:00:00Z\"');\n    \n    // Remove any remaining 'new' keyword usage\n    sanitized = sanitized.replace(/\\bnew\\s+\\w+\\(/g, '\"\"');\n    \n    return sanitized;\n  }\n\n  /**\n   * Enhanced object literal parsing with better error handling\n   * @private\n   */\n  private static parseObjectLiteral(code: string): Record<string, unknown> {\n    try {\n      // First try direct JSON parsing\n      return JSON.parse(code);\n    } catch (jsonError) {\n      // If that fails, try to convert JS object literal to JSON\n      let processedCode = code.trim();\n      \n      try {\n        // Replace Zod expressions with placeholder strings - handle nested structures\n        processedCode = this.replaceZodExpressions(processedCode);\n        \n        // Convert unquoted keys to quoted keys with better regex\n        processedCode = processedCode.replace(\n          /([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g, \n          '$1\"$2\":'\n        );\n        \n        // Remove trailing commas more thoroughly\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, '$1');\n        \n        // Convert single quotes to double quotes (but preserve escaped quotes)\n        processedCode = processedCode.replace(/(?<!\\\\)'/g, '\"');\n        \n        // Handle undefined values\n        processedCode = processedCode.replace(/:\\s*undefined/g, ': null');\n        \n        const result = JSON.parse(processedCode);\n        return result;\n      } catch (conversionError) {\n        // Enhanced error reporting\n        const originalPreview = code.substring(0, 200) + (code.length > 200 ? '...' : '');\n        const processedPreview = processedCode.substring(0, 200) + (processedCode.length > 200 ? '...' : '');\n        \n        throw this.createParserError(\n          `Invalid syntax. Please use valid JSON format or JavaScript object literal syntax.`,\n          'SYNTAX_ERROR',\n          {\n            originalCode: originalPreview,\n            processedCode: processedPreview,\n            jsonError: jsonError instanceof Error ? jsonError.message : String(jsonError),\n            conversionError: conversionError instanceof Error ? conversionError.message : String(conversionError)\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Enhanced Zod expression replacement with better handling of complex expressions\n   * @private\n   */\n  private static replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 100; // Prevent infinite loops\n    \n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n      \n      // Match z.method( and find the matching closing parenthesis\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n        \n        // Find the matching closing parenthesis with better depth tracking\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n        let stringChar: string | null = null;\n        let escaped = false;\n        \n        while (endIndex < result.length && depth > 0) {\n          const char = result[endIndex];\n          \n          // Handle string literals to avoid counting parentheses inside strings\n          if (!escaped && (char === '\"' || char === \"'\")) {\n            if (!stringChar) {\n              stringChar = char;\n            } else if (stringChar === char) {\n              stringChar = null;\n            }\n          } else if (!stringChar) {\n            if (char === '(') {\n              depth++;\n            } else if (char === ')') {\n              depth--;\n            }\n          }\n          \n          escaped = char === '\\\\' && !escaped;\n          endIndex++;\n        }\n        \n        if (depth === 0) {\n          // Check for chained methods like .min().max()\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              // Find the closing parenthesis for this chained method\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n              let chainStringChar: string | null = null;\n              let chainEscaped = false;\n              \n              while (chainEndIndex < result.length && chainDepth > 0) {\n                const char = result[chainEndIndex];\n                \n                if (!chainEscaped && (char === '\"' || char === \"'\")) {\n                  if (!chainStringChar) {\n                    chainStringChar = char;\n                  } else if (chainStringChar === char) {\n                    chainStringChar = null;\n                  }\n                } else if (!chainStringChar) {\n                  if (char === '(') {\n                    chainDepth++;\n                  } else if (char === ')') {\n                    chainDepth--;\n                  }\n                }\n                \n                chainEscaped = char === '\\\\' && !chainEscaped;\n                chainEndIndex++;\n              }\n              \n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n          \n          // Replace the entire Zod expression with a placeholder\n          result = result.slice(0, startIndex) + `\"${this.CONFIG.ZOD_PLACEHOLDER}\"` + result.slice(chainEnd);\n          changed = true;\n        } else {\n          // If we can't find matching parentheses, just replace the method name\n          result = result.replace(/z\\.[a-zA-Z]+/, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n          changed = true;\n        }\n      }\n    }\n    \n    // Handle standalone z.enum() calls and other complex patterns\n    result = result.replace(/z\\.enum\\(\\[[^\\]]*\\]\\)/g, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n    result = result.replace(/z\\.\\w+/g, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n    \n    return result;\n  }\n\n  /**\n   * Enhanced validation and sanitization with comprehensive field type support\n   * @private\n   */\n  private static validateAndSanitize(obj: Record<string, unknown>): ParsedFormConfig {\n    if (typeof obj !== 'object' || obj === null) {\n      throw this.createParserError('Definition must be an object', 'INVALID_DEFINITION');\n    }\n\n    const sanitized: ParsedFormConfig = {\n      fields: []\n    };\n\n    // Validate top-level keys\n    for (const [key, value] of Object.entries(obj)) {\n      if (!this.ALLOWED_KEYS.includes(key as any)) {\n        if (this.CONFIG.ENABLE_STRICT_VALIDATION) {\n          console.warn(`Unknown key '${key}' found in form definition, skipping`);\n        }\n        continue; // Skip unknown keys\n      }\n\n      switch (key) {\n        case 'schema':\n          // Pass through the schema - it's needed for validation\n          sanitized.schema = value;\n          break;\n          \n        case 'fields':\n          if (!Array.isArray(value)) {\n            throw this.createParserError('Fields must be an array', 'INVALID_FIELDS');\n          }\n          sanitized.fields = this.validateFields(value);\n          break;\n          \n        case 'pages':\n          if (Array.isArray(value)) {\n            sanitized.pages = value.map((page, index) => this.validatePage(page, index));\n          }\n          break;\n          \n        case 'title':\n          if (typeof value === 'string') {\n            sanitized.title = value;\n          }\n          break;\n          \n        case 'description':\n          if (typeof value === 'string') {\n            sanitized.description = value;\n          }\n          break;\n          \n        case 'submitLabel':\n          if (typeof value === 'string') {\n            sanitized.submitLabel = value;\n          }\n          break;\n          \n        case 'nextLabel':\n          if (typeof value === 'string') {\n            sanitized.nextLabel = value;\n          }\n          break;\n          \n        case 'previousLabel':\n          if (typeof value === 'string') {\n            sanitized.previousLabel = value;\n          }\n          break;\n          \n        case 'formClassName':\n          if (typeof value === 'string') {\n            sanitized.formClassName = value;\n          }\n          break;\n          \n        case 'fieldClassName':\n          if (typeof value === 'string') {\n            sanitized.fieldClassName = value;\n          }\n          break;\n          \n        case 'progress':\n          if (value && typeof value === 'object') {\n            sanitized.progress = value as ParsedFormConfig['progress'];\n          }\n          break;\n          \n        case 'formOptions':\n          if (value && typeof value === 'object') {\n            sanitized.formOptions = value as ParsedFormConfig['formOptions'];\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced field validation with support for all 24 field types\n   * @private\n   */\n  private static validateFields(fields: unknown[]): ParsedFieldConfig[] {\n    return fields.map((field, index): ParsedFieldConfig => {\n      if (typeof field !== 'object' || field === null) {\n        throw this.createParserError(\n          `Field at index ${index} must be an object`,\n          'INVALID_FIELD',\n          { fieldIndex: index }\n        );\n      }\n\n      const fieldObj = field as Record<string, unknown>;\n\n      // Ensure required fields\n      if (!fieldObj.name || !fieldObj.type) {\n        throw this.createParserError(\n          `Field at index ${index} must have 'name' and 'type' properties`,\n          'MISSING_REQUIRED_FIELD',\n          { fieldIndex: index }\n        );\n      }\n\n      if (typeof fieldObj.name !== 'string' || typeof fieldObj.type !== 'string') {\n        throw this.createParserError(\n          `Field at index ${index} must have string 'name' and 'type' properties`,\n          'INVALID_FIELD_TYPE',\n          { fieldIndex: index }\n        );\n      }\n\n      if (!this.ALLOWED_FIELD_TYPES.includes(fieldObj.type as any)) {\n        throw this.createParserError(\n          `Field at index ${index} has invalid type '${fieldObj.type}'. Supported types: ${this.ALLOWED_FIELD_TYPES.join(', ')}`,\n          'UNSUPPORTED_FIELD_TYPE',\n          { fieldIndex: index, fieldType: fieldObj.type }\n        );\n      }\n\n      // Build properly typed field config\n      const validatedField: ParsedFieldConfig = {\n        name: fieldObj.name,\n        type: fieldObj.type,\n      };\n\n      // Add optional properties with proper type checks\n      this.addOptionalStringProperty(validatedField, fieldObj, 'label');\n      this.addOptionalStringProperty(validatedField, fieldObj, 'placeholder');\n      this.addOptionalStringProperty(validatedField, fieldObj, 'description');\n      \n      if (typeof fieldObj.required === 'boolean') {\n        validatedField.required = fieldObj.required;\n      }\n      \n      if (fieldObj.defaultValue !== undefined) {\n        validatedField.defaultValue = fieldObj.defaultValue;\n      }\n      \n      // Numeric properties\n      this.addOptionalNumberProperty(validatedField, fieldObj, 'min');\n      this.addOptionalNumberProperty(validatedField, fieldObj, 'max');\n      this.addOptionalNumberProperty(validatedField, fieldObj, 'step');\n\n      // Handle complex configurations for different field types\n      this.addFieldSpecificConfigurations(validatedField, fieldObj, index);\n\n      // Handle options array\n      if (fieldObj.options && Array.isArray(fieldObj.options)) {\n        validatedField.options = this.validateOptions(fieldObj.options);\n      }\n\n      // Pass through validation configuration\n      if (fieldObj.validation !== undefined && fieldObj.validation !== null) {\n        validatedField.validation = fieldObj.validation;\n      }\n\n      return validatedField;\n    });\n  }\n\n  /**\n   * Adds field-specific configurations based on field type\n   * @private\n   */\n  private static addFieldSpecificConfigurations(\n    validatedField: ParsedFieldConfig,\n    fieldObj: Record<string, unknown>,\n    index: number\n  ): void {\n    const fieldType = validatedField.type;\n\n    // Array field configuration\n    if (fieldType === 'array' && fieldObj.arrayConfig) {\n      validatedField.arrayConfig = this.validateArrayConfig(fieldObj.arrayConfig, index);\n    }\n\n    // Object field configuration\n    if (fieldType === 'object' && fieldObj.objectConfig) {\n      validatedField.objectConfig = this.validateObjectConfig(fieldObj.objectConfig, index);\n    }\n\n    // Multi-select configuration\n    if (fieldType === 'multiSelect' && fieldObj.multiSelectConfig) {\n      validatedField.multiSelectConfig = this.validateMultiSelectConfig(fieldObj.multiSelectConfig);\n    }\n\n    // Color picker configuration\n    if (fieldType === 'colorPicker' && fieldObj.colorConfig) {\n      validatedField.colorConfig = this.validateColorConfig(fieldObj.colorConfig);\n    }\n\n    // Rating configuration\n    if (fieldType === 'rating' && fieldObj.ratingConfig) {\n      validatedField.ratingConfig = this.validateRatingConfig(fieldObj.ratingConfig);\n    }\n\n    // Phone configuration\n    if (fieldType === 'phone' && fieldObj.phoneConfig) {\n      validatedField.phoneConfig = this.validatePhoneConfig(fieldObj.phoneConfig);\n    }\n\n    // Datalist configuration\n    if (fieldObj.datalist) {\n      validatedField.datalist = this.validateDatalistConfig(fieldObj.datalist);\n    }\n\n    // Pass through other configurations with validation\n    const configKeys = [\n      'sliderConfig', 'fileConfig', 'locationConfig', 'durationConfig',\n      'autocompleteConfig', 'maskedConfig', 'dateConfig', 'textareaConfig',\n      'passwordConfig', 'emailConfig', 'numberConfig'\n    ];\n\n    configKeys.forEach(configKey => {\n      if (fieldObj[configKey] && typeof fieldObj[configKey] === 'object') {\n        (validatedField as any)[configKey] = fieldObj[configKey];\n      }\n    });\n  }\n\n  /**\n   * Helper methods for adding optional properties\n   * @private\n   */\n  private static addOptionalStringProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (source[key] && typeof source[key] === 'string') {\n      target[key] = source[key];\n    }\n  }\n\n  private static addOptionalNumberProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (typeof source[key] === 'number') {\n      target[key] = source[key];\n    }\n  }\n\n  /**\n   * Configuration validators\n   * @private\n   */\n  private static validateArrayConfig(config: unknown, fieldIndex: number): ParsedFieldConfig['arrayConfig'] {\n    if (typeof config !== 'object' || !config) {\n      throw this.createParserError(\n        `Array config at field index ${fieldIndex} must be an object`,\n        'INVALID_ARRAY_CONFIG'\n      );\n    }\n\n    const arrayConfig = config as Record<string, unknown>;\n    const validated: ParsedFieldConfig['arrayConfig'] = {\n      itemType: 'text'\n    };\n\n    if (arrayConfig.itemType && typeof arrayConfig.itemType === 'string') {\n      validated.itemType = arrayConfig.itemType;\n    }\n\n    // Add other array config properties\n    ['itemLabel', 'itemPlaceholder', 'addButtonLabel', 'removeButtonLabel'].forEach(key => {\n      if (arrayConfig[key] && typeof arrayConfig[key] === 'string') {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    ['minItems', 'maxItems'].forEach(key => {\n      if (typeof arrayConfig[key] === 'number') {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    if (typeof arrayConfig.sortable === 'boolean') {\n      validated.sortable = arrayConfig.sortable;\n    }\n\n    if (arrayConfig.objectConfig) {\n      validated.objectConfig = this.validateObjectConfig(arrayConfig.objectConfig, fieldIndex);\n    }\n\n    return validated;\n  }\n\n  private static validateObjectConfig(config: unknown, fieldIndex: number): ObjectConfig {\n    if (typeof config !== 'object' || !config) {\n      throw this.createParserError(\n        `Object config at field index ${fieldIndex} must be an object`,\n        'INVALID_OBJECT_CONFIG'\n      );\n    }\n\n    const objectConfig = config as Record<string, unknown>;\n    const validated: ObjectConfig = {\n      fields: []\n    };\n\n    if (objectConfig.fields && Array.isArray(objectConfig.fields)) {\n      validated.fields = objectConfig.fields.map(field => {\n        if (typeof field !== 'object' || !field) {\n          return { name: '', type: 'text' };\n        }\n        const f = field as Record<string, unknown>;\n        const validatedField: ObjectConfig['fields'][0] = {\n          name: typeof f.name === 'string' ? f.name : '',\n          type: typeof f.type === 'string' ? f.type : 'text',\n        };\n        \n        if (typeof f.label === 'string') validatedField.label = f.label;\n        if (typeof f.placeholder === 'string') validatedField.placeholder = f.placeholder;\n        if (typeof f.description === 'string') validatedField.description = f.description;\n        if (typeof f.min === 'number') validatedField.min = f.min;\n        if (typeof f.max === 'number') validatedField.max = f.max;\n        if (typeof f.step === 'number') validatedField.step = f.step;\n        \n        if (f.options && (Array.isArray(f.options) || typeof f.options === 'function')) {\n          validatedField.options = f.options as ObjectConfig['fields'][0]['options'];\n        }\n        \n        return validatedField;\n      });\n    }\n\n    // Add other object config properties\n    ['title', 'description', 'collapseLabel', 'expandLabel'].forEach(key => {\n      if (objectConfig[key] && typeof objectConfig[key] === 'string') {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    ['collapsible', 'defaultExpanded', 'showCard'].forEach(key => {\n      if (typeof objectConfig[key] === 'boolean') {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    if (objectConfig.layout && ['vertical', 'horizontal', 'grid'].includes(objectConfig.layout as string)) {\n      validated.layout = objectConfig.layout as ObjectConfig['layout'];\n    }\n\n    if (typeof objectConfig.columns === 'number') {\n      validated.columns = objectConfig.columns;\n    }\n\n    return validated;\n  }\n\n  private static validateMultiSelectConfig(config: unknown): ParsedFieldConfig['multiSelectConfig'] {\n    if (typeof config !== 'object' || !config) {\n      return undefined;\n    }\n\n    const multiSelectConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig['multiSelectConfig']> = {};\n\n    if (typeof multiSelectConfig.maxSelections === 'number') {\n      validated.maxSelections = multiSelectConfig.maxSelections;\n    }\n\n    ['searchable', 'creatable'].forEach(key => {\n      if (typeof multiSelectConfig[key] === 'boolean') {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    ['placeholder', 'noOptionsText', 'loadingText'].forEach(key => {\n      if (multiSelectConfig[key] && typeof multiSelectConfig[key] === 'string') {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateColorConfig(config: unknown): ParsedFieldConfig['colorConfig'] {\n    if (typeof config !== 'object' || !config) {\n      return undefined;\n    }\n\n    const colorConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig['colorConfig']> = {};\n\n    if (colorConfig.format && ['hex', 'rgb', 'hsl'].includes(colorConfig.format as string)) {\n      validated.format = colorConfig.format as 'hex' | 'rgb' | 'hsl';\n    }\n\n    ['showPreview', 'showAlpha', 'allowCustom'].forEach(key => {\n      if (typeof colorConfig[key] === 'boolean') {\n        (validated as any)[key] = colorConfig[key];\n      }\n    });\n\n    if (Array.isArray(colorConfig.presetColors)) {\n      validated.presetColors = colorConfig.presetColors.filter(color => typeof color === 'string');\n    }\n\n    return validated;\n  }\n\n  private static validateRatingConfig(config: unknown): ParsedFieldConfig['ratingConfig'] {\n    if (typeof config !== 'object' || !config) {\n      return undefined;\n    }\n\n    const ratingConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig['ratingConfig']> = {};\n\n    if (typeof ratingConfig.max === 'number') {\n      validated.max = ratingConfig.max;\n    }\n\n    ['allowHalf', 'allowClear', 'showValue'].forEach(key => {\n      if (typeof ratingConfig[key] === 'boolean') {\n        (validated as any)[key] = ratingConfig[key];\n      }\n    });\n\n    if (ratingConfig.icon && ['star', 'heart', 'thumbs'].includes(ratingConfig.icon as string)) {\n      validated.icon = ratingConfig.icon as 'star' | 'heart' | 'thumbs';\n    }\n\n    if (ratingConfig.size && ['sm', 'md', 'lg', 'small', 'medium', 'large'].includes(ratingConfig.size as string)) {\n      validated.size = ratingConfig.size as 'sm' | 'md' | 'lg' | 'small' | 'medium' | 'large';\n    }\n\n    return validated;\n  }\n\n  private static validatePhoneConfig(config: unknown): ParsedFieldConfig['phoneConfig'] {\n    if (typeof config !== 'object' || !config) {\n      return undefined;\n    }\n\n    const phoneConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig['phoneConfig']> = {};\n\n    if (phoneConfig.defaultCountry && typeof phoneConfig.defaultCountry === 'string') {\n      validated.defaultCountry = phoneConfig.defaultCountry;\n    }\n\n    ['preferredCountries', 'onlyCountries', 'excludeCountries'].forEach(key => {\n      if (Array.isArray(phoneConfig[key])) {\n        (validated as any)[key] = phoneConfig[key].filter((item: unknown) => typeof item === 'string');\n      }\n    });\n\n    if (phoneConfig.format && ['national', 'international'].includes(phoneConfig.format as string)) {\n      validated.format = phoneConfig.format as 'national' | 'international';\n    }\n\n    return validated;\n  }\n\n  private static validateDatalistConfig(config: unknown): ParsedFieldConfig['datalist'] {\n    if (typeof config !== 'object' || !config) {\n      return undefined;\n    }\n\n    const datalistConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig['datalist']> = {};\n\n    if (Array.isArray(datalistConfig.options)) {\n      validated.options = datalistConfig.options.filter(option => typeof option === 'string');\n    }\n\n    ['debounceMs', 'minChars', 'maxResults'].forEach(key => {\n      if (typeof datalistConfig[key] === 'number') {\n        (validated as any)[key] = datalistConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateOptions(options: unknown[]): Array<{ value: string; label: string }> {\n    return options\n      .filter(option => \n        typeof option === 'object' && \n        option !== null &&\n        typeof (option as any).value === 'string' &&\n        typeof (option as any).label === 'string'\n      )\n      .map(option => ({\n        value: (option as any).value,\n        label: (option as any).label\n      }));\n  }\n\n  private static validatePage(page: unknown, index: number): PageConfig {\n    if (typeof page !== 'object' || !page) {\n      return { page: index };\n    }\n\n    const pageObj = page as Record<string, unknown>;\n    const validated: PageConfig = {\n      page: typeof pageObj.page === 'number' ? pageObj.page : index\n    };\n\n    if (pageObj.title && typeof pageObj.title === 'string') {\n      validated.title = pageObj.title;\n    }\n\n    if (pageObj.description && typeof pageObj.description === 'string') {\n      validated.description = pageObj.description;\n    }\n\n    return validated;\n  }\n\n  // Phase 2: Enhanced Features\n\n  /**\n   * Parses form definition with schema inference capabilities\n   * @param code - The form definition code to parse\n   * @param options - Schema inference options\n   * @returns Parsing result with inferred schema information\n   */\n  static parseWithSchemaInference(code: string, options?: SchemaInferenceOptions): SchemaInferenceResult {\n    const config = this.parse(code);\n    \n    // Basic schema inference implementation\n    let confidence = 0.5; // Base confidence\n    let inferredSchema = null;\n\n    if (options?.enabled) {\n      try {\n        const schemaBuilder: Record<string, string> = {};\n        \n        for (const field of config.fields) {\n          const zodType = this.inferZodTypeFromField(field);\n          if (zodType) {\n            schemaBuilder[field.name] = zodType;\n            confidence += 0.1; // Increase confidence for each successful inference\n          }\n        }\n\n        // Create a basic schema representation\n        inferredSchema = {\n          type: 'object',\n          properties: schemaBuilder,\n          isInferred: true\n        };\n\n        confidence = Math.min(confidence, 1.0);\n      } catch (error) {\n        console.warn('Schema inference failed:', error);\n        confidence = 0.1;\n      }\n    }\n\n    return {\n      config,\n      inferredSchema,\n      confidence\n    };\n  }\n\n  /**\n   * Merges a parsed configuration with a base schema\n   * @param parsedConfig - The parsed form configuration\n   * @param baseSchema - Base schema to merge with\n   * @param strategy - Merge strategy to use\n   * @returns Enhanced form configuration\n   */\n  static mergeSchemas(\n    parsedConfig: ParsedFormConfig, \n    baseSchema: unknown,\n    strategy: 'extend' | 'override' | 'intersect' = 'extend'\n  ): ParsedFormConfig {\n    const merged = { ...parsedConfig };\n\n    if (!baseSchema || typeof baseSchema !== 'object') {\n      return merged;\n    }\n\n    try {\n      // Extract field information from base schema if it has properties\n      const baseSchemaObj = baseSchema as Record<string, unknown>;\n      \n      if (strategy === 'extend' && baseSchemaObj.properties) {\n        // Add missing fields from base schema\n        const existingFieldNames = new Set(merged.fields.map(f => f.name));\n        const baseProperties = baseSchemaObj.properties as Record<string, unknown>;\n        \n        for (const [fieldName, fieldSchema] of Object.entries(baseProperties)) {\n          if (!existingFieldNames.has(fieldName)) {\n            const inferredField = this.createFieldFromSchema(fieldName, fieldSchema);\n            if (inferredField) {\n              merged.fields.push(inferredField);\n            }\n          }\n        }\n      } else if (strategy === 'override') {\n        // Override existing schema completely\n        merged.schema = baseSchema;\n      } else if (strategy === 'intersect') {\n        // Keep only fields that exist in both\n        const baseProperties = (baseSchemaObj.properties as Record<string, unknown>) || {};\n        merged.fields = merged.fields.filter(field => \n          Object.prototype.hasOwnProperty.call(baseProperties, field.name)\n        );\n      }\n\n      // Update the schema property\n      if (strategy !== 'override') {\n        merged.schema = baseSchema;\n      }\n\n    } catch (error) {\n      console.warn('Schema merging failed:', error);\n    }\n\n    return merged;\n  }\n\n  /**\n   * Validates form definition code with AI-friendly error suggestions\n   * @param code - The form definition code to validate\n   * @returns Validation result with detailed errors and suggestions\n   */\n  static validateWithSuggestions(code: string): ValidationWithSuggestionsResult {\n    const errors: EnhancedParserError[] = [];\n    const suggestions: string[] = [];\n\n    try {\n      // Attempt to parse the code\n      this.parse(code);\n      return { isValid: true, errors: [], suggestions: [] };\n    } catch (error) {\n      let errorType: EnhancedParserError['type'] = 'syntax';\n      let message = 'Unknown parsing error';\n      let suggestion = '';\n      let examples: string[] = [];\n\n      if (error instanceof Error) {\n        message = error.message;\n        \n        // Analyze error types and provide specific suggestions\n        if (message.includes('Invalid syntax') || message.includes('JSON.parse')) {\n          errorType = 'syntax';\n          suggestion = 'Check for missing quotes around object keys or trailing commas';\n          examples = [\n            '{ \"name\": \"field1\", \"type\": \"text\" }',\n            '{ fields: [{ name: \"field1\", type: \"text\" }] }'\n          ];\n          suggestions.push('Use double quotes around object keys');\n          suggestions.push('Remove trailing commas before closing brackets');\n        } else if (message.includes('invalid type')) {\n          errorType = 'field_type';\n          suggestion = `Use one of the supported field types: ${this.ALLOWED_FIELD_TYPES.join(', ')}`;\n          examples = [\n            '{ name: \"email\", type: \"email\" }',\n            '{ name: \"age\", type: \"number\" }'\n          ];\n          suggestions.push('Check field type spelling');\n          suggestions.push('Refer to supported field types list');\n        } else if (message.includes('must have')) {\n          errorType = 'validation';\n          suggestion = 'Ensure all required properties are present';\n          examples = [\n            '{ name: \"required-field\", type: \"text\", label: \"Required Field\" }'\n          ];\n          suggestions.push('Add missing required properties: name, type');\n        } else if (message.includes('schema')) {\n          errorType = 'schema';\n          suggestion = 'Check Zod schema syntax and structure';\n          examples = [\n            'schema: z.object({ name: z.string(), email: z.string().email() })'\n          ];\n          suggestions.push('Verify Zod schema syntax');\n        }\n      }\n\n      errors.push({\n        type: errorType,\n        message,\n        suggestion,\n        examples,\n        location: this.extractErrorLocation(code, error)\n      });\n\n      // Add general suggestions\n      suggestions.push('Validate JSON syntax using a JSON validator');\n      suggestions.push('Check for balanced parentheses and brackets');\n      suggestions.push('Ensure all string values are properly quoted');\n\n      return { isValid: false, errors, suggestions };\n    }\n  }\n\n  /**\n   * Infers Zod type from a field configuration\n   * @private\n   */\n  private static inferZodTypeFromField(field: ParsedFieldConfig): string | null {\n    const typeMapping: Record<string, string> = {\n      'text': 'z.string()',\n      'email': 'z.string().email()',\n      'password': 'z.string().min(1)',\n      'url': 'z.string().url()',\n      'tel': 'z.string()',\n      'textarea': 'z.string()',\n      'number': 'z.number()',\n      'date': 'z.string().datetime()',\n      'checkbox': 'z.boolean()',\n      'switch': 'z.boolean()',\n      'select': 'z.string()',\n      'radio': 'z.string()',\n      'multiSelect': 'z.array(z.string())',\n      'file': 'z.instanceof(File)',\n      'slider': 'z.number()',\n      'rating': 'z.number()',\n      'phone': 'z.string()',\n      'colorPicker': 'z.string()',\n      'location': 'z.object({ lat: z.number(), lng: z.number() })',\n      'duration': 'z.number()',\n      'autocomplete': 'z.string()',\n      'masked': 'z.string()',\n      'array': 'z.array(z.unknown())',\n      'object': 'z.object({})'\n    };\n\n    let baseType = typeMapping[field.type];\n    if (!baseType) return null;\n\n    // Add validation constraints\n    if (field.type === 'text' || field.type === 'textarea') {\n      if (field.min && field.max) {\n        baseType = baseType.replace('z.string()', `z.string().min(${field.min}).max(${field.max})`);\n      } else if (field.min) {\n        baseType = baseType.replace('z.string()', `z.string().min(${field.min})`);\n      } else if (field.max) {\n        baseType = baseType.replace('z.string()', `z.string().max(${field.max})`);\n      }\n    }\n\n    if (field.type === 'number' || field.type === 'slider') {\n      if (field.min && field.max) {\n        baseType = baseType.replace('z.number()', `z.number().min(${field.min}).max(${field.max})`);\n      } else if (field.min) {\n        baseType = baseType.replace('z.number()', `z.number().min(${field.min})`);\n      } else if (field.max) {\n        baseType = baseType.replace('z.number()', `z.number().max(${field.max})`);\n      }\n    }\n\n    // Handle required/optional\n    if (field.required === false) {\n      baseType += '.optional()';\n    }\n\n    return baseType;\n  }\n\n  /**\n   * Creates a field configuration from a schema definition\n   * @private\n   */\n  private static createFieldFromSchema(name: string, schema: unknown): ParsedFieldConfig | null {\n    // Basic implementation - would need more sophisticated schema analysis\n    try {\n      const schemaObj = schema as Record<string, unknown>;\n      let type = 'text'; // default\n\n      // Very basic type inference from schema structure\n      if (schemaObj.type === 'string') {\n        type = 'text';\n      } else if (schemaObj.type === 'number') {\n        type = 'number';\n      } else if (schemaObj.type === 'boolean') {\n        type = 'checkbox';\n      }\n\n      return {\n        name,\n        type,\n        label: name.charAt(0).toUpperCase() + name.slice(1).replace(/([A-Z])/g, ' $1')\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Extracts error location information from parsing error\n   * @private\n   */\n  private static extractErrorLocation(code: string, error: unknown): EnhancedParserError['location'] | undefined {\n    try {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      // Try to extract line/column info from JSON parse errors\n      const positionMatch = errorMessage.match(/at position (\\d+)/i);\n      if (positionMatch) {\n        const position = parseInt(positionMatch[1], 10);\n        const lines = code.substring(0, position).split('\\n');\n        return {\n          line: lines.length,\n          column: lines[lines.length - 1].length + 1\n        };\n      }\n\n      // Try to extract field information from validation errors\n      const fieldMatch = errorMessage.match(/field at index (\\d+)/i);\n      if (fieldMatch) {\n        return {\n          field: `field[${fieldMatch[1]}]`\n        };\n      }\n\n    } catch {\n      // Ignore extraction errors\n    }\n\n    return undefined;\n  }\n}",
      "type": "registry:component",
      "target": "components/formedible/parser/formedible-parser.tsx"
    },
    {
      "path": "src/components/formedible/parser/types.ts",
      "content": "\"use client\";\n\n// Core types that replicate the essential parts of formedible types for standalone usage\nexport interface FieldOption {\n  value: string;\n  label: string;\n  disabled?: boolean;\n  description?: string;\n}\n\nexport type FieldOptions = string[] | FieldOption[];\n\nexport interface ObjectConfig {\n  title?: string;\n  description?: string;\n  fields: Array<{\n    name: string;\n    type: string;\n    label?: string;\n    placeholder?: string;\n    description?: string;\n    options?: string[] | Array<{ value: string; label: string }>;\n    min?: number;\n    max?: number;\n    step?: number;\n    [key: string]: unknown;\n  }>;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n  showCard?: boolean;\n  layout?: \"grid\" | \"vertical\" | \"horizontal\" | (string & {});\n  columns?: number;\n  collapseLabel?: string;\n  expandLabel?: string;\n}\n\nexport interface ParsedFieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  description?: string;\n  required?: boolean;\n  defaultValue?: unknown;\n  options?: Array<{ value: string; label: string }>;\n  min?: number;\n  max?: number;\n  step?: number;\n  validation?: unknown;\n  \n  // Field-specific configurations\n  arrayConfig?: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    objectConfig?: ObjectConfig;\n    [key: string]: unknown;\n  };\n  \n  objectConfig?: ObjectConfig;\n  \n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n    [key: string]: unknown;\n  };\n  \n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showPreview?: boolean;\n    showAlpha?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n    [key: string]: unknown;\n  };\n  \n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    allowClear?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs' | unknown;\n    size?: 'sm' | 'md' | 'lg' | 'small' | 'medium' | 'large';\n    showValue?: boolean;\n    [key: string]: unknown;\n  };\n  \n  phoneConfig?: {\n    defaultCountry?: string;\n    preferredCountries?: string[];\n    onlyCountries?: string[];\n    excludeCountries?: string[];\n    format?: 'national' | 'international';\n    [key: string]: unknown;\n  };\n  \n  datalist?: {\n    options?: string[];\n    asyncOptions?: unknown;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n    [key: string]: unknown;\n  };\n  \n  // Allow additional unknown configurations\n  [key: string]: unknown;\n}\n\nexport interface PageConfig {\n  page: number;\n  title?: string;\n  description?: string;\n  component?: unknown;\n  conditional?: unknown;\n}\n\nexport interface ProgressConfig {\n  component?: unknown;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n  className?: string;\n}\n\nexport interface ParsedFormConfig {\n  schema?: unknown;\n  fields: ParsedFieldConfig[];\n  pages?: PageConfig[];\n  title?: string;\n  description?: string;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  progress?: ProgressConfig;\n  formOptions?: {\n    defaultValues?: Record<string, unknown>;\n    onSubmit?: (data: { value: Record<string, unknown> }) => void | Promise<void>;\n    [key: string]: unknown;\n  };\n}\n\nexport interface ParserOptions {\n  strictValidation?: boolean;\n}\n\nexport interface ParserError extends Error {\n  code?: string;\n  field?: string;\n  line?: number;\n  column?: number;\n}\n\n// Phase 2: Enhanced Parser Types\n\n/**\n * Enhanced parser options for Phase 2 features\n */\nexport interface EnhancedParserOptions extends ParserOptions {\n  baseSchema?: unknown; // z.ZodSchema in actual usage\n  mergeStrategy?: 'extend' | 'override' | 'intersect';\n  predefinedHandlers?: {\n    onSubmit?: (data: unknown) => void;\n    specificFields?: Record<string, ParsedFieldConfig>;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Enhanced error type with AI-friendly suggestions\n */\nexport interface EnhancedParserError {\n  type: 'syntax' | 'validation' | 'field_type' | 'schema';\n  message: string;\n  suggestion?: string;\n  location?: {\n    line?: number;\n    column?: number;\n    field?: string;\n  };\n  examples?: string[];\n}\n\n/**\n * Schema inference configuration options\n */\nexport interface SchemaInferenceOptions {\n  enabled?: boolean;\n  fieldTypeMapping?: Record<string, unknown>; // z.ZodType in actual usage\n  defaultValidation?: boolean;\n  inferFromValues?: boolean;\n}\n\n/**\n * Result of schema inference parsing\n */\nexport interface SchemaInferenceResult {\n  config: ParsedFormConfig;\n  inferredSchema: unknown; // z.ZodSchema in actual usage\n  confidence: number;\n}\n\n/**\n * Result of validation with suggestions\n */\nexport interface ValidationWithSuggestionsResult {\n  isValid: boolean;\n  errors: EnhancedParserError[];\n  suggestions: string[];\n}",
      "type": "registry:lib",
      "target": "components/formedible/parser/types.ts"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}