{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "formedible-parser",
  "type": "registry:block",
  "title": "Formedible Parser",
  "description": "Safe parser for Formedible form definitions - handles JSON, JavaScript object literals, and Zod schema expressions",
  "dependencies": [
    "react",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "textarea",
    "label",
    "card"
  ],
  "files": [
    {
      "path": "src/lib/formedible/formedible-parser.ts",
      "content": "\"use client\";\n\nimport type {\n  ParsedFieldConfig,\n  ParsedFormConfig,\n  ParserOptions,\n  ObjectConfig,\n  ParserError,\n  PageConfig,\n  EnhancedParserOptions,\n  EnhancedParserError,\n  SchemaInferenceOptions,\n  SchemaInferenceResult,\n  ValidationWithSuggestionsResult,\n} from \"./parser-types\";\n\n/**\n * FormedibleParser - A safe parser for Formedible form definitions\n *\n * This parser can handle:\n * - Pure JSON format\n * - JavaScript object literals (unquoted keys)\n * - Zod schema expressions (z.string(), z.number(), etc.)\n * - Nested and chained Zod validations (z.string().min(1).max(50))\n *\n * Features:\n * - Sanitizes dangerous code patterns\n * - Validates field types and structure\n * - Removes unknown/dangerous keys\n * - Handles balanced parentheses in Zod expressions\n * - Supports all 24 field types\n * - 100% backward compatibility with existing parser\n *\n * Usage:\n *   const parsed = FormedibleParser.parse(codeString);\n *\n * @version 2.0.0\n * @standalone-ready This class is designed as a standalone package\n */\nexport class FormedibleParser {\n  // All 24 supported field types in formedible\n  private static readonly ALLOWED_FIELD_TYPES = [\n    \"text\",\n    \"email\",\n    \"password\",\n    \"url\",\n    \"tel\",\n    \"textarea\",\n    \"select\",\n    \"checkbox\",\n    \"switch\",\n    \"number\",\n    \"date\",\n    \"slider\",\n    \"file\",\n    \"rating\",\n    \"phone\",\n    \"colorPicker\",\n    \"location\",\n    \"duration\",\n    \"multiSelect\",\n    \"autocomplete\",\n    \"masked\",\n    \"object\",\n    \"array\",\n    \"radio\",\n  ] as const;\n\n  // Allowed top-level keys in form definitions\n  private static readonly ALLOWED_KEYS = [\n    \"schema\",\n    \"fields\",\n    \"pages\",\n    \"progress\",\n    \"submitLabel\",\n    \"nextLabel\",\n    \"previousLabel\",\n    \"formClassName\",\n    \"fieldClassName\",\n    \"formOptions\",\n    \"title\",\n    \"description\",\n  ] as const;\n\n  // Configuration for parser behavior\n  private static CONFIG = {\n    ZOD_PLACEHOLDER: \"__ZOD_SCHEMA__\",\n    MAX_RECURSION_DEPTH: 10,\n    ENABLE_STRICT_VALIDATION: true,\n    MAX_CODE_LENGTH: 1000000, // 1MB limit\n    MAX_NESTING_DEPTH: 50,\n  };\n\n  /**\n   * Main parser method - parses formedible form definition code\n   * @param code - The form definition code (JSON or JS object literal)\n   * @param options - Optional parsing configuration\n   * @returns Parsed and validated form definition\n   * @throws {ParserError} When parsing fails with detailed error information\n   */\n  static parse(\n    code: string,\n    options?: ParserOptions | EnhancedParserOptions\n  ): ParsedFormConfig {\n    if (!code || typeof code !== \"string\") {\n      throw this.createParserError(\n        \"Input code must be a non-empty string\",\n        \"INVALID_INPUT\"\n      );\n    }\n\n    if (code.length > this.CONFIG.MAX_CODE_LENGTH) {\n      throw this.createParserError(\n        `Code length exceeds maximum allowed size of ${this.CONFIG.MAX_CODE_LENGTH} characters`,\n        \"CODE_TOO_LARGE\"\n      );\n    }\n\n    try {\n      // Apply configuration overrides\n      if (options?.strictValidation !== undefined) {\n        this.CONFIG.ENABLE_STRICT_VALIDATION = options.strictValidation;\n      }\n\n      // Remove any potential function calls or dangerous patterns\n      const sanitizedCode = this.sanitizeCode(code);\n\n      // Parse the JSON-like structure\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n\n      // Validate and sanitize the parsed object\n      return this.validateAndSanitize(parsed);\n    } catch (error) {\n      if (error instanceof Error && error.name === \"ParserError\") {\n        throw error;\n      }\n\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      throw this.createParserError(\n        `Failed to parse form definition. ${errorMessage}`,\n        \"PARSE_ERROR\",\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Validates if a field type is supported\n   * @param type - The field type to validate\n   * @returns True if the field type is valid\n   */\n  static isValidFieldType(type: string): boolean {\n    return this.ALLOWED_FIELD_TYPES.includes(type as any);\n  }\n\n  /**\n   * Gets all supported field types\n   * @returns Array of supported field types\n   */\n  static getSupportedFieldTypes(): readonly string[] {\n    return [...this.ALLOWED_FIELD_TYPES];\n  }\n\n  /**\n   * Validates a form configuration without parsing code\n   * @param config - The form configuration to validate\n   * @returns Validation result with errors if any\n   */\n  static validateConfig(config: unknown): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    try {\n      this.validateAndSanitize(config as Record<string, unknown>);\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  }\n\n  /**\n   * Creates a standardized parser error with additional metadata and AI-friendly suggestions\n   * @private\n   */\n  private static createParserError(\n    message: string,\n    code: string,\n    metadata?: Record<string, unknown>\n  ): ParserError {\n    // Enhance error message with helpful context and suggestions\n    let enhancedMessage = message;\n    \n    switch (code) {\n      case \"INVALID_INPUT\":\n        enhancedMessage = `‚ùå Invalid Input: ${message}\n\nüîß How to fix:\n‚Ä¢ Provide a non-empty string containing your form definition\n‚Ä¢ Make sure you're passing the form code as a string, not an object\n\nüìù Example:\nconst formCode = \\`{\n  fields: [\n    { name: \"email\", type: \"email\", label: \"Email Address\" }\n  ]\n}\\`;\nconst parsed = FormedibleParser.parse(formCode);`;\n        break;\n        \n      case \"CODE_TOO_LARGE\":\n        enhancedMessage = `‚ùå Code Too Large: ${message}\n\nüîß How to fix:\n‚Ä¢ Reduce the size of your form definition\n‚Ä¢ Split large forms into multiple smaller forms\n‚Ä¢ Remove unnecessary comments or whitespace\n\nüí° Tips:\n‚Ä¢ Consider using arrays for repetitive field configurations\n‚Ä¢ Use object field types to group related fields`;\n        break;\n        \n      case \"SYNTAX_ERROR\":\n        enhancedMessage = `‚ùå Syntax Error: ${message}\n\nüîß Common fixes:\n‚Ä¢ Use double quotes around object keys: { \"name\": \"value\" }\n‚Ä¢ Remove trailing commas: [item1, item2] not [item1, item2,]\n‚Ä¢ Check for balanced brackets and parentheses\n‚Ä¢ Escape quotes in strings: \"It's working\" ‚Üí \"It\\\\'s working\"\n\nüìù Valid formats:\nJSON: { \"fields\": [{ \"name\": \"email\", \"type\": \"email\" }] }\nJS Object: { fields: [{ name: \"email\", type: \"email\" }] }`;\n        break;\n        \n      case \"INVALID_DEFINITION\":\n        enhancedMessage = `‚ùå Invalid Definition: ${message}\n\nüîß How to fix:\n‚Ä¢ Ensure your form definition is a JavaScript object or valid JSON\n‚Ä¢ Must contain at least a 'fields' array\n\nüìù Minimum required structure:\n{\n  fields: [\n    { name: \"fieldName\", type: \"text\" }\n  ]\n}`;\n        break;\n        \n      case \"INVALID_FIELDS\":\n        enhancedMessage = `‚ùå Invalid Fields: ${message}\n\nüîß How to fix:\n‚Ä¢ The 'fields' property must be an array\n‚Ä¢ Each field must be an object with 'name' and 'type' properties\n\nüìù Example:\n{\n  fields: [\n    { name: \"firstName\", type: \"text\", label: \"First Name\" },\n    { name: \"email\", type: \"email\", label: \"Email Address\" }\n  ]\n}`;\n        break;\n        \n      case \"INVALID_FIELD\":\n        const fieldIndex = metadata?.fieldIndex;\n        enhancedMessage = `‚ùå Invalid Field${fieldIndex !== undefined ? ` at position ${fieldIndex}` : ''}: ${message}\n\nüîß How to fix:\n‚Ä¢ Each field must be an object, not a string or number\n‚Ä¢ Check that field #${fieldIndex || 0} is properly formatted\n\nüìù Field structure:\n{\n  name: \"fieldName\",     // Required: unique field identifier\n  type: \"text\",          // Required: field type\n  label: \"Display Name\", // Optional: user-friendly label\n  required: true         // Optional: validation\n}`;\n        break;\n        \n      case \"MISSING_REQUIRED_FIELD\":\n        const missingFieldIndex = metadata?.fieldIndex;\n        enhancedMessage = `‚ùå Missing Required Properties${missingFieldIndex !== undefined ? ` in field #${missingFieldIndex}` : ''}: ${message}\n\nüîß How to fix:\n‚Ä¢ Every field MUST have both 'name' and 'type' properties\n‚Ä¢ The 'name' should be a unique identifier for the field\n‚Ä¢ The 'type' should be one of the supported field types\n\nüìù Fix field #${missingFieldIndex || 0}:\n{\n  name: \"uniqueFieldName\",  // ‚úÖ Required\n  type: \"text\",             // ‚úÖ Required  \n  label: \"Display Label\"    // ‚úÖ Recommended\n}`;\n        break;\n        \n      case \"UNSUPPORTED_FIELD_TYPE\":\n        const fieldType = metadata?.fieldType;\n        const supportedTypes = this.ALLOWED_FIELD_TYPES.join(', ');\n        enhancedMessage = `‚ùå Unsupported Field Type: ${message}\n\nüîß How to fix:\n‚Ä¢ Change field type from \"${fieldType}\" to one of the supported types\n‚Ä¢ Check for typos in the field type name\n\n‚úÖ Supported field types:\n${supportedTypes}\n\nüìù Common field types:\n‚Ä¢ \"text\" - Single line text input\n‚Ä¢ \"email\" - Email address with validation  \n‚Ä¢ \"number\" - Numeric input with validation\n‚Ä¢ \"select\" - Dropdown selection\n‚Ä¢ \"checkbox\" - Boolean checkbox\n‚Ä¢ \"date\" - Date picker\n‚Ä¢ \"textarea\" - Multi-line text area`;\n        break;\n        \n      case \"INVALID_ARRAY_CONFIG\":\n        enhancedMessage = `‚ùå Invalid Array Configuration: ${message}\n\nüîß How to fix:\n‚Ä¢ Array field configuration must be an object\n‚Ä¢ Provide arrayConfig with proper structure\n\nüìù Example array field:\n{\n  name: \"items\",\n  type: \"array\",\n  arrayConfig: {\n    itemType: \"text\",           // Type of each array item\n    itemLabel: \"Item\",          // Label for each item\n    minItems: 1,               // Minimum number of items\n    maxItems: 10,              // Maximum number of items\n    addButtonLabel: \"Add Item\" // Custom add button text\n  }\n}`;\n        break;\n        \n      case \"INVALID_OBJECT_CONFIG\":\n        enhancedMessage = `‚ùå Invalid Object Configuration: ${message}\n\nüîß How to fix:\n‚Ä¢ Object field configuration must be an object\n‚Ä¢ Provide objectConfig with fields array\n\nüìù Example object field:\n{\n  name: \"address\",\n  type: \"object\",\n  objectConfig: {\n    title: \"Address Information\",\n    fields: [\n      { name: \"street\", type: \"text\", label: \"Street\" },\n      { name: \"city\", type: \"text\", label: \"City\" }\n    ]\n  }\n}`;\n        break;\n        \n      case \"PARSE_ERROR\":\n        enhancedMessage = `‚ùå Parsing Failed: ${message}\n\nüîß Common causes and fixes:\n‚Ä¢ **Syntax Issues**: Check for missing quotes, brackets, or commas\n‚Ä¢ **Invalid JavaScript**: Ensure object literal syntax is correct\n‚Ä¢ **Zod Expressions**: Make sure Zod schemas are properly formatted\n\nüìù Debugging steps:\n1. Validate your JSON syntax using an online JSON validator\n2. Check that all object keys are quoted: { \"name\": \"value\" }\n3. Remove trailing commas: [item1, item2] not [item1, item2,]\n4. Verify Zod expressions: z.string().min(1) not z.string.min(1)\n\nüí° Example working format:\n{\n  fields: [\n    {\n      name: \"email\",\n      type: \"email\", \n      label: \"Email Address\",\n      validation: \"z.string().email()\"\n    }\n  ],\n  schema: \"z.object({ email: z.string().email() })\"\n}`;\n        break;\n        \n      default:\n        enhancedMessage = `‚ùå Parser Error: ${message}\n\nüîß General troubleshooting:\n‚Ä¢ Check JSON/JavaScript syntax\n‚Ä¢ Verify all required properties are present\n‚Ä¢ Ensure field types are supported\n‚Ä¢ Check for typos in property names\n\nüí° Need help? Provide the exact form code that's causing issues for specific assistance.`;\n    }\n    \n    const error = new Error(enhancedMessage) as ParserError;\n    error.name = \"ParserError\";\n    error.code = code;\n\n    if (metadata) {\n      Object.assign(error, metadata);\n    }\n\n    return error;\n  }\n\n  /**\n   * Enhanced code sanitization with better security measures\n   * @private\n   */\n  private static sanitizeCode(code: string): string {\n    // Remove comments first\n    let sanitized = code\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Block comments\n      .replace(/\\/\\/.*$/gm, \"\"); // Line comments\n\n    // Remove dangerous patterns more aggressively\n    const dangerousPatterns = [\n      /\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g,\n      /\\b(document|window|global|process)\\b/g,\n      /\\b__proto__\\b/g,\n      /\\bconstructor\\b/g,\n      /\\bprototype\\b/g,\n    ];\n\n    dangerousPatterns.forEach((pattern) => {\n      sanitized = sanitized.replace(pattern, '\"\"');\n    });\n\n    // Remove any arrow functions or function expressions more thoroughly\n    sanitized = sanitized.replace(/=>\\s*[\\{]?[^}]*[\\}]?/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n\n    // Handle Date objects more safely\n    sanitized = sanitized.replace(\n      /new\\s+Date\\(\\)\\.toISOString\\(\\)\\.split\\('[^']*'\\)\\[0\\]/g,\n      '\"2024-01-01\"'\n    );\n    sanitized = sanitized.replace(/new\\s+Date\\(\\)/g, '\"2024-01-01T00:00:00Z\"');\n\n    // Remove any remaining 'new' keyword usage\n    sanitized = sanitized.replace(/\\bnew\\s+\\w+\\(/g, '\"\"');\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced object literal parsing with better error handling\n   * @private\n   */\n  private static parseObjectLiteral(code: string): Record<string, unknown> {\n    try {\n      // First try direct JSON parsing\n      return JSON.parse(code);\n    } catch (jsonError) {\n      // If that fails, try to convert JS object literal to JSON\n      let processedCode = code.trim();\n\n      try {\n        // Replace Zod expressions with placeholder strings - handle nested structures\n        processedCode = this.replaceZodExpressions(processedCode);\n\n        // Convert unquoted keys to quoted keys with better regex\n        processedCode = processedCode.replace(\n          /([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g,\n          '$1\"$2\":'\n        );\n\n        // Remove trailing commas more thoroughly\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n        // Convert single quotes to double quotes (but preserve escaped quotes)\n        processedCode = processedCode.replace(/(?<!\\\\)'/g, '\"');\n\n        // Handle undefined values\n        processedCode = processedCode.replace(/:\\s*undefined/g, \": null\");\n\n        const result = JSON.parse(processedCode);\n        return result;\n      } catch (conversionError) {\n        // Enhanced error reporting\n        const originalPreview =\n          code.substring(0, 200) + (code.length > 200 ? \"...\" : \"\");\n        const processedPreview =\n          processedCode.substring(0, 200) +\n          (processedCode.length > 200 ? \"...\" : \"\");\n\n        throw this.createParserError(\n          `Invalid syntax. Please use valid JSON format or JavaScript object literal syntax.`,\n          \"SYNTAX_ERROR\",\n          {\n            originalCode: originalPreview,\n            processedCode: processedPreview,\n            jsonError:\n              jsonError instanceof Error\n                ? jsonError.message\n                : String(jsonError),\n            conversionError:\n              conversionError instanceof Error\n                ? conversionError.message\n                : String(conversionError),\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Enhanced Zod expression replacement with better handling of complex expressions\n   * @private\n   */\n  private static replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 100; // Prevent infinite loops\n\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      // Match z.method( and find the matching closing parenthesis\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        // Find the matching closing parenthesis with better depth tracking\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n        let stringChar: string | null = null;\n        let escaped = false;\n\n        while (endIndex < result.length && depth > 0) {\n          const char = result[endIndex];\n\n          // Handle string literals to avoid counting parentheses inside strings\n          if (!escaped && (char === '\"' || char === \"'\")) {\n            if (!stringChar) {\n              stringChar = char;\n            } else if (stringChar === char) {\n              stringChar = null;\n            }\n          } else if (!stringChar) {\n            if (char === \"(\") {\n              depth++;\n            } else if (char === \")\") {\n              depth--;\n            }\n          }\n\n          escaped = char === \"\\\\\" && !escaped;\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          // Check for chained methods like .min().max()\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              // Find the closing parenthesis for this chained method\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n              let chainStringChar: string | null = null;\n              let chainEscaped = false;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                const char = result[chainEndIndex];\n\n                if (!chainEscaped && (char === '\"' || char === \"'\")) {\n                  if (!chainStringChar) {\n                    chainStringChar = char;\n                  } else if (chainStringChar === char) {\n                    chainStringChar = null;\n                  }\n                } else if (!chainStringChar) {\n                  if (char === \"(\") {\n                    chainDepth++;\n                  } else if (char === \")\") {\n                    chainDepth--;\n                  }\n                }\n\n                chainEscaped = char === \"\\\\\" && !chainEscaped;\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          // Replace the entire Zod expression with a placeholder\n          result =\n            result.slice(0, startIndex) +\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"` +\n            result.slice(chainEnd);\n          changed = true;\n        } else {\n          // If we can't find matching parentheses, just replace the method name\n          result = result.replace(\n            /z\\.[a-zA-Z]+/,\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n          );\n          changed = true;\n        }\n      }\n    }\n\n    // Handle standalone z.enum() calls and other complex patterns\n    result = result.replace(\n      /z\\.enum\\(\\[[^\\]]*\\]\\)/g,\n      `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n    );\n    result = result.replace(/z\\.\\w+/g, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n\n    return result;\n  }\n\n  /**\n   * Enhanced validation and sanitization with comprehensive field type support\n   * @private\n   */\n  private static validateAndSanitize(\n    obj: Record<string, unknown>\n  ): ParsedFormConfig {\n    if (typeof obj !== \"object\" || obj === null) {\n      throw this.createParserError(\n        \"Definition must be an object\",\n        \"INVALID_DEFINITION\"\n      );\n    }\n\n    const sanitized: ParsedFormConfig = {\n      fields: [],\n    };\n\n    // Validate top-level keys\n    for (const [key, value] of Object.entries(obj)) {\n      if (!this.ALLOWED_KEYS.includes(key as any)) {\n        if (this.CONFIG.ENABLE_STRICT_VALIDATION) {\n          console.warn(\n            `Unknown key '${key}' found in form definition, skipping`\n          );\n        }\n        continue; // Skip unknown keys\n      }\n\n      switch (key) {\n        case \"schema\":\n          // Pass through the schema - it's needed for validation\n          sanitized.schema = value;\n          break;\n\n        case \"fields\":\n          if (!Array.isArray(value)) {\n            throw this.createParserError(\n              \"Fields must be an array\",\n              \"INVALID_FIELDS\"\n            );\n          }\n          sanitized.fields = this.validateFields(value);\n          break;\n\n        case \"pages\":\n          if (Array.isArray(value)) {\n            sanitized.pages = value.map((page, index) =>\n              this.validatePage(page, index)\n            );\n          }\n          break;\n\n        case \"title\":\n          if (typeof value === \"string\") {\n            sanitized.title = value;\n          }\n          break;\n\n        case \"description\":\n          if (typeof value === \"string\") {\n            sanitized.description = value;\n          }\n          break;\n\n        case \"submitLabel\":\n          if (typeof value === \"string\") {\n            sanitized.submitLabel = value;\n          }\n          break;\n\n        case \"nextLabel\":\n          if (typeof value === \"string\") {\n            sanitized.nextLabel = value;\n          }\n          break;\n\n        case \"previousLabel\":\n          if (typeof value === \"string\") {\n            sanitized.previousLabel = value;\n          }\n          break;\n\n        case \"formClassName\":\n          if (typeof value === \"string\") {\n            sanitized.formClassName = value;\n          }\n          break;\n\n        case \"fieldClassName\":\n          if (typeof value === \"string\") {\n            sanitized.fieldClassName = value;\n          }\n          break;\n\n        case \"progress\":\n          if (value && typeof value === \"object\") {\n            sanitized.progress = value as ParsedFormConfig[\"progress\"];\n          }\n          break;\n\n        case \"formOptions\":\n          if (value && typeof value === \"object\") {\n            sanitized.formOptions = value as ParsedFormConfig[\"formOptions\"];\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced field validation with support for all 24 field types\n   * @private\n   */\n  private static validateFields(fields: unknown[]): ParsedFieldConfig[] {\n    return fields.map((field, index): ParsedFieldConfig => {\n      if (typeof field !== \"object\" || field === null) {\n        throw this.createParserError(\n          `Field at index ${index} must be an object`,\n          \"INVALID_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      const fieldObj = field as Record<string, unknown>;\n\n      // Ensure required fields\n      if (!fieldObj.name || !fieldObj.type) {\n        throw this.createParserError(\n          `Field at index ${index} must have 'name' and 'type' properties`,\n          \"MISSING_REQUIRED_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (\n        typeof fieldObj.name !== \"string\" ||\n        typeof fieldObj.type !== \"string\"\n      ) {\n        throw this.createParserError(\n          `Field at index ${index} must have string 'name' and 'type' properties`,\n          \"INVALID_FIELD_TYPE\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (!this.ALLOWED_FIELD_TYPES.includes(fieldObj.type as any)) {\n        throw this.createParserError(\n          `Field at index ${index} has invalid type '${\n            fieldObj.type\n          }'. Supported types: ${this.ALLOWED_FIELD_TYPES.join(\", \")}`,\n          \"UNSUPPORTED_FIELD_TYPE\",\n          { fieldIndex: index, fieldType: fieldObj.type }\n        );\n      }\n\n      // Build properly typed field config\n      const validatedField: ParsedFieldConfig = {\n        name: fieldObj.name,\n        type: fieldObj.type,\n      };\n\n      // Add optional properties with proper type checks\n      this.addOptionalStringProperty(validatedField, fieldObj, \"label\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"placeholder\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"description\");\n\n      if (typeof fieldObj.required === \"boolean\") {\n        validatedField.required = fieldObj.required;\n      }\n\n      if (fieldObj.defaultValue !== undefined) {\n        validatedField.defaultValue = fieldObj.defaultValue;\n      }\n\n      // Numeric properties\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"min\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"max\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"step\");\n\n      // Handle complex configurations for different field types\n      this.addFieldSpecificConfigurations(validatedField, fieldObj, index);\n\n      // Handle options array\n      if (fieldObj.options && Array.isArray(fieldObj.options)) {\n        validatedField.options = this.validateOptions(fieldObj.options);\n      }\n\n      // Skip validation assignment - let it remain undefined to avoid type conflicts\n\n      return validatedField;\n    });\n  }\n\n  /**\n   * Adds field-specific configurations based on field type\n   * @private\n   */\n  private static addFieldSpecificConfigurations(\n    validatedField: ParsedFieldConfig,\n    fieldObj: Record<string, unknown>,\n    index: number\n  ): void {\n    const fieldType = validatedField.type;\n\n    // Array field configuration\n    if (fieldType === \"array\" && fieldObj.arrayConfig) {\n      validatedField.arrayConfig = this.validateArrayConfig(\n        fieldObj.arrayConfig,\n        index\n      );\n    }\n\n    // Object field configuration\n    if (fieldType === \"object\" && fieldObj.objectConfig) {\n      validatedField.objectConfig = this.validateObjectConfig(\n        fieldObj.objectConfig,\n        index\n      );\n    }\n\n    // Multi-select configuration\n    if (fieldType === \"multiSelect\" && fieldObj.multiSelectConfig) {\n      validatedField.multiSelectConfig = this.validateMultiSelectConfig(\n        fieldObj.multiSelectConfig\n      );\n    }\n\n    // Color picker configuration\n    if (fieldType === \"colorPicker\" && fieldObj.colorConfig) {\n      validatedField.colorConfig = this.validateColorConfig(\n        fieldObj.colorConfig\n      );\n    }\n\n    // Rating configuration\n    if (fieldType === \"rating\" && fieldObj.ratingConfig) {\n      validatedField.ratingConfig = this.validateRatingConfig(\n        fieldObj.ratingConfig\n      );\n    }\n\n    // Phone configuration\n    if (fieldType === \"phone\" && fieldObj.phoneConfig) {\n      validatedField.phoneConfig = this.validatePhoneConfig(\n        fieldObj.phoneConfig\n      );\n    }\n\n    // Datalist configuration\n    if (fieldObj.datalist) {\n      validatedField.datalist = this.validateDatalistConfig(fieldObj.datalist);\n    }\n\n    // Pass through other configurations with validation\n    const configKeys = [\n      \"sliderConfig\",\n      \"fileConfig\",\n      \"locationConfig\",\n      \"durationConfig\",\n      \"autocompleteConfig\",\n      \"maskedConfig\",\n      \"dateConfig\",\n      \"textareaConfig\",\n      \"passwordConfig\",\n      \"emailConfig\",\n      \"numberConfig\",\n    ];\n\n    configKeys.forEach((configKey) => {\n      if (fieldObj[configKey] && typeof fieldObj[configKey] === \"object\") {\n        (validatedField as any)[configKey] = fieldObj[configKey];\n      }\n    });\n  }\n\n  /**\n   * Helper methods for adding optional properties\n   * @private\n   */\n  private static addOptionalStringProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (source[key] && typeof source[key] === \"string\") {\n      target[key] = source[key];\n    }\n  }\n\n  private static addOptionalNumberProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (typeof source[key] === \"number\") {\n      target[key] = source[key];\n    }\n  }\n\n  /**\n   * Configuration validators\n   * @private\n   */\n  private static validateArrayConfig(\n    config: unknown,\n    fieldIndex: number\n  ): ParsedFieldConfig[\"arrayConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Array config at field index ${fieldIndex} must be an object`,\n        \"INVALID_ARRAY_CONFIG\"\n      );\n    }\n\n    const arrayConfig = config as Record<string, unknown>;\n    const validated: ParsedFieldConfig[\"arrayConfig\"] = {\n      itemType: \"text\",\n    };\n\n    if (arrayConfig.itemType && typeof arrayConfig.itemType === \"string\") {\n      validated.itemType = arrayConfig.itemType;\n    }\n\n    // Add other array config properties\n    [\n      \"itemLabel\",\n      \"itemPlaceholder\",\n      \"addButtonLabel\",\n      \"removeButtonLabel\",\n    ].forEach((key) => {\n      if (arrayConfig[key] && typeof arrayConfig[key] === \"string\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    [\"minItems\", \"maxItems\"].forEach((key) => {\n      if (typeof arrayConfig[key] === \"number\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    if (typeof arrayConfig.sortable === \"boolean\") {\n      validated.sortable = arrayConfig.sortable;\n    }\n\n    if (arrayConfig.objectConfig) {\n      validated.objectConfig = this.validateObjectConfig(\n        arrayConfig.objectConfig,\n        fieldIndex\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateObjectConfig(\n    config: unknown,\n    fieldIndex: number\n  ): ObjectConfig {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Object config at field index ${fieldIndex} must be an object`,\n        \"INVALID_OBJECT_CONFIG\"\n      );\n    }\n\n    const objectConfig = config as Record<string, unknown>;\n    const validated: ObjectConfig = {\n      fields: [],\n    };\n\n    if (objectConfig.fields && Array.isArray(objectConfig.fields)) {\n      validated.fields = objectConfig.fields.map((field) => {\n        if (typeof field !== \"object\" || !field) {\n          return { name: \"\", type: \"text\" };\n        }\n        const f = field as Record<string, unknown>;\n        const validatedField: ObjectConfig[\"fields\"][0] = {\n          name: typeof f.name === \"string\" ? f.name : \"\",\n          type: typeof f.type === \"string\" ? f.type : \"text\",\n        };\n\n        if (typeof f.label === \"string\") validatedField.label = f.label;\n        if (typeof f.placeholder === \"string\")\n          validatedField.placeholder = f.placeholder;\n        if (typeof f.description === \"string\")\n          validatedField.description = f.description;\n        if (typeof f.min === \"number\") validatedField.min = f.min;\n        if (typeof f.max === \"number\") validatedField.max = f.max;\n        if (typeof f.step === \"number\") validatedField.step = f.step;\n\n        if (\n          f.options &&\n          (Array.isArray(f.options) || typeof f.options === \"function\")\n        ) {\n          validatedField.options =\n            f.options as ObjectConfig[\"fields\"][0][\"options\"];\n        }\n\n        return validatedField;\n      });\n    }\n\n    // Add other object config properties\n    [\"title\", \"description\", \"collapseLabel\", \"expandLabel\"].forEach((key) => {\n      if (objectConfig[key] && typeof objectConfig[key] === \"string\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    [\"collapsible\", \"defaultExpanded\", \"showCard\"].forEach((key) => {\n      if (typeof objectConfig[key] === \"boolean\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    if (\n      objectConfig.layout &&\n      [\"vertical\", \"horizontal\", \"grid\"].includes(objectConfig.layout as string)\n    ) {\n      validated.layout = objectConfig.layout as ObjectConfig[\"layout\"];\n    }\n\n    if (typeof objectConfig.columns === \"number\") {\n      validated.columns = objectConfig.columns;\n    }\n\n    return validated;\n  }\n\n  private static validateMultiSelectConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"multiSelectConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const multiSelectConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"multiSelectConfig\"]> = {};\n\n    if (typeof multiSelectConfig.maxSelections === \"number\") {\n      validated.maxSelections = multiSelectConfig.maxSelections;\n    }\n\n    [\"searchable\", \"creatable\"].forEach((key) => {\n      if (typeof multiSelectConfig[key] === \"boolean\") {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    [\"placeholder\", \"noOptionsText\", \"loadingText\"].forEach((key) => {\n      if (\n        multiSelectConfig[key] &&\n        typeof multiSelectConfig[key] === \"string\"\n      ) {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateColorConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"colorConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const colorConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"colorConfig\"]> = {};\n\n    if (\n      colorConfig.format &&\n      [\"hex\", \"rgb\", \"hsl\"].includes(colorConfig.format as string)\n    ) {\n      validated.format = colorConfig.format as \"hex\" | \"rgb\" | \"hsl\";\n    }\n\n    [\"showPreview\", \"showAlpha\", \"allowCustom\"].forEach((key) => {\n      if (typeof colorConfig[key] === \"boolean\") {\n        (validated as any)[key] = colorConfig[key];\n      }\n    });\n\n    if (Array.isArray(colorConfig.presetColors)) {\n      validated.presetColors = colorConfig.presetColors.filter(\n        (color) => typeof color === \"string\"\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateRatingConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"ratingConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const ratingConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"ratingConfig\"]> = {};\n\n    if (typeof ratingConfig.max === \"number\") {\n      validated.max = ratingConfig.max;\n    }\n\n    [\"allowHalf\", \"allowClear\", \"showValue\"].forEach((key) => {\n      if (typeof ratingConfig[key] === \"boolean\") {\n        (validated as any)[key] = ratingConfig[key];\n      }\n    });\n\n    if (\n      ratingConfig.icon &&\n      [\"star\", \"heart\", \"thumbs\"].includes(ratingConfig.icon as string)\n    ) {\n      validated.icon = ratingConfig.icon as \"star\" | \"heart\" | \"thumbs\";\n    }\n\n    if (\n      ratingConfig.size &&\n      [\"sm\", \"md\", \"lg\", \"small\", \"medium\", \"large\"].includes(\n        ratingConfig.size as string\n      )\n    ) {\n      validated.size = ratingConfig.size as\n        | \"sm\"\n        | \"md\"\n        | \"lg\"\n        | \"small\"\n        | \"medium\"\n        | \"large\";\n    }\n\n    return validated;\n  }\n\n  private static validatePhoneConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"phoneConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const phoneConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"phoneConfig\"]> = {};\n\n    if (\n      phoneConfig.defaultCountry &&\n      typeof phoneConfig.defaultCountry === \"string\"\n    ) {\n      validated.defaultCountry = phoneConfig.defaultCountry;\n    }\n\n    [\"preferredCountries\", \"onlyCountries\", \"excludeCountries\"].forEach(\n      (key) => {\n        if (Array.isArray(phoneConfig[key])) {\n          (validated as any)[key] = phoneConfig[key].filter(\n            (item: unknown) => typeof item === \"string\"\n          );\n        }\n      }\n    );\n\n    if (\n      phoneConfig.format &&\n      [\"national\", \"international\"].includes(phoneConfig.format as string)\n    ) {\n      validated.format = phoneConfig.format as \"national\" | \"international\";\n    }\n\n    return validated;\n  }\n\n  private static validateDatalistConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"datalist\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const datalistConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"datalist\"]> = {};\n\n    if (Array.isArray(datalistConfig.options)) {\n      validated.options = datalistConfig.options.filter(\n        (option) => typeof option === \"string\"\n      );\n    }\n\n    [\"debounceMs\", \"minChars\", \"maxResults\"].forEach((key) => {\n      if (typeof datalistConfig[key] === \"number\") {\n        (validated as any)[key] = datalistConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateOptions(\n    options: unknown[]\n  ): Array<{ value: string; label: string }> {\n    return options\n      .filter(\n        (option) =>\n          typeof option === \"object\" &&\n          option !== null &&\n          typeof (option as any).value === \"string\" &&\n          typeof (option as any).label === \"string\"\n      )\n      .map((option) => ({\n        value: (option as any).value,\n        label: (option as any).label,\n      }));\n  }\n\n  private static validatePage(page: unknown, index: number): PageConfig {\n    if (typeof page !== \"object\" || !page) {\n      return { page: index };\n    }\n\n    const pageObj = page as Record<string, unknown>;\n    const validated: PageConfig = {\n      page: typeof pageObj.page === \"number\" ? pageObj.page : index,\n    };\n\n    if (pageObj.title && typeof pageObj.title === \"string\") {\n      validated.title = pageObj.title;\n    }\n\n    if (pageObj.description && typeof pageObj.description === \"string\") {\n      validated.description = pageObj.description;\n    }\n\n    return validated;\n  }\n\n  // Phase 2: Enhanced Features\n\n  /**\n   * Parses form definition with schema inference capabilities\n   * @param code - The form definition code to parse\n   * @param options - Schema inference options\n   * @returns Parsing result with inferred schema information\n   */\n  static parseWithSchemaInference(\n    code: string,\n    options?: SchemaInferenceOptions\n  ): SchemaInferenceResult {\n    const config = this.parse(code);\n\n    // Basic schema inference implementation\n    let confidence = 0.5; // Base confidence\n    let inferredSchema = null;\n\n    if (options?.enabled) {\n      try {\n        const schemaBuilder: Record<string, string> = {};\n\n        for (const field of config.fields) {\n          const zodType = this.inferZodTypeFromField(field);\n          if (zodType) {\n            schemaBuilder[field.name] = zodType;\n            confidence += 0.1; // Increase confidence for each successful inference\n          }\n        }\n\n        // Create a basic schema representation\n        inferredSchema = {\n          type: \"object\",\n          properties: schemaBuilder,\n          isInferred: true,\n        };\n\n        confidence = Math.min(confidence, 1.0);\n      } catch (error) {\n        console.warn(\"Schema inference failed:\", error);\n        confidence = 0.1;\n      }\n    }\n\n    return {\n      config,\n      inferredSchema,\n      confidence,\n    };\n  }\n\n  /**\n   * Merges a parsed configuration with a base schema\n   * @param parsedConfig - The parsed form configuration\n   * @param baseSchema - Base schema to merge with\n   * @param strategy - Merge strategy to use\n   * @returns Enhanced form configuration\n   */\n  static mergeSchemas(\n    parsedConfig: ParsedFormConfig,\n    baseSchema: unknown,\n    strategy: \"extend\" | \"override\" | \"intersect\" = \"extend\"\n  ): ParsedFormConfig {\n    const merged = { ...parsedConfig };\n\n    if (!baseSchema || typeof baseSchema !== \"object\") {\n      return merged;\n    }\n\n    try {\n      // Extract field information from base schema if it has properties\n      const baseSchemaObj = baseSchema as Record<string, unknown>;\n\n      if (strategy === \"extend\" && baseSchemaObj.properties) {\n        // Add missing fields from base schema\n        const existingFieldNames = new Set(merged.fields.map((f) => f.name));\n        const baseProperties = baseSchemaObj.properties as Record<\n          string,\n          unknown\n        >;\n\n        for (const [fieldName, fieldSchema] of Object.entries(baseProperties)) {\n          if (!existingFieldNames.has(fieldName)) {\n            const inferredField = this.createFieldFromSchema(\n              fieldName,\n              fieldSchema\n            );\n            if (inferredField) {\n              merged.fields.push(inferredField);\n            }\n          }\n        }\n      } else if (strategy === \"override\") {\n        // Override existing schema completely\n        merged.schema = baseSchema;\n      } else if (strategy === \"intersect\") {\n        // Keep only fields that exist in both\n        const baseProperties =\n          (baseSchemaObj.properties as Record<string, unknown>) || {};\n        merged.fields = merged.fields.filter((field) =>\n          Object.prototype.hasOwnProperty.call(baseProperties, field.name)\n        );\n      }\n\n      // Update the schema property\n      if (strategy !== \"override\") {\n        merged.schema = baseSchema;\n      }\n    } catch (error) {\n      console.warn(\"Schema merging failed:\", error);\n    }\n\n    return merged;\n  }\n\n  /**\n   * Validates form definition code with AI-friendly error suggestions\n   * @param code - The form definition code to validate\n   * @returns Validation result with detailed errors and suggestions\n   */\n  static validateWithSuggestions(\n    code: string\n  ): ValidationWithSuggestionsResult {\n    const errors: EnhancedParserError[] = [];\n    const suggestions: string[] = [];\n\n    try {\n      // Attempt to parse the code\n      this.parse(code);\n      return { isValid: true, errors: [], suggestions: [] };\n    } catch (error) {\n      let errorType: EnhancedParserError[\"type\"] = \"syntax\";\n      let message = \"Unknown parsing error\";\n      let suggestion = \"\";\n      let examples: string[] = [];\n\n      if (error instanceof Error) {\n        message = error.message;\n\n        // Analyze error types and provide specific suggestions\n        if (\n          message.includes(\"Invalid syntax\") ||\n          message.includes(\"JSON.parse\")\n        ) {\n          errorType = \"syntax\";\n          suggestion =\n            \"Check for missing quotes around object keys or trailing commas\";\n          examples = [\n            '{ \"name\": \"field1\", \"type\": \"text\" }',\n            '{ fields: [{ name: \"field1\", type: \"text\" }] }',\n          ];\n          suggestions.push(\"Use double quotes around object keys\");\n          suggestions.push(\"Remove trailing commas before closing brackets\");\n        } else if (message.includes(\"invalid type\")) {\n          errorType = \"field_type\";\n          suggestion = `Use one of the supported field types: ${this.ALLOWED_FIELD_TYPES.join(\n            \", \"\n          )}`;\n          examples = [\n            '{ name: \"email\", type: \"email\" }',\n            '{ name: \"age\", type: \"number\" }',\n          ];\n          suggestions.push(\"Check field type spelling\");\n          suggestions.push(\"Refer to supported field types list\");\n        } else if (message.includes(\"must have\")) {\n          errorType = \"validation\";\n          suggestion = \"Ensure all required properties are present\";\n          examples = [\n            '{ name: \"required-field\", type: \"text\", label: \"Required Field\" }',\n          ];\n          suggestions.push(\"Add missing required properties: name, type\");\n        } else if (message.includes(\"schema\")) {\n          errorType = \"schema\";\n          suggestion = \"Check Zod schema syntax and structure\";\n          examples = [\n            \"schema: z.object({ name: z.string(), email: z.string().email() })\",\n          ];\n          suggestions.push(\"Verify Zod schema syntax\");\n        }\n      }\n\n      errors.push({\n        type: errorType,\n        message,\n        suggestion,\n        examples,\n        location: this.extractErrorLocation(code, error),\n      });\n\n      // Add general suggestions\n      suggestions.push(\"Validate JSON syntax using a JSON validator\");\n      suggestions.push(\"Check for balanced parentheses and brackets\");\n      suggestions.push(\"Ensure all string values are properly quoted\");\n\n      return { isValid: false, errors, suggestions };\n    }\n  }\n\n  /**\n   * Infers Zod type from a field configuration\n   * @private\n   */\n  private static inferZodTypeFromField(\n    field: ParsedFieldConfig\n  ): string | null {\n    const typeMapping: Record<string, string> = {\n      text: \"z.string()\",\n      email: \"z.string().email()\",\n      password: \"z.string().min(1)\",\n      url: \"z.string().url()\",\n      tel: \"z.string()\",\n      textarea: \"z.string()\",\n      number: \"z.number()\",\n      date: \"z.string().datetime()\",\n      checkbox: \"z.boolean()\",\n      switch: \"z.boolean()\",\n      select: \"z.string()\",\n      radio: \"z.string()\",\n      multiSelect: \"z.array(z.string())\",\n      file: \"z.instanceof(File)\",\n      slider: \"z.number()\",\n      rating: \"z.number()\",\n      phone: \"z.string()\",\n      colorPicker: \"z.string()\",\n      location: \"z.object({ lat: z.number(), lng: z.number() })\",\n      duration: \"z.number()\",\n      autocomplete: \"z.string()\",\n      masked: \"z.string()\",\n      array: \"z.array(z.unknown())\",\n      object: \"z.object({})\",\n    };\n\n    let baseType = typeMapping[field.type];\n    if (!baseType) return null;\n\n    // Add validation constraints\n    if (field.type === \"text\" || field.type === \"textarea\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().max(${field.max})`\n        );\n      }\n    }\n\n    if (field.type === \"number\" || field.type === \"slider\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().max(${field.max})`\n        );\n      }\n    }\n\n    // Handle required/optional\n    if (field.required === false) {\n      baseType += \".optional()\";\n    }\n\n    return baseType;\n  }\n\n  /**\n   * Creates a field configuration from a schema definition\n   * @private\n   */\n  private static createFieldFromSchema(\n    name: string,\n    schema: unknown\n  ): ParsedFieldConfig | null {\n    // Basic implementation - would need more sophisticated schema analysis\n    try {\n      const schemaObj = schema as Record<string, unknown>;\n      let type = \"text\"; // default\n\n      // Very basic type inference from schema structure\n      if (schemaObj.type === \"string\") {\n        type = \"text\";\n      } else if (schemaObj.type === \"number\") {\n        type = \"number\";\n      } else if (schemaObj.type === \"boolean\") {\n        type = \"checkbox\";\n      }\n\n      return {\n        name,\n        type,\n        label:\n          name.charAt(0).toUpperCase() +\n          name.slice(1).replace(/([A-Z])/g, \" $1\"),\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Extracts error location information from parsing error\n   * @private\n   */\n  private static extractErrorLocation(\n    code: string,\n    error: unknown\n  ): EnhancedParserError[\"location\"] | undefined {\n    try {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      // Try to extract line/column info from JSON parse errors\n      const positionMatch = errorMessage.match(/at position (\\d+)/i);\n      if (positionMatch) {\n        const position = parseInt(positionMatch[1], 10);\n        const lines = code.substring(0, position).split(\"\\n\");\n        return {\n          line: lines.length,\n          column: lines[lines.length - 1].length + 1,\n        };\n      }\n\n      // Try to extract field information from validation errors\n      const fieldMatch = errorMessage.match(/field at index (\\d+)/i);\n      if (fieldMatch) {\n        return {\n          field: `field[${fieldMatch[1]}]`,\n        };\n      }\n    } catch {\n      // Ignore extraction errors\n    }\n\n    return undefined;\n  }\n}\n\n// Export types for external use\nexport type { ParsedFormConfig, ParsedFieldConfig, ParserOptions, ObjectConfig, ParserError, PageConfig };\n",
      "type": "registry:lib",
      "target": "lib/formedible/formedible-parser.ts"
    },
    {
      "path": "src/lib/formedible/parser-types.ts",
      "content": "\"use client\";\n\n// Import and re-export types from formedible to stay DRY\nimport type { \n  FieldConfig,\n  DynamicText,\n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig\n} from \"./types\";\n\nexport type { \n  FieldConfig,\n  DynamicText,\n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig\n};\n\n// Just use FieldConfig directly - no need to redefine!\nexport type ParsedFieldConfig = FieldConfig;\n\n\nexport interface ParsedFormConfig {\n  schema?: unknown;\n  fields: ParsedFieldConfig[];\n  pages?: PageConfig[];\n  title?: string;\n  description?: string;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  progress?: ProgressConfig;\n  formOptions?: {\n    defaultValues?: Record<string, unknown>;\n    onSubmit?: (data: { value: Record<string, unknown> }) => void | Promise<void>;\n    [key: string]: unknown;\n  };\n}\n\nexport interface ParserOptions {\n  strictValidation?: boolean;\n}\n\nexport interface ParserError extends Error {\n  code?: string;\n  field?: string;\n  line?: number;\n  column?: number;\n}\n\n// Phase 2: Enhanced Parser Types\n\n/**\n * Enhanced parser options for Phase 2 features\n */\nexport interface EnhancedParserOptions extends ParserOptions {\n  baseSchema?: unknown; // z.ZodSchema in actual usage\n  mergeStrategy?: 'extend' | 'override' | 'intersect';\n  predefinedHandlers?: {\n    onSubmit?: (data: unknown) => void;\n    specificFields?: Record<string, ParsedFieldConfig>;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Enhanced error type with AI-friendly suggestions\n */\nexport interface EnhancedParserError {\n  type: 'syntax' | 'validation' | 'field_type' | 'schema';\n  message: string;\n  suggestion?: string;\n  location?: {\n    line?: number;\n    column?: number;\n    field?: string;\n  };\n  examples?: string[];\n}\n\n/**\n * Schema inference configuration options\n */\nexport interface SchemaInferenceOptions {\n  enabled?: boolean;\n  fieldTypeMapping?: Record<string, unknown>; // z.ZodType in actual usage\n  defaultValidation?: boolean;\n  inferFromValues?: boolean;\n}\n\n/**\n * Result of schema inference parsing\n */\nexport interface SchemaInferenceResult {\n  config: ParsedFormConfig;\n  inferredSchema: unknown; // z.ZodSchema in actual usage\n  confidence: number;\n}\n\n/**\n * Result of validation with suggestions\n */\nexport interface ValidationWithSuggestionsResult {\n  isValid: boolean;\n  errors: EnhancedParserError[];\n  suggestions: string[];\n}",
      "type": "registry:lib",
      "target": "lib/formedible/parser-types.ts"
    },
    {
      "path": "src/lib/formedible/parser-config-schema.ts",
      "content": "\"use client\";\n\n/**\n * Parser Configuration Schema for Settings UI\n *\n * This file provides a formedible-compatible schema for configuring\n * parser settings through a UI form. It includes types and field\n * configurations for all parser options.\n */\n\n// Note: In actual usage, this would import from 'zod', but for standalone\n// compatibility, we define the schema structure that can be used with zod\n\n/**\n * Parser configuration options\n */\nexport interface ParserConfig {\n  strictValidation: boolean;\n  enableSchemaInference: boolean;\n  mergeStrategy: \"extend\" | \"override\" | \"intersect\";\n  fieldTypeValidation: boolean;\n  customInstructions?: string;\n  maxCodeLength: number;\n  maxNestingDepth: number;\n  enableZodParsing: boolean;\n  showDetailedErrors: boolean;\n  selectFields: boolean;\n  systemPromptFields: string[];\n  includeTabFormatting: boolean;\n  includePageFormatting: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * Zod schema definition structure (for use with actual zod when available)\n * This represents what the schema would look like when used with zod\n */\nexport const parserConfigSchemaDefinition = {\n  strictValidation: {\n    type: \"boolean\",\n    default: true,\n    description: \"Enable strict validation of form definitions\",\n  },\n  enableSchemaInference: {\n    type: \"boolean\",\n    default: false,\n    description: \"Automatically infer Zod schemas from field definitions\",\n  },\n  mergeStrategy: {\n    type: \"enum\",\n    values: [\"extend\", \"override\", \"intersect\"],\n    default: \"extend\",\n    description: \"Strategy for merging with base schemas\",\n  },\n  fieldTypeValidation: {\n    type: \"boolean\",\n    default: true,\n    description: \"Validate field types against supported types\",\n  },\n  customInstructions: {\n    type: \"string\",\n    optional: true,\n    description: \"Custom parsing instructions or constraints\",\n  },\n  maxCodeLength: {\n    type: \"number\",\n    default: 1000000,\n    min: 1000,\n    max: 10000000,\n    description: \"Maximum allowed code length in characters\",\n  },\n  maxNestingDepth: {\n    type: \"number\",\n    default: 50,\n    min: 5,\n    max: 200,\n    description: \"Maximum nesting depth for object structures\",\n  },\n  enableZodParsing: {\n    type: \"boolean\",\n    default: true,\n    description: \"Enable parsing of Zod schema expressions\",\n  },\n  showDetailedErrors: {\n    type: \"boolean\",\n    default: true,\n    description: \"Show detailed error information in parser output\",\n  },\n};\n\n/**\n * Default parser configuration\n */\nexport const defaultParserConfig: ParserConfig = {\n  strictValidation: true,\n  enableSchemaInference: false,\n  mergeStrategy: \"extend\",\n  fieldTypeValidation: true,\n  customInstructions: undefined,\n  maxCodeLength: 1000000,\n  maxNestingDepth: 50,\n  enableZodParsing: true,\n  showDetailedErrors: true,\n  selectFields: false,\n  // Default to the set of formedible field types used as examples in the UI\n  systemPromptFields: [\n    \"text\",\n    \"email\",\n    \"url\",\n    \"textarea\",\n    \"number\",\n    \"select\",\n    \"multiSelect\",\n    \"radio\",\n    \"checkbox\",\n    \"switch\",\n    \"date\",\n    \"file\",\n    \"slider\",\n    \"rating\",\n    \"phone\",\n    \"colorPicker\",\n    \"password\",\n    \"duration\",\n    \"autocomplete\",\n    \"maskedInput\",\n    \"array\",\n    \"object\",\n  ],\n  includeTabFormatting: true,\n  includePageFormatting: true,\n};\n\n/**\n * Type-safe field examples for each field type - aligned with formedible documentation\n */\nconst fieldExamples = {\n  text: { name: \"fullName\", type: \"text\", label: \"Full Name\", required: true },\n  email: {\n    name: \"email\",\n    type: \"email\",\n    label: \"Email Address\",\n    required: true,\n  },\n  url: { name: \"website\", type: \"url\", label: \"Website URL\" },\n  textarea: {\n    name: \"message\",\n    type: \"textarea\",\n    label: \"Message\",\n    textareaConfig: { rows: 4, maxLength: 500, showWordCount: true },\n  },\n  number: {\n    name: \"age\",\n    type: \"number\",\n    label: \"Age\",\n    numberConfig: { min: 18, max: 120, allowNegative: false },\n  },\n  select: {\n    name: \"country\",\n    type: \"select\",\n    label: \"Country\",\n    options: [\n      { value: \"us\", label: \"United States\" },\n      { value: \"uk\", label: \"United Kingdom\" },\n      { value: \"ca\", label: \"Canada\" },\n    ],\n  },\n  multiSelect: {\n    name: \"skills\",\n    type: \"multiSelect\",\n    label: \"Skills\",\n    options: [\"React\", \"Vue\", \"Angular\", \"Node.js\"],\n    multiSelectConfig: { maxSelections: 3, searchable: true, creatable: true },\n  },\n  radio: {\n    name: \"plan\",\n    type: \"radio\",\n    label: \"Plan\",\n    options: [\n      { value: \"free\", label: \"Free Plan\" },\n      { value: \"pro\", label: \"Pro Plan\" },\n      { value: \"enterprise\", label: \"Enterprise Plan\" },\n    ],\n  },\n  checkbox: {\n    name: \"newsletter\",\n    type: \"checkbox\",\n    label: \"Subscribe to Newsletter\",\n  },\n  switch: {\n    name: \"notifications\",\n    type: \"switch\",\n    label: \"Enable Notifications\",\n  },\n  date: {\n    name: \"birthDate\",\n    type: \"date\",\n    label: \"Birth Date\",\n    dateConfig: { format: \"yyyy-MM-dd\", showTime: false },\n  },\n  file: {\n    name: \"resume\",\n    type: \"file\",\n    label: \"Resume\",\n    fileConfig: {\n      accept: \".pdf,.doc,.docx\",\n      maxSize: 5000000,\n      multiple: false,\n    },\n  },\n  slider: {\n    name: \"experience\",\n    type: \"slider\",\n    label: \"Years Experience\",\n    sliderConfig: { min: 0, max: 20, step: 1 },\n  },\n  rating: {\n    name: \"satisfaction\",\n    type: \"rating\",\n    label: \"Satisfaction Rating\",\n    ratingConfig: { max: 5, allowHalf: true, icon: \"star\" },\n  },\n  phone: {\n    name: \"phone\",\n    type: \"phone\",\n    label: \"Phone Number\",\n    phoneConfig: { defaultCountry: \"US\", format: \"national\" },\n  },\n  colorPicker: {\n    name: \"brandColor\",\n    type: \"colorPicker\",\n    label: \"Brand Color\",\n    colorConfig: {\n      format: \"hex\",\n      presetColors: [\"#ff0000\", \"#00ff00\", \"#0000ff\"],\n      allowCustom: true,\n    },\n  },\n  password: {\n    name: \"password\",\n    type: \"password\",\n    label: \"Password\",\n    passwordConfig: { showToggle: true, strengthMeter: true },\n  },\n  duration: {\n    name: \"workHours\",\n    type: \"duration\",\n    label: \"Work Hours\",\n    durationConfig: { format: \"hm\", showLabels: true },\n  },\n  autocomplete: {\n    name: \"city\",\n    type: \"autocomplete\",\n    label: \"City\",\n    autocompleteConfig: {\n      options: [\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\"],\n      minChars: 2,\n      allowCustom: true,\n    },\n  },\n  maskedInput: {\n    name: \"ssn\",\n    type: \"maskedInput\",\n    label: \"SSN\",\n    maskedInputConfig: { mask: \"000-00-0000\", guide: true },\n  },\n  array: {\n    name: \"team\",\n    type: \"array\",\n    label: \"Team Members\",\n    arrayConfig: {\n      itemType: \"object\",\n      itemLabel: \"Team Member\",\n      minItems: 1,\n      maxItems: 10,\n      sortable: true,\n      addButtonLabel: \"Add Member\",\n      removeButtonLabel: \"Remove\",\n      objectConfig: {\n        fields: [\n          { name: \"name\", type: \"text\", label: \"Full Name\", required: true },\n          {\n            name: \"role\",\n            type: \"select\",\n            label: \"Role\",\n            options: [\"Developer\", \"Designer\", \"Manager\"],\n          },\n          { name: \"email\", type: \"email\", label: \"Email\", required: true },\n        ],\n      },\n    },\n  },\n  object: {\n    name: \"address\",\n    type: \"object\",\n    label: \"Address\",\n    objectConfig: {\n      title: \"Mailing Address\",\n      collapsible: true,\n      layout: \"vertical\",\n      fields: [\n        {\n          name: \"street\",\n          type: \"text\",\n          label: \"Street Address\",\n          required: true,\n        },\n        { name: \"city\", type: \"text\", label: \"City\", required: true },\n        {\n          name: \"state\",\n          type: \"select\",\n          label: \"State\",\n          options: [\"CA\", \"NY\", \"TX\", \"FL\"],\n        },\n        { name: \"zip\", type: \"text\", label: \"ZIP Code\", required: true },\n      ],\n    },\n  },\n} as const;\n\n/**\n * Formedible field configurations for the parser settings UI\n * These can be used to generate a settings form using formedible\n */\nexport const parserConfigFields = [\n  {\n    name: \"strictValidation\",\n    type: \"switch\",\n    label: \"Strict Validation\",\n    description:\n      \"Enable strict validation of form definitions. When enabled, unknown properties are rejected.\",\n    defaultValue: true,\n  },\n  {\n    name: \"enableSchemaInference\",\n    type: \"switch\",\n    label: \"Schema Inference\",\n    description:\n      \"Automatically infer Zod schemas from field definitions to provide better type safety.\",\n    defaultValue: false,\n  },\n  {\n    name: \"mergeStrategy\",\n    type: \"select\",\n    label: \"Schema Merge Strategy\",\n    description: \"How to merge parsed configurations with base schemas.\",\n    defaultValue: \"extend\",\n    options: [\n      {\n        value: \"extend\",\n        label: \"Extend - Add missing fields from base schema\",\n      },\n      { value: \"override\", label: \"Override - Replace schema completely\" },\n      { value: \"intersect\", label: \"Intersect - Keep only common fields\" },\n    ],\n  },\n  {\n    name: \"fieldTypeValidation\",\n    type: \"switch\",\n    label: \"Field Type Validation\",\n    description:\n      \"Validate field types against the list of supported field types.\",\n    defaultValue: true,\n  },\n  {\n    name: \"customInstructions\",\n    type: \"textarea\",\n    label: \"Custom Instructions\",\n    description:\n      \"Optional custom parsing instructions or constraints to apply.\",\n    placeholder: \"Enter any custom parsing rules or requirements...\",\n    required: false,\n  },\n  {\n    name: \"maxCodeLength\",\n    type: \"number\",\n    label: \"Maximum Code Length\",\n    description:\n      \"Maximum allowed length for form definition code (in characters).\",\n    defaultValue: 1000000,\n    min: 1000,\n    max: 10000000,\n    step: 1000,\n  },\n  {\n    name: \"maxNestingDepth\",\n    type: \"number\",\n    label: \"Maximum Nesting Depth\",\n    description:\n      \"Maximum allowed nesting depth for object and array structures.\",\n    defaultValue: 50,\n    min: 5,\n    max: 200,\n    step: 5,\n  },\n  {\n    name: \"enableZodParsing\",\n    type: \"switch\",\n    label: \"Zod Expression Parsing\",\n    description:\n      \"Enable parsing and handling of Zod schema expressions in form definitions.\",\n    defaultValue: true,\n  },\n  {\n    name: \"showDetailedErrors\",\n    type: \"switch\",\n    label: \"Detailed Error Information\",\n    description:\n      \"Include detailed error context and location information in parser output.\",\n    defaultValue: true,\n  },\n  {\n    name: \"selectFields\",\n    type: \"switch\",\n    label: \"Select Fields\",\n    defaultValue: false,\n  },\n  {\n    name: \"systemPromptFields\",\n    type: \"multiSelect\",\n    label: \"Field Types\",\n    description:\n      \"Select which formedible field types to include as examples in the system prompt.\",\n    options: Object.keys(fieldExamples).map((fieldType) => ({\n      value: fieldType,\n      label: fieldType.charAt(0).toUpperCase() + fieldType.slice(1),\n    })),\n    defaultValue: Object.keys(fieldExamples),\n  },\n  {\n    name: \"includeTabFormatting\",\n    type: \"switch\",\n    label: \"Tab Formatting\",\n    description: \"Include tab-based form structure in the system prompt.\",\n    defaultValue: true,\n  },\n  {\n    name: \"includePageFormatting\",\n    type: \"switch\",\n    label: \"Page Formatting\",\n    description: \"Include multi-page form structure in the system prompt.\",\n    defaultValue: true,\n  },\n];\n\n/**\n * Parser configuration form definition\n * Complete formedible form configuration for parser settings\n */\nexport const parserConfigFormDefinition = {\n  title: \"Parser Configuration\",\n  description: \"Configure how the Formedible parser processes form definitions\",\n  fields: parserConfigFields,\n  submitLabel: \"Save Configuration\",\n  formOptions: {\n    defaultValues: defaultParserConfig,\n  },\n};\n\n/**\n * Helper function to validate parser configuration\n */\nexport function validateParserConfig(config: unknown): config is ParserConfig {\n  if (!config || typeof config !== \"object\") {\n    return false;\n  }\n\n  const c = config as Record<string, unknown>;\n\n  return (\n    typeof c.strictValidation === \"boolean\" &&\n    typeof c.enableSchemaInference === \"boolean\" &&\n    (c.mergeStrategy === \"extend\" ||\n      c.mergeStrategy === \"override\" ||\n      c.mergeStrategy === \"intersect\") &&\n    typeof c.fieldTypeValidation === \"boolean\" &&\n    (c.customInstructions === undefined ||\n      typeof c.customInstructions === \"string\") &&\n    typeof c.maxCodeLength === \"number\" &&\n    typeof c.maxNestingDepth === \"number\" &&\n    typeof c.enableZodParsing === \"boolean\" &&\n    typeof c.showDetailedErrors === \"boolean\" &&\n    typeof c.selectFields === \"boolean\" &&\n    Array.isArray(c.systemPromptFields) &&\n    c.systemPromptFields.every((field) => typeof field === \"string\") &&\n    typeof c.includeTabFormatting === \"boolean\" &&\n    typeof c.includePageFormatting === \"boolean\"\n  );\n}\n\n/**\n * Helper function to merge parser configuration with defaults\n */\nexport function mergeParserConfig(config: Partial<ParserConfig>): ParserConfig {\n  return {\n    ...defaultParserConfig,\n    ...config,\n  };\n}\n\n/**\n * Generate a dynamic system prompt based on selected configuration fields\n */\nexport function generateSystemPrompt(config: ParserConfig): string {\n  const fieldDescriptions: Record<string, string> = {\n    strictValidation: config.strictValidation\n      ? \"Use strict validation - reject unknown properties and enforce schema compliance\"\n      : \"Use permissive validation - allow unknown properties and be flexible with schema\",\n    fieldTypeValidation: config.fieldTypeValidation\n      ? \"Validate all field types against the 24 supported formedible field types\"\n      : \"Allow flexible field types without strict validation\",\n    enableSchemaInference: config.enableSchemaInference\n      ? \"Automatically infer Zod schemas from field definitions for better type safety\"\n      : \"Use manual schema definition without automatic inference\",\n    mergeStrategy: `Use \"${\n      config.mergeStrategy\n    }\" strategy when merging schemas - ${\n      config.mergeStrategy === \"extend\"\n        ? \"add missing fields from base schema\"\n        : config.mergeStrategy === \"override\"\n        ? \"replace schema completely\"\n        : \"keep only fields that exist in both schemas\"\n    }`,\n    maxCodeLength: `Maximum allowed form definition length: ${config.maxCodeLength.toLocaleString()} characters`,\n    maxNestingDepth: `Maximum nesting depth for object and array structures: ${config.maxNestingDepth} levels`,\n    enableZodParsing: config.enableZodParsing\n      ? \"Parse and handle Zod schema expressions (z.string(), z.number(), etc.)\"\n      : \"Treat Zod expressions as plain text without parsing\",\n    showDetailedErrors: config.showDetailedErrors\n      ? \"Include detailed error context, location information, and debugging details\"\n      : \"Provide minimal error information\",\n    ...(config.customInstructions\n      ? {\n          customInstructions: `Additional instructions: ${config.customInstructions}`,\n        }\n      : {}),\n  };\n\n  const selectedConfigFields = Object.entries(fieldDescriptions)\n    .filter(([_key, desc]) => Boolean(desc))\n    .map(([_key, desc]) => desc);\n\n  if (\n    !selectedConfigFields.length &&\n    !config.includeTabFormatting &&\n    !config.includePageFormatting\n  ) {\n    return \"\";\n  }\n\n  let prompt = `# Formedible Parser Configuration\n\nYou are working with a Formedible form parser that has been configured with the following settings:\n\n${selectedConfigFields.map((desc, index) => `${index + 1}. ${desc}`).join(\"\\n\")}\n\n## Key Guidelines\n- Follow the configured validation and parsing rules strictly\n- Generate forms that respect the maximum limits and nesting depth\n- Use the specified error message style and detail level\n- Apply the configured schema inference and merging strategies`;\n\n  // Add formatting guidelines\n  if (config.includeTabFormatting || config.includePageFormatting) {\n    prompt += `\n\n## Form Structure Guidelines`;\n\n    if (config.includeTabFormatting) {\n      prompt += `\n- **Tab Layout**: Use the \\`layout: { type: 'tabs' }\\` configuration for organizing forms into logical sections\n- **Tab Structure**: Each tab should group related fields together for better user experience\n- **Tab Navigation**: Ensure tab titles are descriptive and help users understand the content`;\n    }\n\n    if (config.includePageFormatting) {\n      prompt += `\n- **Multi-Page Forms**: Use the \\`pages\\` array to create multi-step forms for complex data collection\n- **Page Structure**: Each page should have a clear purpose and logical flow\n- **Page Navigation**: Include appropriate navigation controls with \\`nextLabel\\`, \\`previousLabel\\`, and \\`submitLabel\\`\n- **Progress Indication**: Consider adding progress indicators for multi-page forms using the \\`progress\\` configuration`;\n    }\n  }\n\n  // Create a comprehensive, realistic form example\n  let basicExample: any = {\n    title: \"User Registration Form\",\n    description: \"Complete user registration with validation\",\n    fields: [\n      {\n        name: \"fullName\",\n        type: \"text\",\n        label: \"Full Name\",\n        placeholder: \"Enter your full name\",\n        required: true,\n        validation: \"z.string().min(2, 'Name must be at least 2 characters')\"\n      },\n      {\n        name: \"email\",\n        type: \"email\", \n        label: \"Email Address\",\n        placeholder: \"your@email.com\",\n        required: true,\n        validation: \"z.string().email('Please enter a valid email address')\"\n      },\n      {\n        name: \"password\",\n        type: \"password\",\n        label: \"Password\",\n        required: true,\n        passwordConfig: { showToggle: true, strengthMeter: true },\n        validation: \"z.string().min(8, 'Password must be at least 8 characters')\"\n      },\n      {\n        name: \"age\",\n        type: \"number\",\n        label: \"Age\",\n        required: true,\n        numberConfig: { min: 18, max: 120, allowNegative: false },\n        validation: \"z.number().min(18, 'Must be at least 18 years old').max(120)\"\n      },\n      {\n        name: \"country\",\n        type: \"select\",\n        label: \"Country\",\n        required: true,\n        options: [\n          { value: \"us\", label: \"United States\" },\n          { value: \"uk\", label: \"United Kingdom\" },\n          { value: \"ca\", label: \"Canada\" },\n          { value: \"au\", label: \"Australia\" }\n        ],\n        validation: \"z.enum(['us', 'uk', 'ca', 'au'])\"\n      },\n      {\n        name: \"newsletter\",\n        type: \"checkbox\",\n        label: \"Subscribe to Newsletter\",\n        description: \"Receive updates about new features and promotions\"\n      }\n    ],\n    schema: \"z.object({ fullName: z.string().min(2), email: z.string().email(), password: z.string().min(8), age: z.number().min(18).max(120), country: z.enum(['us', 'uk', 'ca', 'au']), newsletter: z.boolean().optional() })\",\n    formOptions: {\n      defaultValues: {\n        fullName: \"\",\n        email: \"\",\n        password: \"\",\n        age: 18,\n        country: \"\",\n        newsletter: false\n      },\n      onSubmit: \"async ({ value }) => { console.log('Registration data:', value); await submitRegistration(value); }\",\n      onSubmitInvalid: \"({ errors }) => { console.log('Validation errors:', errors); }\"\n    },\n    submitLabel: \"Create Account\",\n    layout: {\n      type: \"grid\",\n      columns: 2,\n      gap: \"md\"\n    }\n  };\n\n  if (config.includeTabFormatting && config.includePageFormatting) {\n    // Both tabs and pages - comprehensive multi-step form with tabs\n    basicExample = {\n      title: \"Complete Profile Setup\",\n      description: \"Multi-step registration with organized sections\",\n      layout: { type: \"stepper\" },\n      pages: [\n        { title: \"Personal Information\", description: \"Basic details about you\" },\n        { title: \"Account Preferences\", description: \"Customize your experience\" },\n        { title: \"Review & Submit\", description: \"Confirm your information\" }\n      ],\n      tabs: [\n        { id: \"basic\", label: \"Basic Info\", description: \"Name and contact\" },\n        { id: \"address\", label: \"Address\", description: \"Location details\" },\n        { id: \"settings\", label: \"Settings\", description: \"Account preferences\" }\n      ],\n      fields: [\n        {\n          name: \"firstName\",\n          type: \"text\",\n          label: \"First Name\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n          validation: \"z.string().min(1, 'First name is required')\"\n        },\n        {\n          name: \"lastName\", \n          type: \"text\",\n          label: \"Last Name\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n          validation: \"z.string().min(1, 'Last name is required')\"\n        },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n          validation: \"z.string().email('Invalid email address')\"\n        },\n        {\n          name: \"address\",\n          type: \"object\",\n          label: \"Address\",\n          page: 1,\n          tab: \"address\",\n          objectConfig: {\n            title: \"Mailing Address\",\n            fields: [\n              { name: \"street\", type: \"text\", label: \"Street Address\", required: true },\n              { name: \"city\", type: \"text\", label: \"City\", required: true },\n              { name: \"zipCode\", type: \"text\", label: \"ZIP Code\", required: true }\n            ]\n          }\n        },\n        {\n          name: \"notifications\",\n          type: \"switch\",\n          label: \"Email Notifications\",\n          page: 2,\n          tab: \"settings\"\n        },\n        {\n          name: \"theme\",\n          type: \"select\",\n          label: \"Preferred Theme\",\n          page: 2,\n          tab: \"settings\",\n          options: [\n            { value: \"light\", label: \"Light\" },\n            { value: \"dark\", label: \"Dark\" },\n            { value: \"auto\", label: \"Auto\" }\n          ]\n        }\n      ],\n      schema: \"z.object({ firstName: z.string().min(1), lastName: z.string().min(1), email: z.string().email(), address: z.object({ street: z.string(), city: z.string(), zipCode: z.string() }), notifications: z.boolean().optional(), theme: z.enum(['light', 'dark', 'auto']).optional() })\",\n      formOptions: {\n        defaultValues: {\n          firstName: \"\",\n          lastName: \"\",\n          email: \"\",\n          address: { street: \"\", city: \"\", zipCode: \"\" },\n          notifications: true,\n          theme: \"auto\"\n        },\n        onSubmit: \"async ({ value }) => { console.log('Profile setup complete:', value); await saveProfile(value); }\"\n      },\n      nextLabel: \"Continue\",\n      previousLabel: \"Back\",\n      submitLabel: \"Complete Setup\"\n    };\n  } else if (config.includeTabFormatting) {\n    // Tab-based form with organized sections\n    basicExample = {\n      title: \"Project Application Form\",\n      description: \"Comprehensive application with tabbed organization\",\n      layout: { type: \"tabs\" },\n      tabs: [\n        { id: \"personal\", label: \"Personal Info\", description: \"Your basic information\" },\n        { id: \"project\", label: \"Project Details\", description: \"About your project\" },\n        { id: \"experience\", label: \"Experience\", description: \"Your background\" }\n      ],\n      fields: [\n        {\n          name: \"fullName\",\n          type: \"text\",\n          label: \"Full Name\",\n          required: true,\n          tab: \"personal\",\n          validation: \"z.string().min(2, 'Name must be at least 2 characters')\"\n        },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email Address\",\n          required: true,\n          tab: \"personal\",\n          validation: \"z.string().email('Please enter a valid email')\"\n        },\n        {\n          name: \"phone\",\n          type: \"phone\",\n          label: \"Phone Number\",\n          tab: \"personal\",\n          phoneConfig: { defaultCountry: \"US\", format: \"national\" }\n        },\n        {\n          name: \"projectTitle\",\n          type: \"text\",\n          label: \"Project Title\",\n          required: true,\n          tab: \"project\",\n          validation: \"z.string().min(5, 'Project title must be at least 5 characters')\"\n        },\n        {\n          name: \"projectDescription\",\n          type: \"textarea\",\n          label: \"Project Description\",\n          required: true,\n          tab: \"project\",\n          textareaConfig: { rows: 6, maxLength: 1000, showWordCount: true },\n          validation: \"z.string().min(50, 'Description must be at least 50 characters')\"\n        },\n        {\n          name: \"budget\",\n          type: \"select\",\n          label: \"Budget Range\",\n          required: true,\n          tab: \"project\",\n          options: [\n            { value: \"under-5k\", label: \"Under $5,000\" },\n            { value: \"5k-15k\", label: \"$5,000 - $15,000\" },\n            { value: \"15k-50k\", label: \"$15,000 - $50,000\" },\n            { value: \"over-50k\", label: \"Over $50,000\" }\n          ]\n        },\n        {\n          name: \"yearsExperience\",\n          type: \"slider\",\n          label: \"Years of Experience\",\n          tab: \"experience\",\n          sliderConfig: { min: 0, max: 30, step: 1 }\n        },\n        {\n          name: \"skills\",\n          type: \"multiSelect\",\n          label: \"Skills\",\n          tab: \"experience\",\n          options: [\"JavaScript\", \"TypeScript\", \"React\", \"Node.js\", \"Python\", \"Design\"],\n          multiSelectConfig: { maxSelections: 5, searchable: true }\n        }\n      ],\n      schema: \"z.object({ fullName: z.string().min(2), email: z.string().email(), phone: z.string().optional(), projectTitle: z.string().min(5), projectDescription: z.string().min(50), budget: z.enum(['under-5k', '5k-15k', '15k-50k', 'over-50k']), yearsExperience: z.number().min(0).max(30).optional(), skills: z.array(z.string()).optional() })\",\n      formOptions: {\n        defaultValues: {\n          fullName: \"\",\n          email: \"\",\n          phone: \"\",\n          projectTitle: \"\",\n          projectDescription: \"\",\n          budget: \"\",\n          yearsExperience: 0,\n          skills: []\n        },\n        onSubmit: \"async ({ value }) => { console.log('Application submitted:', value); await submitApplication(value); }\"\n      },\n      submitLabel: \"Submit Application\"\n    };\n  } else if (config.includePageFormatting) {\n    // Multi-page form with step-by-step progression\n    basicExample = {\n      title: \"Customer Onboarding\",\n      description: \"Complete your account setup in simple steps\",\n      layout: { type: \"stepper\" },\n      pages: [\n        { title: \"Account Details\", description: \"Create your account credentials\" },\n        { title: \"Personal Information\", description: \"Tell us about yourself\" },\n        { title: \"Preferences\", description: \"Customize your experience\" },\n        { title: \"Confirmation\", description: \"Review and confirm your information\" }\n      ],\n      fields: [\n        {\n          name: \"username\",\n          type: \"text\",\n          label: \"Username\",\n          required: true,\n          page: 1,\n          placeholder: \"Choose a unique username\",\n          validation: \"z.string().min(3, 'Username must be at least 3 characters')\"\n        },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email Address\",\n          required: true,\n          page: 1,\n          validation: \"z.string().email('Please enter a valid email address')\"\n        },\n        {\n          name: \"password\",\n          type: \"password\",\n          label: \"Password\",\n          required: true,\n          page: 1,\n          passwordConfig: { showToggle: true, strengthMeter: true },\n          validation: \"z.string().min(8, 'Password must be at least 8 characters')\"\n        },\n        {\n          name: \"firstName\",\n          type: \"text\",\n          label: \"First Name\",\n          required: true,\n          page: 2,\n          validation: \"z.string().min(1, 'First name is required')\"\n        },\n        {\n          name: \"lastName\",\n          type: \"text\",\n          label: \"Last Name\",\n          required: true,\n          page: 2,\n          validation: \"z.string().min(1, 'Last name is required')\"\n        },\n        {\n          name: \"birthDate\",\n          type: \"date\",\n          label: \"Date of Birth\",\n          page: 2,\n          dateConfig: { format: \"yyyy-MM-dd\", showTime: false }\n        },\n        {\n          name: \"company\",\n          type: \"text\",\n          label: \"Company (Optional)\",\n          page: 2\n        },\n        {\n          name: \"notifications\",\n          type: \"switch\",\n          label: \"Email Notifications\",\n          description: \"Receive product updates and newsletters\",\n          page: 3\n        },\n        {\n          name: \"language\",\n          type: \"select\",\n          label: \"Preferred Language\",\n          page: 3,\n          options: [\n            { value: \"en\", label: \"English\" },\n            { value: \"es\", label: \"Spanish\" },\n            { value: \"fr\", label: \"French\" },\n            { value: \"de\", label: \"German\" }\n          ],\n          validation: \"z.enum(['en', 'es', 'fr', 'de'])\"\n        },\n        {\n          name: \"interests\",\n          type: \"multiSelect\",\n          label: \"Interests\",\n          page: 3,\n          options: [\"Technology\", \"Design\", \"Marketing\", \"Sales\", \"Finance\", \"Education\"],\n          multiSelectConfig: { maxSelections: 3, searchable: true }\n        }\n      ],\n      schema: \"z.object({ username: z.string().min(3), email: z.string().email(), password: z.string().min(8), firstName: z.string().min(1), lastName: z.string().min(1), birthDate: z.date().optional(), company: z.string().optional(), notifications: z.boolean().optional(), language: z.enum(['en', 'es', 'fr', 'de']).optional(), interests: z.array(z.string()).optional() })\",\n      formOptions: {\n        defaultValues: {\n          username: \"\",\n          email: \"\",\n          password: \"\",\n          firstName: \"\",\n          lastName: \"\",\n          birthDate: undefined,\n          company: \"\",\n          notifications: true,\n          language: \"en\",\n          interests: []\n        },\n        onSubmit: \"async ({ value }) => { console.log('Onboarding complete:', value); await completeOnboarding(value); }\"\n      },\n      nextLabel: \"Continue\",\n      previousLabel: \"Back\",\n      submitLabel: \"Complete Setup\",\n      progress: {\n        showProgress: true,\n        showStepNumbers: true\n      }\n    };\n  }\n\n  // Filter field examples based on selected field types\n  const selectedFieldExamples = Object.entries(fieldExamples)\n    .filter(([type]) => config.systemPromptFields.includes(type));\n\n  if (selectedFieldExamples.length > 0) {\n    prompt += `\n\n## Field Examples\n\nEach field type has a complete example configuration:\n\n### Available Field Types (Selected: ${config.systemPromptFields.join(', ')})\n${selectedFieldExamples\n  .map(\n    ([type, example]) => `**${type}**: \\`${JSON.stringify(example, null, 2)}\\``\n  )\n  .join(\"\\n\\n\")}`;\n  } else {\n    prompt += `\n\n## Field Examples\n\nNo specific field types selected. Use the default formedible field types as needed.`;\n  }\n\n  prompt += `\n\n## Complete Form Example\n\nBased on your current configuration:\n\n\\`\\`\\`json\n${JSON.stringify(basicExample, null, 2)}\n\\`\\`\\`\n\nWhen generating forms, use these field examples and adapt the structure based on the configuration options above.`;\n\n  return prompt;\n}\n",
      "type": "registry:lib",
      "target": "lib/formedible/parser-config-schema.ts"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}