{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-formedible",
  "type": "registry:hook",
  "title": "Use Formedible",
  "description": "A powerful React hook for creating schema-driven forms with TanStack Form and shadcn/ui components",
  "dependencies": [
    "@tanstack/react-form",
    "@radix-ui/react-checkbox",
    "@radix-ui/react-label",
    "@radix-ui/react-select",
    "@radix-ui/react-switch",
    "date-fns",
    "react-day-picker",
    "lucide-react",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "calendar",
    "popover"
  ],
  "files": [
    {
      "path": "src/hooks/use-formedible.tsx",
      "content": "\"use client\";\nimport React, { useState, useMemo } from \"react\";\nimport { useForm } from \"@tanstack/react-form\";\nimport { z } from \"zod\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { TextField } from \"@/components/fields/text-field\";\nimport { TextareaField } from \"@/components/fields/textarea-field\";\nimport { SelectField } from \"@/components/fields/select-field\";\nimport { CheckboxField } from \"@/components/fields/checkbox-field\";\nimport { SwitchField } from \"@/components/fields/switch-field\";\nimport { NumberField } from \"@/components/fields/number-field\";\nimport { DateField } from \"@/components/fields/date-field\";\nimport { SliderField } from \"@/components/fields/slider-field\";\nimport { FileUploadField } from \"@/components/fields/file-upload-field\";\nimport { ArrayField } from \"@/components/fields/array-field\";\nimport { RadioField } from \"@/components/fields/radio-field\";\nimport { MultiSelectField } from \"@/components/fields/multi-select-field\";\nimport { ColorPickerField } from \"@/components/fields/color-picker-field\";\nimport { RatingField } from \"@/components/fields/rating-field\";\nimport { PhoneField } from \"@/components/fields/phone-field\";\nimport { InlineValidationWrapper } from \"@/components/fields/inline-validation-wrapper\";\nimport { FieldHelp } from \"@/components/fields/field-help\";\n\ninterface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  // HTML form attributes\n  action?: string;\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  encType?: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'text/plain';\n  target?: '_blank' | '_self' | '_parent' | '_top' | string;\n  autoComplete?: 'on' | 'off';\n  noValidate?: boolean;\n  acceptCharset?: string;\n  // Event handlers\n  onReset?: (e: React.FormEvent) => void;\n  onInput?: (e: React.FormEvent) => void;\n  onInvalid?: (e: React.FormEvent) => void;\n  onKeyDown?: (e: React.KeyboardEvent) => void;\n  onKeyUp?: (e: React.KeyboardEvent) => void;\n  onKeyPress?: (e: React.KeyboardEvent) => void;\n  onFocus?: (e: React.FocusEvent) => void;\n  onBlur?: (e: React.FocusEvent) => void;\n  // Accessibility\n  role?: string;\n  'aria-label'?: string;\n  'aria-labelledby'?: string;\n  'aria-describedby'?: string;\n  tabIndex?: number;\n}\n\ninterface FieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  description?: string;\n  options?: string[] | { value: string; label: string }[];\n  min?: number;\n  max?: number;\n  step?: number;\n  accept?: string;\n  multiple?: boolean;\n  component?: React.ComponentType<any>;\n  wrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>;\n  page?: number;\n  validation?: z.ZodSchema<any>;\n  dependencies?: string[];\n  conditional?: (values: any) => boolean;\n  // Array field configuration\n  arrayConfig?: {\n    itemType: string; // Type of items in the array ('text', 'email', 'number', etc.)\n    itemLabel?: string; // Label for each item (e.g., \"Email Address\")\n    itemPlaceholder?: string; // Placeholder for each item\n    itemValidation?: z.ZodSchema<any>; // Validation for each item\n    minItems?: number; // Minimum number of items\n    maxItems?: number; // Maximum number of items\n    addButtonLabel?: string; // Label for add button\n    removeButtonLabel?: string; // Label for remove button\n    itemComponent?: React.ComponentType<any>; // Custom component for each item\n    sortable?: boolean; // Whether items can be reordered\n    defaultValue?: any; // Default value for new items\n  };\n  // Datalist configuration for text inputs\n  datalist?: {\n    options?: string[]; // Static options\n    asyncOptions?: (query: string) => Promise<string[]>; // Async function for dynamic options\n    debounceMs?: number; // Debounce time for async calls\n    minChars?: number; // Minimum characters to trigger async search\n    maxResults?: number; // Maximum number of results to show\n  };\n  // Help and tooltip configuration\n  help?: {\n    text?: string; // Help text displayed below field\n    tooltip?: string; // Tooltip text on hover/focus\n    position?: 'top' | 'bottom' | 'left' | 'right'; // Tooltip position\n    link?: { url: string; text: string }; // Help link\n  };\n  // Inline validation configuration\n  inlineValidation?: {\n    enabled?: boolean; // Enable inline validation\n    debounceMs?: number; // Debounce time for validation\n    showSuccess?: boolean; // Show success state\n    asyncValidator?: (value: any) => Promise<string | null>; // Async validation function\n  };\n  // Field grouping\n  group?: string; // Group name for organizing fields\n  section?: {\n    title: string; // Section title\n    description?: string; // Section description\n    collapsible?: boolean; // Whether section can be collapsed\n    defaultExpanded?: boolean; // Default expansion state\n  };\n  // Rating field specific\n  ratingConfig?: {\n    max?: number; // Maximum rating (default 5)\n    allowHalf?: boolean; // Allow half ratings\n    icon?: 'star' | 'heart' | 'thumbs'; // Rating icon type\n    size?: 'sm' | 'md' | 'lg'; // Icon size\n    showValue?: boolean; // Show numeric value\n  };\n  // Phone field specific\n  phoneConfig?: {\n    defaultCountry?: string; // Default country code\n    format?: 'national' | 'international'; // Phone format\n    allowedCountries?: string[]; // Allowed country codes\n    placeholder?: string; // Custom placeholder\n  };\n  // Color picker specific\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl'; // Color format\n    showPreview?: boolean; // Show color preview\n    presetColors?: string[]; // Preset color options\n    allowCustom?: boolean; // Allow custom colors\n  };\n  // Multi-select specific\n  multiSelectConfig?: {\n    maxSelections?: number; // Maximum selections\n    searchable?: boolean; // Enable search\n    creatable?: boolean; // Allow creating new options\n    placeholder?: string; // Placeholder text\n    noOptionsText?: string; // Text when no options\n    loadingText?: string; // Loading text\n  };\n}\n\ninterface PageConfig {\n  page: number;\n  title?: string;\n  description?: string;\n  component?: React.ComponentType<{ \n    children: React.ReactNode; \n    title?: string; \n    description?: string; \n    page: number;\n    totalPages: number;\n  }>;\n}\n\ninterface ProgressConfig {\n  component?: React.ComponentType<{ \n    value: number; \n    currentPage: number; \n    totalPages: number; \n    className?: string;\n  }>;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n  className?: string;\n}\n\ninterface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  schema?: z.ZodSchema<TFormValues>;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  pages?: PageConfig[];\n  progress?: ProgressConfig;\n  defaultComponents?: {\n    [key: string]: React.ComponentType<any>;\n  };\n  globalWrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>;\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: { value: TFormValues; formApi: any }) => any | Promise<any>;\n    onSubmitInvalid: (props: { value: TFormValues; formApi: any }) => void;\n    onChange?: (props: { value: TFormValues; formApi: any }) => void;\n    onBlur?: (props: { value: TFormValues; formApi: any }) => void;\n    onFocus?: (props: { value: TFormValues; formApi: any }) => void;\n    onReset?: (props: { value: TFormValues; formApi: any }) => void;\n    asyncDebounceMs: number;\n    canSubmitWhenInvalid: boolean;\n    validators: {\n      onChange?: z.ZodSchema<any>;\n      onChangeAsync?: z.ZodSchema<any>;\n      onChangeAsyncDebounceMs?: number;\n      onBlur?: z.ZodSchema<any>;\n      onBlurAsync?: z.ZodSchema<any>;\n      onBlurAsyncDebounceMs?: number;\n      onSubmit?: z.ZodSchema<any>;\n      onSubmitAsync?: z.ZodSchema<any>;\n    };\n  }>;\n  onPageChange?: (page: number, direction: 'next' | 'previous') => void;\n  autoSubmitOnChange?: boolean;\n  autoSubmitDebounceMs?: number;\n  disabled?: boolean;\n  loading?: boolean;\n  resetOnSubmitSuccess?: boolean;\n  showSubmitButton?: boolean;\n  // Form-level event handlers\n  onFormReset?: (e: React.FormEvent, formApi: any) => void;\n  onFormInput?: (e: React.FormEvent, formApi: any) => void;\n  onFormInvalid?: (e: React.FormEvent, formApi: any) => void;\n  onFormKeyDown?: (e: React.KeyboardEvent, formApi: any) => void;\n  onFormKeyUp?: (e: React.KeyboardEvent, formApi: any) => void;\n  onFormFocus?: (e: React.FocusEvent, formApi: any) => void;\n  onFormBlur?: (e: React.FocusEvent, formApi: any) => void;\n}\n\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  number: NumberField,\n  date: DateField,\n  slider: SliderField,\n  file: FileUploadField,\n  array: ArrayField,\n  radio: RadioField,\n  multiSelect: MultiSelectField,\n  colorPicker: ColorPickerField,\n  rating: RatingField,\n  phone: PhoneField,\n};\n\nconst DefaultProgressComponent: React.FC<{\n  value: number;\n  currentPage: number;\n  totalPages: number;\n  className?: string;\n}> = ({ value, currentPage, totalPages, className }) => (\n  <div className={cn(\"space-y-2\", className)}>\n    <div className=\"flex justify-between text-sm text-muted-foreground\">\n      <span>Step {currentPage} of {totalPages}</span>\n      <span>{Math.round(value)}%</span>\n    </div>\n    <Progress value={value} className=\"h-2\" />\n  </div>\n);\n\nconst DefaultPageComponent: React.FC<{\n  children: React.ReactNode;\n  title?: string;\n  description?: string;\n  page: number;\n  totalPages: number;\n}> = ({ children, title, description }) => (\n  <div className=\"space-y-6\">\n    {(title || description) && (\n      <div className=\"space-y-2\">\n        {title && <h3 className=\"text-lg font-semibold\">{title}</h3>}\n        {description && <p className=\"text-muted-foreground\">{description}</p>}\n      </div>\n    )}\n    <div className=\"space-y-4\">\n      {children}\n    </div>\n  </div>\n);\n\nexport function useFormedible<TFormValues extends Record<string, any>>(\n  options: UseFormedibleOptions<TFormValues>\n) {\n  const {\n    fields = [],\n    schema,\n    submitLabel = \"Submit\",\n    nextLabel = \"Next\",\n    previousLabel = \"Previous\",\n    formClassName,\n    fieldClassName,\n    pages = [],\n    progress,\n    defaultComponents = {},\n    globalWrapper,\n    formOptions,\n    onPageChange,\n    autoSubmitOnChange = false,\n    autoSubmitDebounceMs = 1000,\n    disabled = false,\n    loading = false,\n    resetOnSubmitSuccess = false,\n    showSubmitButton = true,\n    // Form-level event handlers\n    onFormReset,\n    onFormInput,\n    onFormInvalid,\n    onFormKeyDown,\n    onFormKeyUp,\n    onFormFocus,\n    onFormBlur,\n  } = options;\n\n  const [currentPage, setCurrentPage] = useState(1);\n\n  // Combine default components with user overrides\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\n\n  // Group fields by pages\n  const fieldsByPage = useMemo(() => {\n    const grouped: { [page: number]: FieldConfig[] } = {};\n    \n    fields.forEach(field => {\n      const page = field.page || 1;\n      if (!grouped[page]) grouped[page] = [];\n      grouped[page].push(field);\n    });\n\n    return grouped;\n  }, [fields]);\n\n  const totalPages = Math.max(...Object.keys(fieldsByPage).map(Number), 1);\n  const hasPages = totalPages > 1;\n\n  // Calculate progress\n  const progressValue = hasPages ? ((currentPage - 1) / (totalPages - 1)) * 100 : 100;\n\n  // Setup form with schema validation if provided\n  const formConfig = {\n    ...formOptions,\n    ...(schema && {\n      validators: {\n        onChange: schema,\n        ...formOptions?.validators,\n      }\n    }),\n    ...(resetOnSubmitSuccess && formOptions?.onSubmit && {\n      onSubmit: async (props: any) => {\n        try {\n          const result = await formOptions.onSubmit!(props);\n          // Reset form on successful submit if option is enabled\n          form.reset();\n          return result;\n        } catch (error) {\n          throw error;\n        }\n      }\n    })\n  };\n\n  const form = useForm(formConfig as any);\n\n  // Set up form event listeners if provided\n  React.useEffect(() => {\n    const unsubscribers: (() => void)[] = [];\n    let autoSubmitTimeout: NodeJS.Timeout;\n    let onChangeTimeout: NodeJS.Timeout;\n    let onBlurTimeout: NodeJS.Timeout;\n\n    if (formOptions?.onChange || autoSubmitOnChange) {\n      const unsubscribe = form.store.subscribe(() => {\n        const formApi = form;\n        const values = formApi.state.values;\n        \n        // Call user's onChange handler only if form is valid (debounced)\n        if (formOptions?.onChange && formApi.state.isValid) {\n          clearTimeout(onChangeTimeout);\n          onChangeTimeout = setTimeout(() => {\n            formOptions.onChange!({ value: values as TFormValues, formApi });\n          }, 300); // 300ms debounce\n        }\n\n        // Handle auto-submit on change\n        if (autoSubmitOnChange && !disabled && !loading) {\n          clearTimeout(autoSubmitTimeout);\n          autoSubmitTimeout = setTimeout(() => {\n            if (form.state.canSubmit) {\n              form.handleSubmit();\n            }\n          }, autoSubmitDebounceMs);\n        }\n      });\n      unsubscribers.push(unsubscribe);\n    }\n\n    // Set up onBlur event listener\n    if (formOptions?.onBlur) {\n      let lastFocusedField: string | null = null;\n      \n      const handleBlur = (event: FocusEvent) => {\n        const target = event.target as HTMLElement;\n        const fieldName = target.getAttribute('name');\n        \n        if (fieldName && lastFocusedField === fieldName) {\n          clearTimeout(onBlurTimeout);\n          onBlurTimeout = setTimeout(() => {\n            const formApi = form;\n            const values = formApi.state.values;\n            formOptions.onBlur!({ value: values as TFormValues, formApi });\n          }, 100); // 100ms debounce for blur\n        }\n      };\n\n      const handleFocus = (event: FocusEvent) => {\n        const target = event.target as HTMLElement;\n        const fieldName = target.getAttribute('name');\n        lastFocusedField = fieldName;\n      };\n\n      // Add event listeners to document for blur/focus events\n      document.addEventListener('blur', handleBlur, true);\n      document.addEventListener('focus', handleFocus, true);\n      \n      unsubscribers.push(() => {\n        document.removeEventListener('blur', handleBlur, true);\n        document.removeEventListener('focus', handleFocus, true);\n      });\n    }\n\n    // Clean up timeouts on unmount\n    unsubscribers.push(() => {\n      clearTimeout(autoSubmitTimeout);\n      clearTimeout(onChangeTimeout);\n      clearTimeout(onBlurTimeout);\n    });\n\n    return () => {\n      unsubscribers.forEach(unsub => unsub());\n    };\n  }, [form, autoSubmitOnChange, autoSubmitDebounceMs, disabled, loading, formOptions?.onChange, formOptions?.onBlur]);\n\n  const getCurrentPageFields = () => fieldsByPage[currentPage] || [];\n\n  const getCurrentPageConfig = () => pages.find(p => p.page === currentPage);\n\n  const goToNextPage = () => {\n    if (currentPage < totalPages) {\n      // Check if current page has validation errors\n      const currentPageFields = getCurrentPageFields();\n      const formState = form.state;\n      \n      const hasPageErrors = currentPageFields.some(field => {\n        const fieldState = formState.fieldMeta[field.name];\n        return fieldState && fieldState.errors && fieldState.errors.length > 0;\n      });\n\n      if (hasPageErrors) {\n        // Mark all fields on current page as touched to show validation errors\n        currentPageFields.forEach(field => {\n          form.setFieldMeta(field.name, (prev) => ({ ...prev, isTouched: true }));\n        });\n        return; // Don't navigate if there are errors\n      }\n\n      const newPage = currentPage + 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, 'next');\n    }\n  };\n\n  const goToPreviousPage = () => {\n    if (currentPage > 1) {\n      const newPage = currentPage - 1;\n      setCurrentPage(newPage);\n      onPageChange?.(newPage, 'previous');\n    }\n  };\n\n  const isLastPage = currentPage === totalPages;\n  const isFirstPage = currentPage === 1;\n\n  // Validated setCurrentPage that checks all pages between current and target\n  const setCurrentPageWithValidation = (targetPage: number) => {\n    if (targetPage < 1 || targetPage > totalPages || targetPage === currentPage) {\n      return;\n    }\n\n    // If going forward, validate all pages between current and target\n    if (targetPage > currentPage) {\n      for (let page = currentPage; page < targetPage; page++) {\n        const pageFields = fieldsByPage[page] || [];\n        const formState = form.state;\n        \n        const hasPageErrors = pageFields.some(field => {\n          const fieldState = formState.fieldMeta[field.name];\n          return fieldState && fieldState.errors && fieldState.errors.length > 0;\n        });\n\n        if (hasPageErrors) {\n          // Mark all fields on this page as touched to show validation errors\n          pageFields.forEach(field => {\n            form.setFieldMeta(field.name, (prev) => ({ ...prev, isTouched: true }));\n          });\n          return; // Don't navigate if there are errors\n        }\n      }\n    }\n\n    // If validation passes or going backward, allow navigation\n    setCurrentPage(targetPage);\n    onPageChange?.(targetPage, targetPage > currentPage ? 'next' : 'previous');\n  };\n\n  const Form: React.FC<FormProps> = ({ \n    className, \n    children, \n    onSubmit,\n    // HTML form attributes\n    action,\n    method,\n    encType,\n    target,\n    autoComplete,\n    noValidate,\n    acceptCharset,\n    // Event handlers\n    onReset,\n    onInput,\n    onInvalid,\n    onKeyDown,\n    onKeyUp,\n    onKeyPress,\n    onFocus,\n    onBlur,\n    // Accessibility\n    role,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby,\n    'aria-describedby': ariaDescribedby,\n    tabIndex,\n  }) => {\n    const handleSubmit = (e: React.FormEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (onSubmit) {\n        onSubmit(e);\n      } else if (isLastPage) {\n        form.handleSubmit();\n      } else {\n        goToNextPage();\n      }\n    };\n\n    const handleReset = (e: React.FormEvent) => {\n      if (onReset) {\n        onReset(e);\n      }\n      if (onFormReset) {\n        onFormReset(e, form);\n      }\n      form.reset();\n    };\n\n    const handleInput = (e: React.FormEvent) => {\n      if (onInput) {\n        onInput(e);\n      }\n      if (onFormInput) {\n        onFormInput(e, form);\n      }\n    };\n\n    const handleInvalid = (e: React.FormEvent) => {\n      if (onInvalid) {\n        onInvalid(e);\n      }\n      if (onFormInvalid) {\n        onFormInvalid(e, form);\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n      if (onFormKeyDown) {\n        onFormKeyDown(e, form);\n      }\n    };\n\n    const handleKeyUp = (e: React.KeyboardEvent) => {\n      if (onKeyUp) {\n        onKeyUp(e);\n      }\n      if (onFormKeyUp) {\n        onFormKeyUp(e, form);\n      }\n    };\n\n    const handleKeyPress = (e: React.KeyboardEvent) => {\n      if (onKeyPress) {\n        onKeyPress(e);\n      }\n    };\n\n    const handleFocus = (e: React.FocusEvent) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      if (onFormFocus) {\n        onFormFocus(e, form);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      if (onFormBlur) {\n        onFormBlur(e, form);\n      }\n    };\n\n    const formClass = cn(\"space-y-6\", formClassName, className);\n\n    const renderField = (fieldConfig: FieldConfig) => {\n      const { \n        name, \n        type, \n        label, \n        placeholder, \n        description, \n        options,\n        min,\n        max,\n        step,\n        accept,\n        multiple,\n        component: CustomComponent,\n        wrapper: CustomWrapper,\n        conditional,\n        validation,\n        arrayConfig,\n        datalist,\n        help,\n        inlineValidation,\n        group,\n        section,\n        ratingConfig,\n        phoneConfig,\n        colorConfig,\n        multiSelectConfig\n      } = fieldConfig;\n\n      return (\n        <form.Field \n          key={name} \n          name={name as keyof TFormValues & string}\n          validators={validation ? { onChange: validation } : undefined}\n        >\n          {(field) => {\n            // Get current form values directly from the field\n            const currentValues = field.form.state.values;\n            \n            // Check conditional rendering with current form values\n            if (conditional && !conditional(currentValues)) {\n              return null;\n            }\n\n            const baseProps = {\n              fieldApi: field,\n              label,\n              placeholder,\n              description,\n              wrapperClassName: fieldClassName,\n              min,\n              max,\n              step,\n              accept,\n              multiple,\n              disabled: disabled || loading || field.form.state.isSubmitting,\n            };\n\n            // Select the component to use\n            const FieldComponent = CustomComponent || fieldComponents[type] || TextField;\n\n            // Add type-specific props\n            let props: any = { ...baseProps };\n            \n            if (type === 'select') {\n              props = { ...props, options: options || [] };\n            } else if (type === 'array') {\n              props = { ...props, arrayConfig };\n            } else if (['text', 'email', 'password', 'url', 'tel'].includes(type)) {\n              props = { ...props, type, datalist };\n            } else if (type === 'radio') {\n              props = { ...props, options: options || [] };\n            } else if (type === 'multiSelect') {\n              props = { ...props, options: options || [], multiSelectConfig };\n            } else if (type === 'colorPicker') {\n              props = { ...props, colorConfig };\n            } else if (type === 'rating') {\n              props = { ...props, ratingConfig };\n            } else if (type === 'phone') {\n              props = { ...props, phoneConfig };\n            }\n\n            // Render the field component\n            const fieldElement = <FieldComponent {...props} />;\n\n            // Apply inline validation wrapper if enabled\n            const wrappedFieldElement = inlineValidation?.enabled \n              ? (\n                  <InlineValidationWrapper\n                    fieldApi={field}\n                    inlineValidation={inlineValidation}\n                  >\n                    {fieldElement}\n                  </InlineValidationWrapper>\n                )\n              : fieldElement;\n\n            // Add field help if provided\n            const fieldWithHelp = help ? (\n              <div className=\"space-y-2\">\n                {wrappedFieldElement}\n                <FieldHelp help={help} />\n              </div>\n            ) : wrappedFieldElement;\n\n            // Apply custom wrapper or global wrapper\n            const Wrapper = CustomWrapper || globalWrapper;\n            \n            return Wrapper \n              ? <Wrapper field={fieldConfig}>{fieldWithHelp}</Wrapper>\n              : fieldWithHelp;\n          }}\n        </form.Field>\n      );\n    };\n\n    const renderPageContent = () => {\n      const currentFields = getCurrentPageFields();\n      const pageConfig = getCurrentPageConfig();\n      \n      // Group fields by section and group\n      const groupedFields = currentFields.reduce((acc, field) => {\n        const sectionKey = field.section?.title || 'default';\n        const groupKey = field.group || 'default';\n        \n        if (!acc[sectionKey]) {\n          acc[sectionKey] = {\n            section: field.section,\n            groups: {}\n          };\n        }\n        \n        if (!acc[sectionKey].groups[groupKey]) {\n          acc[sectionKey].groups[groupKey] = [];\n        }\n        \n        acc[sectionKey].groups[groupKey].push(field);\n        return acc;\n      }, {} as Record<string, { section?: any; groups: Record<string, FieldConfig[]> }>);\n\n      const renderSection = (sectionKey: string, sectionData: any) => {\n        const { section, groups } = sectionData;\n        const [isExpanded, setIsExpanded] = React.useState(\n          section?.defaultExpanded !== false\n        );\n\n        const sectionContent = (\n          <div className=\"space-y-4\">\n            {Object.entries(groups).map(([groupKey, groupFields]) => (\n              <div key={groupKey} className={cn(\n                groupKey !== 'default' ? \"p-4 border rounded-lg bg-muted/20\" : \"\"\n              )}>\n                {groupKey !== 'default' && (\n                  <h4 className=\"font-medium text-sm text-muted-foreground mb-3 uppercase tracking-wide\">\n                    {groupKey}\n                  </h4>\n                )}\n                <div className={cn(\n                  groupKey !== 'default' ? \"space-y-3\" : \"space-y-4\"\n                )}>\n                                     {(groupFields as FieldConfig[]).map(field => renderField(field))}\n                </div>\n              </div>\n            ))}\n          </div>\n        );\n\n        if (section && sectionKey !== 'default') {\n          return (\n            <div key={sectionKey} className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <div className=\"flex items-center justify-between\">\n                  <h3 className=\"text-lg font-semibold\">{section.title}</h3>\n                  {section.collapsible && (\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => setIsExpanded(!isExpanded)}\n                      className=\"text-muted-foreground hover:text-foreground\"\n                    >\n                      {isExpanded ? 'Collapse' : 'Expand'}\n                    </Button>\n                  )}\n                </div>\n                {section.description && (\n                  <p className=\"text-muted-foreground text-sm\">{section.description}</p>\n                )}\n              </div>\n              \n              {(!section.collapsible || isExpanded) && sectionContent}\n            </div>\n          );\n        }\n\n        return sectionContent;\n      };\n\n      const sectionsToRender = Object.entries(groupedFields);\n      \n      const PageComponent = pageConfig?.component || DefaultPageComponent;\n\n      return (\n        <PageComponent\n          title={pageConfig?.title}\n          description={pageConfig?.description}\n          page={currentPage}\n          totalPages={totalPages}\n        >\n          {sectionsToRender.length === 1 && sectionsToRender[0][0] === 'default' \n                         ? sectionsToRender[0][1].groups.default?.map((field: FieldConfig) => renderField(field))\n            : sectionsToRender.map(([sectionKey, sectionData]) => \n                renderSection(sectionKey, sectionData)\n              )\n          }\n        </PageComponent>\n      );\n    };\n\n    const renderProgress = () => {\n      if (!hasPages || !progress) return null;\n\n      const ProgressComponent = progress.component || DefaultProgressComponent;\n      \n      return (\n        <ProgressComponent\n          value={progressValue}\n          currentPage={currentPage}\n          totalPages={totalPages}\n          className={progress.className}\n        />\n      );\n    };\n\n    const renderNavigation = () => {\n      if (!showSubmitButton) return null;\n      if (!hasPages) {\n        return (\n          <form.Subscribe\n            selector={(state) => ({\n              canSubmit: state.canSubmit,\n              isSubmitting: state.isSubmitting,\n            })}\n          >\n            {(state) => {\n              const { canSubmit, isSubmitting } = state as any;\n              return (\n                <Button\n                  type=\"submit\"\n                  disabled={!canSubmit || isSubmitting || disabled || loading}\n                  className=\"w-full\"\n                >\n                  {loading ? \"Loading...\" : isSubmitting ? \"Submitting...\" : submitLabel}\n                </Button>\n              );\n            }}\n          </form.Subscribe>\n        );\n      }\n\n      return (\n        <form.Subscribe\n          selector={(state) => ({\n            canSubmit: state.canSubmit,\n            isSubmitting: state.isSubmitting,\n          })}\n        >\n          {(state) => {\n            const { canSubmit, isSubmitting } = state as any;\n            return (\n              <div className=\"flex justify-between gap-4\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={goToPreviousPage}\n                  disabled={isFirstPage || disabled || loading}\n                  className={isFirstPage ? \"invisible\" : \"\"}\n                >\n                  {previousLabel}\n                </Button>\n                \n                <Button\n                  type=\"submit\"\n                  disabled={(!canSubmit || isSubmitting || disabled || loading) && isLastPage}\n                  className=\"flex-1 max-w-xs\"\n                >\n                  {loading && isLastPage\n                    ? \"Loading...\"\n                    : isSubmitting && isLastPage\n                    ? \"Submitting...\"\n                    : isLastPage\n                    ? submitLabel\n                    : nextLabel}\n                </Button>\n              </div>\n            );\n          }}\n        </form.Subscribe>\n      );\n    };\n\n          return (\n        <form \n          onSubmit={handleSubmit} \n          className={formClass}\n          action={action}\n          method={method}\n          encType={encType}\n          target={target}\n          autoComplete={autoComplete}\n          noValidate={noValidate}\n          acceptCharset={acceptCharset}\n          onReset={handleReset}\n          onInput={handleInput}\n          onInvalid={handleInvalid}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n          onKeyPress={handleKeyPress}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n          role={role}\n          aria-label={ariaLabel}\n          aria-labelledby={ariaLabelledby}\n          aria-describedby={ariaDescribedby}\n          tabIndex={tabIndex}\n        >\n        {children || (\n          <>\n            {renderProgress()}\n            {renderPageContent()}\n            {renderNavigation()}\n          </>\n        )}\n      </form>\n    );\n  };\n\n  return {\n    form,\n    Form,\n    currentPage,\n    totalPages,\n    goToNextPage,\n    goToPreviousPage,\n    setCurrentPage: setCurrentPageWithValidation,\n    isFirstPage,\n    isLastPage,\n    progressValue,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-formedible.tsx"
    },
    {
      "path": "src/lib/formedible/types.ts",
      "content": "import type { AnyFieldApi } from '@tanstack/react-form';\n\n// Props that all basic field components rendered by FormedibleRoot will receive\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  description?: string; // Added description\n  placeholder?: string;\n  inputClassName?: string;   // For the <Input /> component itself\n  labelClassName?: string;   // For the <Label /> component\n  wrapperClassName?: string; // For the div wrapping label and input\n} ",
      "type": "registry:hook",
      "target": "lib/formedible/types.ts"
    },
    {
      "path": "src/components/fields/text-field.tsx",
      "content": "'use client';\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '../../lib/formedible/types';\n\nexport interface TextFieldSpecificProps extends BaseFieldProps {\n  type?: 'text' | 'email' | 'password' | 'url' | 'tel' | 'datetime-local';\n  datalist?: {\n    options?: string[];\n    asyncOptions?: (query: string) => Promise<string[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n  };\n}\n\nexport const TextField: React.FC<TextFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  type = 'text',\n  datalist,\n}) => {\n  const { name, state, handleChange, handleBlur } = fieldApi;\n  const value = state.value as string | number | undefined;\n  \n  // Datalist state\n  const [datalistOptions, setDatalistOptions] = useState<string[]>(datalist?.options || []);\n  const [isLoadingOptions, setIsLoadingOptions] = useState(false);\n  const [lastQuery, setLastQuery] = useState('');\n\n  // Debounced async options fetching\n  const fetchAsyncOptions = useCallback(\n    async (query: string) => {\n      if (!datalist?.asyncOptions) return;\n      \n      const minChars = datalist.minChars || 1;\n      if (query.length < minChars) {\n        setDatalistOptions(datalist.options || []);\n        return;\n      }\n\n      if (query === lastQuery) return;\n      \n      setIsLoadingOptions(true);\n      setLastQuery(query);\n      \n      try {\n        const results = await datalist.asyncOptions(query);\n        const maxResults = datalist.maxResults || 10;\n        const limitedResults = results.slice(0, maxResults);\n        \n        // Combine static options with async results\n        const staticOptions = datalist.options || [];\n        const combinedOptions = [...staticOptions, ...limitedResults];\n        \n        // Remove duplicates\n        const uniqueOptions = Array.from(new Set(combinedOptions));\n        \n        setDatalistOptions(uniqueOptions);\n      } catch (error) {\n        console.error('Error fetching datalist options:', error);\n        // Fallback to static options on error\n        setDatalistOptions(datalist.options || []);\n      } finally {\n        setIsLoadingOptions(false);\n      }\n    },\n    [datalist, lastQuery]\n  );\n\n  // Debounced effect for async options\n  useEffect(() => {\n    if (!datalist?.asyncOptions) return;\n    \n    const debounceMs = datalist.debounceMs || 300;\n    const currentValue = String(value || '');\n    \n    const timeoutId = setTimeout(() => {\n      fetchAsyncOptions(currentValue);\n    }, debounceMs);\n\n    return () => clearTimeout(timeoutId);\n  }, [value, fetchAsyncOptions, datalist]);\n\n  // Generate unique datalist id\n  const datalistId = useMemo(() => \n    datalist ? `${name}-datalist` : undefined, \n    [name, datalist]\n  );\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    handleChange(e.target.value);\n  };\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n          {isLoadingOptions && (\n            <span className=\"ml-2 text-xs text-muted-foreground\">Loading...</span>\n          )}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Input\n        id={name}\n        name={name}\n        type={type}\n        value={value === undefined || value === null ? '' : String(value)}\n        onBlur={handleBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        className={cn(inputClassName, state.meta.errors.length ? \"border-destructive\" : \"\")}\n        disabled={fieldApi.form.state.isSubmitting}\n        list={datalistId}\n        autoComplete={datalist ? \"off\" : undefined}\n      />\n      {datalist && datalistOptions.length > 0 && (\n        <datalist id={datalistId}>\n          {datalistOptions.map((option, index) => (\n            <option key={`${option}-${index}`} value={option} />\n          ))}\n        </datalist>\n      )}\n      {state.meta.isTouched && state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{typeof err === 'string' ? err : (err as Error)?.message || 'Invalid'}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/text-field.tsx"
    },
    {
      "path": "src/components/fields/textarea-field.tsx",
      "content": "import React from 'react';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '../../lib/formedible/types';\n\nexport interface TextareaFieldSpecificProps extends BaseFieldProps {\n  rows?: number;\n}\n\nexport const TextareaField: React.FC<TextareaFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  placeholder,\n  description,\n  rows = 3,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={fieldApi.name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Textarea\n        id={fieldApi.name}\n        name={fieldApi.name}\n        value={(fieldApi.state.value as string) || ''}\n        onBlur={fieldApi.handleBlur}\n        onChange={(e) => fieldApi.handleChange(e.target.value)}\n        placeholder={placeholder}\n        rows={rows}\n        className={cn(inputClassName, fieldApi.state.meta.errors.length ? \"border-destructive\" : \"\")}\n        disabled={fieldApi.form.state.isSubmitting}\n      />\n      {fieldApi.state.meta.isTouched && fieldApi.state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{String(err)}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/textarea-field.tsx"
    },
    {
      "path": "src/components/fields/select-field.tsx",
      "content": "import React from 'react';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\ninterface SelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n}\n\nexport const SelectField: React.FC<SelectFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  placeholder,\n  description,\n  options = [],\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={fieldApi.name + \"-trigger\"} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Select\n        value={(fieldApi.state.value as string) || ''}\n        onValueChange={(value) => fieldApi.handleChange(value)}\n        disabled={fieldApi.form.state.isSubmitting}\n      >\n        <SelectTrigger\n          id={fieldApi.name + \"-trigger\"}\n          onBlur={fieldApi.handleBlur}\n          className={cn(inputClassName, fieldApi.state.meta.errors.length ? \"border-destructive\" : \"\")}\n        >\n          <SelectValue placeholder={placeholder || \"Select an option\"} />\n        </SelectTrigger>\n        <SelectContent>\n          {options.map((option, index) => {\n            const value = typeof option === 'string' ? option : option.value;\n            const label = typeof option === 'string' ? option : option.label;\n            return (\n              <SelectItem key={value + index} value={value}>\n                {label}\n              </SelectItem>\n            );\n          })}\n        </SelectContent>\n      </Select>\n      {fieldApi.state.meta.isTouched && fieldApi.state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{String(err)}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/select-field.tsx"
    },
    {
      "path": "src/components/fields/checkbox-field.tsx",
      "content": "import React from 'react';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\nexport const CheckboxField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      <div className=\"flex items-center space-x-2\">\n        <Checkbox\n          id={fieldApi.name}\n          checked={!!fieldApi.state.value}\n          onCheckedChange={(checked) => fieldApi.handleChange(Boolean(checked))}\n          onBlur={fieldApi.handleBlur}\n          disabled={fieldApi.form.state.isSubmitting}\n          aria-describedby={description ? `${fieldApi.name}-description` : undefined}\n        />\n        {label && (\n          <Label htmlFor={fieldApi.name} className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}>\n            {label}\n          </Label>\n        )}\n      </div>\n      {description && <p id={`${fieldApi.name}-description`} className=\"text-xs text-muted-foreground\">{description}</p>}\n      {fieldApi.state.meta.isTouched && fieldApi.state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{String(err)}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/checkbox-field.tsx"
    },
    {
      "path": "src/components/fields/switch-field.tsx",
      "content": "import React from 'react';\nimport { Switch } from '@/components/ui/switch';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\nexport const SwitchField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      <div className=\"flex items-center space-x-2\">\n        <Switch\n          id={fieldApi.name}\n          checked={!!fieldApi.state.value}\n          onCheckedChange={(checked) => fieldApi.handleChange(checked)}\n          onBlur={fieldApi.handleBlur}\n          disabled={fieldApi.form.state.isSubmitting}\n          aria-describedby={description ? `${fieldApi.name}-description` : undefined}\n        />\n        {label && (\n          <Label htmlFor={fieldApi.name} className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}>\n            {label}\n          </Label>\n        )}\n      </div>\n      {description && <p id={`${fieldApi.name}-description`} className=\"text-xs text-muted-foreground\">{description}</p>}\n      {fieldApi.state.meta.isTouched && fieldApi.state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{String(err)}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/switch-field.tsx"
    },
    {
      "path": "src/components/fields/number-field.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '../../lib/formedible/types';\n\nexport interface NumberFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nexport const NumberField: React.FC<NumberFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  min,\n  max,\n  step,\n}) => {\n  const { name, state, handleChange, handleBlur } = fieldApi;\n  const value = state.value as number | string | undefined;\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value;\n    if (val === '') {\n      handleChange(undefined);\n    } else {\n      const num = parseFloat(val);\n      handleChange(isNaN(num) ? val : num);\n    }\n  };\n\n  let displayValue: string | number = '';\n  if (typeof value === 'number') {\n    displayValue = value;\n  } else if (typeof value === 'string') {\n    displayValue = value;\n  }\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Input\n        id={name}\n        name={name}\n        type=\"number\"\n        value={displayValue}\n        onBlur={handleBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        min={min}\n        max={max}\n        step={step}\n        className={cn(inputClassName, state.meta.errors.length ? \"border-destructive\" : \"\")}\n        disabled={fieldApi.form.state.isSubmitting}\n      />\n      {state.meta.isTouched && state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{typeof err === 'string' ? err : (err as Error)?.message || 'Invalid'}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/number-field.tsx"
    },
    {
      "path": "src/components/fields/date-field.tsx",
      "content": "import React from 'react';\nimport { format, parseISO } from 'date-fns';\nimport { Calendar as CalendarIcon } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport { Label } from '@/components/ui/label';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\nexport const DateField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  placeholder = \"Pick a date\",\n  description,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const [isOpen, setIsOpen] = React.useState(false);\n\n  const selectedDate = fieldApi.state.value\n    ? fieldApi.state.value instanceof Date\n      ? fieldApi.state.value\n      : typeof fieldApi.state.value === 'string'\n        ? parseISO(fieldApi.state.value)\n        : undefined\n    : undefined;\n\n  const handleDateSelect = (date: Date | undefined) => {\n    fieldApi.handleChange(date);\n    fieldApi.handleBlur();\n    setIsOpen(false);\n  };\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={fieldApi.name + \"-trigger\"} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            id={fieldApi.name + \"-trigger\"}\n            variant={\"outline\"}\n            className={cn(\n              \"w-full justify-start text-left font-normal\",\n              !selectedDate && \"text-muted-foreground\",\n              inputClassName,\n              fieldApi.state.meta.errors.length ? \"border-destructive\" : \"\"\n            )}\n            disabled={fieldApi.form.state.isSubmitting}\n            onBlur={fieldApi.handleBlur}\n          >\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\n            {selectedDate ? format(selectedDate, \"PPP\") : <span>{placeholder}</span>}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\">\n          <Calendar\n            mode=\"single\"\n            selected={selectedDate}\n            onSelect={handleDateSelect}\n            initialFocus\n            disabled={fieldApi.form.state.isSubmitting}\n          />\n        </PopoverContent>\n      </Popover>\n      {fieldApi.state.meta.isTouched && fieldApi.state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{String(err)}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/date-field.tsx"
    },
    {
      "path": "src/components/fields/slider-field.tsx",
      "content": "import React from 'react';\nimport { Slider } from '@/components/ui/slider';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '../../lib/formedible/types';\n\nexport interface SliderFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  valueLabelPrefix?: string; // E.g., \"Temperature\"\n  valueLabelSuffix?: string; // E.g., \"FPS\" \n  valueDisplayPrecision?: number; // For toFixed()\n  showRawValue?: boolean; // Optionally show raw value next to formatted one\n}\n\nexport const SliderField: React.FC<SliderFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  min = 0,\n  max = 100,\n  step = 1,\n  valueLabelPrefix = '',\n  valueLabelSuffix = '',\n  valueDisplayPrecision = 0,\n  showRawValue = false,\n  wrapperClassName,\n  inputClassName,\n  labelClassName,\n}) => {\n  const { name, state, handleChange, handleBlur } = fieldApi;\n  const fieldValue = typeof state.value === 'number' ? state.value : min;\n  const displayValue = fieldValue.toFixed(valueDisplayPrecision);\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={cn(\"text-sm font-medium\", labelClassName)}>\n          {label} ({valueLabelPrefix}{displayValue}{valueLabelSuffix})\n          {showRawValue && <span className=\"text-xs text-muted-foreground ml-2\">(Raw: {state.value})</span>}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Slider\n        id={name}\n        name={name}\n        value={[fieldValue]} // Slider expects an array\n        onValueChange={(valueArray) => handleChange(valueArray[0])} // Send single number to form state\n        onBlur={handleBlur}\n        disabled={fieldApi.form.state.isSubmitting}\n        min={min}\n        max={max}\n        step={step}\n        className={cn(inputClassName, state.meta.errors.length ? \"border-destructive\" : \"\")}\n      />\n      {state.meta.isTouched && state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{typeof err === 'string' ? err : (err as Error)?.message || 'Invalid'}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/fields/slider-field.tsx"
    },
    {
      "path": "src/components/fields/file-upload-field.tsx",
      "content": "import React from \"react\";\nimport type { AnyFieldApi } from \"@tanstack/react-form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport { PaperclipIcon, XIcon, UploadCloudIcon } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface FileUploadFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  accept?: string;\n  className?: string;\n  wrapperClassName?: string;\n  description?: string;\n}\n\nexport const FileUploadField: React.FC<FileUploadFieldProps> = ({\n  fieldApi,\n  label,\n  accept,\n  className,\n  wrapperClassName,\n  description,\n}) => {\n  const { name, state, handleChange, handleBlur } = fieldApi;\n  const file = state.value as File | null;\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFile = e.target.files?.[0] ?? null;\n    handleChange(selectedFile);\n    handleBlur();\n  };\n\n  const handleRemoveFile = () => {\n    handleChange(null);\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    if (inputElement) {\n      inputElement.value = \"\";\n    }\n    handleBlur();\n  };\n\n  const triggerFileInput = () => {\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    inputElement?.click();\n  };\n\n  return (\n    <div\n      className={cn(\"space-y-1.5\", wrapperClassName)}\n    >\n      {label && (\n        <Label className=\"text-sm font-medium cursor-pointer\" onClick={triggerFileInput}>\n          {label}\n        </Label>\n      )}\n      {description && <p className=\"text-xs text-muted-foreground\">{description}</p>}\n      <Input\n        id={name}\n        name={name}\n        type=\"file\"\n        accept={accept}\n        onChange={handleFileChange}\n        className=\"hidden\"\n      />\n      {file ? (\n        <div\n          className=\"flex items-center justify-between p-2.5 border rounded-lg bg-muted/40 shadow-sm hover:shadow-md transition-shadow\"\n        >\n          <div className=\"flex items-center gap-2 text-sm overflow-hidden\">\n            <PaperclipIcon className=\"h-5 w-5 text-primary shrink-0\" />\n            <span className=\"truncate\" title={file.name}>{file.name}</span>\n            <span className=\"text-xs text-muted-foreground whitespace-nowrap\">\n              ({(file.size / 1024).toFixed(1)} KB)\n            </span>\n          </div>\n          <Button\n            type=\"button\"\n            variant=\"ghost\"\n            size=\"icon\"\n            onClick={handleRemoveFile}\n            className=\"h-7 w-7 text-destructive hover:bg-destructive/10 shrink-0\"\n            aria-label=\"Remove file\"\n          >\n            <XIcon className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      ) : (\n        <button\n          type=\"button\"\n          onClick={triggerFileInput}\n          className={cn(\n            \"w-full flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-lg hover:border-primary transition-colors cursor-pointer bg-background hover:bg-muted/50\",\n            className,\n            state.meta.errors.length ? \"border-destructive hover:border-destructive\" : \"border-muted-foreground/50\",\n          )}\n        >\n          <UploadCloudIcon className=\"h-8 w-8 text-muted-foreground mb-2\" />\n          <span className=\"text-sm font-medium text-muted-foreground\">\n            Click or drag and drop a file\n          </span>\n          {accept && <span className=\"text-xs text-muted-foreground/80 mt-1\">Accepted types: {accept}</span>}\n        </button>\n      )}\n      {state.meta.isTouched && state.meta.errors.length > 0 && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {state.meta.errors.map((err: any, index: number) => (\n            <p key={index}>{typeof err === 'string' ? err : (err as Error)?.message || 'Invalid'}</p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/fields/file-upload-field.tsx"
    }
  ],
  "docs": "Make sure to install @tanstack/react-form and configure your shadcn/ui components before using this hook.",
  "categories": [
    "form",
    "hook"
  ]
}