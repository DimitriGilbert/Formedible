{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-formedible",
  "type": "registry:block",
  "title": "Formedible Form Builder",
  "description": "A powerful React hook for creating schema-driven forms with TanStack Form and shadcn/ui components. Includes field components, validation, and advanced features.",
  "dependencies": [
    "@tanstack/react-form",
    "zod",
    "date-fns",
    "react-day-picker",
    "lucide-react",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "calendar",
    "popover",
    "badge",
    "slider",
    "radio-group",
    "progress",
    "tabs",
    "accordion",
    "sonner"
  ],
  "files": [
    {
      "path": "src/hooks/use-formedible.tsx",
      "content": "\"use client\";\nimport React, { useState, useMemo, memo, useRef } from \"react\";\nimport { useForm, AnyFormApi, AnyFieldApi } from \"@tanstack/react-form\";\nimport { z } from \"zod\";\nimport { cn } from \"@/lib/utils\";\nimport type {\n  FormedibleFormApi,\n  FieldComponentProps,\n  BaseFieldProps,\n  FieldConfig,\n  PageConfig,\n  ProgressConfig,\n  FormProps,\n  ConditionalFieldsSubscriptionProps,\n  FieldConditionalRendererProps,\n  UseFormedibleOptions,\n  SectionRendererProps,\n  LayoutConfig,\n  FormGridProps,\n  TabAnalyticsState,\n  PageAnalyticsState,\n  AnalyticsContext,\n  PerformanceMetrics,\n} from \"@/lib/formedible/types\";\nimport { Button } from \"@/components/ui/button\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { TextField } from \"@/components/formedible/fields/text-field\";\nimport { TextareaField } from \"@/components/formedible/fields/textarea-field\";\nimport { SelectField } from \"@/components/formedible/fields/select-field\";\nimport { CheckboxField } from \"@/components/formedible/fields/checkbox-field\";\nimport { SwitchField } from \"@/components/formedible/fields/switch-field\";\nimport { NumberField } from \"@/components/formedible/fields/number-field\";\nimport { DateField } from \"@/components/formedible/fields/date-field\";\nimport { SliderField } from \"@/components/formedible/fields/slider-field\";\nimport { FileUploadField } from \"@/components/formedible/fields/file-upload-field\";\nimport { ArrayField } from \"@/components/formedible/fields/array-field\";\nimport { RadioField } from \"@/components/formedible/fields/radio-field\";\nimport { FormTabs } from \"@/components/formedible/layout/form-tabs\";\nimport { MultiSelectField } from \"@/components/formedible/fields/multi-select-field\";\nimport { ColorPickerField } from \"@/components/formedible/fields/color-picker-field\";\nimport { RatingField } from \"@/components/formedible/fields/rating-field\";\nimport { PhoneField } from \"@/components/formedible/fields/phone-field\";\nimport { LocationPickerField } from \"@/components/formedible/fields/location-picker-field\";\nimport { DurationPickerField } from \"@/components/formedible/fields/duration-picker-field\";\nimport { AutocompleteField } from \"@/components/formedible/fields/autocomplete-field\";\nimport { MaskedInputField } from \"@/components/formedible/fields/masked-input-field\";\nimport { ObjectField } from \"@/components/formedible/fields/object-field\";\nimport { InlineValidationWrapper } from \"@/components/formedible/fields/inline-validation-wrapper\";\nimport { FieldHelp } from \"@/components/formedible/fields/field-help\";\nimport { FormGrid } from \"@/components/formedible/layout/form-grid\";\n\n// Utility function to scroll to top of a specific form\nconst scrollToTop = (\n  htmlFormRef: React.RefObject<HTMLFormElement | null>,\n  smooth = true,\n  enabled = true\n) => {\n  if (typeof window !== \"undefined\" && htmlFormRef.current && enabled) {\n    // Check if form is already in view to prevent unnecessary jumping\n    const rect = htmlFormRef.current.getBoundingClientRect();\n    const isInView = rect.top >= 0 && rect.top <= window.innerHeight * 0.3;\n    \n    if (!isInView) {\n      htmlFormRef.current.scrollIntoView({\n        behavior: smooth ? \"smooth\" : \"auto\",\n        block: \"start\",\n      });\n    }\n  }\n};\n\n\n// TanStack Form Best Practice: Reusable subscription component for conditional fields\n\nconst ConditionalFieldsSubscription = <\n  TFormValues extends Record<string, unknown> = Record<string, unknown>\n>({\n  form,\n  fields: _fields,\n  conditionalSections: _conditionalSections,\n  children,\n}: ConditionalFieldsSubscriptionProps<TFormValues>) => {\n  // For now, subscribe to all form values since we don't have explicit dependencies\n  // This could be optimized further by analyzing the condition functions\n  return (\n    <form.Subscribe selector={(state: { values: TFormValues }) => state.values}>\n      {(values: TFormValues) => children(values as Record<string, unknown>)}\n    </form.Subscribe>\n  );\n};\n\n// TanStack Form Best Practice: Individual field conditional renderer\n\nconst FieldConditionalRenderer = ({\n  form,\n  fieldConfig,\n  children,\n}: FieldConditionalRendererProps) => {\n  const { conditional } = fieldConfig;\n\n  // If no conditional logic, always render\n  if (!conditional) {\n    return <>{children(true)}</>;\n  }\n\n  // TanStack Form Best Practice: Use subscription with minimal selector\n  // This prevents parent re-renders by only subscribing to form state changes\n  return (\n    <form.Subscribe selector={(state: any) => state.values}>\n      {(values: any) => children(conditional(values))}\n    </form.Subscribe>\n  );\n};\n\n\n\n\n// Field components with proper typing - each component accepts FieldComponentProps\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  number: NumberField,\n  date: DateField,\n  slider: SliderField,\n  file: FileUploadField,\n  array: ArrayField,\n  radio: RadioField,\n  multiSelect: MultiSelectField,\n  colorPicker: ColorPickerField,\n  rating: RatingField,\n  phone: PhoneField,\n  location: LocationPickerField,\n  duration: DurationPickerField,\n  autocomplete: AutocompleteField,\n  masked: MaskedInputField,\n  object: ObjectField,\n};\n\nconst DefaultProgressComponent: React.FC<{\n  value: number;\n  currentPage: number;\n  totalPages: number;\n  className?: string;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n}> = memo(\n  ({\n    value,\n    currentPage,\n    totalPages,\n    className,\n    showSteps = true,\n    showPercentage = true,\n  }) => (\n    <div className={cn(\"space-y-2\", className)}>\n      {(showSteps || showPercentage) && (\n        <div className=\"flex justify-between text-sm text-muted-foreground\">\n          {showSteps && (\n            <span>\n              Step {currentPage} of {totalPages}\n            </span>\n          )}\n          {showPercentage && <span>{Math.round(value)}%</span>}\n        </div>\n      )}\n      <Progress value={value} className=\"h-2\" />\n    </div>\n  )\n);\n\nDefaultProgressComponent.displayName = \"DefaultProgressComponent\";\n\nconst DefaultPageComponent: React.FC<{\n  children: React.ReactNode;\n  title?: string;\n  description?: string;\n  page: number;\n  totalPages: number;\n}> = ({ children, title, description }) => (\n  <div className=\"space-y-6\">\n    {(title || description) && (\n      <div className=\"space-y-2\">\n        {title && <h3 className=\"text-lg font-semibold\">{title}</h3>}\n        {description && <p className=\"text-muted-foreground\">{description}</p>}\n      </div>\n    )}\n    <div className=\"space-y-4\">{children}</div>\n  </div>\n);\n\n\nconst SectionRenderer: React.FC<\n  SectionRendererProps & { \n    collapseLabel?: string; \n    expandLabel?: string; \n    form?: AnyFormApi;\n    layout?: LayoutConfig;\n  }\n> = ({\n  sectionKey,\n  sectionData,\n  renderField,\n  collapseLabel = \"Collapse\",\n  expandLabel = \"Expand\",\n  form,\n  layout,\n}) => {\n  const { section, groups } = sectionData;\n  const [isExpanded, setIsExpanded] = React.useState(\n    section?.defaultExpanded !== false\n  );\n\n  // Check if any fields in this section will actually render\n  const hasVisibleFields = React.useMemo(() => {\n    if (!form) return true; // Fallback to showing section if form is not available\n    \n    const currentValues = form.state.values;\n    return Object.values(groups).some((groupFields) =>\n      (groupFields as FieldConfig[]).some((field) => {\n        // Check individual field conditional\n        if (field.conditional && !field.conditional(currentValues)) {\n          return false;\n        }\n        return true;\n      })\n    );\n  }, [groups, form?.state.values, form]);\n\n  const renderSectionContent = () => {\n    const allVisibleFields = Object.entries(groups).flatMap(([groupKey, groupFields]) => {\n      // Filter out fields that won't render due to conditionals\n      const visibleGroupFields = (groupFields as FieldConfig[]).filter((field) => {\n        if (!form) return true;\n        const currentValues = form.state.values;\n        return !field.conditional || field.conditional(currentValues);\n      });\n\n      return visibleGroupFields.map((field) => ({ ...field, groupKey }));\n    });\n\n    // If layout is specified and is grid, use FormGrid\n    if (layout && layout.type === \"grid\") {\n      return (\n        <FormGrid \n          columns={layout.columns as FormGridProps['columns']}\n          gap={layout.gap as FormGridProps['gap']}\n          responsive={layout.responsive}\n          className={layout.className}\n        >\n          {allVisibleFields.map((field) => (\n            <div key={field.name}>\n              {renderField(field)}\n            </div>\n          ))}\n        </FormGrid>\n      );\n    }\n    \n    // For flex layouts, use simple flex wrapper\n    if (layout && layout.type === \"flex\") {\n      return (\n        <div className={cn(\n          \"flex flex-wrap\",\n          layout.gap ? `gap-${layout.gap}` : \"gap-4\",\n          layout.className\n        )}>\n          {allVisibleFields.map((field) => (\n            <div key={field.name}>\n              {renderField(field)}\n            </div>\n          ))}\n        </div>\n      );\n    }\n\n    // For vertical layouts or no layout, use the original group structure\n    return (\n      <div className=\"space-y-4\">\n        {Object.entries(groups).map(([groupKey, groupFields]) => {\n          // Filter out fields that won't render due to conditionals\n          const visibleGroupFields = (groupFields as FieldConfig[]).filter((field) => {\n            if (!form) return true;\n            const currentValues = form.state.values;\n            return !field.conditional || field.conditional(currentValues);\n          });\n\n          // Don't render empty groups\n          if (visibleGroupFields.length === 0) return null;\n\n          return (\n            <div\n              key={groupKey}\n              className={cn(\n                groupKey !== \"default\" ? \"p-4 border rounded-lg bg-muted/20\" : \"\"\n              )}\n            >\n              {groupKey !== \"default\" && (\n                <h4 className=\"font-medium text-sm text-muted-foreground mb-3 uppercase tracking-wide\">\n                  {groupKey}\n                </h4>\n              )}\n              <div className={groupKey !== \"default\" ? \"space-y-3\" : \"space-y-4\"}>\n                {visibleGroupFields.map((field) => renderField(field))}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n\n  const sectionContent = renderSectionContent();\n\n  if (section && sectionKey !== \"default\") {\n    // Don't render section if no fields are visible\n    if (!hasVisibleFields) {\n      return null;\n    }\n\n    return (\n      <div key={sectionKey} className=\"space-y-4\">\n        <div className=\"space-y-2\">\n          <div className=\"flex items-center justify-between\">\n            {section.title && (\n              <h3 className=\"text-lg font-semibold\">{section.title}</h3>\n            )}\n            {section.collapsible && (\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={() => setIsExpanded(!isExpanded)}\n                className=\"text-muted-foreground hover:text-foreground\"\n              >\n                {isExpanded ? collapseLabel : expandLabel}\n              </Button>\n            )}\n          </div>\n          {section.description && (\n            <p className=\"text-muted-foreground text-sm\">\n              {section.description}\n            </p>\n          )}\n        </div>\n\n        {(!section.collapsible || isExpanded) && sectionContent}\n      </div>\n    );\n  }\n\n  return sectionContent;\n};\n\nexport function useFormedible<TFormValues extends Record<string, unknown>>(\n  options: UseFormedibleOptions<TFormValues>\n) {\n  const {\n    fields = [],\n\n    submitLabel = \"Submit\",\n    nextLabel = \"Next\",\n    previousLabel = \"Previous\",\n    collapseLabel = \"Collapse\",\n    expandLabel = \"Expand\",\n    formClassName,\n    fieldClassName,\n    labelClassName,\n    buttonClassName,\n    submitButtonClassName,\n    submitButton,\n    pages,\n    progress,\n    tabs,\n    defaultComponents,\n    globalWrapper,\n    formOptions,\n    onPageChange,\n    autoSubmitOnChange,\n    autoSubmitDebounceMs,\n    disabled,\n    loading,\n    resetOnSubmitSuccess,\n    showSubmitButton = true,\n    autoScroll = false,\n    onFormReset,\n    onFormInput,\n    onFormInvalid,\n    onFormKeyDown,\n    onFormKeyUp,\n    onFormFocus,\n    onFormBlur,\n    // Advanced features\n    crossFieldValidation = [],\n    asyncValidation = {},\n    analytics,\n    conditionalSections = [],\n    persistence,\n    layout,\n  } = options;\n\n  const htmlFormRef = useRef<HTMLFormElement>(null);\n  const [currentPage, setCurrentPage] = useState(1);\n\n  // Advanced features state\n  const [crossFieldErrors, setCrossFieldErrors] = useState<\n    Record<string, string>\n  >({});\n  const [asyncValidationStates, setAsyncValidationStates] = useState<\n    Record<string, { loading: boolean; error?: string }>\n  >({});\n\n  // Enhanced analytics state management\n  const analyticsContextRef = React.useRef<AnalyticsContext>({\n    sessionId: `session_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,\n    formId: `form_${Date.now()}`,\n    userId: undefined,\n    startTime: Date.now(),\n    pageStates: {},\n    tabStates: {},\n    performanceMetrics: {\n      renderCount: 0,\n      lastRenderTime: 0,\n      averageRenderTime: 0,\n      validationDurations: {},\n      submissionMetrics: {\n        totalTime: 0,\n        validationTime: 0,\n        processingTime: 0,\n      },\n    },\n    fieldInteractions: {},\n  });\n  \n  // Legacy refs for backward compatibility\n  const formStartTime = React.useRef<number>(analyticsContextRef.current.startTime);\n  const fieldFocusTimes = React.useRef<Record<string, number>>({});\n  const pageStartTime = React.useRef<number>(Date.now());\n  const tabStartTime = React.useRef<Record<string, number>>({});\n  const tabVisitHistory = React.useRef<Set<string>>(new Set());\n\n  // Combine default components with user overrides\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\n\n  // Group fields by pages\n  const fieldsByPage = useMemo(() => {\n    const grouped: { [page: number]: FieldConfig[] } = {};\n\n    fields.forEach((field) => {\n      const page = field.page || 1;\n      if (!grouped[page]) grouped[page] = [];\n      grouped[page].push(field);\n    });\n\n    return grouped;\n  }, [fields]);\n\n  // Function to check if a page should be visible based on conditions\n  const getVisiblePages = React.useCallback(\n    (currentValues: Record<string, unknown>) => {\n      const allPageNumbers = Object.keys(fieldsByPage)\n        .map(Number)\n        .sort((a, b) => a - b);\n\n      return allPageNumbers.filter((pageNumber) => {\n        // Check if the page itself has a condition\n        const pageConfig = pages?.find((p) => p.page === pageNumber);\n        if (pageConfig?.conditional && !pageConfig.conditional(currentValues)) {\n          return false;\n        }\n\n        // Check if page has any visible fields\n        const pageFields = fieldsByPage[pageNumber] || [];\n        const hasVisibleFields = pageFields.some((field) => {\n          // Check field's own conditional\n          if (field.conditional && !field.conditional(currentValues)) {\n            return false;\n          }\n\n          // Check conditional sections\n          const conditionalSection = conditionalSections.find((section) =>\n            section.fields.includes(field.name)\n          );\n\n          if (conditionalSection) {\n            return conditionalSection.condition(currentValues as TFormValues);\n          }\n\n          return true;\n        });\n\n        return hasVisibleFields;\n      });\n    },\n    [fieldsByPage, pages, conditionalSections]\n  );\n\n  // Group fields by tabs\n  const fieldsByTab = useMemo(() => {\n    const grouped: { [tab: string]: FieldConfig[] } = {};\n\n    fields.forEach((field) => {\n      const tab = field.tab || \"default\";\n      if (!grouped[tab]) grouped[tab] = [];\n      grouped[tab].push(field);\n    });\n\n    return grouped;\n  }, [fields]);\n\n  // State to track visible pages based on current form values\n  const [visiblePages, setVisiblePages] = useState<number[]>(() => {\n    // Initialize with all possible pages\n    return Object.keys(fieldsByPage)\n      .map(Number)\n      .sort((a, b) => a - b);\n  });\n\n  const totalPages = Math.max(visiblePages.length, 1);\n  const hasPages = totalPages > 1;\n  const hasTabs = tabs && tabs.length > 0;\n\n  // Calculate progress\n  const progressValue = hasPages\n    ? ((currentPage - 1) / (totalPages - 1)) * 100\n    : 100;\n\n  // Create a ref to store the form instance for the onSubmit callback\n  const formRef = React.useRef<FormedibleFormApi<TFormValues> | null>(null);\n\n  // Refs for async validation debouncing\n  const asyncValidationTimeouts = React.useRef<\n    Record<string, ReturnType<typeof setTimeout>>\n  >({});\n\n  // Keep track of AbortControllers for async validations\n  const asyncValidationAbortControllers = React.useRef<\n    Record<string, AbortController>\n  >({});\n\n  // Cross-field validation function\n  const validateCrossFields = React.useCallback(\n    (values: Partial<TFormValues>) => {\n      const errors: Record<string, string> = {};\n\n      crossFieldValidation.forEach((validation) => {\n        const relevantValues = validation.fields.reduce((acc, field) => {\n          acc[field] = values[field];\n          return acc;\n        }, {} as Partial<TFormValues>);\n\n        const error = validation.validator(relevantValues);\n        if (error) {\n          validation.fields.forEach((field) => {\n            errors[field as string] = validation.message;\n          });\n        }\n      });\n\n      setCrossFieldErrors(errors);\n      return errors;\n    },\n    [crossFieldValidation]\n  );\n\n  // Async validation function\n  const validateFieldAsync = React.useCallback(\n    async (fieldName: string, value: unknown) => {\n      const asyncConfig = asyncValidation[fieldName];\n      if (!asyncConfig) return;\n\n      // Cancel any existing validation for this field\n      if (asyncValidationAbortControllers.current[fieldName]) {\n        asyncValidationAbortControllers.current[fieldName].abort();\n      }\n\n      // Create new abort controller\n      const abortController = new AbortController();\n      asyncValidationAbortControllers.current[fieldName] = abortController;\n\n      // Clear existing timeout\n      if (asyncValidationTimeouts.current[fieldName]) {\n        clearTimeout(asyncValidationTimeouts.current[fieldName]);\n      }\n\n      // Set loading state\n      setAsyncValidationStates((prev) => ({\n        ...prev,\n        [fieldName]: { loading: true },\n      }));\n\n      // Debounce the validation\n      asyncValidationTimeouts.current[fieldName] = setTimeout(async () => {\n        try {\n          if (abortController.signal.aborted) return;\n\n          const error = await asyncConfig.validator(value);\n\n          if (abortController.signal.aborted) return;\n\n          setAsyncValidationStates((prev) => ({\n            ...prev,\n            [fieldName]: { loading: false, error: error || undefined },\n          }));\n\n          // Update form field error if needed\n          if (formRef.current) {\n            formRef.current?.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errors: error ? [error] : [],\n            }));\n          }\n        } catch {\n          setAsyncValidationStates((prev) => ({\n            ...prev,\n            [fieldName]: { loading: false, error: \"Validation failed\" },\n          }));\n        }\n      }, asyncConfig.debounceMs || 500);\n    },\n    [asyncValidation]\n  );\n\n  // Setup form with schema validation if provided\n  const formConfig = {\n    ...formOptions,\n    ...(resetOnSubmitSuccess &&\n      formOptions?.onSubmit && {\n        onSubmit: async (props: {\n          value: TFormValues;\n          formApi: FormedibleFormApi<TFormValues>;\n        }) => {\n          // Run cross-field validation before submit\n          const crossFieldErrors = validateCrossFields(\n            props.value as Partial<TFormValues>\n          );\n          if (Object.keys(crossFieldErrors).length > 0) {\n            throw new Error(\"Cross-field validation failed\");\n          }\n\n          // Enhanced analytics tracking for form completion\n          if (analytics) {\n            const context = analyticsContextRef.current;\n            const timeSpent = Date.now() - context.startTime;\n            \n            // Track submission performance\n            const submissionStartTime = Date.now();\n            \n            // Update performance metrics\n            context.performanceMetrics.submissionMetrics.totalTime = timeSpent;\n            \n            // Call enhanced completion analytics\n            analytics.onFormComplete?.(timeSpent, props.value);\n            \n            // Track submission performance when promise resolves\n            const originalOnSubmit = formOptions.onSubmit;\n            if (originalOnSubmit) {\n              const submissionPromise = originalOnSubmit(props);\n              if (submissionPromise instanceof Promise) {\n                submissionPromise.finally(() => {\n                  const processingTime = Date.now() - submissionStartTime;\n                  context.performanceMetrics.submissionMetrics.processingTime = processingTime;\n                  analytics.onSubmissionPerformance?.(\n                    timeSpent,\n                    context.performanceMetrics.submissionMetrics.validationTime,\n                    processingTime\n                  );\n                });\n              }\n            }\n          }\n\n          let result: unknown;\n          if (formOptions.onSubmit) {\n            result = await formOptions.onSubmit(props);\n          }\n\n          // Clear storage on successful submit\n          clearStorage();\n\n          // Reset form on successful submit if option is enabled\n          if (formRef.current) {\n            formRef.current?.reset();\n          }\n          return result;\n        },\n      }),\n  };\n\n  const form = useForm(formConfig);\n\n  // Store form reference for the onSubmit callback\n  React.useEffect(() => {\n    formRef.current = form;\n  }, [form]);\n\n  // Enhanced analytics helper functions with performance optimization\n  const trackFieldInteraction = React.useCallback((\n    fieldName: string, \n    action: 'focus' | 'blur' | 'change' | 'error' | 'complete',\n    additionalData?: { timeSpent?: number; value?: unknown; errors?: string[]; isValid?: boolean }\n  ) => {\n    const context = analyticsContextRef.current;\n    const timestamp = Date.now();\n    \n    // Initialize field tracking if not exists\n    if (!context.fieldInteractions[fieldName]) {\n      context.fieldInteractions[fieldName] = {\n        focusCount: 0,\n        totalTimeSpent: 0,\n        changeCount: 0,\n        errorCount: 0,\n        isCompleted: false,\n      };\n    }\n    \n    const fieldData = context.fieldInteractions[fieldName];\n    \n    switch (action) {\n      case 'focus':\n        fieldData.focusCount++;\n        fieldFocusTimes.current[fieldName] = timestamp;\n        analytics?.onFieldFocus?.(fieldName, timestamp);\n        break;\n        \n      case 'blur':\n        if (additionalData?.timeSpent !== undefined) {\n          fieldData.totalTimeSpent += additionalData.timeSpent;\n          analytics?.onFieldBlur?.(fieldName, additionalData.timeSpent);\n        }\n        break;\n        \n      case 'change':\n        fieldData.changeCount++;\n        analytics?.onFieldChange?.(fieldName, additionalData?.value, timestamp);\n        break;\n        \n      case 'error':\n        if (additionalData?.errors?.length) {\n          fieldData.errorCount++;\n          analytics?.onFieldError?.(fieldName, additionalData.errors, timestamp);\n        }\n        break;\n        \n      case 'complete':\n        if (additionalData?.isValid !== undefined && additionalData?.timeSpent !== undefined) {\n          fieldData.isCompleted = additionalData.isValid;\n          analytics?.onFieldComplete?.(fieldName, additionalData.isValid, additionalData.timeSpent);\n        }\n        break;\n    }\n  }, [analytics]);\n\n  const trackTabChange = React.useCallback((fromTab: string, toTab: string) => {\n    const context = analyticsContextRef.current;\n    const timestamp = Date.now();\n    const timeSpent = tabStartTime.current[fromTab] ? timestamp - tabStartTime.current[fromTab] : 0;\n    \n    // Track tab visit\n    if (!tabVisitHistory.current.has(toTab)) {\n      tabVisitHistory.current.add(toTab);\n      analytics?.onTabFirstVisit?.(toTab, timestamp);\n    }\n    \n    // Initialize tab states if not exists\n    if (!context.tabStates[fromTab]) {\n      context.tabStates[fromTab] = {\n        tabId: fromTab,\n        startTime: tabStartTime.current[fromTab] || timestamp,\n        visitCount: 0,\n        fieldsCompleted: 0,\n        totalFields: 0,\n        hasErrors: false,\n        completionPercentage: 0,\n      };\n    }\n    \n    if (!context.tabStates[toTab]) {\n      context.tabStates[toTab] = {\n        tabId: toTab,\n        startTime: timestamp,\n        visitCount: 0,\n        fieldsCompleted: 0,\n        totalFields: 0,\n        hasErrors: false,\n        completionPercentage: 0,\n      };\n    }\n    \n    // Update tab states\n    const fromTabState = context.tabStates[fromTab];\n    const toTabState = context.tabStates[toTab];\n    \n    toTabState.visitCount++;\n    tabStartTime.current[toTab] = timestamp;\n    \n    // Calculate completion state for from tab\n    const tabFields = fieldsByTab[fromTab] || [];\n    fromTabState.totalFields = tabFields.length;\n    fromTabState.fieldsCompleted = tabFields.filter(field => \n      context.fieldInteractions[field.name]?.isCompleted\n    ).length;\n    fromTabState.completionPercentage = fromTabState.totalFields > 0 \n      ? (fromTabState.fieldsCompleted / fromTabState.totalFields) * 100 \n      : 0;\n    \n    // Check for validation errors in from tab\n    const formState = form.state;\n    fromTabState.hasErrors = tabFields.some(field => {\n      const fieldState = formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n      return fieldState && fieldState.errors && fieldState.errors.length > 0;\n    });\n    \n    analytics?.onTabChange?.(fromTab, toTab, timeSpent, {\n      completionPercentage: fromTabState.completionPercentage,\n      hasErrors: fromTabState.hasErrors,\n    });\n  }, [analytics, fieldsByTab, form]);\n\n  const trackPageChange = React.useCallback((fromPage: number, toPage: number) => {\n    const context = analyticsContextRef.current;\n    const timestamp = Date.now();\n    const timeSpent = timestamp - pageStartTime.current;\n    \n    // Initialize page states if not exists\n    if (!context.pageStates[fromPage]) {\n      context.pageStates[fromPage] = {\n        pageNumber: fromPage,\n        startTime: pageStartTime.current,\n        visitCount: 0,\n        fieldsCompleted: 0,\n        totalFields: 0,\n        hasErrors: false,\n        completionPercentage: 0,\n        validationErrors: {},\n        lastActiveField: undefined,\n      };\n    }\n    \n    const pageState = context.pageStates[fromPage];\n    const pageFields = fieldsByPage[fromPage] || [];\n    \n    // Update page completion metrics\n    pageState.totalFields = pageFields.length;\n    pageState.fieldsCompleted = pageFields.filter(field => \n      context.fieldInteractions[field.name]?.isCompleted\n    ).length;\n    pageState.completionPercentage = pageState.totalFields > 0 \n      ? (pageState.fieldsCompleted / pageState.totalFields) * 100 \n      : 0;\n    \n    // Check for validation errors\n    const formState = form.state;\n    const validationErrors: Record<string, string[]> = {};\n    pageState.hasErrors = pageFields.some(field => {\n      const fieldState = formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n      const hasErrors = fieldState && fieldState.errors && fieldState.errors.length > 0;\n      if (hasErrors) {\n        validationErrors[field.name] = fieldState.errors;\n      }\n      return hasErrors;\n    });\n    pageState.validationErrors = validationErrors;\n    \n    pageStartTime.current = timestamp;\n    \n    analytics?.onPageChange?.(fromPage, toPage, timeSpent, {\n      hasErrors: pageState.hasErrors,\n      completionPercentage: pageState.completionPercentage,\n    });\n  }, [analytics, fieldsByPage, form]);\n\n  // Track visible pages using a ref to avoid circular dependencies\n  const visiblePagesRef = React.useRef<number[]>(\n    Object.keys(fieldsByPage)\n      .map(Number)\n      .sort((a, b) => a - b)\n  );\n\n  // Update visible pages when form values change (without causing re-renders)\n  React.useEffect(() => {\n    const updateVisiblePages = () => {\n      const currentValues = form.state.values as Record<string, unknown>;\n      const newVisiblePages = getVisiblePages(currentValues);\n\n      // Only update if actually changed\n      if (\n        JSON.stringify(visiblePagesRef.current) !==\n        JSON.stringify(newVisiblePages)\n      ) {\n        visiblePagesRef.current = newVisiblePages;\n\n        // Update state only when necessary\n        setVisiblePages(newVisiblePages);\n\n        // Check if current page is still visible using setCurrentPage callback\n        setCurrentPage((prevCurrentPage) => {\n          const currentActualPage = newVisiblePages[prevCurrentPage - 1];\n          if (\n            !currentActualPage &&\n            prevCurrentPage > 1 &&\n            newVisiblePages.length > 0\n          ) {\n            return 1; // Navigate to first visible page\n          }\n          return prevCurrentPage; // Keep current page\n        });\n      }\n    };\n\n    // Set up subscription\n    const unsubscribe = form.store.subscribe(updateVisiblePages);\n\n    // Initialize on mount\n    updateVisiblePages();\n\n    return unsubscribe;\n  }, [form, getVisiblePages]);\n\n  // Form persistence logic\n  const persistenceTimeout = React.useRef<\n    ReturnType<typeof setTimeout> | undefined\n  >(undefined);\n\n  const saveToStorage = React.useCallback(\n    (values: Partial<TFormValues>) => {\n      if (!persistence) return;\n\n      try {\n        const storage =\n          persistence.storage === \"localStorage\"\n            ? localStorage\n            : sessionStorage;\n        const filteredValues = persistence.exclude\n          ? Object.fromEntries(\n              Object.entries(values as Record<string, unknown>).filter(\n                ([key]) =>\n                  !(persistence.exclude && persistence.exclude.includes(key))\n              )\n            )\n          : values;\n\n        storage.setItem(\n          persistence.key,\n          JSON.stringify({\n            values: filteredValues,\n            timestamp: Date.now(),\n            currentPage,\n          })\n        );\n      } catch (error) {\n        console.warn(\"Failed to save form data to storage:\", error);\n      }\n    },\n    [persistence, currentPage]\n  );\n\n  const clearStorage = React.useCallback(() => {\n    if (!persistence) return;\n\n    try {\n      const storage =\n        persistence.storage === \"localStorage\" ? localStorage : sessionStorage;\n      storage.removeItem(persistence.key);\n    } catch (error) {\n      console.warn(\"Failed to clear form data from storage:\", error);\n    }\n  }, [persistence]);\n\n  const loadFromStorage = React.useCallback(() => {\n    if (!persistence?.restoreOnMount) return null;\n\n    try {\n      const storage =\n        persistence.storage === \"localStorage\" ? localStorage : sessionStorage;\n      const saved = storage.getItem(persistence.key);\n      if (saved) {\n        const parsed = JSON.parse(saved);\n        return parsed;\n      }\n    } catch (error) {\n      console.warn(\"Failed to load form data from storage:\", error);\n    }\n    return null;\n  }, [persistence]);\n\n  // Restore form data on mount\n  React.useEffect(() => {\n    const savedData = loadFromStorage();\n    if (savedData && savedData.values) {\n      // Restore form values\n      Object.entries(savedData.values as Record<string, unknown>).forEach(\n        ([key, value]) => {\n          try {\n            form.setFieldValue(key as keyof TFormValues & string, value as any);\n          } catch (error) {\n            console.warn(`Failed to restore field value for ${key}:`, error);\n          }\n        }\n      );\n\n      // Restore current page if it was saved\n      if (savedData.currentPage && savedData.currentPage <= totalPages) {\n        setCurrentPage(savedData.currentPage);\n      }\n    }\n  }, [loadFromStorage, form, totalPages]);\n\n  // Set up form event listeners if provided\n  React.useEffect(() => {\n    const unsubscribers: (() => void)[] = [];\n    let autoSubmitTimeout: ReturnType<typeof setTimeout>;\n    let onChangeTimeout: ReturnType<typeof setTimeout>;\n    let onBlurTimeout: ReturnType<typeof setTimeout>;\n\n    // Enhanced form start analytics\n    if (analytics?.onFormStart) {\n      analytics.onFormStart(analyticsContextRef.current.startTime);\n    }\n\n    if (\n      formOptions?.onChange ||\n      autoSubmitOnChange ||\n      crossFieldValidation.length > 0 ||\n      analytics ||\n      persistence\n    ) {\n      const unsubscribe = form.store.subscribe(() => {\n        const formApi = form;\n        const values = formApi.state.values;\n\n        // Run cross-field validation on change\n        if (crossFieldValidation.length > 0) {\n          validateCrossFields(values as Partial<TFormValues>);\n        }\n\n        // Save to storage (debounced)\n        if (persistence) {\n          clearTimeout(persistenceTimeout.current);\n          persistenceTimeout.current = setTimeout(() => {\n            saveToStorage(values as Partial<TFormValues>);\n          }, persistence.debounceMs || 1000);\n        }\n\n        // Call user's onChange handler only if form is valid (debounced)\n        if (formOptions?.onChange && formApi.state.isValid) {\n          clearTimeout(onChangeTimeout);\n          onChangeTimeout = setTimeout(() => {\n            if (!formOptions.onChange) return;\n            formOptions.onChange({ value: values as TFormValues, formApi });\n          }, 300); // 300ms debounce\n        }\n\n        // Handle auto-submit on change\n        if (autoSubmitOnChange && !disabled && !loading) {\n          clearTimeout(autoSubmitTimeout);\n          autoSubmitTimeout = setTimeout(() => {\n            if (form.state.canSubmit) {\n              form.handleSubmit();\n            }\n          }, autoSubmitDebounceMs);\n        }\n      });\n      unsubscribers.push(unsubscribe);\n    }\n\n    // Enhanced analytics using TanStack Form subscriptions instead of document event listeners\n    if (analytics) {\n      // Subscribe to form state changes for field validation analytics\n      const fieldValidationUnsubscribe = form.store.subscribe(() => {\n        const formState = form.state;\n        const fieldMeta = formState.fieldMeta;\n        \n        // Track field validation errors\n        Object.entries(fieldMeta).forEach(([fieldName, meta]) => {\n          if (meta && typeof meta === 'object' && 'errors' in meta && Array.isArray(meta.errors) && meta.errors.length > 0) {\n            trackFieldInteraction(fieldName, 'error', { errors: meta.errors });\n          }\n        });\n      });\n      unsubscribers.push(fieldValidationUnsubscribe);\n\n      // Subscribe to field changes with optimized tracking\n      const fieldChangeUnsubscribe = form.store.subscribe(() => {\n        // Performance: only track changes when form values actually change\n        const values = form.state.values;\n        Object.entries(values as Record<string, unknown>).forEach(([fieldName, value]) => {\n          const context = analyticsContextRef.current;\n          \n          // Initialize field tracking if needed\n          if (!context.fieldInteractions[fieldName]) {\n            context.fieldInteractions[fieldName] = {\n              focusCount: 0,\n              totalTimeSpent: 0,\n              changeCount: 0,\n              errorCount: 0,\n              isCompleted: false,\n            };\n          }\n          \n          const fieldData = context.fieldInteractions[fieldName];\n          \n          // Only track if this is a new value (prevents duplicate events)\n          if (fieldData.changeCount === 0) {\n            trackFieldInteraction(fieldName, 'change', { value });\n            \n            // Trigger async validation if configured\n            if (asyncValidation[fieldName]) {\n              validateFieldAsync(fieldName, value);\n            }\n          }\n        });\n      });\n      unsubscribers.push(fieldChangeUnsubscribe);\n\n      // User's onBlur handler using subscription\n      if (formOptions?.onBlur) {\n        const blurUnsubscribe = form.store.subscribe(() => {\n          clearTimeout(onBlurTimeout);\n          onBlurTimeout = setTimeout(() => {\n            if (!formOptions.onBlur) return;\n            const formApi = form;\n            const values = formApi.state.values;\n            formOptions.onBlur({ value: values as TFormValues, formApi });\n          }, 100); // 100ms debounce for blur\n        });\n        unsubscribers.push(blurUnsubscribe);\n      }\n    }\n\n    // Enhanced cleanup with form abandonment tracking\n    unsubscribers.push(() => {\n      // Track form abandonment if analytics is enabled and form wasn't completed\n      if (analytics?.onFormAbandon) {\n        const context = analyticsContextRef.current;\n        const totalFields = fields.length;\n        const completedFields = Object.values(context.fieldInteractions).filter(\n          field => field.isCompleted\n        ).length;\n        const completionPercentage = totalFields > 0 ? (completedFields / totalFields) * 100 : 0;\n        \n        // Only track abandonment if form had some interaction\n        if (completedFields > 0 || Object.keys(context.fieldInteractions).length > 0) {\n          analytics.onFormAbandon(completionPercentage, {\n            currentPage: analyticsContextRef.current.currentPage,\n            currentTab: analyticsContextRef.current.currentTab,\n            lastActiveField: Object.keys(context.fieldInteractions).pop(),\n          });\n        }\n      }\n      \n      clearTimeout(autoSubmitTimeout);\n      clearTimeout(onChangeTimeout);\n      clearTimeout(onBlurTimeout);\n      clearTimeout(persistenceTimeout.current);\n      // Clear async validation timeouts\n      Object.values(asyncValidationTimeouts.current).forEach((timeout) => {\n        clearTimeout(timeout);\n      });\n\n      // Cancel all in-flight async validations\n      Object.values(asyncValidationAbortControllers.current).forEach(\n        (controller) => {\n          controller.abort();\n        }\n      );\n    });\n\n    return () => {\n      unsubscribers.forEach((unsub) => unsub());\n    };\n  }, [\n    form,\n    autoSubmitOnChange,\n    autoSubmitDebounceMs,\n    disabled,\n    loading,\n    formOptions,\n    crossFieldValidation,\n    analytics,\n    asyncValidation,\n    validateFieldAsync,\n    persistence,\n    saveToStorage,\n    validateCrossFields,\n  ]);\n\n  const getCurrentPageFields = () => {\n    if (hasTabs) {\n      // When using tabs, return all fields (tabs handle their own filtering)\n      return fields;\n    }\n    // Get the actual page number from visible pages array\n    const actualPageNumber = visiblePages[currentPage - 1];\n    return actualPageNumber ? fieldsByPage[actualPageNumber] || [] : [];\n  };\n\n  const getCurrentPageConfig = () => {\n    const actualPageNumber = visiblePages[currentPage - 1];\n    return actualPageNumber\n      ? pages?.find((p) => p.page === actualPageNumber)\n      : undefined;\n  };\n\n  const goToNextPage = () => {\n    if (currentPage < totalPages) {\n      // Check if current page has validation errors\n      const currentPageFields = getCurrentPageFields();\n      const formState = form.state;\n\n      const hasPageErrors = currentPageFields.some((field) => {\n        const fieldState =\n          formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n        return fieldState && fieldState.errors && fieldState.errors.length > 0;\n      });\n\n      if (hasPageErrors) {\n        // Mark all fields on current page as touched to show validation errors\n        currentPageFields.forEach((field) => {\n          form.setFieldMeta(field.name, (prev) => ({\n            ...prev,\n            isTouched: true,\n          }));\n        });\n        return; // Don't navigate if there are errors\n      }\n\n      const newPage = currentPage + 1;\n\n      // Enhanced analytics tracking with validation state\n      if (analytics) {\n        trackPageChange(currentPage, newPage);\n      }\n\n      setCurrentPage(newPage);\n      pageStartTime.current = Date.now();\n      onPageChange?.(newPage, \"next\");\n      scrollToTop(htmlFormRef, true, autoScroll);\n    }\n  };\n\n  const goToPreviousPage = () => {\n    if (currentPage > 1) {\n      const newPage = currentPage - 1;\n\n      // Enhanced analytics tracking with validation state\n      if (analytics) {\n        trackPageChange(currentPage, newPage);\n      }\n\n      setCurrentPage(newPage);\n      pageStartTime.current = Date.now();\n      onPageChange?.(newPage, \"previous\");\n      scrollToTop(htmlFormRef, true, autoScroll);\n    }\n  };\n\n  const isLastPage = currentPage === totalPages;\n  const isFirstPage = currentPage === 1;\n\n  // Validated setCurrentPage that checks all pages between current and target\n  const setCurrentPageWithValidation = (targetPage: number) => {\n    if (\n      targetPage < 1 ||\n      targetPage > totalPages ||\n      targetPage === currentPage\n    ) {\n      return;\n    }\n\n    // If going forward, validate all pages between current and target\n    if (targetPage > currentPage) {\n      for (\n        let pageIndex = currentPage - 1;\n        pageIndex < targetPage - 1;\n        pageIndex++\n      ) {\n        const actualPageNumber = visiblePages[pageIndex];\n        if (!actualPageNumber) continue;\n\n        const pageFields = fieldsByPage[actualPageNumber] || [];\n        const formState = form.state;\n\n        const hasPageErrors = pageFields.some((field) => {\n          const fieldState =\n            formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n          return (\n            fieldState && fieldState.errors && fieldState.errors.length > 0\n          );\n        });\n\n        if (hasPageErrors) {\n          // Mark all fields on this page as touched to show validation errors\n          pageFields.forEach((field) => {\n            form.setFieldMeta(field.name, (prev) => ({\n              ...prev,\n              isTouched: true,\n            }));\n          });\n          return; // Don't navigate if there are errors\n        }\n      }\n    }\n\n    // If validation passes or going backward, allow navigation\n    setCurrentPage(targetPage);\n    onPageChange?.(targetPage, targetPage > currentPage ? \"next\" : \"previous\");\n    scrollToTop(htmlFormRef, true, autoScroll);\n  };\n\n  const Form: React.FC<FormProps> = ({\n    className,\n    children,\n    onSubmit,\n    // HTML form attributes\n    action,\n    method,\n    encType,\n    target,\n    autoComplete,\n    noValidate,\n    acceptCharset,\n    // Event handlers\n    onReset,\n    onInput,\n    onInvalid,\n    onKeyDown,\n    onKeyUp,\n\n    onFocus,\n    onBlur,\n    // Accessibility\n    role,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledby,\n    \"aria-describedby\": ariaDescribedby,\n    tabIndex,\n  }) => {\n    const handleSubmit = (e: React.FormEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (onSubmit) {\n        onSubmit(e);\n      } else if (isLastPage) {\n        form.handleSubmit();\n      } else {\n        goToNextPage();\n      }\n    };\n\n    const handleReset = (e: React.FormEvent) => {\n      if (onReset) {\n        onReset(e);\n      }\n      if (onFormReset) {\n        onFormReset(e, form);\n      }\n      form.reset();\n    };\n\n    const handleInput = (e: React.FormEvent) => {\n      if (onInput) {\n        onInput(e);\n      }\n      if (onFormInput) {\n        onFormInput(e, form);\n      }\n    };\n\n    const handleInvalid = (e: React.FormEvent) => {\n      if (onInvalid) {\n        onInvalid(e);\n      }\n      if (onFormInvalid) {\n        onFormInvalid(e, form);\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n      if (onFormKeyDown) {\n        onFormKeyDown(e, form);\n      }\n    };\n\n    const handleKeyUp = (e: React.KeyboardEvent) => {\n      if (onKeyUp) {\n        onKeyUp(e);\n      }\n      if (onFormKeyUp) {\n        onFormKeyUp(e, form);\n      }\n    };\n\n    // Tab state for controlled FormTabs component with analytics\n    const [activeTab, setActiveTab] = useState(() => {\n      if (tabs && tabs.length > 0) return tabs[0].id;\n      return \"\";\n    });\n\n    // Enhanced tab change handler with analytics\n    const handleTabChange = React.useCallback((newTabId: string) => {\n      const previousTab = activeTab;\n      \n      // Track tab change if analytics is enabled\n      if (analytics && previousTab && previousTab !== newTabId) {\n        trackTabChange(previousTab, newTabId);\n      }\n      \n      // Initialize tab start time for new tab\n      if (newTabId && !tabStartTime.current[newTabId]) {\n        tabStartTime.current[newTabId] = Date.now();\n      }\n      \n      setActiveTab(newTabId);\n    }, [activeTab, analytics, trackTabChange]);\n\n    // Initialize first tab start time\n    React.useEffect(() => {\n      if (activeTab && !tabStartTime.current[activeTab]) {\n        tabStartTime.current[activeTab] = Date.now();\n        // Track first tab visit\n        if (analytics?.onTabFirstVisit) {\n          analytics.onTabFirstVisit(activeTab, Date.now());\n        }\n      }\n    }, [activeTab, analytics]);\n\n    const handleFocus = (e: React.FocusEvent) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      if (onFormFocus) {\n        onFormFocus(e, form);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      if (onFormBlur) {\n        onFormBlur(e, form);\n      }\n    };\n\n    const formClass = cn(\"space-y-6\", formClassName, className);\n\n    // Helper function to resolve options (static or dynamic)\n    const resolveOptions = React.useCallback(\n      (\n        options: FieldConfig[\"options\"],\n        currentValues: Record<string, unknown>\n      ) => {\n        if (typeof options === \"function\") {\n          return options(currentValues);\n        }\n        return options;\n      },\n      []\n    );\n\n    const renderField = React.useCallback(\n      (fieldConfig: FieldConfig) => {\n        const {\n          name,\n          type,\n          label,\n          placeholder,\n          description,\n          options,\n          min,\n          max,\n          step,\n          accept,\n          multiple,\n          component: CustomComponent,\n          wrapper: CustomWrapper,\n          validation,\n          arrayConfig,\n          datalist,\n          help,\n          inlineValidation,\n\n          ratingConfig,\n          phoneConfig,\n          colorConfig,\n          multiSelectConfig,\n          locationConfig,\n          durationConfig,\n          autocompleteConfig,\n          maskedInputConfig,\n          objectConfig,\n          sliderConfig,\n          numberConfig,\n          dateConfig,\n          fileConfig,\n          textareaConfig,\n          passwordConfig,\n          emailConfig,\n        } = fieldConfig;\n\n        return (\n          <form.Field\n            key={name}\n            name={name as keyof TFormValues & string}\n            validators={\n              validation\n                ? {\n                    onChange: ({ value }) => {\n                      const result = validation.safeParse(value);\n                      return result.success\n                        ? undefined\n                        : result.error.issues[0]?.message || \"Invalid value\";\n                    },\n                  }\n                : undefined\n            }\n          >\n            {(field) => {\n              // TanStack Form Best Practice: Use FieldConditionalRenderer to prevent parent re-renders\n              return (\n                <FieldConditionalRenderer form={form} fieldConfig={fieldConfig}>\n                  {(shouldRender) => {\n                    if (!shouldRender) {\n                      return null;\n                    }\n\n                    // Subscribe to form values for dynamic options\n                    return (\n                      <form.Subscribe selector={(state: any) => state.values}>\n                        {(currentValues: any) => {\n                          // Check for cross-field validation errors\n                          const crossFieldError = crossFieldErrors[name];\n                          const asyncValidationState =\n                            asyncValidationStates[name];\n\n                          // Resolve options (static or dynamic)\n                          const resolvedOptions = resolveOptions(\n                            options,\n                            currentValues\n                          );\n\n                          const baseProps = {\n                            fieldApi: field as unknown as AnyFieldApi,\n                            label,\n                            placeholder,\n                            description,\n                            wrapperClassName: fieldClassName,\n                            labelClassName,\n                            min,\n                            max,\n                            step,\n                            accept,\n                            multiple,\n                            disabled:\n                              disabled ||\n                              loading ||\n                              field.form.state.isSubmitting,\n                            crossFieldError,\n                            asyncValidationState,\n                          };\n\n                          // Select the component to use\n                          const FieldComponent =\n                            CustomComponent ||\n                            fieldComponents[type] ||\n                            TextField;\n\n                          // Add type-specific props\n                          let props: FieldComponentProps = { ...baseProps };\n\n                          // Normalize options to the expected format\n                          const normalizedOptions = resolvedOptions\n                            ? resolvedOptions.map((opt) =>\n                                typeof opt === \"string\"\n                                  ? { value: opt, label: opt }\n                                  : opt\n                              )\n                            : [];\n\n                          if (type === \"select\") {\n                            props = { ...props, options: normalizedOptions };\n                          } else if (type === \"array\") {\n                            const mappedArrayConfig = arrayConfig\n                              ? {\n                                  itemType: arrayConfig.itemType || \"text\",\n                                  itemLabel: arrayConfig.itemLabel,\n                                  itemPlaceholder: arrayConfig.itemPlaceholder,\n                                  minItems: arrayConfig.minItems,\n                                  maxItems: arrayConfig.maxItems,\n                                  itemValidation: arrayConfig.itemValidation,\n                                  itemComponent:\n                                    arrayConfig.itemComponent as React.ComponentType<BaseFieldProps>,\n                                  addButtonLabel: arrayConfig.addButtonLabel,\n                                  removeButtonLabel:\n                                    arrayConfig.removeButtonLabel,\n                                  sortable: arrayConfig.sortable,\n                                  defaultValue: arrayConfig.defaultValue,\n                                  objectConfig: arrayConfig.objectConfig,\n                                }\n                              : undefined;\n                            props = {\n                              ...props,\n                              arrayConfig: mappedArrayConfig,\n                            };\n                          } else if (\n                            [\n                              \"text\",\n                              \"email\",\n                              \"password\",\n                              \"url\",\n                              \"tel\",\n                            ].includes(type)\n                          ) {\n                            props = {\n                              ...props,\n                              type: type as\n                                | \"text\"\n                                | \"email\"\n                                | \"password\"\n                                | \"url\"\n                                | \"tel\",\n                              datalist: datalist?.options,\n                            };\n                          } else if (type === \"radio\") {\n                            props = { ...props, options: normalizedOptions };\n                          } else if (type === \"multiSelect\") {\n                            props = {\n                              ...props,\n                              options: normalizedOptions,\n                              multiSelectConfig,\n                            };\n                          } else if (type === \"colorPicker\") {\n                            props = { ...props, colorConfig };\n                          } else if (type === \"rating\") {\n                            props = { ...props, ratingConfig };\n                          } else if (type === \"phone\") {\n                            props = { ...props, phoneConfig };\n                          } else if (type === \"location\") {\n                            props = { ...props, locationConfig };\n                          } else if (type === \"duration\") {\n                            props = { ...props, durationConfig };\n                          } else if (type === \"autocomplete\") {\n                            // Handle dynamic options for autocomplete\n                            const resolvedAutocompleteConfig =\n                              autocompleteConfig\n                                ? {\n                                    ...autocompleteConfig,\n                                    options: resolveOptions(\n                                      autocompleteConfig.options,\n                                      currentValues\n                                    ),\n                                  }\n                                : undefined;\n                            props = {\n                              ...props,\n                              autocompleteConfig: resolvedAutocompleteConfig,\n                            };\n                          } else if (type === \"masked\") {\n                            props = { ...props, maskedInputConfig };\n                          } else if (type === \"object\") {\n                            props = { ...props, objectConfig, form };\n                          } else if (type === \"slider\") {\n                            props = { ...props, sliderConfig };\n                          } else if (type === \"number\") {\n                            props = { ...props, numberConfig };\n                          } else if (type === \"date\") {\n                            props = { ...props, dateConfig };\n                          } else if (type === \"file\") {\n                            props = { ...props, fileConfig };\n                          } else if (type === \"textarea\") {\n                            props = { ...props, textareaConfig };\n                          } else if (type === \"password\") {\n                            props = { ...props, passwordConfig };\n                          } else if (type === \"email\") {\n                            props = { ...props, emailConfig };\n                          }\n\n                          // Render the field component\n                          const fieldElement = <FieldComponent {...props} />;\n\n                          // Apply inline validation wrapper if enabled\n                          const wrappedFieldElement =\n                            inlineValidation?.enabled ? (\n                              <InlineValidationWrapper\n                                fieldApi={field as unknown as AnyFieldApi}\n                                inlineValidation={inlineValidation}\n                              >\n                                {fieldElement}\n                              </InlineValidationWrapper>\n                            ) : (\n                              fieldElement\n                            );\n\n                          // Add field help if provided\n                          const fieldWithHelp = help ? (\n                            <div className=\"space-y-2\">\n                              {wrappedFieldElement}\n                              <FieldHelp help={help} />\n                            </div>\n                          ) : (\n                            wrappedFieldElement\n                          );\n\n                          // Apply custom wrapper or global wrapper\n                          const Wrapper = CustomWrapper || globalWrapper;\n\n                          return Wrapper ? (\n                            <Wrapper field={fieldConfig}>\n                              {fieldWithHelp}\n                            </Wrapper>\n                          ) : (\n                            fieldWithHelp\n                          );\n                        }}\n                      </form.Subscribe>\n                    );\n                  }}\n                </FieldConditionalRenderer>\n              );\n            }}\n          </form.Field>\n        );\n      },\n      [resolveOptions]\n    );\n\n    const renderTabContent = React.useCallback(\n      (tabFields: FieldConfig[]) => {\n        // TanStack Form Best Practice: Use reusable subscription component\n        return (\n          <ConditionalFieldsSubscription\n            form={form}\n            fields={tabFields}\n            conditionalSections={conditionalSections}\n          >\n            {(currentValues) => {\n              // Filter fields based on conditional sections using subscribed values\n              const visibleFields = tabFields.filter((field) => {\n                const conditionalSection = conditionalSections.find((section) =>\n                  section.fields.includes(field.name)\n                );\n\n                if (conditionalSection) {\n                  return conditionalSection.condition(\n                    currentValues as TFormValues\n                  );\n                }\n\n                return true;\n              });\n\n              // Group fields by section and group\n              const groupedFields = visibleFields.reduce((acc, field) => {\n                const sectionKey = field.section?.title || \"default\";\n                const groupKey = field.group || \"default\";\n\n                if (!acc[sectionKey]) {\n                  acc[sectionKey] = {\n                    section: field.section,\n                    groups: {},\n                  };\n                }\n\n                if (!acc[sectionKey].groups[groupKey]) {\n                  acc[sectionKey].groups[groupKey] = [];\n                }\n\n                acc[sectionKey].groups[groupKey].push(field);\n                return acc;\n              }, {} as Record<string, { section?: { title?: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\n\n              const renderSection = (\n                sectionKey: string,\n                sectionData: {\n                  section?: {\n                    title?: string;\n                    description?: string;\n                    collapsible?: boolean;\n                    defaultExpanded?: boolean;\n                  };\n                  groups: Record<string, FieldConfig[]>;\n                }\n              ) => (\n                <SectionRenderer\n                  key={sectionKey}\n                  sectionKey={sectionKey}\n                  sectionData={sectionData}\n                  renderField={renderField}\n                  collapseLabel={collapseLabel}\n                  expandLabel={expandLabel}\n                  form={form as unknown as AnyFormApi}\n                  layout={layout}\n                />\n              );\n\n              const sectionsToRender = Object.entries(groupedFields);\n\n              return sectionsToRender.length === 1 &&\n                sectionsToRender[0][0] === \"default\"\n                ? sectionsToRender[0][1].groups.default?.map(\n                    (field: FieldConfig) => renderField(field)\n                  )\n                : sectionsToRender.map(([sectionKey, sectionData]) =>\n                    renderSection(sectionKey, sectionData)\n                  );\n            }}\n          </ConditionalFieldsSubscription>\n        );\n      },\n      [renderField]\n    );\n\n    const renderPageContent = React.useCallback(() => {\n      if (hasTabs) {\n        // Render tabs - memoize tab content to prevent rerenders\n        const tabsToRender = tabs!.map((tab) => ({\n          id: tab.id,\n          label: tab.label,\n          content: renderTabContent(fieldsByTab[tab.id] || []),\n        }));\n\n        return (\n          <FormTabs\n            tabs={tabsToRender}\n            activeTab={activeTab}\n            onTabChange={handleTabChange}\n          />\n        );\n      }\n\n      // Original page rendering logic with TanStack Form best practices\n      const currentFields = getCurrentPageFields();\n      const pageConfig = getCurrentPageConfig();\n\n      // For now, subscribe to all form values since we don't have explicit dependencies\n      // This could be optimized further by analyzing the condition functions\n\n      // TanStack Form Best Practice: Use targeted selector for minimal re-renders\n      return (\n        <form.Subscribe selector={(state: any) => state.values}>\n          {(currentValues: any) => {\n            // Filter fields based on conditional sections using subscribed values\n            const visibleFields = currentFields.filter((field) => {\n              const conditionalSection = conditionalSections.find((section) =>\n                section.fields.includes(field.name)\n              );\n\n              if (conditionalSection) {\n                return conditionalSection.condition(\n                  currentValues as TFormValues\n                );\n              }\n\n              return true;\n            });\n\n            // Group fields by section and group\n            const groupedFields = visibleFields.reduce((acc, field) => {\n              const sectionKey = field.section?.title || \"default\";\n              const groupKey = field.group || \"default\";\n\n              if (!acc[sectionKey]) {\n                acc[sectionKey] = {\n                  section: field.section,\n                  groups: {},\n                };\n              }\n\n              if (!acc[sectionKey].groups[groupKey]) {\n                acc[sectionKey].groups[groupKey] = [];\n              }\n\n              acc[sectionKey].groups[groupKey].push(field);\n              return acc;\n            }, {} as Record<string, { section?: { title?: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\n\n            const renderSection = (\n              sectionKey: string,\n              sectionData: {\n                section?: {\n                  title?: string;\n                  description?: string;\n                  collapsible?: boolean;\n                  defaultExpanded?: boolean;\n                };\n                groups: Record<string, FieldConfig[]>;\n              }\n            ) => (\n              <SectionRenderer\n                key={sectionKey}\n                sectionKey={sectionKey}\n                sectionData={sectionData}\n                renderField={renderField}\n                collapseLabel={collapseLabel}\n                expandLabel={expandLabel}\n                form={form as unknown as AnyFormApi}\n                layout={layout}\n              />\n            );\n\n            const sectionsToRender = Object.entries(groupedFields);\n\n            const PageComponent = pageConfig?.component || DefaultPageComponent;\n\n            return (\n              <PageComponent\n                title={pageConfig?.title}\n                description={pageConfig?.description}\n                page={currentPage}\n                totalPages={totalPages}\n              >\n                {sectionsToRender.length === 1 &&\n                sectionsToRender[0][0] === \"default\"\n                  ? sectionsToRender[0][1].groups.default?.map(\n                      (field: FieldConfig) => renderField(field)\n                    )\n                  : sectionsToRender.map(([sectionKey, sectionData]) =>\n                      renderSection(sectionKey, sectionData)\n                    )}\n              </PageComponent>\n            );\n          }}\n        </form.Subscribe>\n      );\n    }, [renderTabContent, renderField, activeTab]);\n\n    const renderProgress = () => {\n      if (!hasPages || !progress) return null;\n\n      const ProgressComponent = progress.component || DefaultProgressComponent;\n\n      return (\n        <ProgressComponent\n          value={progressValue}\n          currentPage={currentPage}\n          totalPages={totalPages}\n          className={progress.className}\n          showSteps={progress.showSteps}\n          showPercentage={progress.showPercentage}\n        />\n      );\n    };\n\n    const renderNavigation = () => {\n      if (!showSubmitButton) return null;\n      if (!hasPages) {\n        return (\n          <form.Subscribe\n            selector={(state) => ({\n              canSubmit: state.canSubmit,\n              isSubmitting: state.isSubmitting,\n            })}\n          >\n            {(state) => {\n              const { canSubmit, isSubmitting } = state as {\n                canSubmit: boolean;\n                isSubmitting: boolean;\n              };\n\n              const SubmitButton = submitButton || Button;\n\n              return (\n                <div className=\"flex justify-end\">\n                  <SubmitButton\n                    type=\"submit\"\n                    disabled={!canSubmit || isSubmitting || disabled || loading}\n                    className={cn(\"px-8\", submitButtonClassName)}\n                  >\n                  {loading\n                    ? \"Loading...\"\n                    : isSubmitting\n                    ? \"Submitting...\"\n                    : submitLabel}\n                  </SubmitButton>\n                </div>\n              );\n            }}\n          </form.Subscribe>\n        );\n      }\n\n      return (\n        <form.Subscribe\n          selector={(state) => ({\n            canSubmit: state.canSubmit,\n            isSubmitting: state.isSubmitting,\n          })}\n        >\n          {(state) => {\n            const { canSubmit, isSubmitting } = state as {\n              canSubmit: boolean;\n              isSubmitting: boolean;\n            };\n\n            const SubmitButton = submitButton || Button;\n\n            return (\n              <div className=\"flex justify-between gap-4\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={goToPreviousPage}\n                  disabled={isFirstPage || disabled || loading}\n                  className={cn(\n                    isFirstPage ? \"invisible\" : \"\",\n                    buttonClassName\n                  )}\n                >\n                  {previousLabel}\n                </Button>\n\n                <SubmitButton\n                  type=\"submit\"\n                  disabled={\n                    (!canSubmit || isSubmitting || disabled || loading) &&\n                    isLastPage\n                  }\n                  className={cn(\n                    \"px-8\",\n                    isLastPage ? submitButtonClassName : buttonClassName\n                  )}\n                >\n                  {loading && isLastPage\n                    ? \"Loading...\"\n                    : isSubmitting && isLastPage\n                    ? \"Submitting...\"\n                    : isLastPage\n                    ? submitLabel\n                    : nextLabel}\n                </SubmitButton>\n              </div>\n            );\n          }}\n        </form.Subscribe>\n      );\n    };\n\n    return (\n      <form\n        ref={htmlFormRef}\n        onSubmit={handleSubmit}\n        className={formClass}\n        action={action}\n        method={method}\n        encType={encType}\n        target={target}\n        autoComplete={autoComplete}\n        noValidate={noValidate}\n        acceptCharset={acceptCharset}\n        onReset={handleReset}\n        onInput={handleInput}\n        onInvalid={handleInvalid}\n        onKeyDown={handleKeyDown}\n        onKeyUp={handleKeyUp}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledby}\n        aria-describedby={ariaDescribedby}\n        tabIndex={tabIndex}\n      >\n        {children || (\n          <>\n            {renderProgress()}\n            {renderPageContent()}\n            {renderNavigation()}\n          </>\n        )}\n      </form>\n    );\n  };\n\n  return {\n    form,\n    Form,\n    currentPage,\n    totalPages,\n    visiblePages,\n    goToNextPage,\n    goToPreviousPage,\n    setCurrentPage: setCurrentPageWithValidation,\n    isFirstPage,\n    isLastPage,\n    progressValue,\n    // Advanced features\n    crossFieldErrors,\n    asyncValidationStates,\n    validateCrossFields,\n    validateFieldAsync,\n    saveToStorage,\n    loadFromStorage,\n    clearStorage,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/lib/formedible/types.ts",
      "content": "import React from 'react';\nimport type { AnyFieldApi } from '@tanstack/react-form';\nimport type { FormApi, ValidationError, FormState } from '@tanstack/form-core';\nimport { z } from 'zod';\n\n// Strict type definitions for better type safety\nexport interface StrictFieldApi<T = unknown> {\n  name: string;\n  value: T;\n  errors: ValidationError[];\n  touched: boolean;\n  setValue: (value: T) => void;\n  setTouched: (touched: boolean) => void;\n  validate: () => Promise<ValidationError[]>;\n}\n\nexport interface TypedFormState<TFormData = Record<string, unknown>> {\n  values: TFormData;\n  errors: Record<keyof TFormData, ValidationError[]>;\n  touched: Record<keyof TFormData, boolean>;\n  isSubmitting: boolean;\n  isValidating: boolean;\n  canSubmit: boolean;\n}\n\nexport interface TypedFormSubscriptionSelector<TFormData = Record<string, unknown>, TSelected = unknown> {\n  (state: FormState<TFormData, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined>): TSelected;\n}\n\n// Validation error types based on TanStack Form\nexport type FormedibleValidationError = ValidationError;\n\n// Validation error that can be a string, Error object, or custom validation result\nexport type FieldValidationError = string | Error | ValidationError;\n\n// Array of validation errors for a field\nexport type FieldValidationErrors = FieldValidationError[];\n\n// Type alias for our FormApi - use the core FormApi type which is what useForm actually returns\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\n  TFormData,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  never\n>;\n\n// Option types for select, radio, and multi-select fields\nexport type FieldOption = {\n  value: string;\n  label: string;\n  disabled?: boolean;\n  description?: string;\n};\n\nexport type FieldOptions = string[] | FieldOption[];\n\n// Normalize options to consistent format\nexport type NormalizedFieldOption = FieldOption;\n\n// Props that all basic field components rendered by FormedibleRoot will receive\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  description?: string;\n  placeholder?: string;\n  inputClassName?: string;   // For the <Input /> component itself\n  labelClassName?: string;   // For the <Label /> component\n  wrapperClassName?: string; // For the div wrapping label and input\n}\n\n// Specific field component prop types\nexport interface SelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n}\n\nexport interface RadioFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n}\n\nexport interface MultiSelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n  maxSelections?: number;\n}\n\n// Shared object configuration interface - DRY!\nexport interface ObjectConfig {\n  title?: string;\n  description?: string;\n  fields: Array<{\n    name: string;\n    type: string;\n    label?: string;\n    placeholder?: string;\n    description?: string;\n    options?: Array<{ value: string; label: string }> | ((values: Record<string, unknown>) => Array<{ value: string; label: string }>);\n    min?: number;\n    max?: number;\n    step?: number;\n    [key: string]: unknown;\n  }>;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n  showCard?: boolean;\n  layout?: \"grid\" | \"vertical\" | \"horizontal\";\n  columns?: number;\n  collapseLabel?: string;\n  expandLabel?: string;\n}\n\nexport interface ArrayFieldProps extends BaseFieldProps {\n  arrayConfig: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    itemComponent?: React.ComponentType<BaseFieldProps>;\n    itemProps?: Record<string, unknown>;\n    // Use the shared ObjectConfig - DRY!\n    objectConfig?: ObjectConfig;\n  };\n}\n\nexport interface TextFieldProps extends BaseFieldProps {\n  type?: 'text' | 'email' | 'password' | 'url' | 'tel';\n  datalist?: string[];\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  autoComplete?: string;\n}\n\nexport interface NumberFieldProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  precision?: number;\n}\n\nexport interface DateFieldProps extends BaseFieldProps {\n  dateConfig?: {\n    format?: string;\n    minDate?: Date;\n    maxDate?: Date;\n    disabledDates?: Date[];\n    showTime?: boolean;\n    timeFormat?: string;\n  };\n}\n\nexport interface SliderFieldProps extends BaseFieldProps {\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    // Value mapping between slider value (int) and display value (arbitrary)\n    valueMapping?: Array<{\n      sliderValue: number;\n      displayValue: string | number;\n      label?: string;\n    }>;\n    // Gradient colors for the slider\n    gradientColors?: {\n      start: string;\n      end: string;\n      direction?: 'horizontal' | 'vertical';\n    };\n    // Custom visualization component for each step\n    visualizationComponent?: React.ComponentType<{\n      value: number;\n      displayValue: string | number;\n      label?: string;\n      isActive: boolean;\n    }>;\n    // Legacy and additional config\n    valueLabelPrefix?: string;\n    valueLabelSuffix?: string;\n    valueDisplayPrecision?: number;\n    showRawValue?: boolean;\n    showValue?: boolean;\n    showTooltip?: boolean;\n    showTicks?: boolean;\n    orientation?: 'horizontal' | 'vertical';\n    marks?: Array<{ value: number; label: string }>;\n  };\n}\n\nexport interface FileUploadFieldProps extends BaseFieldProps {\n  fileConfig?: {\n    accept?: string;\n    multiple?: boolean;\n    maxSize?: number;\n    maxFiles?: number;\n    allowedTypes?: string[];\n    uploadUrl?: string;\n    onUpload?: (files: File[]) => Promise<string[]>;\n  };\n}\n\nexport interface LocationPickerFieldProps extends BaseFieldProps {\n  locationConfig?: LocationConfig;\n}\n\nexport interface DurationPickerFieldProps extends BaseFieldProps {\n  durationConfig?: DurationConfig;\n}\n\nexport interface AutocompleteFieldProps extends BaseFieldProps {\n  autocompleteConfig?: AutocompleteConfig;\n}\n\nexport interface MaskedInputFieldProps extends BaseFieldProps {\n  maskedConfig?: MaskedInputConfig;\n}\n\nexport interface ColorPickerFieldProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showPreview?: boolean; // Show color preview\n    showAlpha?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n  };\n}\n\nexport interface RatingFieldProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    allowClear?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs' | React.ComponentType;\n    size?: 'sm' | 'md' | 'lg' | 'small' | 'medium' | 'large';\n    showValue?: boolean;\n  };\n}\n\nexport interface PhoneFieldProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    preferredCountries?: string[];\n    onlyCountries?: string[];\n    excludeCountries?: string[];\n    format?: 'national' | 'international';\n  };\n}\n\nexport interface ObjectFieldProps extends BaseFieldProps {\n  objectConfig?: ObjectConfig;\n  disabled?: boolean;\n  form?: any;\n}\n\n// Field-specific interfaces moved from field components for centralization\nexport interface TextFieldSpecificProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\" | \"datetime-local\";\n  datalist?: {\n    options?: string[];\n    asyncOptions?: (query: string) => Promise<string[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n  };\n}\n\nexport interface NumberFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nexport interface TextareaFieldSpecificProps extends BaseFieldProps {\n  rows?: number;\n}\n\nexport interface RadioFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  direction?: 'horizontal' | 'vertical';\n}\n\nexport interface PhoneFieldSpecificProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    format?: 'national' | 'international';\n    allowedCountries?: string[];\n    placeholder?: string;\n    excludedCountries?: string[];\n  };\n}\n\nexport interface MultiSelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n}\n\nexport interface ColorPickerFieldSpecificProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showPreview?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n    showAlpha?: boolean;\n  };\n}\n\nexport interface RatingFieldSpecificProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs';\n    size?: 'sm' | 'md' | 'lg';\n    allowClear?: boolean;\n    showValue?: boolean;\n  };\n}\n\nexport interface SliderFieldSpecificProps extends BaseFieldProps {\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    // Value mapping between slider value (int) and display value (arbitrary)\n    valueMapping?: Array<{\n      sliderValue: number;\n      displayValue: string | number;\n      label?: string;\n    }>;\n    // Gradient colors for the slider\n    gradientColors?: {\n      start: string;\n      end: string;\n      direction?: 'horizontal' | 'vertical';\n    };\n    // Custom visualization component for each step\n    visualizationComponent?: React.ComponentType<{\n      value: number;\n      displayValue: string | number;\n      label?: string;\n      isActive: boolean;\n    }>;\n    // Legacy support\n    valueLabelPrefix?: string;\n    valueLabelSuffix?: string;\n    valueDisplayPrecision?: number;\n    showRawValue?: boolean;\n    showValue?: boolean;\n    showTooltip?: boolean;\n    orientation?: 'horizontal' | 'vertical';\n    marks?: Array<{ value: number; label: string }>;\n  };\n  // Direct props for backwards compatibility\n  min?: number;\n  max?: number;\n  step?: number;\n  valueLabelPrefix?: string;\n  valueLabelSuffix?: string;\n  valueDisplayPrecision?: number;\n  showRawValue?: boolean;\n}\n\n// Layout component interfaces moved from layout components for centralization\nexport interface FormGridProps {\n  children: React.ReactNode;\n  columns?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n  gap?: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12';\n  responsive?: boolean;\n  className?: string;\n}\n\nexport interface FormTabsProps {\n  children?: React.ReactNode;\n  tabs: {\n    id: string;\n    label: string;\n    content: React.ReactNode;\n  }[];\n  activeTab: string; // CONTROLLED - NO INTERNAL STATE\n  className?: string;\n  onTabChange: (tabId: string) => void; // REQUIRED - PARENT CONTROLS STATE\n}\n\nexport interface FormAccordionProps {\n  children?: React.ReactNode;\n  sections: {\n    id: string;\n    title: string;\n    content: React.ReactNode;\n    defaultOpen?: boolean;\n  }[];\n  type?: 'single' | 'multiple';\n  className?: string;\n}\n\nexport interface FormStepperStep {\n  id: string;\n  title: string;\n  description?: string;\n  content: React.ReactNode;\n  optional?: boolean;\n}\n\nexport interface FormStepperProps {\n  children?: React.ReactNode;\n  steps: FormStepperStep[];\n  currentStep?: number;\n  onStepChange?: (stepIndex: number) => void;\n  onComplete?: () => void;\n  className?: string;\n  allowSkip?: boolean;\n  showStepNumbers?: boolean;\n}\n\n// Wrapper component interfaces moved from field components for centralization\nexport interface FieldWrapperProps extends BaseFieldProps {\n  children: React.ReactNode;\n  htmlFor?: string;\n  showErrors?: boolean;\n}\n\nexport interface InlineValidationWrapperProps {\n  children: React.ReactNode;\n  fieldApi: AnyFieldApi;\n  inlineValidation?: {\n    enabled?: boolean;\n    debounceMs?: number;\n    showSuccess?: boolean;\n    asyncValidator?: (value: unknown) => Promise<string | null>;\n  };\n  className?: string;\n}\n\n// Union type for all possible field component props - using intersection for flexibility\nexport type FieldComponentProps = BaseFieldProps & {\n  // Optional props that specific field types might need\n  options?: FieldOptions;\n  arrayConfig?: ArrayFieldProps['arrayConfig'];\n  objectConfig?: ObjectConfig;\n  type?: TextFieldProps['type'];\n  datalist?: string[];\n  dateConfig?: DateFieldProps['dateConfig'];\n  sliderConfig?: SliderFieldProps['sliderConfig'];\n  fileConfig?: FileUploadFieldProps['fileConfig'];\n  locationConfig?: LocationPickerFieldProps['locationConfig'];\n  durationConfig?: DurationPickerFieldProps['durationConfig'];\n  autocompleteConfig?: AutocompleteFieldProps['autocompleteConfig'];\n  maskedConfig?: MaskedInputFieldProps['maskedConfig'];\n  colorConfig?: ColorPickerFieldProps['colorConfig'];\n  ratingConfig?: RatingFieldProps['ratingConfig'];\n  phoneConfig?: PhoneFieldProps['phoneConfig'];\n  // Legacy support for existing configurations\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n  maskedInputConfig?: MaskedInputConfig;\n  // Allow additional props for extensibility\n  [key: string]: unknown;\n};\n\n// Cross-field validation configuration\nexport interface CrossFieldValidation<TFormValues = Record<string, unknown>> {\n  fields: (keyof TFormValues)[];\n  validator: (values: Partial<TFormValues>) => string | null;\n  message: string;\n}\n\n// Async validation configuration\nexport interface AsyncValidation {\n  validator: (value: unknown) => Promise<string | null>;\n  debounceMs?: number;\n  loadingMessage?: string;\n}\n\n// Enhanced form analytics and tracking configuration\nexport interface FormAnalytics {\n  // Field-level analytics\n  onFieldFocus?: (fieldName: string, timestamp: number) => void;\n  onFieldBlur?: (fieldName: string, timeSpent: number) => void;\n  onFieldChange?: (fieldName: string, value: unknown, timestamp: number) => void;\n  onFieldComplete?: (fieldName: string, isValid: boolean, timeSpent: number) => void;\n  onFieldError?: (fieldName: string, errors: string[], timestamp: number) => void;\n  \n  // Form-level analytics\n  onFormStart?: (timestamp: number) => void;\n  onFormComplete?: (timeSpent: number, formData: unknown) => void;\n  onFormAbandon?: (completionPercentage: number, context?: { currentPage?: number; currentTab?: string; lastActiveField?: string }) => void;\n  onFormReset?: (timestamp: number, reason?: string) => void;\n  \n  // Page-level analytics (for multi-page forms)\n  onPageChange?: (fromPage: number, toPage: number, timeSpent: number, pageValidationState?: { hasErrors: boolean; completionPercentage: number }) => void;\n  onPageComplete?: (pageNumber: number, timeSpent: number, fieldsCompleted: number, totalFields: number) => void;\n  onPageAbandon?: (pageNumber: number, completionPercentage: number, timeSpent: number) => void;\n  onPageValidationError?: (pageNumber: number, errors: Record<string, string[]>, timestamp: number) => void;\n  \n  // Tab-level analytics (for tabbed forms)\n  onTabChange?: (fromTab: string, toTab: string, timeSpent: number, tabCompletionState?: { completionPercentage: number; hasErrors: boolean }) => void;\n  onTabComplete?: (tabId: string, timeSpent: number, fieldsCompleted: number, totalFields: number) => void;\n  onTabAbandon?: (tabId: string, completionPercentage: number, timeSpent: number) => void;\n  onTabValidationError?: (tabId: string, errors: Record<string, string[]>, timestamp: number) => void;\n  onTabFirstVisit?: (tabId: string, timestamp: number) => void;\n  \n  // Performance analytics\n  onRenderPerformance?: (componentName: string, renderTime: number, rerenderCount: number) => void;\n  onValidationPerformance?: (fieldName: string, validationType: 'sync' | 'async', duration: number) => void;\n  onSubmissionPerformance?: (submissionTime: number, validationTime: number, processingTime: number) => void;\n}\n\n// Tab analytics state tracking\nexport interface TabAnalyticsState {\n  tabId: string;\n  startTime: number;\n  visitCount: number;\n  fieldsCompleted: number;\n  totalFields: number;\n  hasErrors: boolean;\n  lastActiveField?: string;\n  completionPercentage: number;\n}\n\n// Page analytics state tracking  \nexport interface PageAnalyticsState {\n  pageNumber: number;\n  startTime: number;\n  visitCount: number;\n  fieldsCompleted: number;\n  totalFields: number;\n  hasErrors: boolean;\n  lastActiveField?: string;\n  completionPercentage: number;\n  validationErrors: Record<string, string[]>;\n}\n\n// Performance tracking metrics\nexport interface PerformanceMetrics {\n  renderCount: number;\n  lastRenderTime: number;\n  averageRenderTime: number;\n  validationDurations: Record<string, number[]>;\n  submissionMetrics: {\n    totalTime: number;\n    validationTime: number;\n    processingTime: number;\n  };\n}\n\n// Analytics context for tracking form interaction patterns\nexport interface AnalyticsContext {\n  sessionId: string;\n  formId: string;\n  userId?: string;\n  currentPage?: number;\n  currentTab?: string;\n  startTime: number;\n  pageStates: Record<number, PageAnalyticsState>;\n  tabStates: Record<string, TabAnalyticsState>;\n  performanceMetrics: PerformanceMetrics;\n  fieldInteractions: Record<string, {\n    focusCount: number;\n    totalTimeSpent: number;\n    changeCount: number;\n    errorCount: number;\n    isCompleted: boolean;\n  }>;\n}\n\n// Layout configuration for forms\nexport interface LayoutConfig {\n  type: 'grid' | 'flex' | 'tabs' | 'accordion' | 'stepper';\n  columns?: number;\n  gap?: string;\n  responsive?: boolean;\n  className?: string;\n}\n\n// Conditional sections configuration\nexport interface ConditionalSection<TFormValues = Record<string, unknown>> {\n  condition: (values: TFormValues) => boolean;\n  fields: string[];\n  layout?: LayoutConfig;\n}\n\n// Location picker configuration\nexport interface LocationValue {\n  lat: number;\n  lng: number;\n  address?: string;\n  country?: string;\n  city?: string;\n  state?: string;\n  postalCode?: string;\n  [key: string]: any; // Allow additional properties from different services\n}\n\nexport interface LocationSearchResult extends LocationValue {\n  id: string | number;\n  relevance?: number;\n  bounds?: {\n    northeast: { lat: number; lng: number };\n    southwest: { lat: number; lng: number };\n  };\n}\n\nexport interface LocationConfig {\n  // Basic configuration\n  defaultLocation?: { lat: number; lng: number };\n  zoom?: number;\n  searchPlaceholder?: string;\n  enableSearch?: boolean;\n  enableGeolocation?: boolean;\n  enableManualEntry?: boolean;\n  showMap?: boolean;\n  \n  // Map provider - determines which map component to render\n  mapProvider?: 'google' | 'openstreetmap' | 'bing' | 'custom' | 'cartodb' | 'stamen' | 'satellite';\n  \n  // User-defined search function\n  // This function should handle the API calls to your preferred geocoding service\n  searchCallback?: (query: string, options?: {\n    // Optional parameters that can be passed to the search\n    limit?: number;\n    countryCode?: string;\n    bounds?: {\n      northeast: { lat: number; lng: number };\n      southwest: { lat: number; lng: number };\n    };\n    [key: string]: any;\n  }) => Promise<LocationSearchResult[]>;\n  \n  // User-defined reverse geocoding function\n  // This function should convert coordinates back to an address\n  reverseGeocodeCallback?: (lat: number, lng: number) => Promise<LocationValue>;\n  \n  // Map rendering callback - allows complete customization of map display\n  mapRenderCallback?: (params: {\n    location: LocationValue | null;\n    onLocationSelect: (location: LocationValue) => void;\n    mapContainer: HTMLDivElement;\n    zoom: number;\n    readonly: boolean;\n    defaultLocation?: { lat: number; lng: number };\n  }) => {\n    // Return cleanup function\n    cleanup?: () => void;\n    // Update location on map\n    updateLocation?: (location: LocationValue) => void;\n  };\n  \n  // Provider-specific configuration\n  googleMaps?: {\n    apiKey: string;\n    libraries?: string[];\n    mapOptions?: any; // Google Maps MapOptions\n    searchOptions?: any; // Google Places search options\n  };\n  \n  openStreetMap?: {\n    tileServer?: string; // Custom tile server URL\n    attribution?: string;\n    nominatimEndpoint?: string; // Custom Nominatim endpoint\n    searchOptions?: {\n      countrycodes?: string;\n      addressdetails?: boolean;\n      limit?: number;\n      [key: string]: any;\n    };\n  };\n  \n  bingMaps?: {\n    apiKey: string;\n    mapOptions?: any; // Bing Maps options\n    searchOptions?: any; // Bing geocoding options\n  };\n  \n  // Custom provider configuration\n  custom?: {\n    [key: string]: any;\n  };\n  \n  // Search behavior\n  searchOptions?: {\n    debounceMs?: number;\n    minQueryLength?: number;\n    maxResults?: number;\n    countryCode?: string; // ISO country code to restrict search\n    bounds?: {\n      northeast: { lat: number; lng: number };\n      southwest: { lat: number; lng: number };\n    };\n    [key: string]: any;\n  };\n  \n  // UI customization\n  ui?: {\n    showCoordinates?: boolean;\n    showAddress?: boolean;\n    mapHeight?: number;\n    searchInputClassName?: string;\n    mapClassName?: string;\n    coordinatesFormat?: 'decimal' | 'dms'; // Decimal degrees or degrees/minutes/seconds\n    [key: string]: any;\n  };\n}\n\n// Duration picker configuration\nexport interface DurationValue {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  totalSeconds?: number;\n}\n\nexport interface DurationConfig {\n  format?: 'hms' | 'hm' | 'ms' | 'hours' | 'minutes' | 'seconds';\n  maxHours?: number;\n  maxMinutes?: number;\n  maxSeconds?: number;\n  showLabels?: boolean;\n  allowNegative?: boolean;\n}\n\n// Autocomplete configuration\nexport interface AutocompleteConfig {\n  options?: string[] | { value: string; label: string }[];\n  asyncOptions?: (query: string) => Promise<string[] | { value: string; label: string }[]>;\n  debounceMs?: number;\n  minChars?: number;\n  maxResults?: number;\n  allowCustom?: boolean;\n  placeholder?: string;\n  noOptionsText?: string;\n  loadingText?: string;\n}\n\n// Masked input configuration\nexport interface MaskedInputConfig {\n  mask: string | ((value: string) => string);\n  placeholder?: string;\n  showMask?: boolean;\n  guide?: boolean;\n  keepCharPositions?: boolean;\n  pipe?: (conformedValue: string, config: unknown) => false | string | { value: string; indexesOfPipedChars: number[] };\n}\n\n// Field validation configuration\nexport interface FieldValidationConfig {\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  custom?: string;\n  includes?: string;\n  startsWith?: string;\n  endsWith?: string;\n  email?: boolean;\n  url?: boolean;\n  uuid?: boolean;\n  transform?: string;\n  refine?: string;\n  customMessages?: Record<string, string>;\n}\n\n// Help configuration for fields\nexport interface FieldHelpConfig {\n  text?: string;\n  tooltip?: string;\n  position?: 'top' | 'bottom' | 'left' | 'right';\n  link?: { url: string; text: string };\n}\n\n// Inline validation configuration\nexport interface InlineValidationConfig {\n  enabled?: boolean;\n  debounceMs?: number;\n  showSuccess?: boolean;\n  asyncValidator?: (value: unknown) => Promise<string | null>;\n}\n\n// Section configuration\nexport interface SectionConfig {\n  title?: string;\n  description?: string;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n}\n\n// Datalist configuration\nexport interface DatalistConfig {\n  options?: string[];\n  asyncOptions?: (query: string) => Promise<string[]>;\n  debounceMs?: number;\n  minChars?: number;\n  maxResults?: number;\n}\n\n// Textarea configuration\nexport interface TextareaConfig {\n  rows?: number;\n  cols?: number;\n  resize?: 'none' | 'vertical' | 'horizontal' | 'both';\n  maxLength?: number;\n  showWordCount?: boolean;\n}\n\n// Password configuration\nexport interface PasswordConfig {\n  showToggle?: boolean;\n  strengthMeter?: boolean;\n  minStrength?: number;\n  requirements?: {\n    minLength?: number;\n    requireUppercase?: boolean;\n    requireLowercase?: boolean;\n    requireNumbers?: boolean;\n    requireSymbols?: boolean;\n  };\n}\n\n// Email configuration\nexport interface EmailConfig {\n  allowedDomains?: string | string[];\n  blockedDomains?: string | string[];\n  suggestions?: string | string[];\n  validateMX?: boolean;\n}\n\n// Number configuration\nexport interface NumberConfig {\n  min?: number;\n  max?: number;\n  step?: number;\n  precision?: number;\n  allowNegative?: boolean;\n  showSpinButtons?: boolean;\n}\n\n// Multi-select configuration\nexport interface MultiSelectConfig {\n  maxSelections?: number;\n  searchable?: boolean;\n  creatable?: boolean;\n  placeholder?: string;\n  noOptionsText?: string;\n  loadingText?: string;\n}\n\n// Hook interfaces moved from use-formedible.tsx for centralization\nexport interface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  // HTML form attributes\n  action?: string;\n  method?: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  encType?:\n    | \"application/x-www-form-urlencoded\"\n    | \"multipart/form-data\"\n    | \"text/plain\";\n  target?: \"_blank\" | \"_self\" | \"_parent\" | \"_top\" | string;\n  autoComplete?: \"on\" | \"off\";\n  noValidate?: boolean;\n  acceptCharset?: string;\n  // Event handlers\n  onReset?: (e: React.FormEvent) => void;\n  onInput?: (e: React.FormEvent) => void;\n  onInvalid?: (e: React.FormEvent) => void;\n  onKeyDown?: (e: React.KeyboardEvent) => void;\n  onKeyUp?: (e: React.KeyboardEvent) => void;\n  onFocus?: (e: React.FocusEvent) => void;\n  onBlur?: (e: React.FocusEvent) => void;\n  // Accessibility\n  role?: string;\n  \"aria-label\"?: string;\n  \"aria-labelledby\"?: string;\n  \"aria-describedby\"?: string;\n  tabIndex?: number;\n}\n\nexport interface ConditionalFieldsSubscriptionProps<\n  TFormValues extends Record<string, unknown> = Record<string, unknown>\n> {\n  form: any;\n  fields: FieldConfig[];\n  conditionalSections: Array<{\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }>;\n  children: (currentValues: Record<string, unknown>) => React.ReactNode;\n}\n\nexport interface FieldConditionalRendererProps {\n  form: any;\n  fieldConfig: FieldConfig;\n  children: (shouldRender: boolean) => React.ReactNode;\n}\n\nexport interface SectionRendererProps {\n  sectionKey: string;\n  sectionData: {\n    section?: {\n      title?: string;\n      description?: string;\n      collapsible?: boolean;\n      defaultExpanded?: boolean;\n    };\n    groups: Record<string, FieldConfig[]>;\n  };\n  renderField: (field: FieldConfig) => React.ReactNode;\n}\n\nexport interface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  schema?: z.ZodSchema<TFormValues>;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  // Translation support for section buttons\n  collapseLabel?: string;\n  expandLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  labelClassName?: string;\n  buttonClassName?: string;\n  submitButtonClassName?: string;\n  // Auto scroll configuration\n  autoScroll?: boolean;\n  submitButton?: React.ComponentType<\n    React.ButtonHTMLAttributes<HTMLButtonElement> & {\n      children?: React.ReactNode;\n    }\n  >;\n  pages?: PageConfig[];\n  progress?: ProgressConfig;\n  tabs?: {\n    id: string;\n    label: string;\n    description?: string;\n  }[];\n  defaultComponents?: {\n    [key: string]: React.ComponentType<FieldComponentProps>;\n  };\n  globalWrapper?: React.ComponentType<{\n    children: React.ReactNode;\n    field: FieldConfig;\n  }>;\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => unknown | Promise<unknown>;\n    onSubmitInvalid: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onChange?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onBlur?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onFocus?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onReset?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    asyncDebounceMs: number;\n    canSubmitWhenInvalid: boolean;\n  }>;\n  onPageChange?: (page: number, direction: \"next\" | \"previous\") => void;\n  autoSubmitOnChange?: boolean;\n  autoSubmitDebounceMs?: number;\n  disabled?: boolean;\n  loading?: boolean;\n  resetOnSubmitSuccess?: boolean;\n  showSubmitButton?: boolean;\n  // Form-level event handlers\n  onFormReset?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormInput?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormInvalid?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormKeyDown?: (\n    e: React.KeyboardEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormKeyUp?: (\n    e: React.KeyboardEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormFocus?: (\n    e: React.FocusEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormBlur?: (\n    e: React.FocusEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  // Advanced validation features\n  crossFieldValidation?: {\n    fields: (keyof TFormValues)[];\n    validator: (values: Partial<TFormValues>) => string | null;\n    message: string;\n  }[];\n  asyncValidation?: {\n    [fieldName: string]: {\n      validator: (value: unknown) => Promise<string | null>;\n      debounceMs?: number;\n      loadingMessage?: string;\n    };\n  };\n  // Form analytics and tracking\n  analytics?: FormAnalytics;\n  // Layout configuration\n  layout?: {\n    type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n    columns?: number;\n    gap?: string;\n    responsive?: boolean;\n    className?: string;\n  };\n  // Conditional sections\n  conditionalSections?: {\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }[];\n  // Form persistence\n  persistence?: {\n    key: string;\n    storage: \"localStorage\" | \"sessionStorage\";\n    debounceMs?: number;\n    exclude?: string[];\n    restoreOnMount?: boolean;\n  };\n}\n\n// Main FieldConfig interface - DRY version using existing types\nexport interface FieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  description?: string;\n  options?: string[] | { value: string; label: string }[] | ((values: Record<string, unknown>) => string[] | { value: string; label: string }[]);\n  min?: number;\n  max?: number;\n  step?: number;\n  accept?: string;\n  multiple?: boolean;\n  component?: React.ComponentType<FieldComponentProps>;\n  wrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>;\n  page?: number;\n  tab?: string;\n  validation?: z.ZodSchema<unknown>;\n  dependencies?: string[];\n  conditional?: (values: Record<string, unknown>) => boolean;\n  group?: string;\n  \n  // Configuration objects using existing types\n  arrayConfig?: ArrayFieldProps['arrayConfig'];\n  ratingConfig?: RatingFieldProps['ratingConfig'];\n  phoneConfig?: PhoneFieldProps['phoneConfig'];\n  colorConfig?: ColorPickerFieldProps['colorConfig'];\n  multiSelectConfig?: MultiSelectConfig;\n  locationConfig?: LocationConfig;\n  durationConfig?: DurationConfig;\n  autocompleteConfig?: AutocompleteConfig;\n  maskedInputConfig?: MaskedInputConfig;\n  objectConfig?: ObjectConfig;\n  sliderConfig?: SliderFieldProps['sliderConfig'];\n  numberConfig?: NumberConfig;\n  dateConfig?: DateFieldProps['dateConfig'];\n  fileConfig?: FileUploadFieldProps['fileConfig'];\n  textareaConfig?: TextareaConfig;\n  passwordConfig?: PasswordConfig;\n  emailConfig?: EmailConfig;\n  \n  // Additional configurations\n  datalist?: DatalistConfig;\n  help?: FieldHelpConfig;\n  inlineValidation?: InlineValidationConfig;\n  section?: SectionConfig;\n  validationConfig?: FieldValidationConfig;\n}\n\n// Page configuration for multi-page forms\nexport interface PageConfig {\n  page: number;\n  title?: string;\n  description?: string;\n  component?: React.ComponentType<{\n    children: React.ReactNode;\n    title?: string;\n    description?: string;\n    page: number;\n    totalPages: number;\n  }>;\n  conditional?: (values: Record<string, unknown>) => boolean;\n}\n\n// Progress configuration for multi-page forms\nexport interface ProgressConfig {\n  component?: React.ComponentType<{\n    value: number;\n    currentPage: number;\n    totalPages: number;\n    className?: string;\n  }>;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n  className?: string;\n} ",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/formedible/colors.ts",
      "content": "export const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\nexport const hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {\n  const rgb = hexToRgb(hex);\n  if (!rgb) return null;\n  \n  const { r, g, b } = rgb;\n  const rNorm = r / 255;\n  const gNorm = g / 255;\n  const bNorm = b / 255;\n  \n  const max = Math.max(rNorm, gNorm, bNorm);\n  const min = Math.min(rNorm, gNorm, bNorm);\n  const diff = max - min;\n  \n  let h = 0;\n  let s = 0;\n  const l = (max + min) / 2;\n  \n  if (diff !== 0) {\n    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);\n    \n    switch (max) {\n      case rNorm: h = (gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0); break;\n      case gNorm: h = (bNorm - rNorm) / diff + 2; break;\n      case bNorm: h = (rNorm - gNorm) / diff + 4; break;\n    }\n    h /= 6;\n  }\n  \n  return {\n    h: Math.round(h * 360),\n    s: Math.round(s * 100),\n    l: Math.round(l * 100)\n  };\n};",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/location.ts",
      "content": "import type {\n  LocationSearchResult,\n  LocationValue,\n} from \"@/lib/formedible/types\";\n\nexport const builtInProviders = {\n  nominatim: async (\n    query: string,\n    options: any = {}\n  ): Promise<LocationSearchResult[]> => {\n    const endpoint =\n      options.endpoint || \"https://nominatim.openstreetmap.org/search\";\n    const params = new URLSearchParams({\n      q: query,\n      format: \"json\",\n      limit: String(options.limit || 5),\n      addressdetails: \"1\",\n      ...options.searchOptions,\n    });\n\n    try {\n      const response = await fetch(`${endpoint}?${params}`);\n      const data = await response.json();\n\n      return data.map((item: any, index: number) => ({\n        id: item.place_id || index,\n        lat: parseFloat(item.lat),\n        lng: parseFloat(item.lon),\n        address: item.display_name,\n        city: item.address?.city || item.address?.town || item.address?.village,\n        state: item.address?.state,\n        country: item.address?.country,\n        postalCode: item.address?.postcode,\n        relevance: parseFloat(item.importance || 0),\n        bounds: item.boundingbox\n          ? {\n              northeast: {\n                lat: parseFloat(item.boundingbox[1]),\n                lng: parseFloat(item.boundingbox[3]),\n              },\n              southwest: {\n                lat: parseFloat(item.boundingbox[0]),\n                lng: parseFloat(item.boundingbox[2]),\n              },\n            }\n          : undefined,\n      }));\n    } catch (error) {\n      console.error(\"Nominatim search error:\", error);\n      return [];\n    }\n  },\n\n  nominatimReverse: async (\n    lat: number,\n    lng: number,\n    options: any = {}\n  ): Promise<LocationValue> => {\n    const endpoint =\n      options.endpoint || \"https://nominatim.openstreetmap.org/reverse\";\n    const params = new URLSearchParams({\n      lat: String(lat),\n      lon: String(lng),\n      format: \"json\",\n      addressdetails: \"1\",\n      ...options.searchOptions,\n    });\n\n    try {\n      const response = await fetch(`${endpoint}?${params}`);\n      const data = await response.json();\n\n      return {\n        lat,\n        lng,\n        address: data.display_name,\n        city: data.address?.city || data.address?.town || data.address?.village,\n        state: data.address?.state,\n        country: data.address?.country,\n        postalCode: data.address?.postcode,\n      };\n    } catch (error) {\n      console.error(\"Nominatim reverse geocoding error:\", error);\n      return { lat, lng, address: `${lat}, ${lng}` };\n    }\n  },\n};\n\nexport function formatCoordinates(\n  lat: number,\n  lng: number,\n  format: \"decimal\" | \"dms\" = \"decimal\"\n): string {\n  if (format === \"decimal\") {\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  } else {\n    const latDeg = Math.floor(Math.abs(lat));\n    const latMin = Math.floor((Math.abs(lat) - latDeg) * 60);\n    const latSec = ((Math.abs(lat) - latDeg) * 60 - latMin) * 60;\n    const latDir = lat >= 0 ? \"N\" : \"S\";\n\n    const lngDeg = Math.floor(Math.abs(lng));\n    const lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);\n    const lngSec = ((Math.abs(lng) - lngDeg) * 60 - lngMin) * 60;\n    const lngDir = lng >= 0 ? \"E\" : \"W\";\n\n    return `${latDeg}°${latMin}'${latSec.toFixed(\n      2\n    )}\"${latDir} ${lngDeg}°${lngMin}'${lngSec.toFixed(2)}\"${lngDir}`;\n  }\n}\n\nexport const defaultMapRenderer = (params: {\n  location: LocationValue | null;\n  onLocationSelect: (location: LocationValue) => void;\n  mapContainer: HTMLDivElement;\n  zoom: number;\n  readonly: boolean;\n  defaultLocation?: { lat: number; lng: number };\n}) => {\n  const {\n    location,\n    onLocationSelect,\n    mapContainer,\n    zoom,\n    readonly,\n    defaultLocation,\n  } = params;\n\n  const leafletMap = (window as any).L.map(mapContainer, {\n    center: [\n      location?.lat || defaultLocation?.lat || 51.5074,\n      location?.lng || defaultLocation?.lng || -0.1278,\n    ],\n    zoom: zoom || 10,\n    zoomControl: true,\n    dragging: !readonly,\n    touchZoom: !readonly,\n    scrollWheelZoom: !readonly,\n    doubleClickZoom: !readonly,\n    boxZoom: !readonly,\n    keyboard: !readonly,\n    tap: !readonly,\n  });\n\n  const osmTileLayer = (window as any).L.tileLayer(\n    \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    {\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n      maxZoom: 19,\n    }\n  );\n\n  osmTileLayer.addTo(leafletMap);\n\n  let currentMarker: any = null;\n\n  const updateMarker = (loc: LocationValue | null) => {\n    if (currentMarker) {\n      leafletMap.removeLayer(currentMarker);\n      currentMarker = null;\n    }\n\n    if (loc) {\n      const customIcon = (window as any).L.divIcon({\n        className: \"custom-div-icon\",\n        html: `\n          <div style=\"\n            background-color: #ef4444;\n            color: white;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 12px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n            white-space: nowrap;\n            position: relative;\n            margin-bottom: 8px;\n          \">\n            📍 ${loc.address || `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`}\n          </div>\n          <div style=\"\n            width: 0;\n            height: 0;\n            border-left: 8px solid transparent;\n            border-right: 8px solid transparent;\n            border-top: 8px solid #ef4444;\n            margin: 0 auto;\n            margin-top: -4px;\n          \"></div>\n        `,\n        iconSize: [0, 0],\n        iconAnchor: [0, 0],\n      });\n\n      currentMarker = (window as any).L.marker([loc.lat, loc.lng], {\n        icon: customIcon,\n      });\n      currentMarker.addTo(leafletMap);\n\n      leafletMap.setView([loc.lat, loc.lng], leafletMap.getZoom());\n    }\n  };\n\n  if (!readonly) {\n    leafletMap.on(\"click\", (e: any) => {\n      const { lat, lng } = e.latlng;\n\n      onLocationSelect({\n        lat: lat,\n        lng: lng,\n        address: `Map Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`,\n      });\n    });\n  }\n\n  updateMarker(location);\n\n  return {\n    updateMarker,\n    destroy: () => {\n      leafletMap.remove();\n    },\n    setTileLayer: (tileConfig: {\n      url: string;\n      attribution: string;\n      maxZoom?: number;\n    }) => {\n      const newTileLayer = (window as any).L.tileLayer(tileConfig.url, {\n        attribution: tileConfig.attribution,\n        maxZoom: tileConfig.maxZoom || 18,\n      });\n\n      newTileLayer.addTo(leafletMap);\n    },\n  };\n};",
      "type": "registry:lib"
    },
    {
      "path": "src/hooks/use-field-state.ts",
      "content": "import { AnyFieldApi } from \"@tanstack/react-form\";\n\nexport interface UseFieldStateReturn {\n  name: string;\n  value: unknown;\n  isDisabled: boolean;\n  hasErrors: boolean;\n  errors: string[];\n  onBlur: () => void;\n  onChange: (value: unknown) => void;\n}\n\nexport function useFieldState(fieldApi: AnyFieldApi): UseFieldStateReturn {\n  const name = fieldApi.name;\n  const value = fieldApi.state.value;\n  const isDisabled = fieldApi.form.state.isSubmitting;\n  const isTouched = fieldApi.state.meta.isTouched;\n  const errors = fieldApi.state.meta.errors || [];\n  const hasErrors = isTouched && errors.length > 0;\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const onChange = (newValue: unknown) => {\n    fieldApi.handleChange(newValue);\n  };\n\n  return {\n    name,\n    value,\n    isDisabled,\n    hasErrors,\n    errors,\n    onBlur,\n    onChange,\n  };\n}",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-dropdown.ts",
      "content": "import { useEffect, useRef, useState } from \"react\";\n\nexport interface UseDropdownReturn {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n  toggle: () => void;\n  close: () => void;\n  open: () => void;\n}\n\nexport function useDropdown(initialOpen = false): UseDropdownReturn {\n  const [isOpen, setIsOpen] = useState(initialOpen);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        containerRef.current &&\n        !containerRef.current.contains(event.target as Node)\n      ) {\n        setIsOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }\n  }, [isOpen]);\n\n  const toggle = () => setIsOpen(!isOpen);\n  const close = () => setIsOpen(false);\n  const open = () => setIsOpen(true);\n\n  return {\n    isOpen,\n    setIsOpen,\n    containerRef,\n    toggle,\n    close,\n    open,\n  };\n}",
      "type": "registry:hook"
    },
    {
      "path": "src/components/formedible/fields/array-field.tsx",
      "content": "'use client';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Plus, Trash2, GripVertical } from 'lucide-react';\nimport type { BaseFieldProps, ArrayFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\nimport { NestedFieldRenderer } from './shared-field-renderer';\n\nexport const ArrayField: React.FC<ArrayFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  arrayConfig,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  \n  const value = useMemo(() => (fieldApi.state?.value as unknown[]) || [], [fieldApi.state?.value]);\n  \n  const {\n    itemType,\n    itemLabel,\n    itemPlaceholder,\n    minItems = 0,\n    maxItems = 10,\n    addButtonLabel = \"Add Item\",\n    removeButtonLabel = \"Remove\",\n    itemComponent: CustomItemComponent,\n    sortable = false,\n    defaultValue = '',\n    itemProps = {},\n    objectConfig,\n  } = arrayConfig || {};\n\n  // Create field config for each item\n  const createItemFieldConfig = useCallback((index: number) => {\n    const baseConfig: any = {\n      name: `${name}[${index}]`,\n      type: itemType || 'text',\n      label: itemLabel ? `${itemLabel} ${index + 1}` : undefined,\n      placeholder: itemPlaceholder,\n      component: CustomItemComponent,\n      ...itemProps,\n    };\n\n    // Add object config if item type is object\n    if (itemType === 'object' && objectConfig) {\n      baseConfig.objectConfig = objectConfig;\n    }\n\n    return baseConfig;\n  }, [name, itemType, itemLabel, itemPlaceholder, CustomItemComponent, itemProps, objectConfig]);\n\n  const addItem = useCallback(() => {\n    if (value.length >= maxItems) return;\n    \n    const newValue = [...value, defaultValue];\n    fieldApi.handleChange(newValue);\n  }, [value, maxItems, defaultValue, fieldApi]);\n\n  const removeItem = useCallback((index: number) => {\n    if (value.length <= minItems) return;\n    \n    const newValue = value.filter((_, i) => i !== index);\n    fieldApi.handleChange(newValue);\n    fieldApi.handleBlur();\n  }, [value, minItems, fieldApi]);\n\n  const updateItem = useCallback((index: number, newItemValue: unknown) => {\n    const newValue = [...value];\n    newValue[index] = newItemValue;\n    fieldApi.handleChange(newValue);\n  }, [value, fieldApi]);\n\n  const moveItem = useCallback((fromIndex: number, toIndex: number) => {\n    if (!sortable) return;\n    if (fromIndex === toIndex) return;\n    \n    const newValue = [...value];\n    const [movedItem] = newValue.splice(fromIndex, 1);\n    newValue.splice(toIndex, 0, movedItem);\n    fieldApi.handleChange(newValue);\n  }, [value, fieldApi, sortable]);\n\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\n\n\n\n  // Create a mock field API for each item\n  const createItemFieldApi = useCallback((index: number) => {\n    return {\n      name: `${name}[${index}]`,\n      state: {\n        value: value[index],\n        meta: {\n          errors: [],\n          isTouched: false,\n          isValidating: false,\n        },\n      },\n      handleChange: (newValue: unknown) => updateItem(index, newValue),\n      handleBlur: () => fieldApi.handleBlur(),\n      form: fieldApi.form,\n    };\n  }, [name, value, updateItem, fieldApi]);\n\n  const canAddMore = value.length < maxItems;\n  const canRemove = value.length > minItems;\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-4\">\n        <div className=\"space-y-3\">\n          {value.map((_, index) => (\n              <div\n                key={index}\n                className=\"flex items-start gap-2 p-3 border rounded-lg bg-card\"\n                onDragOver={sortable ? (e) => {\n                  e.preventDefault();\n                  e.dataTransfer.dropEffect = 'move';\n                } : undefined}\n                onDrop={sortable ? (e) => {\n                  e.preventDefault();\n                  if (draggedIndex !== null && draggedIndex !== index) {\n                    moveItem(draggedIndex, index);\n                  }\n                } : undefined}\n              >\n                {sortable && (\n                  <button\n                    type=\"button\"\n                    className=\"mt-2 p-1 hover:bg-muted rounded cursor-grab active:cursor-grabbing\"\n                    draggable\n                    onDragStart={(e) => {\n                      setDraggedIndex(index);\n                      e.dataTransfer.effectAllowed = 'move';\n                    }}\n                    onDragEnd={() => {\n                      setDraggedIndex(null);\n                    }}\n                    disabled={isDisabled}\n                  >\n                    <GripVertical className=\"h-4 w-4 text-muted-foreground\" />\n                  </button>\n                )}\n                \n                <div className=\"flex-1\">\n                  <NestedFieldRenderer\n                    fieldConfig={createItemFieldConfig(index)}\n                    fieldApi={createItemFieldApi(index)}\n                    form={fieldApi.form}\n                    currentValues={fieldApi.form?.state?.values || {}}\n                  />\n                </div>\n                \n                {canRemove && (\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => removeItem(index)}\n                    className=\"mt-2 h-8 w-8 p-0 text-destructive hover:text-destructive\"\n                    title={removeButtonLabel}\n                    disabled={isDisabled}\n                  >\n                    <Trash2 className=\"h-4 w-4\" />\n                  </Button>\n                )}\n              </div>\n            ))}\n            \n            {value.length === 0 && (\n              <div className=\"text-center py-8 text-muted-foreground border-2 border-dashed rounded-lg\">\n                <p className=\"text-sm\">No items added yet</p>\n                <p className=\"text-xs mt-1\">Click &quot;{addButtonLabel}&quot; to add your first item</p>\n              </div>\n            )}\n          </div>\n          \n          {canAddMore && (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={addItem}\n              className=\"w-full\"\n              disabled={isDisabled}\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              {addButtonLabel}\n            </Button>\n          )}\n          \n          {minItems > 0 && value.length < minItems && (\n            <p className=\"text-xs text-muted-foreground\">\n              Minimum {minItems} item{minItems !== 1 ? 's' : ''} required\n            </p>\n          )}\n        </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/autocomplete-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { Input } from \"@/components/ui/input\";\nimport { Card } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface AutocompleteOption {\n  value: string;\n  label: string;\n}\n\ninterface AutocompleteFieldProps extends BaseFieldProps {\n  autocompleteConfig?: {\n    options?: string[] | AutocompleteOption[];\n    asyncOptions?: (query: string) => Promise<string[] | AutocompleteOption[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n    allowCustom?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n}\n\nexport const AutocompleteField: React.FC<AutocompleteFieldProps> = ({\n  fieldApi,\n  placeholder,\n  inputClassName,\n  autocompleteConfig = {},\n  ...wrapperProps\n}) => {\n  const {\n    options = [],\n    asyncOptions,\n    debounceMs = 300,\n    minChars = 1,\n    maxResults = 10,\n    allowCustom = true,\n    noOptionsText = \"No options found\",\n    loadingText = \"Loading...\"\n  } = autocompleteConfig;\n\n  const name = fieldApi.name;\n\n  const [inputValue, setInputValue] = useState(fieldApi.state?.value || \"\");\n  const [filteredOptions, setFilteredOptions] = useState<AutocompleteOption[]>([]);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [highlightedIndex, setHighlightedIndex] = useState(-1);\n  \n  const inputRef = useRef<HTMLInputElement>(null);\n  const listRef = useRef<HTMLDivElement>(null);\n  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // Normalize options to consistent format\n  const normalizeOptions = (opts: string[] | AutocompleteOption[]): AutocompleteOption[] => {\n    return opts.map(opt => \n      typeof opt === 'string' ? { value: opt, label: opt } : opt\n    );\n  };\n\n  // Filter static options\n  const filterStaticOptions = React.useCallback((query: string): AutocompleteOption[] => {\n    if (!query || query.length < minChars) return [];\n    \n    const normalizedOptions = normalizeOptions(options);\n    return normalizedOptions\n      .filter(option => \n        option.label.toLowerCase().includes(query.toLowerCase()) ||\n        option.value.toLowerCase().includes(query.toLowerCase())\n      )\n      .slice(0, maxResults);\n  }, [minChars, options, maxResults]);\n\n  // Handle async options\n  const fetchAsyncOptions = React.useCallback(async (query: string) => {\n    if (!asyncOptions || query.length < minChars) return;\n\n    setIsLoading(true);\n    try {\n      const results = await asyncOptions(query);\n      const normalizedResults = normalizeOptions(results);\n      setFilteredOptions(normalizedResults.slice(0, maxResults));\n    } catch (error) {\n      console.error('Autocomplete async options error:', error);\n      setFilteredOptions([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [asyncOptions, minChars, maxResults]);\n\n  // Debounced search\n  useEffect(() => {\n    if (debounceRef.current) {\n      clearTimeout(debounceRef.current);\n    }\n\n    debounceRef.current = setTimeout(() => {\n      if (asyncOptions) {\n        fetchAsyncOptions(inputValue);\n      } else {\n        setFilteredOptions(filterStaticOptions(inputValue));\n      }\n    }, debounceMs);\n\n    return () => {\n      if (debounceRef.current) {\n        clearTimeout(debounceRef.current);\n      }\n    };\n  }, [inputValue, asyncOptions, debounceMs, fetchAsyncOptions, filterStaticOptions]);\n\n  // Handle input change\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    setIsOpen(true);\n    setHighlightedIndex(-1);\n    \n    if (allowCustom) {\n      fieldApi.handleChange(value);\n    }\n  };\n\n  // Handle option selection\n  const handleOptionSelect = (option: AutocompleteOption) => {\n    setInputValue(option.label);\n    fieldApi.handleChange(option.value);\n    setIsOpen(false);\n    setHighlightedIndex(-1);\n    inputRef.current?.blur();\n  };\n\n  // Handle keyboard navigation\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!isOpen) {\n      if (e.key === 'ArrowDown' || e.key === 'Enter') {\n        setIsOpen(true);\n        return;\n      }\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setHighlightedIndex(prev => \n          prev < filteredOptions.length - 1 ? prev + 1 : prev\n        );\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setHighlightedIndex(prev => prev > 0 ? prev - 1 : -1);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {\n          handleOptionSelect(filteredOptions[highlightedIndex]);\n        } else if (allowCustom && inputValue) {\n          fieldApi.handleChange(inputValue);\n          setIsOpen(false);\n        }\n        break;\n      case 'Escape':\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n        inputRef.current?.blur();\n        break;\n    }\n  };\n\n  // Handle focus/blur\n  const handleFocus = () => {\n    if (inputValue.length >= minChars) {\n      setIsOpen(true);\n    }\n  };\n\n  const handleInputBlur = () => {\n    // Delay closing to allow option clicks\n    setTimeout(() => {\n      if (!listRef.current?.contains(document.activeElement)) {\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n      }\n    }, 150);\n  };\n\n  // Scroll highlighted option into view\n  useEffect(() => {\n    if (highlightedIndex >= 0 && listRef.current) {\n      const highlightedElement = listRef.current.children[highlightedIndex] as HTMLElement;\n      if (highlightedElement) {\n        highlightedElement.scrollIntoView({\n          block: 'nearest',\n          behavior: 'smooth'\n        });\n      }\n    }\n  }, [highlightedIndex]);\n\n  const showDropdown = isOpen && (filteredOptions.length > 0 || isLoading || (inputValue.length >= minChars && !isLoading));\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"relative\">\n        <Input\n          ref={inputRef}\n          id={fieldApi.name}\n          name={fieldApi.name}\n          value={inputValue}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={handleFocus}\n          onBlur={(e) => {\n            handleInputBlur();\n            fieldApi.handleBlur();\n          }}\n          placeholder={placeholder || autocompleteConfig.placeholder || \"Type to search...\"}\n          className={cn(inputClassName, isOpen && \"rounded-b-none\")}\n          autoComplete=\"off\"\n          disabled={isDisabled}\n        />\n\n        {showDropdown && (\n          <Card className=\"absolute top-full left-0 right-0 z-50 max-h-60 overflow-y-auto border-t-0 rounded-t-none\">\n            <div ref={listRef} className=\"p-1\">\n              {isLoading && (\n                <div className=\"px-3 py-2 text-sm text-muted-foreground\">\n                  {loadingText}\n                </div>\n              )}\n              \n              {!isLoading && filteredOptions.length === 0 && inputValue.length >= minChars && (\n                <div className=\"px-3 py-2 text-sm text-muted-foreground\">\n                  {noOptionsText}\n                  {allowCustom && (\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      className=\"ml-2 h-auto p-1 text-xs\"\n                      onClick={() => {\n                        fieldApi.handleChange(inputValue);\n                        setIsOpen(false);\n                      }}\n                      disabled={isDisabled}\n                    >\n                      Use \"{inputValue}\"\n                    </Button>\n                  )}\n                </div>\n              )}\n              \n              {!isLoading && filteredOptions.map((option, index) => (\n                <button\n                  key={`${option.value}-${index}`}\n                  type=\"button\"\n                  className={cn(\n                    \"w-full text-left px-3 py-2 text-sm rounded-sm transition-colors\",\n                    \"hover:bg-muted focus:bg-muted focus:outline-none\",\n                    highlightedIndex === index && \"bg-muted\"\n                  )}\n                  onClick={() => handleOptionSelect(option)}\n                  onMouseEnter={() => setHighlightedIndex(index)}\n                  disabled={isDisabled}\n                >\n                  <div className=\"font-medium\">{option.label}</div>\n                  {option.value !== option.label && (\n                    <div className=\"text-xs text-muted-foreground\">{option.value}</div>\n                  )}\n                </button>\n              ))}\n            </div>\n          </Card>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/checkbox-field.tsx",
      "content": "import React from 'react';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const CheckboxField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as boolean | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n\n  const onCheckedChange = (checked: boolean) => {\n    fieldApi.handleChange(checked);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\n    // because Checkbox components need the label positioned next to (not above) the control\n    <FieldWrapper \n      fieldApi={fieldApi} \n      label={undefined}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"flex items-center space-x-2\">\n        <Checkbox\n          id={name}\n          checked={!!value}\n          onCheckedChange={onCheckedChange}\n          onBlur={onBlur}\n          disabled={isDisabled}\n          aria-describedby={description ? `${name}-description` : undefined}\n        />\n        {label && (\n          <Label \n            htmlFor={name} \n            className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}\n          >\n            {label}\n          </Label>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/color-picker-field.tsx",
      "content": "'use client';\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { Palette, Check } from 'lucide-react';\nimport type { ColorPickerFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nconst DEFAULT_PRESETS = [\n  '#FF0000', '#FF8000', '#FFFF00', '#80FF00', '#00FF00', '#00FF80',\n  '#00FFFF', '#0080FF', '#0000FF', '#8000FF', '#FF00FF', '#FF0080',\n  '#000000', '#404040', '#808080', '#C0C0C0', '#FFFFFF', '#8B4513'\n];\n\n// Color conversion utilities\nconst hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\n\n\nconst hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {\n  const rgb = hexToRgb(hex);\n  if (!rgb) return null;\n  \n  const { r, g, b } = rgb;\n  const rNorm = r / 255;\n  const gNorm = g / 255;\n  const bNorm = b / 255;\n  \n  const max = Math.max(rNorm, gNorm, bNorm);\n  const min = Math.min(rNorm, gNorm, bNorm);\n  const diff = max - min;\n  \n  let h = 0;\n  let s = 0;\n  const l = (max + min) / 2;\n  \n  if (diff !== 0) {\n    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);\n    \n    switch (max) {\n      case rNorm:\n        h = (gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0);\n        break;\n      case gNorm:\n        h = (bNorm - rNorm) / diff + 2;\n        break;\n      case bNorm:\n        h = (rNorm - gNorm) / diff + 4;\n        break;\n    }\n    h /= 6;\n  }\n  \n  return {\n    h: Math.round(h * 360),\n    s: Math.round(s * 100),\n    l: Math.round(l * 100)\n  };\n};\n\nconst formatColor = (hex: string, format: 'hex' | 'rgb' | 'hsl'): string => {\n  switch (format) {\n    case 'rgb': {\n      const rgb = hexToRgb(hex);\n      return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\n    }\n    case 'hsl': {\n      const hsl = hexToHsl(hex);\n      return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\n    }\n    default:\n      return hex;\n  }\n};\n\nexport const ColorPickerField: React.FC<ColorPickerFieldSpecificProps> = ({\n  fieldApi,\n  colorConfig = {},\n  inputClassName,\n  ...wrapperProps\n}) => {\n  const {\n    format = 'hex',\n    showPreview = true,\n    presetColors = DEFAULT_PRESETS,\n    allowCustom = true,\n  } = colorConfig;\n\n  const name = fieldApi.name;\n  \n  const value = (fieldApi.state?.value as string) || '#000000';\n  \n  const [isOpen, setIsOpen] = useState(false);\n  const [customInput, setCustomInput] = useState(value);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const colorInputRef = useRef<HTMLInputElement>(null);\n\n  // Ensure value is always a valid hex color\n  const normalizedValue = value.startsWith('#') ? value : `#${value}`;\n  const displayValue = formatColor(normalizedValue, format);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleColorSelect = (color: string) => {\n    const formattedColor = formatColor(color, format);\n    fieldApi.handleChange(formattedColor);\n    setCustomInput(color);\n    setIsOpen(false);\n    fieldApi.handleBlur();\n  };\n\n  const handleCustomInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    setCustomInput(inputValue);\n    \n    // Validate and update if it's a valid color\n    if (inputValue.match(/^#[0-9A-Fa-f]{6}$/)) {\n      const formattedColor = formatColor(inputValue, format);\n      fieldApi.handleChange(formattedColor);\n    }\n  };\n\n  const handleNativeColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const color = e.target.value;\n    const formattedColor = formatColor(color, format);\n    fieldApi.handleChange(formattedColor);\n    setCustomInput(color);\n  };\n\n  const isValidColor = (color: string): boolean => {\n    return /^#[0-9A-Fa-f]{6}$/.test(color);\n  };\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"relative space-y-2\" ref={containerRef}>\n        <div className=\"flex gap-2\">\n          {/* Color preview and trigger */}\n          <div className=\"relative\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              className={cn(\n                \"w-12 h-10 p-0 border-2\",\n                fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\",\n                inputClassName\n              )}\n              onClick={() => setIsOpen(!isOpen)}\n              disabled={isDisabled}\n              style={{ backgroundColor: normalizedValue }}\n            >\n              {!showPreview && <Palette className=\"h-4 w-4\" />}\n            </Button>\n            \n            {/* Native color input (hidden) */}\n            <input\n              ref={colorInputRef}\n              type=\"color\"\n              value={normalizedValue}\n              onChange={handleNativeColorChange}\n              onBlur={() => fieldApi.handleBlur()}\n              className=\"absolute inset-0 w-full h-full opacity-0 cursor-pointer\"\n              disabled={isDisabled}\n            />\n          </div>\n\n          {/* Color value input */}\n          <Input\n            value={displayValue}\n            onChange={(e) => {\n              const inputValue = e.target.value;\n              fieldApi.handleChange(inputValue);\n              // Try to extract hex value for internal use\n              if (inputValue.startsWith('#')) {\n                setCustomInput(inputValue);\n              }\n            }}\n            onBlur={() => {\n              fieldApi.handleBlur();\n            }}\n            placeholder={'#000000'}\n            className={cn(\n              \"flex-1\",\n              fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\"\n            )}\n            disabled={isDisabled}\n          />\n        </div>\n\n        {/* Color picker dropdown */}\n        {isOpen && (\n          <div className=\"absolute z-50 mt-1 p-4 bg-popover border rounded-md shadow-lg w-64\">\n            {/* Preset colors */}\n            <div className=\"mb-4\">\n              <h4 className=\"text-sm font-medium mb-2\">Preset Colors</h4>\n              <div className=\"grid grid-cols-6 gap-2\">\n                {presetColors.map((color, index) => (\n                  <button\n                    key={index}\n                    type=\"button\"\n                    className={cn(\n                      \"w-8 h-8 rounded border-2 hover:scale-110 transition-transform\",\n                      normalizedValue.toLowerCase() === color.toLowerCase() \n                        ? \"border-primary ring-2 ring-primary ring-offset-2\" \n                        : \"border-muted hover:border-primary\"\n                    )}\n                    style={{ backgroundColor: color }}\n                    onClick={() => handleColorSelect(color)}\n                    title={color}\n                  >\n                    {normalizedValue.toLowerCase() === color.toLowerCase() && (\n                      <Check className=\"h-4 w-4 text-white drop-shadow-lg\" />\n                    )}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Custom color input */}\n            {allowCustom && (\n              <div>\n                <h4 className=\"text-sm font-medium mb-2\">Custom Color</h4>\n                <div className=\"flex gap-2\">\n                  <Input\n                    value={customInput}\n                    onChange={handleCustomInputChange}\n                    placeholder=\"#000000\"\n                    className=\"flex-1 text-xs\"\n                  />\n                  <Button\n                    type=\"button\"\n                    size=\"sm\"\n                    onClick={() => handleColorSelect(customInput)}\n                    disabled={!isValidColor(customInput)}\n                  >\n                    Apply\n                  </Button>\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/date-field.tsx",
      "content": "import React from 'react';\nimport { format, parseISO } from 'date-fns';\nimport { Calendar as CalendarIcon } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const DateField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const [isOpen, setIsOpen] = React.useState(false);\n\n  const value = fieldApi.state?.value;\n  const selectedDate = value\n    ? value instanceof Date\n      ? value\n      : typeof value === 'string'\n        ? parseISO(value)\n        : undefined\n    : undefined;\n\n  const handleDateSelect = (date: Date | undefined) => {\n    fieldApi.handleChange(date);\n    fieldApi.handleBlur();\n    setIsOpen(false);\n  };\n\n  const computedInputClassName = cn(\n    \"w-full justify-start text-left font-normal\",\n    !selectedDate && \"text-muted-foreground\",\n    hasErrors ? \"border-destructive\" : \"\",\n    inputClassName\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            variant=\"outline\"\n            className={computedInputClassName}\n            disabled={isDisabled}\n            onClick={() => setIsOpen(true)}\n          >\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\n            {selectedDate ? format(selectedDate, \"PPP\") : <span>{placeholder || \"Pick a date\"}</span>}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\">\n          <Calendar\n            mode=\"single\"\n            selected={selectedDate}\n            onSelect={handleDateSelect}\n            initialFocus\n            disabled={isDisabled}\n          />\n        </PopoverContent>\n      </Popover>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/duration-picker-field.tsx",
      "content": "\"use client\";\nimport React, { useState } from \"react\";\nimport type { BaseFieldProps, DurationConfig, DurationValue } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { cn } from \"@/lib/utils\";\n\n\n\ninterface DurationPickerFieldProps extends BaseFieldProps {\n  durationConfig?: DurationConfig;\n}\n\nconst parseDuration = (value: any, format: string) => {\n  if (!value) return { hours: 0, minutes: 0, seconds: 0 };\n  \n  if (typeof value === 'number') {\n    const totalSeconds = Math.abs(value);\n    return {\n      hours: Math.floor(totalSeconds / 3600),\n      minutes: Math.floor((totalSeconds % 3600) / 60),\n      seconds: totalSeconds % 60\n    };\n  }\n  \n  if (typeof value === 'object') {\n    return {\n      hours: value.hours || 0,\n      minutes: value.minutes || 0,\n      seconds: value.seconds || 0\n    };\n  }\n  \n  return { hours: 0, minutes: 0, seconds: 0 };\n};\n\nconst formatOutput = (hours: number, minutes: number, seconds: number, format: string) => {\n  const totalSeconds = hours * 3600 + minutes * 60 + seconds;\n  \n  switch (format) {\n    case 'hours': return hours + minutes / 60 + seconds / 3600;\n    case 'minutes': return hours * 60 + minutes + seconds / 60;\n    case 'seconds': return totalSeconds;\n    default: return { hours, minutes, seconds, totalSeconds };\n  }\n};\n\nexport const DurationPickerField: React.FC<DurationPickerFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  durationConfig,\n}) => {\n  const name = fieldApi.name;\n  const format = durationConfig?.format || 'hms';\n  const maxHours = durationConfig?.maxHours || 23;\n  const maxMinutes = durationConfig?.maxMinutes || 59;\n  const maxSeconds = durationConfig?.maxSeconds || 59;\n  const showLabels = durationConfig?.showLabels !== false;\n\n  const currentValue = parseDuration(fieldApi.state?.value, format);\n  const [hours, setHours] = useState(currentValue.hours);\n  const [minutes, setMinutes] = useState(currentValue.minutes);\n  const [seconds, setSeconds] = useState(currentValue.seconds);\n\n  const updateField = (h: number, m: number, s: number) => {\n    const output = formatOutput(h, m, s, format);\n    fieldApi.handleChange(output);\n  };\n\n  const handleHoursChange = (h: number) => {\n    setHours(h);\n    updateField(h, minutes, seconds);\n  };\n\n  const handleMinutesChange = (m: number) => {\n    setMinutes(m);\n    updateField(hours, m, seconds);\n  };\n\n  const handleSecondsChange = (s: number) => {\n    setSeconds(s);\n    updateField(hours, minutes, s);\n  };\n\n  const formatDuration = () => {\n    const parts = [];\n    if (format.includes('h') && hours > 0) parts.push(`${hours}h`);\n    if (format.includes('m') && minutes > 0) parts.push(`${minutes}m`);\n    if (format.includes('s') && seconds > 0) parts.push(`${seconds}s`);\n    return parts.join(' ') || '0';\n  };\n\n  const renderTimeInput = (value: number, onChange: (value: number) => void, max: number, unit: string, show: boolean) => {\n    if (!show) return null;\n\n    return (\n      <div className=\"flex flex-col space-y-1\">\n        {showLabels && (\n          <Label className=\"text-xs text-muted-foreground capitalize\">\n            {unit}\n          </Label>\n        )}\n        <Select value={value.toString()} onValueChange={(val) => onChange(parseInt(val))}>\n          <SelectTrigger className={cn(\"w-20\", inputClassName)}>\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            {Array.from({ length: max + 1 }, (_, i) => (\n              <SelectItem key={i} value={i.toString()}>\n                {i.toString().padStart(2, '0')}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n    );\n  };\n\n  const handleManualInput = (input: string) => {\n    const hourMatch = input.match(/(\\d+)h/i);\n    const minuteMatch = input.match(/(\\d+)m(?!s)/i);\n    const secondMatch = input.match(/(\\d+)s/i);\n    \n    const newHours = hourMatch ? Math.min(Math.max(0, parseInt(hourMatch[1], 10)), maxHours) : 0;\n    const newMinutes = minuteMatch ? Math.min(Math.max(0, parseInt(minuteMatch[1], 10)), maxMinutes) : 0;\n    const newSeconds = secondMatch ? Math.min(Math.max(0, parseInt(secondMatch[1], 10)), maxSeconds) : 0;\n    \n    setHours(newHours);\n    setMinutes(newMinutes);\n    setSeconds(newSeconds);\n    updateField(newHours, newMinutes, newSeconds);\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={labelClassName}>\n          {label}\n        </Label>\n      )}\n      \n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <div className=\"space-y-3\">\n        {/* Dropdown selectors */}\n        <div className=\"flex gap-3\">\n          {renderTimeInput(hours, handleHoursChange, maxHours, 'hours', format.includes('h'))}\n          {renderTimeInput(minutes, handleMinutesChange, maxMinutes, 'minutes', format.includes('m'))}\n          {renderTimeInput(seconds, handleSecondsChange, maxSeconds, 'seconds', format.includes('s'))}\n        </div>\n\n        {/* Manual input alternative */}\n        <div className=\"space-y-2\">\n          <Input\n            id={name}\n            value={formatDuration()}\n            placeholder={placeholder || \"Enter duration (e.g., 1h 30m 45s)\"}\n            className={inputClassName}\n            onChange={(e) => handleManualInput(e.target.value)}\n          />\n          <div className=\"text-xs text-muted-foreground\">\n            Format: {format === 'hms' ? '1h 30m 45s' : format === 'hm' ? '1h 30m' : format === 'ms' ? '30m 45s' : `${format} only`}\n          </div>\n        </div>\n\n        {/* Duration display */}\n        <div className=\"text-sm text-muted-foreground\">\n          Total: {formatDuration()}\n          {format !== 'seconds' && ` (${hours * 3600 + minutes * 60 + seconds} seconds)`}\n        </div>\n      </div>\n\n      {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">\n          {fieldApi.state?.meta?.errors[0]}\n        </p>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/base-field-wrapper.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Label } from \"@/components/ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport type { FieldWrapperProps } from \"@/lib/formedible/types\";\nexport type { FieldWrapperProps } from \"@/lib/formedible/types\";\n\n// Simplified wrapper that doesn't interfere with TanStack Form's state management\nexport const FieldWrapper: React.FC<FieldWrapperProps> = ({\n  fieldApi,\n  label,\n  description,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  children,\n  htmlFor,\n  showErrors = true,\n}) => {\n  const name = fieldApi.name;\n  const hasErrors =\n    fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label\n          htmlFor={htmlFor || name}\n          className={cn(\"text-sm font-medium\", labelClassName)}\n        >\n          {label}\n        </Label>\n      )}\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n\n      {children}\n\n      {showErrors && hasErrors && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state?.meta?.errors?.map(\n            (err: string | Error, index: number) => (\n              <p key={index}>\n                {typeof err === \"string\"\n                  ? err\n                  : (err as Error)?.message || \"Invalid\"}\n              </p>\n            )\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/field-help.tsx",
      "content": "'use client';\nimport React, { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { HelpCircle, ExternalLink, Info } from 'lucide-react';\n\ninterface FieldHelpProps {\n  help?: {\n    text?: string;\n    tooltip?: string;\n    position?: 'top' | 'bottom' | 'left' | 'right';\n    link?: { url: string; text: string };\n  };\n  className?: string;\n}\n\nexport const FieldHelp: React.FC<FieldHelpProps> = ({\n  help,\n  className,\n}) => {\n  const [showTooltip, setShowTooltip] = useState(false);\n\n  if (!help || (!help.text && !help.tooltip && !help.link)) {\n    return null;\n  }\n\n  const { text, tooltip, position = 'top', link } = help;\n\n  return (\n    <div className={cn(\"space-y-2\", className)}>\n      {/* Help text */}\n      {text && (\n        <div className=\"flex items-start gap-2 text-xs text-muted-foreground\">\n          <Info className=\"h-3 w-3 mt-0.5 flex-shrink-0\" />\n          <p>{text}</p>\n        </div>\n      )}\n\n      {/* Tooltip trigger */}\n      {tooltip && (\n        <div className=\"relative inline-block\">\n          <Button\n            type=\"button\"\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"h-6 w-6 p-0 text-muted-foreground hover:text-foreground\"\n            onMouseEnter={() => setShowTooltip(true)}\n            onMouseLeave={() => setShowTooltip(false)}\n            onFocus={() => setShowTooltip(true)}\n            onBlur={() => setShowTooltip(false)}\n          >\n            <HelpCircle className=\"h-3 w-3\" />\n          </Button>\n\n          {/* Tooltip */}\n          {showTooltip && (\n            <div\n              className={cn(\n                \"absolute z-50 px-2 py-1 text-xs text-white bg-black rounded shadow-lg whitespace-nowrap\",\n                \"pointer-events-none\",\n                {\n                  'bottom-full left-1/2 -translate-x-1/2 mb-1': position === 'top',\n                  'top-full left-1/2 -translate-x-1/2 mt-1': position === 'bottom',\n                  'right-full top-1/2 -translate-y-1/2 mr-1': position === 'left',\n                  'left-full top-1/2 -translate-y-1/2 ml-1': position === 'right',\n                }\n              )}\n            >\n              {tooltip}\n              {/* Tooltip arrow */}\n              <div\n                className={cn(\n                  \"absolute w-0 h-0 border-2 border-transparent\",\n                  {\n                    'top-full left-1/2 -translate-x-1/2 border-t-black border-b-0': position === 'top',\n                    'bottom-full left-1/2 -translate-x-1/2 border-b-black border-t-0': position === 'bottom',\n                    'top-1/2 left-full -translate-y-1/2 border-l-black border-r-0': position === 'left',\n                    'top-1/2 right-full -translate-y-1/2 border-r-black border-l-0': position === 'right',\n                  }\n                )}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Help link */}\n      {link && (\n        <div className=\"flex items-center gap-1\">\n          <Button\n            type=\"button\"\n            variant=\"link\"\n            size=\"sm\"\n            className=\"h-auto p-0 text-xs text-primary hover:text-primary/80\"\n            onClick={() => window.open(link.url, '_blank', 'noopener,noreferrer')}\n          >\n            {link.text}\n            <ExternalLink className=\"h-3 w-3 ml-1\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/field-registry.tsx",
      "content": "'use client';\nimport React from 'react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\n// Import all field components\nimport { TextField } from './text-field';\nimport { TextareaField } from './textarea-field';\nimport { NumberField } from './number-field';\nimport { SelectField } from './select-field';\nimport { MultiSelectField } from './multi-select-field';\nimport { CheckboxField } from './checkbox-field';\nimport { SwitchField } from './switch-field';\nimport { RadioField } from './radio-field';\nimport { SliderField } from './slider-field';\nimport { DateField } from './date-field';\nimport { RatingField } from './rating-field';\nimport { PhoneField } from './phone-field';\nimport { ColorPickerField } from './color-picker-field';\nimport { FileUploadField } from './file-upload-field';\nimport { ArrayField } from './array-field';\nimport { AutocompleteField } from './autocomplete-field';\nimport { DurationPickerField } from './duration-picker-field';\nimport { LocationPickerField } from './location-picker-field';\nimport { MaskedInputField } from './masked-input-field';\nimport { ObjectField } from './object-field';\n\n// Type-safe field component registry with flexible props\nexport interface FieldComponentProps extends BaseFieldProps {\n  [key: string]: unknown;\n}\n\nexport type FieldComponent = React.ComponentType<any>;\n\nexport const fieldComponents: Record<string, FieldComponent> = {\n  text: TextField,\n  textarea: TextareaField,\n  number: NumberField,\n  select: SelectField,\n  multiselect: MultiSelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  radio: RadioField,\n  slider: SliderField,\n  date: DateField,\n  rating: RatingField,\n  phone: PhoneField,\n  color: ColorPickerField,\n  file: FileUploadField,\n  array: ArrayField,\n  autocomplete: AutocompleteField,\n  duration: DurationPickerField,\n  location: LocationPickerField,\n  masked: MaskedInputField,\n  object: ObjectField,\n};\n\n// Helper function to get field component with type safety\nexport const getFieldComponent = (type: string): FieldComponent | null => {\n  return fieldComponents[type] || null;\n};\n\n// Helper function to create properly typed field props\nexport const createFieldProps = (\n  baseProps: BaseFieldProps,\n  additionalProps: Record<string, unknown> = {}\n): FieldComponentProps => {\n  return {\n    ...baseProps,\n    ...additionalProps,\n  };\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/shared-field-renderer.tsx",
      "content": "'use client';\nimport React from 'react';\nimport type { FieldComponentProps, FieldConfig } from '@/lib/formedible/types';\nimport { TextField } from './text-field';\nimport { TextareaField } from './textarea-field';\nimport { SelectField } from './select-field';\nimport { CheckboxField } from './checkbox-field';\nimport { SwitchField } from './switch-field';\nimport { NumberField } from './number-field';\nimport { DateField } from './date-field';\nimport { SliderField } from './slider-field';\nimport { FileUploadField } from './file-upload-field';\nimport { RadioField } from './radio-field';\nimport { MultiSelectField } from './multi-select-field';\nimport { ColorPickerField } from './color-picker-field';\nimport { RatingField } from './rating-field';\nimport { PhoneField } from './phone-field';\nimport { LocationPickerField } from './location-picker-field';\nimport { DurationPickerField } from './duration-picker-field';\nimport { AutocompleteField } from './autocomplete-field';\nimport { MaskedInputField } from './masked-input-field';\n\n// Single source of truth for field type mapping - used everywhere!\n// NOTE: ArrayField and ObjectField are not included here to avoid circular dependencies\n// They handle their own nested field rendering using this shared renderer\nexport const FIELD_TYPE_COMPONENTS: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  tel: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  number: NumberField,\n  date: DateField,\n  slider: SliderField,\n  file: FileUploadField,\n  radio: RadioField,\n  multiSelect: MultiSelectField,\n  colorPicker: ColorPickerField,\n  rating: RatingField,\n  phone: PhoneField,\n  location: LocationPickerField,\n  duration: DurationPickerField,\n  autocomplete: AutocompleteField,\n  masked: MaskedInputField,\n};\n\n/**\n * Nested Field Renderer - for use inside array and object fields\n * This properly respects TanStack Form's architecture by using form.Subscribe\n * for conditional logic instead of breaking the reactivity system\n */\nexport const NestedFieldRenderer: React.FC<SharedFieldRendererProps> = ({\n  fieldConfig,\n  fieldApi,\n  form,\n  currentValues = {},\n  resolveOptions,\n}) => {\n  const {\n    name,\n    type,\n    label,\n    placeholder,\n    description,\n    options,\n    min,\n    max,\n    step,\n    accept,\n    multiple,\n    component: CustomComponent,\n    conditional,\n    arrayConfig,\n    datalist,\n    ratingConfig,\n    phoneConfig,\n    colorConfig,\n    multiSelectConfig,\n    locationConfig,\n    durationConfig,\n    autocompleteConfig,\n    maskedInputConfig,\n    objectConfig,\n    sliderConfig,\n    numberConfig,\n    dateConfig,\n    fileConfig,\n    textareaConfig,\n    passwordConfig,\n    emailConfig,\n  } = fieldConfig;\n\n  // If there's conditional logic and we have form access, use TanStack Form's subscription pattern\n  if (conditional && form) {\n    return (\n      <form.Subscribe selector={(state: any) => state.values}>\n        {(formValues: any) => {\n          // For nested fields (array items or object fields), we need to determine the correct context\n          let contextValues = formValues;\n          \n          if (fieldApi.name.includes('[') && fieldApi.name.includes(']')) {\n            // This is an array field - get the parent array item values\n            const parentPath = fieldApi.name.split('.')[0]; // e.g., \"roomDetails[0]\"\n            const pathParts = parentPath.match(/(.+)\\[(\\d+)\\]/);\n            if (pathParts) {\n              const [, arrayName, index] = pathParts;\n              const arrayValue = formValues[arrayName];\n              if (arrayValue && arrayValue[parseInt(index)]) {\n                contextValues = arrayValue[parseInt(index)];\n              }\n            }\n          } else if (fieldApi.name.includes('.')) {\n            // This is a nested object field - get the parent object values\n            const parentPath = fieldApi.name.split('.').slice(0, -1).join('.');\n            const parentValue = parentPath.split('.').reduce((obj: Record<string, unknown> | null | undefined, key: string) => obj?.[key] as Record<string, unknown> | null | undefined, formValues as Record<string, unknown>);\n            if (parentValue && typeof parentValue === 'object') {\n              contextValues = parentValue;\n            }\n          }\n            \n          const shouldRender = conditional(contextValues);\n          if (!shouldRender) {\n            return null;\n          }\n          \n          // Render the actual field\n          return renderActualField();\n        }}\n      </form.Subscribe>\n    );\n  }\n\n  // No conditional logic - render directly\n  return renderActualField();\n\n  function renderActualField() {\n    // For nested rendering, we need to handle array and object types recursively\n    // Import them dynamically to avoid circular dependencies\n    if (type === 'array') {\n      // Import ArrayField dynamically\n      const ArrayField = require('./array-field').ArrayField;\n      return (\n        <ArrayField\n          fieldApi={fieldApi}\n          label={label}\n          description={description}\n          placeholder={placeholder}\n          arrayConfig={arrayConfig}\n        />\n      );\n    }\n\n    if (type === 'object') {\n      // Import ObjectField dynamically\n      const ObjectField = require('./object-field').ObjectField;\n      return (\n        <ObjectField\n          fieldApi={fieldApi}\n          objectConfig={objectConfig}\n          form={form}\n          label={label}\n          description={description}\n          placeholder={placeholder}\n        />\n      );\n    }\n\n    // Select the component to use\n    const FieldComponent =\n      CustomComponent ||\n      FIELD_TYPE_COMPONENTS[type] ||\n      TextField;\n\n    // Resolve options (static or dynamic)\n    const resolvedOptions = options && resolveOptions \n      ? resolveOptions(options, currentValues)\n      : Array.isArray(options) \n        ? options.map((opt: any) =>\n            typeof opt === 'string'\n              ? { value: opt, label: opt }\n              : opt\n          )\n        : [];\n\n    // Build base props\n    const baseProps: FieldComponentProps = {\n      fieldApi,\n      label,\n      placeholder,\n      description,\n      min,\n      max,\n      step,\n      accept,\n      multiple,\n    };\n\n    // Add type-specific props\n    let props: FieldComponentProps = { ...baseProps };\n\n    if (type === 'select' || type === 'radio' || type === 'multiSelect') {\n      props.options = resolvedOptions;\n    }\n\n    if (['text', 'email', 'password', 'url', 'tel'].includes(type)) {\n      props.type = type as any;\n      props.datalist = datalist?.options;\n    }\n\n    // Add all the config objects\n    if (type === 'rating') props.ratingConfig = ratingConfig;\n    if (type === 'phone') props.phoneConfig = phoneConfig;\n    if (type === 'colorPicker') props.colorConfig = colorConfig;\n    if (type === 'multiSelect') props.multiSelectConfig = multiSelectConfig;\n    if (type === 'location') props.locationConfig = locationConfig;\n    if (type === 'duration') props.durationConfig = durationConfig;\n    if (type === 'autocomplete') {\n      props.autocompleteConfig = autocompleteConfig && resolveOptions \n        ? {\n            ...autocompleteConfig,\n            options: resolveOptions(autocompleteConfig.options, currentValues),\n          }\n        : autocompleteConfig;\n    }\n    if (type === 'masked') props.maskedInputConfig = maskedInputConfig;\n    if (type === 'slider') props.sliderConfig = sliderConfig;\n    if (type === 'number') props.numberConfig = numberConfig;\n    if (type === 'date') props.dateConfig = dateConfig;\n    if (type === 'file') props.fileConfig = fileConfig;\n    if (type === 'textarea') props.textareaConfig = textareaConfig;\n    if (type === 'password') props.passwordConfig = passwordConfig;\n    if (type === 'email') props.emailConfig = emailConfig;\n\n    return <FieldComponent {...props} />;\n  }\n};\n\nexport interface SharedFieldRendererProps {\n  fieldConfig: FieldConfig;\n  fieldApi: any;\n  form?: any;\n  currentValues?: Record<string, unknown>;\n  resolveOptions?: (\n    options: FieldConfig['options'],\n    currentValues: Record<string, unknown>\n  ) => { value: string; label: string }[];\n}\n\n/**\n * Shared field renderer - THE SINGLE SOURCE OF TRUTH\n * This is used by use-formedible, array-field, and object-field\n * NO MORE DUPLICATION!\n */\nexport const SharedFieldRenderer: React.FC<SharedFieldRendererProps> = ({\n  fieldConfig,\n  fieldApi,\n  form,\n  currentValues = {},\n  resolveOptions,\n}) => {\n  const {\n    name,\n    type,\n    label,\n    placeholder,\n    description,\n    options,\n    min,\n    max,\n    step,\n    accept,\n    multiple,\n    component: CustomComponent,\n    conditional,\n    arrayConfig,\n    datalist,\n    ratingConfig,\n    phoneConfig,\n    colorConfig,\n    multiSelectConfig,\n    locationConfig,\n    durationConfig,\n    autocompleteConfig,\n    maskedInputConfig,\n    objectConfig,\n    sliderConfig,\n    numberConfig,\n    dateConfig,\n    fileConfig,\n    textareaConfig,\n    passwordConfig,\n    emailConfig,\n  } = fieldConfig;\n\n  // Check conditional logic first - if field should not render, return null\n  if (conditional && form?.state?.values) {\n    const shouldRender = conditional(form.state.values);\n    if (!shouldRender) {\n      return null;\n    }\n  }\n\n  // Handle special cases - array and object fields are NOT rendered by this component\n  // They have their own components to avoid circular dependencies\n  if (type === 'array' || type === 'object') {\n    console.warn(`SharedFieldRenderer: ${type} fields should handle their own rendering to avoid circular dependencies`);\n    return null;\n  }\n\n  // Select the component to use\n  const FieldComponent =\n    CustomComponent ||\n    FIELD_TYPE_COMPONENTS[type] ||\n    TextField;\n\n  // Resolve options (static or dynamic)\n  const resolvedOptions = options && resolveOptions \n    ? resolveOptions(options, currentValues)\n    : Array.isArray(options) \n      ? options.map((opt: any) =>\n          typeof opt === 'string'\n            ? { value: opt, label: opt }\n            : opt\n        )\n      : [];\n\n  // Build base props\n  const baseProps: FieldComponentProps = {\n    fieldApi,\n    label,\n    placeholder,\n    description,\n    min,\n    max,\n    step,\n    accept,\n    multiple,\n  };\n\n  // Add type-specific props\n  let props: FieldComponentProps = { ...baseProps };\n\n  if (type === 'select' || type === 'radio' || type === 'multiSelect') {\n    props.options = resolvedOptions;\n  }\n\n  if (type === 'array' && arrayConfig) {\n    props.arrayConfig = arrayConfig;\n  }\n\n  if (['text', 'email', 'password', 'url', 'tel'].includes(type)) {\n    props.type = type as any;\n    props.datalist = datalist?.options;\n  }\n\n  // Add all the config objects\n  if (type === 'rating') props.ratingConfig = ratingConfig;\n  if (type === 'phone') props.phoneConfig = phoneConfig;\n  if (type === 'colorPicker') props.colorConfig = colorConfig;\n  if (type === 'multiSelect') props.multiSelectConfig = multiSelectConfig;\n  if (type === 'location') props.locationConfig = locationConfig;\n  if (type === 'duration') props.durationConfig = durationConfig;\n  if (type === 'autocomplete') {\n    props.autocompleteConfig = autocompleteConfig && resolveOptions \n      ? {\n          ...autocompleteConfig,\n          options: resolveOptions(autocompleteConfig.options, currentValues),\n        }\n      : autocompleteConfig;\n  }\n  if (type === 'masked') props.maskedInputConfig = maskedInputConfig;\n  if (type === 'object') {\n    props.objectConfig = objectConfig;\n    props.form = form; // Pass form for conditional logic!\n  }\n  if (type === 'slider') props.sliderConfig = sliderConfig;\n  if (type === 'number') props.numberConfig = numberConfig;\n  if (type === 'date') props.dateConfig = dateConfig;\n  if (type === 'file') props.fileConfig = fileConfig;\n  if (type === 'textarea') props.textareaConfig = textareaConfig;\n  if (type === 'password') props.passwordConfig = passwordConfig;\n  if (type === 'email') props.emailConfig = emailConfig;\n\n  return <FieldComponent {...props} />;\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/file-upload-field.tsx",
      "content": "import React from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport { PaperclipIcon, XIcon, UploadCloudIcon } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface FileUploadFieldSpecificProps extends BaseFieldProps {\n  accept?: string;\n  className?: string;\n}\n\nexport const FileUploadField: React.FC<FileUploadFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  accept,\n  className,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n  \n  const file = fieldApi.state?.value as File | null;\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFile = e.target.files?.[0] ?? null;\n    fieldApi.handleChange(selectedFile);\n    fieldApi.handleBlur();\n  };\n\n  const handleRemoveFile = () => {\n    fieldApi.handleChange(null);\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    if (inputElement) {\n      inputElement.value = \"\";\n    }\n    fieldApi.handleBlur();\n  };\n\n  const triggerFileInput = () => {\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    inputElement?.click();\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-1.5\">\n        <Input\n          id={name}\n          name={name}\n          type=\"file\"\n          accept={accept}\n          onChange={handleFileChange}\n          className=\"hidden\"\n          disabled={isDisabled}\n        />\n        {file ? (\n          <div\n            className=\"flex items-center justify-between p-2.5 border rounded-lg bg-muted/40 shadow-sm hover:shadow-md transition-shadow\"\n          >\n            <div className=\"flex items-center gap-2 text-sm overflow-hidden\">\n              <PaperclipIcon className=\"h-5 w-5 text-primary shrink-0\" />\n              <span className=\"truncate\" title={file.name}>{file.name}</span>\n              <span className=\"text-xs text-muted-foreground whitespace-nowrap\">\n                ({(file.size / 1024).toFixed(1)} KB)\n              </span>\n            </div>\n            <Button\n              type=\"button\"\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={handleRemoveFile}\n              className=\"h-7 w-7 text-destructive hover:bg-destructive/10 shrink-0\"\n              aria-label=\"Remove file\"\n              disabled={isDisabled}\n            >\n              <XIcon className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        ) : (\n          <button\n            type=\"button\"\n            onClick={triggerFileInput}\n            className={cn(\n              \"w-full flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-lg hover:border-primary transition-colors cursor-pointer bg-background hover:bg-muted/50\",\n              className,\n              hasErrors ? \"border-destructive hover:border-destructive\" : \"border-muted-foreground/50\",\n              isDisabled && \"opacity-50 cursor-not-allowed\"\n            )}\n            disabled={isDisabled}\n          >\n            <UploadCloudIcon className=\"h-8 w-8 text-muted-foreground mb-2\" />\n            <span className=\"text-sm font-medium text-muted-foreground\">\n              Click or drag and drop a file\n            </span>\n            {accept && <span className=\"text-xs text-muted-foreground/80 mt-1\">Accepted types: {accept}</span>}\n          </button>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/inline-validation-wrapper.tsx",
      "content": "'use client';\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Check, X, Loader2 } from 'lucide-react';\nimport type { AnyFieldApi } from '@tanstack/react-form';\nimport type { InlineValidationWrapperProps } from '@/lib/formedible/types';\n\n\n\nexport const InlineValidationWrapper: React.FC<InlineValidationWrapperProps> = ({\n  children,\n  fieldApi,\n  inlineValidation = {},\n  className,\n}) => {\n  const {\n    enabled = true,\n    debounceMs = 300,\n    showSuccess = true,\n    asyncValidator,\n  } = inlineValidation;\n\n  const [validationState, setValidationState] = useState<{\n    isValidating: boolean;\n    isValid: boolean | null;\n    message: string | null;\n  }>({\n    isValidating: false,\n    isValid: null,\n    message: null,\n  });\n\n  const { state } = fieldApi;\n  const value = state.value;\n  const hasErrors = state.meta.errors.length > 0;\n  const isTouched = state.meta.isTouched;\n\n  // Validation function\n  const validateValue = useCallback(async (currentValue: unknown) => {\n    if (!enabled || !asyncValidator) return;\n\n    setValidationState(prev => ({ ...prev, isValidating: true }));\n\n    try {\n      const result = await asyncValidator(currentValue);\n      \n      setValidationState({\n        isValidating: false,\n        isValid: result === null,\n        message: result,\n      });\n    } catch (error) {\n      setValidationState({\n        isValidating: false,\n        isValid: false,\n        message: error instanceof Error ? error.message : 'Validation failed',\n      });\n    }\n  }, [enabled, asyncValidator]);\n\n  // Debounced validation function\n  const debouncedValidate = useMemo(\n    () => debounce(validateValue, debounceMs),\n    [validateValue, debounceMs]\n  );\n\n  // Trigger validation when value changes\n  useEffect(() => {\n    if (enabled && isTouched && value !== undefined && value !== '') {\n      debouncedValidate(value);\n    } else {\n      setValidationState({\n        isValidating: false,\n        isValid: null,\n        message: null,\n      });\n    }\n  }, [value, isTouched, enabled, debouncedValidate]);\n\n  // Reset validation state when field is reset\n  useEffect(() => {\n    if (!isTouched) {\n      setValidationState({\n        isValidating: false,\n        isValid: null,\n        message: null,\n      });\n    }\n  }, [isTouched]);\n\n  const getValidationIcon = () => {\n    if (!enabled || !isTouched) return null;\n    \n    if (validationState.isValidating) {\n      return <Loader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />;\n    }\n\n    if (hasErrors) {\n      return <X className=\"h-4 w-4 text-destructive\" />;\n    }\n\n    if (validationState.isValid === false) {\n      return <X className=\"h-4 w-4 text-destructive\" />;\n    }\n\n    if (showSuccess && validationState.isValid === true) {\n      return <Check className=\"h-4 w-4 text-green-500\" />;\n    }\n\n    if (showSuccess && !hasErrors && isTouched && value) {\n      return <Check className=\"h-4 w-4 text-green-500\" />;\n    }\n\n    return null;\n  };\n\n  const getValidationMessage = () => {\n    if (!enabled || !isTouched) return null;\n\n    // Show form validation errors first\n    if (hasErrors) {\n      return state.meta.errors[0];\n    }\n\n    // Show async validation message\n    if (validationState.message) {\n      return validationState.message;\n    }\n\n    return null;\n  };\n\n  const validationIcon = getValidationIcon();\n  const validationMessage = getValidationMessage();\n\n  return (\n    <div className={cn(\"relative\", className)}>\n      {/* Field with validation icon */}\n      <div className=\"relative\">\n        {children}\n        {validationIcon && (\n          <div className=\"absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none\">\n            {validationIcon}\n          </div>\n        )}\n      </div>\n      \n      {/* Validation message */}\n      {validationMessage && (\n        <div className={cn(\n          \"text-xs mt-1 flex items-center gap-1\",\n          hasErrors || validationState.isValid === false\n            ? \"text-destructive\"\n            : \"text-muted-foreground\"\n        )}>\n          {typeof validationMessage === 'string' \n            ? validationMessage \n            : (validationMessage as Error)?.message || 'Validation error'\n          }\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Debounce utility function\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout>;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n} ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/location-picker-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef, useCallback } from \"react\";\nimport type {\n  BaseFieldProps,\n  LocationConfig,\n  LocationValue,\n  LocationSearchResult,\n} from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card } from \"@/components/ui/card\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\n\n// Built-in search providers\nconst builtInProviders = {\n  // OpenStreetMap/Nominatim search\n  nominatim: async (\n    query: string,\n    options: any = {}\n  ): Promise<LocationSearchResult[]> => {\n    const endpoint =\n      options.endpoint || \"https://nominatim.openstreetmap.org/search\";\n    const params = new URLSearchParams({\n      q: query,\n      format: \"json\",\n      limit: String(options.limit || 5),\n      addressdetails: \"1\",\n      ...options.searchOptions,\n    });\n\n    try {\n      const response = await fetch(`${endpoint}?${params}`);\n      const data = await response.json();\n\n      return data.map((item: any, index: number) => ({\n        id: item.place_id || index,\n        lat: parseFloat(item.lat),\n        lng: parseFloat(item.lon),\n        address: item.display_name,\n        city: item.address?.city || item.address?.town || item.address?.village,\n        state: item.address?.state,\n        country: item.address?.country,\n        postalCode: item.address?.postcode,\n        relevance: parseFloat(item.importance || 0),\n        bounds: item.boundingbox\n          ? {\n              northeast: {\n                lat: parseFloat(item.boundingbox[1]),\n                lng: parseFloat(item.boundingbox[3]),\n              },\n              southwest: {\n                lat: parseFloat(item.boundingbox[0]),\n                lng: parseFloat(item.boundingbox[2]),\n              },\n            }\n          : undefined,\n      }));\n    } catch (error) {\n      console.error(\"Nominatim search error:\", error);\n      return [];\n    }\n  },\n\n  // OpenStreetMap reverse geocoding\n  nominatimReverse: async (\n    lat: number,\n    lng: number,\n    options: any = {}\n  ): Promise<LocationValue> => {\n    const endpoint =\n      options.endpoint || \"https://nominatim.openstreetmap.org/reverse\";\n    const params = new URLSearchParams({\n      lat: String(lat),\n      lon: String(lng),\n      format: \"json\",\n      addressdetails: \"1\",\n      ...options.searchOptions,\n    });\n\n    try {\n      const response = await fetch(`${endpoint}?${params}`);\n      const data = await response.json();\n\n      return {\n        lat,\n        lng,\n        address: data.display_name,\n        city: data.address?.city || data.address?.town || data.address?.village,\n        state: data.address?.state,\n        country: data.address?.country,\n        postalCode: data.address?.postcode,\n      };\n    } catch (error) {\n      console.error(\"Nominatim reverse geocoding error:\", error);\n      return { lat, lng, address: `${lat}, ${lng}` };\n    }\n  },\n};\n\n// Proper map implementation using user-configurable tile providers\nconst defaultMapRenderer = (params: {\n  location: LocationValue | null;\n  onLocationSelect: (location: LocationValue) => void;\n  mapContainer: HTMLDivElement;\n  zoom: number;\n  readonly: boolean;\n  defaultLocation?: { lat: number; lng: number };\n}) => {\n  const {\n    location,\n    onLocationSelect,\n    mapContainer,\n    zoom,\n    readonly,\n    defaultLocation,\n  } = params;\n\n  // Initialize Leaflet map\n  const leafletMap = (window as any).L.map(mapContainer, {\n    center: [\n      location?.lat || defaultLocation?.lat || 51.5074,\n      location?.lng || defaultLocation?.lng || -0.1278,\n    ],\n    zoom: zoom || 10,\n    zoomControl: true,\n    dragging: !readonly,\n    touchZoom: !readonly,\n    scrollWheelZoom: !readonly,\n    doubleClickZoom: !readonly,\n    boxZoom: !readonly,\n    keyboard: !readonly,\n    tap: !readonly,\n  });\n\n  // Default tile layer - OpenStreetMap\n  const osmTileLayer = (window as any).L.tileLayer(\n    \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    {\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n      maxZoom: 19,\n    }\n  );\n\n  // Add default tile layer\n  osmTileLayer.addTo(leafletMap);\n\n  // Current marker\n  let currentMarker: any = null;\n\n  // Update marker position\n  const updateMarker = (loc: LocationValue | null) => {\n    if (currentMarker) {\n      leafletMap.removeLayer(currentMarker);\n      currentMarker = null;\n    }\n\n    if (loc) {\n      const customIcon = (window as any).L.divIcon({\n        className: \"custom-div-icon\",\n        html: `\n          <div style=\"\n            background-color: #ef4444;\n            color: white;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 12px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n            white-space: nowrap;\n            position: relative;\n            margin-bottom: 8px;\n          \">\n            📍 ${loc.address || `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`}\n          </div>\n          <div style=\"\n            width: 0;\n            height: 0;\n            border-left: 8px solid transparent;\n            border-right: 8px solid transparent;\n            border-top: 8px solid #ef4444;\n            margin: 0 auto;\n            margin-top: -4px;\n          \"></div>\n        `,\n        iconSize: [0, 0],\n        iconAnchor: [0, 0],\n      });\n\n      currentMarker = (window as any).L.marker([loc.lat, loc.lng], {\n        icon: customIcon,\n      });\n      currentMarker.addTo(leafletMap);\n\n      // Center map on marker\n      leafletMap.setView([loc.lat, loc.lng], leafletMap.getZoom());\n    }\n  };\n\n  // Handle map clicks\n  if (!readonly) {\n    leafletMap.on(\"click\", (e: any) => {\n      const { lat, lng } = e.latlng;\n\n      onLocationSelect({\n        lat: lat,\n        lng: lng,\n        address: `Map Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`,\n      });\n    });\n  }\n\n  // Initial marker update\n  updateMarker(location);\n\n  return {\n    cleanup: () => {\n      if (leafletMap) {\n        leafletMap.remove();\n      }\n    },\n    updateLocation: (newLocation: LocationValue) => {\n      updateMarker(newLocation);\n    },\n    switchTileLayer: (tileConfig: {\n      url: string;\n      attribution: string;\n      maxZoom?: number;\n      apiKey?: string;\n    }) => {\n      // Remove current tile layer\n      leafletMap.eachLayer((layer: any) => {\n        if (layer instanceof (window as any).L.TileLayer) {\n          leafletMap.removeLayer(layer);\n        }\n      });\n\n      // Add new tile layer\n      const newTileLayer = (window as any).L.tileLayer(tileConfig.url, {\n        attribution: tileConfig.attribution,\n        maxZoom: tileConfig.maxZoom || 18,\n      });\n\n      newTileLayer.addTo(leafletMap);\n    },\n  };\n};\n\n// Utility to format coordinates\nconst formatCoordinates = (\n  lat: number,\n  lng: number,\n  format: \"decimal\" | \"dms\" = \"decimal\"\n) => {\n  if (format === \"decimal\") {\n    return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;\n  } else {\n    // Convert to degrees, minutes, seconds\n    const latDeg = Math.floor(Math.abs(lat));\n    const latMin = Math.floor((Math.abs(lat) - latDeg) * 60);\n    const latSec = ((Math.abs(lat) - latDeg) * 60 - latMin) * 60;\n    const latDir = lat >= 0 ? \"N\" : \"S\";\n\n    const lngDeg = Math.floor(Math.abs(lng));\n    const lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);\n    const lngSec = ((Math.abs(lng) - lngDeg) * 60 - lngMin) * 60;\n    const lngDir = lng >= 0 ? \"E\" : \"W\";\n\n    return `${latDeg}°${latMin}'${latSec.toFixed(\n      2\n    )}\"${latDir}, ${lngDeg}°${lngMin}'${lngSec.toFixed(2)}\"${lngDir}`;\n  }\n};\n\n// Built-in tile providers configuration\nconst TILE_PROVIDERS = {\n  openstreetmap: {\n    url: \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    attribution:\n      '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n    maxZoom: 19,\n  },\n  cartodb: {\n    url: \"https://cartodb-basemaps-{s}.global.ssl.fastly.net/rastertiles/voyager/{z}/{x}/{y}.png\",\n    attribution:\n      '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors, &copy; <a href=\"https://carto.com/attributions\">CARTO</a>',\n    maxZoom: 19,\n  },\n  stamen: {\n    url: \"https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png\",\n    attribution:\n      'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>',\n    maxZoom: 18,\n  },\n  satellite: {\n    url: \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n    attribution:\n      \"Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community\",\n    maxZoom: 19,\n  },\n};\n\n// Constants - prevent re-creation\nconst DEFAULT_LOCATION = { lat: 51.5074, lng: -0.1278 };\n\n// Load Leaflet CSS and JS dynamically\nconst loadLeaflet = () => {\n  if (typeof (window as any).L !== \"undefined\") {\n    return Promise.resolve();\n  }\n\n  return new Promise<void>((resolve, reject) => {\n    // Load CSS\n    const link = document.createElement(\"link\");\n    link.rel = \"stylesheet\";\n    link.href = \"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\";\n    document.head.appendChild(link);\n\n    // Load JS\n    const script = document.createElement(\"script\");\n    script.src = \"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\";\n    script.onload = () => resolve();\n    script.onerror = () => reject(new Error(\"Failed to load Leaflet\"));\n    document.head.appendChild(script);\n  });\n};\n\ninterface LocationPickerFieldProps extends BaseFieldProps {\n  locationConfig?: LocationConfig;\n}\n\nexport const LocationPickerField: React.FC<LocationPickerFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  locationConfig,\n}) => {\n  // Extract config with defaults - NO objects created inline\n  const config = locationConfig || {};\n  const defaultLocation = config.defaultLocation || DEFAULT_LOCATION;\n  const zoom = config.zoom || 10;\n  const searchPlaceholder = config.searchPlaceholder || \"🔍 Search for an address or place...\";\n  const enableSearch = config.enableSearch !== false;\n  const enableGeolocation = config.enableGeolocation !== false;\n  const enableManualEntry = config.enableManualEntry !== false;\n  const showMap = config.showMap !== false;\n  const mapProvider = config.mapProvider || \"openstreetmap\";\n  const searchCallback = config.searchCallback;\n  const reverseGeocodeCallback = config.reverseGeocodeCallback;\n  const mapRenderCallback = config.mapRenderCallback;\n  \n  // Search options with defaults\n  const searchOpts = config.searchOptions || {};\n  const debounceMs = searchOpts.debounceMs || 300;\n  const minQueryLength = searchOpts.minQueryLength || 2;\n  const maxResults = searchOpts.maxResults || 5;\n  \n  // UI options with defaults\n  const uiOpts = config.ui || {};\n  const showCoordinates = uiOpts.showCoordinates !== false;\n  const showAddress = uiOpts.showAddress !== false;\n  const mapHeight = uiOpts.mapHeight || 400;\n  const coordinatesFormat = uiOpts.coordinatesFormat || \"decimal\";\n\n  // Simple state - no complex dependencies\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [isSearching, setIsSearching] = useState(false);\n  const [searchResults, setSearchResults] = useState<LocationSearchResult[]>([]);\n  const [showResults, setShowResults] = useState(false);\n  const [currentLocation, setCurrentLocation] = useState<LocationValue | null>(fieldApi.state?.value || null);\n  const [geoError, setGeoError] = useState<string | null>(null);\n  const [manualLat, setManualLat] = useState(\"\");\n  const [manualLng, setManualLng] = useState(\"\");\n  const [isManualDialogOpen, setIsManualDialogOpen] = useState(false);\n  const [leafletLoaded, setLeafletLoaded] = useState(false);\n\n  const mapRef = useRef<HTMLDivElement>(null);\n  const searchTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const mapInstanceRef = useRef<any>(null);\n\n  // Load Leaflet on mount only if map is enabled - simple\n  useEffect(() => {\n    if (!showMap) {\n      setLeafletLoaded(false);\n      return;\n    }\n    \n    loadLeaflet()\n      .then(() => setLeafletLoaded(true))\n      .catch(() => setGeoError(\"Failed to load map library\"));\n  }, [showMap]);\n\n  // Search function - simple, no complex dependencies\n  const performSearch = useCallback(async (query: string) => {\n    if (!query.trim() || query.length < minQueryLength) {\n      setSearchResults([]);\n      setShowResults(false);\n      return;\n    }\n\n    setIsSearching(true);\n    try {\n      let results: LocationSearchResult[];\n      \n      if (searchCallback) {\n        results = await searchCallback(query, { limit: maxResults });\n      } else {\n        results = await builtInProviders.nominatim(query, { \n          limit: maxResults,\n          ...config.openStreetMap \n        });\n      }\n      \n      setSearchResults(results);\n      setShowResults(true);\n    } catch (error) {\n      console.error(\"Location search error:\", error);\n      setSearchResults([]);\n      setGeoError(\"Search failed. Please try again.\");\n    } finally {\n      setIsSearching(false);\n    }\n  }, [searchCallback, minQueryLength, maxResults, config.openStreetMap]);\n\n  // Debounced search - simple\n  useEffect(() => {\n    if (!enableSearch) return;\n\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n\n    searchTimeoutRef.current = setTimeout(() => {\n      performSearch(searchQuery);\n    }, debounceMs);\n\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, [searchQuery, enableSearch, performSearch, debounceMs]);\n\n  // Location selection - simple\n  const handleLocationSelect = useCallback(async (location: LocationValue) => {\n    // Add address if missing\n    if (!location.address && location.lat && location.lng) {\n      try {\n        let geocodedLocation: LocationValue;\n        \n        if (reverseGeocodeCallback) {\n          geocodedLocation = await reverseGeocodeCallback(location.lat, location.lng);\n        } else {\n          geocodedLocation = await builtInProviders.nominatimReverse(\n            location.lat, \n            location.lng, \n            config.openStreetMap\n          );\n        }\n        \n        location = { ...location, ...geocodedLocation };\n      } catch (error) {\n        console.error(\"Reverse geocoding error:\", error);\n        location.address = `${location.lat}, ${location.lng}`;\n      }\n    }\n\n    setCurrentLocation(location);\n    fieldApi.handleChange(location);\n    setShowResults(false);\n    setSearchQuery(location.address || `${location.lat}, ${location.lng}`);\n    setGeoError(null);\n\n    if (mapInstanceRef.current?.updateLocation) {\n      mapInstanceRef.current.updateLocation(location);\n    }\n  }, [fieldApi, reverseGeocodeCallback, config.openStreetMap]);\n\n  // Initialize map - simple\n  useEffect(() => {\n    if (!showMap || !mapRef.current || !leafletLoaded) return;\n\n    const mapRenderer = mapRenderCallback || defaultMapRenderer;\n    \n    const mapInstance = mapRenderer({\n      location: currentLocation,\n      onLocationSelect: handleLocationSelect,\n      mapContainer: mapRef.current,\n      zoom,\n      readonly: false,\n      defaultLocation,\n    });\n\n    mapInstanceRef.current = mapInstance;\n\n    // Apply tile provider if not default\n    if (mapProvider !== \"openstreetmap\") {\n      const tileConfig = TILE_PROVIDERS[mapProvider as keyof typeof TILE_PROVIDERS];\n      if (tileConfig && 'switchTileLayer' in mapInstance) {\n        (mapInstance as any).switchTileLayer(tileConfig);\n      }\n    }\n\n    return () => {\n      if (mapInstance.cleanup) {\n        mapInstance.cleanup();\n      }\n    };\n  }, [showMap, leafletLoaded, currentLocation, handleLocationSelect, mapRenderCallback, zoom, defaultLocation, mapProvider]);\n\n  // Simple handlers - no complex state\n  const handleGetCurrentLocation = () => {\n    if (!enableGeolocation || !navigator.geolocation) {\n      setGeoError(\"Geolocation is not supported by your browser\");\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const location: LocationValue = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          address: \"Current Location\",\n        };\n        handleLocationSelect(location);\n      },\n      (error) => {\n        const errorMessages: Record<number, string> = {\n          1: \"Location access denied. Please enable location permissions.\",\n          2: \"Location unavailable. Please try again.\",\n          3: \"Location request timed out. Please try again.\",\n        };\n        setGeoError(errorMessages[error.code] || \"Failed to get location\");\n      }\n    );\n  };\n\n  const handleManualCoordinatesSubmit = () => {\n    const lat = parseFloat(manualLat);\n    const lng = parseFloat(manualLng);\n    if (!isNaN(lat) && !isNaN(lng)) {\n      const location: LocationValue = {\n        lat,\n        lng,\n        address: `${lat}, ${lng}`,\n      };\n      handleLocationSelect(location);\n      setIsManualDialogOpen(false);\n      setManualLat(\"\");\n      setManualLng(\"\");\n    } else {\n      setGeoError(\"Invalid coordinates. Please enter valid numbers.\");\n    }\n  };\n\n  const handleClearLocation = () => {\n    setCurrentLocation(null);\n    fieldApi.handleChange(null);\n    setSearchQuery(\"\");\n    setGeoError(null);\n\n    if (mapInstanceRef.current?.updateLocation) {\n      mapInstanceRef.current.updateLocation(null);\n    }\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-3\">\n        {/* Address Search Input */}\n        {enableSearch && (\n          <div className=\"relative\">\n            <div className=\"relative\">\n              <Input\n                id={fieldApi.name}\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                placeholder={placeholder || searchPlaceholder}\n                className={cn(\n                  \"pl-10 pr-4\",\n                  inputClassName,\n                  uiOpts.searchInputClassName,\n                  isSearching && \"animate-pulse\"\n                )}\n                onFocus={() => searchResults.length > 0 && setShowResults(true)}\n                onBlur={() => setTimeout(() => setShowResults(false), 200)}\n              />\n              <div className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground\">\n                {isSearching ? (\n                  <div className=\"w-4 h-4 border-2 border-muted-foreground border-t-transparent rounded-full animate-spin\" />\n                ) : (\n                  <span className=\"text-sm\">🔍</span>\n                )}\n              </div>\n              {searchQuery && (\n                <button\n                  type=\"button\"\n                  onClick={() => {\n                    setSearchQuery(\"\");\n                    setSearchResults([]);\n                    setShowResults(false);\n                  }}\n                  className=\"absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground\"\n                >\n                  ✕\n                </button>\n              )}\n            </div>\n\n            {/* Enhanced Search Results */}\n            {showResults && searchResults.length > 0 && (\n              <Card className=\"absolute top-full left-0 right-0 z-[999] mt-1 max-h-60 overflow-y-auto shadow-lg border-2\">\n                <div className=\"p-1\">\n                  {searchResults.map((result) => (\n                    <button\n                      key={result.id}\n                      type=\"button\"\n                      className=\"w-full text-left p-3 hover:bg-muted/80 rounded-md text-sm transition-colors border-b border-border/50 last:border-b-0\"\n                      onClick={() => handleLocationSelect(result)}\n                    >\n                      <div className=\"flex items-start gap-2\">\n                        <span className=\"text-lg mt-0.5\">📍</span>\n                        <div className=\"flex-1 min-w-0\">\n                          <div className=\"font-medium text-foreground truncate\">\n                            {result.address}\n                          </div>\n                          {showCoordinates && (\n                            <div className=\"text-xs text-muted-foreground mt-1\">\n                              {formatCoordinates(\n                                result.lat,\n                                result.lng,\n                                coordinatesFormat\n                              )}\n                            </div>\n                          )}\n                          {result.city && (\n                            <div className=\"text-xs text-muted-foreground/80 mt-0.5\">\n                              {[result.city, result.state, result.country]\n                                .filter(Boolean)\n                                .join(\", \")}\n                            </div>\n                          )}\n                        </div>\n                      </div>\n                    </button>\n                  ))}\n                </div>\n              </Card>\n            )}\n\n            {/* No Results Message */}\n            {showResults &&\n              searchResults.length === 0 &&\n              !isSearching &&\n              searchQuery.length >= minQueryLength && (\n                <Card className=\"absolute top-full left-0 right-0 z-[70] mt-1 shadow-lg\">\n                  <div className=\"p-4 text-center text-muted-foreground\">\n                    <div className=\"text-2xl mb-2\">🗺️</div>\n                    <div className=\"text-sm\">\n                      No locations found for \"{searchQuery}\"\n                    </div>\n                    <div className=\"text-xs mt-1\">\n                      Try a different search term or use coordinates\n                    </div>\n                  </div>\n                </Card>\n              )}\n          </div>\n        )}\n\n        {/* Action Buttons */}\n        <div className=\"flex flex-wrap gap-2\">\n          {enableGeolocation && (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={handleGetCurrentLocation}\n            >\n              📍 Current Location\n            </Button>\n          )}\n\n          {enableManualEntry && (\n            <Dialog\n              open={isManualDialogOpen}\n              onOpenChange={setIsManualDialogOpen}\n            >\n              <DialogTrigger asChild>\n                <Button type=\"button\" variant=\"outline\" size=\"sm\">\n                  🎯 Enter Coordinates\n                </Button>\n              </DialogTrigger>\n              <DialogContent className=\"sm:max-w-[425px]\">\n                <DialogHeader>\n                  <DialogTitle>Enter Coordinates</DialogTitle>\n                  <DialogDescription>\n                    Enter the latitude and longitude coordinates.\n                  </DialogDescription>\n                </DialogHeader>\n                <div className=\"grid gap-4 py-4\">\n                  <div className=\"grid grid-cols-4 items-center gap-4\">\n                    <Label htmlFor=\"latitude\" className=\"text-right\">\n                      Latitude\n                    </Label>\n                    <Input\n                      id=\"latitude\"\n                      value={manualLat}\n                      onChange={(e) => setManualLat(e.target.value)}\n                      className=\"col-span-3\"\n                      placeholder=\"e.g., 40.7128\"\n                    />\n                  </div>\n                  <div className=\"grid grid-cols-4 items-center gap-4\">\n                    <Label htmlFor=\"longitude\" className=\"text-right\">\n                      Longitude\n                    </Label>\n                    <Input\n                      id=\"longitude\"\n                      value={manualLng}\n                      onChange={(e) => setManualLng(e.target.value)}\n                      className=\"col-span-3\"\n                      placeholder=\"e.g., -74.0060\"\n                    />\n                  </div>\n                </div>\n                <DialogFooter>\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    onClick={() => setIsManualDialogOpen(false)}\n                  >\n                    Cancel\n                  </Button>\n                  <Button type=\"button\" onClick={handleManualCoordinatesSubmit}>\n                    Set Location\n                  </Button>\n                </DialogFooter>\n              </DialogContent>\n            </Dialog>\n          )}\n\n          {currentLocation && (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={handleClearLocation}\n            >\n              🗑️ Clear\n            </Button>\n          )}\n        </div>\n\n        {/* Map */}\n        {showMap && (\n          <div className=\"relative\">\n            {!leafletLoaded && (\n              <div className=\"absolute inset-0 flex items-center justify-center bg-muted rounded-md\">\n                <div className=\"text-muted-foreground\">Loading map...</div>\n              </div>\n            )}\n            <div\n              ref={mapRef}\n              className={cn(\"w-full border rounded-md\", uiOpts.mapClassName)}\n              style={{ height: `${mapHeight}px`, minHeight: \"300px\" }}\n            />\n          </div>\n        )}\n\n        {/* Location Display */}\n        {currentLocation && (\n          <div className=\"text-sm space-y-1\">\n            {showAddress && currentLocation.address && (\n              <div className=\"font-medium\">{currentLocation.address}</div>\n            )}\n            {showCoordinates && (\n              <div className=\"text-muted-foreground\">\n                📍{\" \"}\n                {formatCoordinates(\n                  currentLocation.lat,\n                  currentLocation.lng,\n                  coordinatesFormat\n                )}\n              </div>\n            )}\n            {currentLocation.city && (\n              <div className=\"text-muted-foreground text-xs\">\n                {[\n                  currentLocation.city,\n                  currentLocation.state,\n                  currentLocation.country,\n                ]\n                  .filter(Boolean)\n                  .join(\", \")}\n              </div>\n            )}\n          </div>\n        )}\n\n        {/* Error Display */}\n        {geoError && (\n          <div className=\"text-sm text-destructive bg-destructive/10 p-2 rounded-md\">\n            {geoError}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/masked-input-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\ninterface MaskedInputFieldProps extends BaseFieldProps {\n  maskedInputConfig?: {\n    mask: string | ((value: string) => string);\n    placeholder?: string;\n    showMask?: boolean;\n    guide?: boolean;\n    keepCharPositions?: boolean;\n    pipe?: (conformedValue: string, config: unknown) => false | string | { value: string; indexesOfPipedChars: number[] };\n  };\n}\n\n// Common mask patterns\nconst MASK_PATTERNS = {\n  phone: '(000) 000-0000',\n  ssn: '000-00-0000',\n  creditCard: '0000 0000 0000 0000',\n  date: '00/00/0000',\n  time: '00:00',\n  zipCode: '00000',\n  zipCodeExtended: '00000-0000',\n  currency: '$0,000.00',\n};\n\nexport const MaskedInputField: React.FC<MaskedInputFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  maskedInputConfig = {},\n}) => {\n  const name = fieldApi.name;\n\n  const {\n    mask = '',\n    showMask = false,\n    guide = true,\n\n    pipe\n  } = maskedInputConfig;\n\n  const [displayValue, setDisplayValue] = useState('');\n  const [rawValue, setRawValue] = useState('');\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Apply mask to value\n  const applyMask = React.useCallback((value: string): string => {\n    if (!mask) return value;\n\n    if (typeof mask === 'function') {\n      return mask(value);\n    }\n\n    // Handle string mask patterns\n    let maskedValue = '';\n    let digitIndex = 0;\n    let letterIndex = 0;\n    const cleanDigits = value.replace(/\\D/g, ''); // Extract digits\n    const cleanLetters = value.replace(/[^a-zA-Z]/g, ''); // Extract letters\n\n    for (let i = 0; i < mask.length; i++) {\n      const maskChar = mask[i];\n      \n      if (maskChar === '0' || maskChar === '9') {\n        // Digit placeholder\n        if (digitIndex < cleanDigits.length) {\n          maskedValue += cleanDigits[digitIndex];\n          digitIndex++;\n        } else if (guide && showMask) {\n          maskedValue += '_';\n        } else {\n          break; // Stop if no more digits and not showing guide\n        }\n      } else if (maskChar === 'A' || maskChar === 'a') {\n        // Letter placeholder\n        if (letterIndex < cleanLetters.length) {\n          const char = cleanLetters[letterIndex];\n          maskedValue += maskChar === 'A' ? char.toUpperCase() : char.toLowerCase();\n          letterIndex++;\n        } else if (guide && showMask) {\n          maskedValue += '_';\n        } else {\n          break; // Stop if no more letters and not showing guide\n        }\n      } else {\n        // Literal character\n        maskedValue += maskChar;\n      }\n    }\n\n    // Apply pipe function if provided\n    if (pipe) {\n      const piped = pipe(maskedValue, { mask, guide, showMask });\n      if (piped === false) {\n        return displayValue; // Reject the change\n      }\n      if (typeof piped === 'string') {\n        return piped;\n      }\n      if (piped && typeof piped === 'object' && piped.value) {\n        return piped.value;\n      }\n    }\n\n    return maskedValue;\n  }, [mask, guide, showMask, pipe, displayValue]);\n\n  // Initialize from field value\n  useEffect(() => {\n    const value = fieldApi.state?.value || '';\n    setRawValue(value);\n    setDisplayValue(applyMask(value));\n  }, [fieldApi.state?.value, applyMask]);\n\n  // Extract raw value from masked value\n  const extractRawValue = (maskedValue: string): string => {\n    if (!mask || typeof mask === 'function') {\n      return maskedValue;\n    }\n\n    // For string masks, extract only the actual input characters\n    let rawValue = '';\n    let maskIndex = 0;\n\n    for (let i = 0; i < maskedValue.length && maskIndex < mask.length; i++) {\n      const char = maskedValue[i];\n      const maskChar = mask[maskIndex];\n\n      if (maskChar === '0' || maskChar === '9') {\n        if (/\\d/.test(char)) {\n          rawValue += char;\n        }\n        maskIndex++;\n      } else if (maskChar === 'A' || maskChar === 'a') {\n        if (/[a-zA-Z]/.test(char)) {\n          rawValue += char;\n        }\n        maskIndex++;\n      } else if (char === maskChar) {\n        // Skip literal characters\n        maskIndex++;\n      } else {\n        // Character doesn't match mask, skip it\n        continue;\n      }\n    }\n\n    return rawValue;\n  };\n\n  // Handle input change\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    const newRawValue = extractRawValue(inputValue);\n    const newDisplayValue = applyMask(newRawValue);\n\n    setRawValue(newRawValue);\n    setDisplayValue(newDisplayValue);\n    fieldApi.handleChange(newRawValue);\n  };\n\n  // Handle key down for better UX\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const input = e.target as HTMLInputElement;\n    const { selectionStart, selectionEnd } = input;\n\n    // Handle backspace to skip over literal characters\n    if (e.key === 'Backspace' && selectionStart !== null && selectionEnd !== null && selectionStart === selectionEnd && selectionStart > 0) {\n      const maskChar = typeof mask === 'string' ? mask[selectionStart - 1] : '';\n      \n      // If the previous character is a literal (not a placeholder), skip it\n      if (maskChar && maskChar !== '0' && maskChar !== '9' && maskChar !== 'A' && maskChar !== 'a') {\n        e.preventDefault();\n        const newCursorPos = selectionStart - 1;\n        setTimeout(() => {\n          if (inputRef.current) {\n            inputRef.current.setSelectionRange(newCursorPos, newCursorPos);\n          }\n        }, 0);\n      }\n    }\n  };\n\n  // Get placeholder text\n  const getPlaceholder = (): string => {\n    if (placeholder) return placeholder;\n    if (maskedInputConfig.placeholder) return maskedInputConfig.placeholder;\n    if (showMask && typeof mask === 'string') {\n      return mask.replace(/[09Aa]/g, '_');\n    }\n    return '';\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={labelClassName}>\n          {label}\n        </Label>\n      )}\n      \n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <Input\n        ref={inputRef}\n        id={name}\n        name={name}\n        value={displayValue}\n        onChange={handleInputChange}\n        onKeyDown={handleKeyDown}\n        placeholder={getPlaceholder()}\n        className={inputClassName}\n      />\n\n      {/* Show mask pattern hint */}\n      {mask && typeof mask === 'string' && (\n        <div className=\"text-xs text-muted-foreground\">\n          Format: {mask.replace(/[09]/g, '#').replace(/[Aa]/g, 'A')}\n        </div>\n      )}\n\n      {/* Show raw value for debugging */}\n      {process.env.NODE_ENV === 'development' && rawValue !== displayValue && (\n        <div className=\"text-xs text-muted-foreground\">\n          Raw value: {rawValue}\n        </div>\n      )}\n\n      {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">\n          {fieldApi.state?.meta?.errors[0]}\n        </p>\n      )}\n    </div>\n  );\n};\n\n// Export common mask patterns for convenience\nexport { MASK_PATTERNS };",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/multi-select-field.tsx",
      "content": "'use client';\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\n\nimport { cn } from '@/lib/utils';\nimport { X, ChevronDown, Check } from 'lucide-react';\nimport type { MultiSelectFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nexport const MultiSelectField: React.FC<MultiSelectFieldSpecificProps> = ({\n  fieldApi,\n  options = [],\n  multiSelectConfig = {},\n  \n  ...wrapperProps\n}) => {\n  const {\n    maxSelections = Infinity,\n    searchable = true,\n    creatable = false,\n    placeholder = 'Select options...',\n    noOptionsText = 'No options found',\n  } = multiSelectConfig;\n\n  const name = fieldApi.name;\n  const selectedValues = Array.isArray(fieldApi.state?.value) ? fieldApi.state?.value : [];\n  \n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const containerRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const normalizedOptions = options.map(option => \n    typeof option === 'string' \n      ? { value: option, label: option }\n      : option\n  );\n\n  // Filter options based on search query\n  const filteredOptions = normalizedOptions.filter(option =>\n    option.label.toLowerCase().includes(searchQuery.toLowerCase()) ||\n    option.value.toLowerCase().includes(searchQuery.toLowerCase())\n  );\n\n  // Add create option if enabled and query doesn't match existing options\n  const canCreate = creatable && \n    searchQuery.trim() && \n    !normalizedOptions.some(opt => \n      opt.value.toLowerCase() === searchQuery.toLowerCase() ||\n      opt.label.toLowerCase() === searchQuery.toLowerCase()\n    ) &&\n    !selectedValues.includes(searchQuery.trim());\n\n  const displayOptions = [...filteredOptions];\n  if (canCreate) {\n    displayOptions.unshift({\n      value: searchQuery.trim(),\n      label: `Create \"${searchQuery.trim()}\"`,\n      isCreateOption: true\n    } as { value: string; label: string; isCreateOption: true });\n  }\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n        setSearchQuery('');\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleSelect = (optionValue: string) => {\n    if (selectedValues.includes(optionValue)) {\n      // Remove if already selected\n      const newValues = selectedValues.filter(v => v !== optionValue);\n      fieldApi.handleChange(newValues);\n    } else if (selectedValues.length < maxSelections) {\n      // Add if not at max selections\n      const newValues = [...selectedValues, optionValue];\n      fieldApi.handleChange(newValues);\n    }\n    \n    setSearchQuery('');\n    if (!searchable) {\n      setIsOpen(false);\n    }\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (valueToRemove: string) => {\n    const newValues = selectedValues.filter(v => v !== valueToRemove);\n    fieldApi.handleChange(newValues);\n    fieldApi.handleBlur();\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Backspace' && !searchQuery && selectedValues.length > 0) {\n      // Remove last selected item on backspace\n      handleRemove(selectedValues[selectedValues.length - 1]);\n    } else if (e.key === 'Enter' && canCreate) {\n      e.preventDefault();\n      handleSelect(searchQuery.trim());\n    } else if (e.key === 'Escape') {\n      setIsOpen(false);\n      setSearchQuery('');\n    }\n  };\n\n  const getSelectedLabels = () => {\n    return selectedValues.map(value => {\n      const option = normalizedOptions.find(opt => opt.value === value);\n      return option ? option.label : value;\n    });\n  };\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"space-y-2\" ref={containerRef}>\n        {wrapperProps.label && maxSelections < Infinity && (\n          <div className=\"text-sm text-muted-foreground\">\n            ({selectedValues.length}/{maxSelections})\n          </div>\n        )}\n\n        <div className=\"relative\">\n          {/* Selected items display */}\n          <div\n            className={cn(\n              \"min-h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background\",\n              \"focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2\",\n              fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\",\n              isDisabled ? \"opacity-50 cursor-not-allowed\" : \"cursor-text\"\n            )}\n            onClick={() => {\n              if (!isDisabled) {\n                setIsOpen(true);\n                inputRef.current?.focus();\n              }\n            }}\n          >\n          <div className=\"flex flex-wrap gap-1 items-center\">\n            {/* Selected tags */}\n            {selectedValues.map((value, index) => {\n              const label = getSelectedLabels()[index];\n              return (\n                <Badge\n                  key={value}\n                  variant=\"secondary\"\n                  className=\"text-xs h-6 px-2 gap-1\"\n                >\n                  {label}\n                  <Button\n                    type=\"button\"\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-3 w-3 p-0 hover:bg-destructive hover:text-destructive-foreground\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleRemove(value);\n                    }}\n                    disabled={isDisabled}\n                  >\n                    <X className=\"h-2 w-2\" />\n                  </Button>\n                </Badge>\n              );\n            })}\n            \n            {/* Search input */}\n            {searchable && (\n              <Input\n                ref={inputRef}\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                onKeyDown={handleKeyDown}\n                onFocus={() => setIsOpen(true)}\n                onBlur={fieldApi.handleBlur}\n                placeholder={selectedValues.length === 0 ? placeholder : ''}\n                className=\"border-0 p-0 h-6 focus-visible:ring-0 focus-visible:ring-offset-0 bg-transparent\"\n                disabled={isDisabled || selectedValues.length >= maxSelections}\n              />\n            )}\n            \n            {/* Dropdown indicator */}\n            <ChevronDown \n              className={cn(\n                \"h-4 w-4 text-muted-foreground transition-transform ml-auto\",\n                isOpen ? \"rotate-180\" : \"\"\n              )} \n            />\n          </div>\n        </div>\n\n        {/* Dropdown */}\n        {isOpen && (\n          <div className=\"absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto\">\n            {displayOptions.length === 0 ? (\n              <div className=\"p-2 text-sm text-muted-foreground text-center\">\n                {noOptionsText}\n              </div>\n            ) : (\n              displayOptions.map((option: { value: string; label: string; isCreateOption?: boolean }, index) => {\n                const isSelected = selectedValues.includes(option.value);\n                const isDisabled = !isSelected && selectedValues.length >= maxSelections;\n                \n                return (\n                  <button\n                    key={`${option.value}-${index}`}\n                    type=\"button\"\n                    className={cn(\n                      \"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\",\n                      \"flex items-center justify-between\",\n                      isSelected ? \"bg-accent\" : \"\",\n                      isDisabled ? \"opacity-50 cursor-not-allowed\" : \"\",\n                      option.isCreateOption ? \"font-medium text-primary\" : \"\"\n                    )}\n                    onClick={() => !isDisabled && handleSelect(option.value)}\n                    disabled={isDisabled}\n                  >\n                    <span>{option.label}</span>\n                    {isSelected && <Check className=\"h-4 w-4\" />}\n                  </button>\n                );\n              })\n            )}\n          </div>\n        )}\n      </div>\n\n      </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/number-field.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Input } from '@/components/ui/input';\nimport { cn } from '@/lib/utils';\nimport type { NumberFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nexport const NumberField: React.FC<NumberFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  min,\n  max,\n  step,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as number | string | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value;\n    let parsedValue: number | string | undefined;\n    \n    if (val === '') {\n      parsedValue = undefined;\n    } else {\n      const num = parseFloat(val);\n      parsedValue = isNaN(num) ? val : num;\n    }\n    \n    fieldApi.handleChange(parsedValue);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  let displayValue: string | number = '';\n  if (typeof value === 'number') {\n    displayValue = value;\n  } else if (typeof value === 'string') {\n    displayValue = value;\n  }\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Input\n        id={name}\n        name={name}\n        type=\"number\"\n        value={displayValue}\n        onBlur={onBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        className={computedInputClassName}\n        disabled={isDisabled}\n        min={min}\n        max={max}\n        step={step}\n      />\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/object-field.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport type { BaseFieldProps, ObjectFieldProps, LayoutConfig } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from './base-field-wrapper';\nimport { NestedFieldRenderer } from './shared-field-renderer';\n\nexport const ObjectField: React.FC<ObjectFieldProps> = ({\n  fieldApi,\n  objectConfig,\n  disabled,\n  form,\n  ...wrapperProps\n}) => {\n  const [isExpanded, setIsExpanded] = React.useState(\n    objectConfig?.defaultExpanded !== false\n  );\n\n  // Create a properly typed mockFieldApi that includes the form property\n  const createMockFieldApi = (fieldName: string, fieldValue: unknown) => {\n    return {\n      name: `${fieldApi.name}.${fieldName}`,\n      form: fieldApi.form, // Include the form property to fix the bug\n      state: {\n        ...fieldApi.state,\n        value: fieldValue,\n        meta: {\n          ...fieldApi.state.meta,\n          errors: [], // Reset errors for subfield\n          isTouched: false, // Reset touched state for subfield\n        }\n      },\n      handleChange: (value: unknown) => {\n        const currentValue = fieldApi.state?.value || {};\n        fieldApi.handleChange({\n          ...currentValue,\n          [fieldName]: value\n        });\n      },\n      handleBlur: fieldApi.handleBlur,\n    };\n  };\n\n  const renderField = (subFieldConfig: any) => {\n    const fieldValue = fieldApi.state?.value?.[subFieldConfig.name] || '';\n    const mockFieldApi = createMockFieldApi(subFieldConfig.name, fieldValue) as unknown as BaseFieldProps['fieldApi'];\n\n    return (\n      <div key={subFieldConfig.name}>\n        <NestedFieldRenderer\n          fieldConfig={subFieldConfig}\n          fieldApi={mockFieldApi}\n          form={form}\n          currentValues={form?.state?.values || {}}\n        />\n      </div>\n    );\n  };\n\n  const getLayoutClasses = () => {\n    const layout = objectConfig?.layout || \"vertical\";\n    const columns = objectConfig?.columns || 2;\n    \n    switch (layout) {\n      case \"horizontal\":\n        return \"flex flex-wrap gap-4\";\n      case \"grid\":\n        return `grid grid-cols-1 md:grid-cols-${columns} gap-4`;\n      default:\n        return \"space-y-4\";\n    }\n  };\n\n  const content = (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"space-y-4\">\n        {/* Object title and description */}\n        {(objectConfig?.title || objectConfig?.description) && (\n          <div className=\"space-y-1\">\n            {objectConfig?.title && (\n              <div className=\"flex items-center justify-between\">\n                <h4 className=\"text-sm font-medium text-muted-foreground\">\n                  {objectConfig.title}\n                </h4>\n                {objectConfig?.collapsible && (\n                  <button\n                    type=\"button\"\n                    onClick={() => setIsExpanded(!isExpanded)}\n                    className=\"text-xs text-muted-foreground hover:text-foreground\"\n                  >\n                    {isExpanded ? (objectConfig?.collapseLabel || \"Collapse\") : (objectConfig?.expandLabel || \"Expand\")}\n                  </button>\n                )}\n              </div>\n            )}\n            {objectConfig?.description && (\n              <p className=\"text-xs text-muted-foreground\">\n                {objectConfig.description}\n              </p>\n            )}\n          </div>\n        )}\n\n        {/* Fields */}\n        {(!objectConfig?.collapsible || isExpanded) && (\n          <>\n            {objectConfig?.title && <div className=\"border-t my-4\" />}\n            <div className={getLayoutClasses()}>\n              {objectConfig?.fields?.map(renderField)}\n            </div>\n          </>\n        )}\n\n        {/* Show field errors */}\n        {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n          <div className=\"text-sm text-destructive\">\n            {fieldApi.state?.meta?.errors.join(\", \")}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n\n  // Wrap in card if specified\n  if (objectConfig?.showCard) {\n    return (\n      <Card className=\"w-full\">\n        {(objectConfig?.title || objectConfig?.description) && (\n          <CardHeader className=\"pb-3\">\n            {objectConfig?.title && (\n              <div className=\"flex items-center justify-between\">\n                <CardTitle className=\"text-base\">{objectConfig.title}</CardTitle>\n                {objectConfig?.collapsible && (\n                  <button\n                    type=\"button\"\n                    onClick={() => setIsExpanded(!isExpanded)}\n                    className=\"text-xs text-muted-foreground hover:text-foreground\"\n                  >\n                    {isExpanded ? (objectConfig?.collapseLabel || \"Collapse\") : (objectConfig?.expandLabel || \"Expand\")}\n                  </button>\n                )}\n              </div>\n            )}\n            {objectConfig?.description && (\n              <p className=\"text-sm text-muted-foreground mt-1\">\n                {objectConfig.description}\n              </p>\n            )}\n          </CardHeader>\n        )}\n        <CardContent className=\"pt-0\">\n          {(!objectConfig?.collapsible || isExpanded) && (\n            <>\n              <div className={getLayoutClasses()}>\n                {objectConfig?.fields?.map(renderField)}\n              </div>\n            </>\n          )}\n          \n          {/* Show field errors */}\n          {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n            <div className=\"text-sm text-destructive mt-4\">\n              {fieldApi.state?.meta?.errors.join(\", \")}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return content;\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/phone-field.tsx",
      "content": "'use client';\nimport React, { useState, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { ChevronDown, Phone } from 'lucide-react';\nimport type { PhoneFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\n// Common country codes and their formatting\nconst COUNTRY_CODES = {\n  US: { code: '+1', name: 'United States', flag: '🇺🇸', format: '(###) ###-####' },\n  CA: { code: '+1', name: 'Canada', flag: '🇨🇦', format: '(###) ###-####' },\n  GB: { code: '+44', name: 'United Kingdom', flag: '🇬🇧', format: '#### ### ####' },\n  FR: { code: '+33', name: 'France', flag: '🇫🇷', format: '## ## ## ## ##' },\n  DE: { code: '+49', name: 'Germany', flag: '🇩🇪', format: '### ### ####' },\n  IT: { code: '+39', name: 'Italy', flag: '🇮🇹', format: '### ### ####' },\n  ES: { code: '+34', name: 'Spain', flag: '🇪🇸', format: '### ### ###' },\n  AU: { code: '+61', name: 'Australia', flag: '🇦🇺', format: '#### ### ###' },\n  JP: { code: '+81', name: 'Japan', flag: '🇯🇵', format: '##-####-####' },\n  CN: { code: '+86', name: 'China', flag: '🇨🇳', format: '### #### ####' },\n  IN: { code: '+91', name: 'India', flag: '🇮🇳', format: '##### #####' },\n  BR: { code: '+55', name: 'Brazil', flag: '🇧🇷', format: '(##) #####-####' },\n  MX: { code: '+52', name: 'Mexico', flag: '🇲🇽', format: '## #### ####' },\n  RU: { code: '+7', name: 'Russia', flag: '🇷🇺', format: '### ###-##-##' },\n  KR: { code: '+82', name: 'South Korea', flag: '🇰🇷', format: '##-####-####' },\n};\n\nconst formatPhoneNumber = (value: string, format: string): string => {\n  // Remove all non-digits\n  const digits = value.replace(/\\D/g, '');\n  \n  // Apply format pattern\n  let formatted = '';\n  let digitIndex = 0;\n  \n  for (const char of format) {\n    if (char === '#' && digitIndex < digits.length) {\n      formatted += digits[digitIndex];\n      digitIndex++;\n    } else if (char !== '#') {\n      formatted += char;\n    } else {\n      break;\n    }\n  }\n  \n  return formatted;\n};\n\nconst extractDigits = (value: string): string => {\n  return value.replace(/\\D/g, '');\n};\n\nexport const PhoneField: React.FC<PhoneFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder: fieldPlaceholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  phoneConfig = {},\n}) => {\n  const {\n    defaultCountry = 'US',\n    format = 'national',\n    allowedCountries,\n    placeholder,\n  } = phoneConfig;\n\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n  \n  const [selectedCountry, setSelectedCountry] = useState(defaultCountry);\n  const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);\n  const [phoneNumber, setPhoneNumber] = useState('');\n\n  const availableCountries = allowedCountries \n    ? Object.entries(COUNTRY_CODES).filter(([code]) => allowedCountries.includes(code))\n    : Object.entries(COUNTRY_CODES);\n\n  const currentCountry = COUNTRY_CODES[selectedCountry as keyof typeof COUNTRY_CODES];\n\n  // Parse existing value on mount\n  useEffect(() => {\n    if (value) {\n      // Try to extract country code and phone number\n      const digits = extractDigits(value);\n      \n      // Find matching country code\n      const matchingCountry = Object.entries(COUNTRY_CODES).find(([_, country]) => {\n        const countryDigits = extractDigits(country.code);\n        return digits.startsWith(countryDigits);\n      });\n\n      if (matchingCountry) {\n        const [countryCode, countryData] = matchingCountry;\n        setSelectedCountry(countryCode);\n        \n        const countryCodeDigits = extractDigits(countryData.code);\n        const phoneDigits = digits.slice(countryCodeDigits.length);\n        setPhoneNumber(formatPhoneNumber(phoneDigits, countryData.format));\n      } else {\n        setPhoneNumber(value);\n      }\n    }\n  }, [value]);\n\n  const handlePhoneNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    const digits = extractDigits(inputValue);\n    \n    // Format the phone number according to country format\n    const formatted = formatPhoneNumber(digits, currentCountry.format);\n    setPhoneNumber(formatted);\n    \n    // Create the final value based on format preference\n    const finalValue = format === 'international' \n      ? `${currentCountry.code} ${formatted}`.trim()\n      : formatted;\n    \n    fieldApi.handleChange(finalValue);\n  };\n\n  const handleCountryChange = (countryCode: string) => {\n    setSelectedCountry(countryCode);\n    setIsCountryDropdownOpen(false);\n    \n    // Update the value with new country code\n    const newCountry = COUNTRY_CODES[countryCode as keyof typeof COUNTRY_CODES];\n    const digits = extractDigits(phoneNumber);\n    const formatted = formatPhoneNumber(digits, newCountry.format);\n    \n    const finalValue = format === 'international' \n      ? `${newCountry.code} ${formatted}`.trim()\n      : formatted;\n    \n    fieldApi.handleChange(finalValue);\n  };\n\n  const getPlaceholder = (): string => {\n    if (placeholder) return placeholder;\n    \n    const exampleNumber = formatPhoneNumber('1234567890', currentCountry.format);\n    return format === 'international' \n      ? `${currentCountry.code} ${exampleNumber}`\n      : exampleNumber;\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-2\">\n        <div className=\"flex\">\n          {/* Country selector */}\n          <div className=\"relative\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              className={cn(\n                \"rounded-r-none border-r-0 px-3 h-10 min-w-[80px]\",\n                hasErrors ? \"border-destructive\" : \"\"\n              )}\n              onClick={() => setIsCountryDropdownOpen(!isCountryDropdownOpen)}\n              disabled={isDisabled}\n            >\n              <span className=\"flex items-center gap-2\">\n                <span className=\"text-base\">{currentCountry.flag}</span>\n                {format === 'international' && (\n                  <span className=\"text-xs text-muted-foreground\">\n                    {currentCountry.code}\n                  </span>\n                )}\n                <ChevronDown className=\"h-3 w-3\" />\n              </span>\n            </Button>\n\n            {/* Country dropdown */}\n            {isCountryDropdownOpen && (\n              <div className=\"absolute z-50 top-full left-0 mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto min-w-[200px]\">\n                {availableCountries.map(([code, country]) => (\n                  <button\n                    key={code}\n                    type=\"button\"\n                    className={cn(\n                      \"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\",\n                      \"flex items-center gap-3\",\n                      selectedCountry === code ? \"bg-accent\" : \"\"\n                    )}\n                    onClick={() => handleCountryChange(code)}\n                  >\n                    <span className=\"text-base\">{country.flag}</span>\n                    <div className=\"flex-1\">\n                      <div className=\"font-medium\">{country.name}</div>\n                      <div className=\"text-xs text-muted-foreground\">{country.code}</div>\n                    </div>\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Phone number input */}\n          <Input\n            value={phoneNumber}\n            onChange={handlePhoneNumberChange}\n            onBlur={() => fieldApi.handleBlur()}\n            placeholder={getPlaceholder()}\n            className={cn(\n              \"rounded-l-none flex-1\",\n              hasErrors ? \"border-destructive\" : \"\",\n              inputClassName\n            )}\n            disabled={isDisabled}\n          />\n        </div>\n\n        {/* Format hint */}\n        <div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\n          <Phone className=\"h-3 w-3\" />\n          <span>\n            Format: {currentCountry.format.replace(/#/g, '0')}\n            {format === 'international' && ` (${currentCountry.code})`}\n          </span>\n        </div>\n      </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/radio-field.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Label } from '@/components/ui/label';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { cn } from '@/lib/utils';\nimport type { RadioFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nexport const RadioField: React.FC<RadioFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  options = [],\n  direction = 'vertical',\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as string | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const normalizedOptions = options.map(option => \n    typeof option === 'string' \n      ? { value: option, label: option }\n      : option\n  );\n\n  const onValueChange = (value: string) => {\n    fieldApi.handleChange(value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <RadioGroup\n        value={value || ''}\n        onValueChange={onValueChange}\n        onBlur={onBlur}\n        disabled={isDisabled}\n        className={cn(\n          direction === 'horizontal' \n            ? \"flex flex-wrap gap-6\" \n            : \"flex flex-col space-y-2\",\n          inputClassName\n        )}\n      >\n        {normalizedOptions.map((option, index) => (\n          <div key={`${option.value}-${index}`} className=\"flex items-center space-x-2\">\n            <RadioGroupItem\n              value={option.value}\n              id={`${name}-${option.value}`}\n              className={cn(\n                hasErrors ? \"border-destructive\" : \"\"\n              )}\n            />\n            <Label\n              htmlFor={`${name}-${option.value}`}\n              className=\"text-sm font-normal cursor-pointer\"\n            >\n              {option.label}\n            </Label>\n          </div>\n        ))}\n      </RadioGroup>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/rating-field.tsx",
      "content": "'use client';\nimport React, { useState } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Star, Heart, ThumbsUp } from 'lucide-react';\nimport type { RatingFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nconst ICON_COMPONENTS = {\n  star: Star,\n  heart: Heart,\n  thumbs: ThumbsUp,\n};\n\nconst SIZE_CLASSES = {\n  sm: 'h-4 w-4',\n  md: 'h-6 w-6',\n  lg: 'h-8 w-8',\n};\n\nexport const RatingField: React.FC<RatingFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  ratingConfig = {},\n}) => {\n  const {\n    max = 5,\n    allowHalf = false,\n    icon = 'star',\n    size = 'md',\n    showValue = false,\n  } = ratingConfig;\n\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as number) || 0;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  \n  const [hoverValue, setHoverValue] = useState<number | null>(null);\n  const IconComponent = ICON_COMPONENTS[icon];\n  const iconSizeClass = SIZE_CLASSES[size];\n\n  const handleRatingClick = (rating: number) => {\n    fieldApi.handleChange(rating);\n    fieldApi.handleBlur();\n  };\n\n  const handleMouseEnter = (rating: number) => {\n    if (!fieldApi.form.state.isSubmitting) {\n      setHoverValue(rating);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    setHoverValue(null);\n  };\n\n  const getRatingValue = (index: number, isHalf: boolean = false): number => {\n    return isHalf ? index + 0.5 : index + 1;\n  };\n\n  const shouldShowFilled = (index: number, isHalf: boolean = false): boolean => {\n    const ratingValue = getRatingValue(index, isHalf);\n    const currentValue = hoverValue !== null ? hoverValue : value;\n    \n    if (isHalf) {\n      return currentValue >= ratingValue;\n    } else {\n      return currentValue >= ratingValue || (allowHalf && currentValue >= ratingValue - 0.5);\n    }\n  };\n\n  const shouldShowHalfFilled = (index: number): boolean => {\n    if (!allowHalf) return false;\n    \n    const currentValue = hoverValue !== null ? hoverValue : value;\n    const fullRating = index + 1;\n    const halfRating = index + 0.5;\n    \n    return currentValue >= halfRating && currentValue < fullRating;\n  };\n\n\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-2\">\n        {showValue && (\n          <div className=\"text-xs text-muted-foreground\">\n            ({value}/{max})\n          </div>\n        )}\n        \n        <div className=\"flex items-center gap-1\">\n          {Array.from({ length: max }, (_, index) => (\n            <div key={index} className=\"relative\">\n              {/* Full star/icon button */}\n              <button\n                type=\"button\"\n                className={cn(\n                  \"relative transition-all duration-150 hover:scale-110\",\n                  isDisabled \n                    ? \"cursor-not-allowed opacity-50\" \n                    : \"cursor-pointer\"\n                )}\n                onClick={() => !isDisabled && handleRatingClick(getRatingValue(index, false))}\n                onMouseEnter={() => !isDisabled && handleMouseEnter(getRatingValue(index, false))}\n                onMouseLeave={handleMouseLeave}\n                onBlur={() => fieldApi.handleBlur()}\n                disabled={isDisabled}\n                title={`Rate ${getRatingValue(index, false)} ${icon}${getRatingValue(index, false) !== 1 ? 's' : ''}`}\n              >\n                  <IconComponent\n                    className={cn(\n                      iconSizeClass,\n                      \"transition-colors duration-150\",\n                      shouldShowFilled(index, false)\n                        ? icon === 'star' \n                          ? \"fill-yellow-400 text-yellow-400\" \n                          : icon === 'heart'\n                          ? \"fill-red-500 text-red-500\"\n                          : \"fill-blue-500 text-blue-500\"\n                        : \"text-muted-foreground hover:text-muted-foreground/80\"\n                    )}\n                  />\n                  \n                  {/* Half-fill overlay for half ratings */}\n                  {allowHalf && shouldShowHalfFilled(index) && (\n                    <div className=\"absolute inset-0 overflow-hidden\" style={{ width: '50%' }}>\n                      <IconComponent\n                        className={cn(\n                          iconSizeClass,\n                          icon === 'star' \n                            ? \"fill-yellow-400 text-yellow-400\" \n                            : icon === 'heart'\n                            ? \"fill-red-500 text-red-500\"\n                            : \"fill-blue-500 text-blue-500\"\n                        )}\n                      />\n                    </div>\n                  )}\n                </button>\n\n                {/* Half star/icon button (if half ratings allowed) */}\n                {allowHalf && (\n                  <button\n                    type=\"button\"\n                    className={cn(\n                      \"absolute inset-0 w-1/2 transition-all duration-150\",\n                      isDisabled \n                        ? \"cursor-not-allowed\" \n                        : \"cursor-pointer\"\n                    )}\n                    onClick={() => !isDisabled && handleRatingClick(getRatingValue(index, true))}\n                    onMouseEnter={() => !isDisabled && handleMouseEnter(getRatingValue(index, true))}\n                    onMouseLeave={handleMouseLeave}\n                    disabled={isDisabled}\n                    title={`Rate ${getRatingValue(index, true)} ${icon}s`}\n                  />\n                )}\n              </div>\n            ))}\n            \n            {/* Clear rating button */}\n            {value > 0 && (\n              <button\n                type=\"button\"\n                className={cn(\n                  \"ml-2 text-xs text-muted-foreground hover:text-foreground transition-colors\",\n                  isDisabled ? \"cursor-not-allowed opacity-50\" : \"cursor-pointer\"\n                )}\n                onClick={() => !isDisabled && handleRatingClick(0)}\n                disabled={isDisabled}\n                title=\"Clear rating\"\n              >\n                Clear\n              </button>\n            )}\n          </div>\n        </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/select-field.tsx",
      "content": "import React from 'react';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface SelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n}\n\nexport const SelectField: React.FC<SelectFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  options = [],\n}) => {\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onValueChange = (value: string) => {\n    fieldApi.handleChange(value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Select\n        value={value}\n        onValueChange={onValueChange}\n        disabled={isDisabled}\n      >\n        <SelectTrigger\n          id={name + \"-trigger\"}\n          onBlur={onBlur}\n          className={computedInputClassName}\n        >\n          <SelectValue placeholder={placeholder || \"Select an option\"} />\n        </SelectTrigger>\n        <SelectContent>\n          {options.map((option, index) => {\n            const optionValue = typeof option === 'string' ? option : option.value;\n            const optionLabel = typeof option === 'string' ? option : option.label;\n            return (\n              <SelectItem key={optionValue + index} value={optionValue}>\n                {optionLabel}\n              </SelectItem>\n            );\n          })}\n        </SelectContent>\n      </Select>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/slider-field.tsx",
      "content": "import React from \"react\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { cn } from \"@/lib/utils\";\nimport type { SliderFieldSpecificProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\n\n\nexport const SliderField: React.FC<SliderFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  sliderConfig,\n  // Backwards compatibility props\n  min: directMin = 0,\n  max: directMax = 100,\n  step: directStep = 1,\n  valueLabelPrefix: directPrefix = \"\",\n  valueLabelSuffix: directSuffix = \"\",\n  valueDisplayPrecision: directPrecision = 0,\n  showRawValue: directShowRaw = false,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n\n  // Use sliderConfig if provided, otherwise use direct props\n  const config = sliderConfig || {\n    min: directMin,\n    max: directMax,\n    step: directStep,\n    valueLabelPrefix: directPrefix,\n    valueLabelSuffix: directSuffix,\n    valueDisplayPrecision: directPrecision,\n    showRawValue: directShowRaw,\n  };\n\n  const {\n    min = 0,\n    max = 100,\n    step = 1,\n    valueMapping,\n    gradientColors,\n    visualizationComponent: VisualizationComponent,\n    valueLabelPrefix = \"\",\n    valueLabelSuffix = \"\",\n    valueDisplayPrecision = 0,\n    showRawValue = false,\n    showValue = true,\n    marks = [],\n  } = config;\n\n  const fieldValue =\n    typeof fieldApi.state?.value === \"number\" ? fieldApi.state?.value : min;\n\n  // Get display value from mapping or calculate it\n  const getDisplayValue = (sliderValue: number) => {\n    if (valueMapping) {\n      const mapping = valueMapping.find((m) => m.sliderValue === sliderValue);\n      return mapping ? mapping.displayValue : sliderValue;\n    }\n    return sliderValue.toFixed(valueDisplayPrecision);\n  };\n\n  const displayValue = getDisplayValue(fieldValue);\n  const mappingItem = valueMapping?.find((m) => m.sliderValue === fieldValue);\n\n  const onValueChange = (valueArray: number[]) => {\n    const newValue = valueArray[0];\n    fieldApi.handleChange(newValue);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  // Custom label with value display\n  const customLabel =\n    label && showValue\n      ? `${label} (${valueLabelPrefix}${displayValue}${valueLabelSuffix})`\n      : label;\n\n  // Generate unique ID for this slider instance\n  const sliderId = `slider-${name}-${Math.random().toString(36).substr(2, 9)}`;\n  \n  // Calculate current color based on slider value\n  const getCurrentColor = () => {\n    if (!gradientColors) return null;\n    \n    const percentage = ((fieldValue - min) / (max - min)) * 100;\n    \n    // Parse hex colors\n    const startColor = gradientColors.start;\n    const endColor = gradientColors.end;\n    \n    // Convert hex to RGB\n    const hexToRgb = (hex: string) => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    };\n    \n    const startRgb = hexToRgb(startColor);\n    const endRgb = hexToRgb(endColor);\n    \n    if (!startRgb || !endRgb) return startColor;\n    \n    // Interpolate between start and end colors\n    const r = Math.round(startRgb.r + (endRgb.r - startRgb.r) * (percentage / 100));\n    const g = Math.round(startRgb.g + (endRgb.g - startRgb.g) * (percentage / 100));\n    const b = Math.round(startRgb.b + (endRgb.b - startRgb.b) * (percentage / 100));\n    \n    return `rgb(${r}, ${g}, ${b})`;\n  };\n  \n  const currentColor = getCurrentColor();\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={customLabel}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-4\">\n        {showRawValue && (\n          <div className=\"text-xs text-muted-foreground\">\n            Raw: {fieldApi.state?.value}\n          </div>\n        )}\n\n        {/* Custom visualization component if provided */}\n        {VisualizationComponent && valueMapping && (\n          <div className=\"flex justify-between items-center mb-2\">\n            {valueMapping.map((mapping, index) => (\n              <VisualizationComponent\n                key={index}\n                value={mapping.sliderValue}\n                displayValue={mapping.displayValue}\n                label={mapping.label}\n                isActive={fieldValue === mapping.sliderValue}\n              />\n            ))}\n          </div>\n        )}\n\n        <div className=\"relative\">\n          {gradientColors && currentColor && (\n            <style>{`\n              .${sliderId} [data-slot=\"slider-range\"] {\n                background: ${currentColor} !important;\n              }\n            `}</style>\n          )}\n          <Slider\n            id={name}\n            name={name}\n            value={[fieldValue]}\n            onValueChange={onValueChange}\n            onBlur={onBlur}\n            disabled={isDisabled}\n            min={min}\n            max={max}\n            step={step}\n            className={cn(inputClassName, gradientColors && sliderId)}\n          />\n\n          {/* Marks display */}\n          {marks.length > 0 && (\n            <div className=\"flex justify-between text-xs text-muted-foreground mt-2\">\n              {marks.map((mark, index) => (\n                <span key={index} className=\"text-center\">\n                  {mark.label}\n                </span>\n              ))}\n            </div>\n          )}\n        </div>\n\n        {/* Display current mapping info */}\n        {mappingItem?.label && (\n          <div className=\"text-sm text-muted-foreground text-center\">\n            {mappingItem.label}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/switch-field.tsx",
      "content": "import React from 'react';\nimport { Switch } from '@/components/ui/switch';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const SwitchField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as boolean | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n\n  const onCheckedChange = (checked: boolean) => {\n    fieldApi.handleChange(checked);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\n    // because Switch components need the label positioned next to (not above) the control\n    <FieldWrapper \n      fieldApi={fieldApi} \n      label={undefined}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"flex items-center space-x-2\">\n        <Switch\n          id={name}\n          checked={!!value}\n          onCheckedChange={onCheckedChange}\n          onBlur={onBlur}\n          disabled={isDisabled}\n          aria-describedby={description ? `${name}-description` : undefined}\n        />\n        {label && (\n          <Label \n            htmlFor={name} \n            className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}\n          >\n            {label}\n          </Label>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/text-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport type { TextFieldSpecificProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\n\n\nexport const TextField: React.FC<TextFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  type = \"text\",\n  datalist,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as string | number | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  // Datalist state\n  const [datalistOptions, setDatalistOptions] = useState<string[]>(\n    datalist?.options || []\n  );\n  const [isLoadingOptions, setIsLoadingOptions] = useState(false);\n  const [lastQuery, setLastQuery] = useState(\"\");\n\n  // Debounced async options fetching\n  const fetchAsyncOptions = useCallback(\n    async (query: string) => {\n      if (!datalist?.asyncOptions) return;\n\n      const minChars = datalist.minChars || 1;\n      if (query.length < minChars) {\n        setDatalistOptions(datalist.options || []);\n        return;\n      }\n\n      if (query === lastQuery) return;\n\n      setIsLoadingOptions(true);\n      setLastQuery(query);\n\n      try {\n        const results = await datalist.asyncOptions(query);\n        const maxResults = datalist.maxResults || 10;\n        const limitedResults = results.slice(0, maxResults);\n\n        // Combine static options with async results\n        const staticOptions = datalist.options || [];\n        const combinedOptions = [...staticOptions, ...limitedResults];\n\n        // Remove duplicates\n        const uniqueOptions = Array.from(new Set(combinedOptions));\n\n        setDatalistOptions(uniqueOptions);\n      } catch (error) {\n        console.error(\"Error fetching datalist options:\", error);\n        // Fallback to static options on error\n        setDatalistOptions(datalist.options || []);\n      } finally {\n        setIsLoadingOptions(false);\n      }\n    },\n    [datalist, lastQuery]\n  );\n\n  // Debounced effect for async options\n  useEffect(() => {\n    if (!datalist?.asyncOptions) return;\n\n    const debounceMs = datalist.debounceMs || 300;\n    const currentValue = String(value || \"\");\n\n    const timeoutId = setTimeout(() => {\n      fetchAsyncOptions(currentValue);\n    }, debounceMs);\n\n    return () => clearTimeout(timeoutId);\n  }, [value, fetchAsyncOptions, datalist]);\n\n  // Generate unique datalist id\n  const datalistId = useMemo(\n    () => (datalist ? `${name}-datalist` : undefined),\n    [name, datalist]\n  );\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    fieldApi.handleChange(e.target.value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\",\n    isLoadingOptions ? \"pr-8\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"relative\">\n        <Input\n          id={name}\n          name={name}\n          type={type}\n          value={value === undefined || value === null ? \"\" : String(value)}\n          onBlur={onBlur}\n          onChange={onChange}\n          placeholder={placeholder}\n          className={computedInputClassName}\n          disabled={isDisabled}\n          list={datalistId}\n          autoComplete={datalist ? \"off\" : undefined}\n        />\n        {isLoadingOptions && (\n          <div className=\"absolute right-2 top-1/2 transform -translate-y-1/2\">\n            <span className=\"text-xs text-muted-foreground\">Loading...</span>\n          </div>\n        )}\n        {datalist && datalistOptions.length > 0 && (\n          <datalist id={datalistId}>\n            {datalistOptions.map((option, index) => (\n              <option key={`${option}-${index}`} value={option} />\n            ))}\n          </datalist>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/fields/textarea-field.tsx",
      "content": "import React from 'react';\nimport { Textarea } from '@/components/ui/textarea';\nimport { cn } from '@/lib/utils';\nimport type { TextareaFieldSpecificProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\n\nexport const TextareaField: React.FC<TextareaFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  rows = 3,\n}) => {\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    fieldApi.handleChange(e.target.value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Textarea\n        id={name}\n        name={name}\n        value={value}\n        onBlur={onBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        rows={rows}\n        className={computedInputClassName}\n        disabled={isDisabled}\n      />\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/layout/form-tabs.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormTabsProps } from \"@/lib/formedible/types\";\n\n\n// PURE DISPLAY COMPONENT - NO STATE, NO RERENDERS\nexport const FormTabs: React.FC<FormTabsProps> = ({\n  children,\n  tabs,\n  activeTab,\n  className,\n  onTabChange,\n}) => {\n  return (\n    <div className={cn(\"space-y-4\", className)}>\n      {children}\n      \n      <Tabs value={activeTab} onValueChange={onTabChange}>\n        <TabsList className=\"grid w-full\" style={{ gridTemplateColumns: `repeat(${tabs.length}, 1fr)` }}>\n          {tabs.map((tab) => (\n            <TabsTrigger key={tab.id} value={tab.id}>\n              {tab.label}\n            </TabsTrigger>\n          ))}\n        </TabsList>\n        \n        {tabs.map((tab) => (\n          <TabsContent key={tab.id} value={tab.id} className=\"space-y-4\">\n            {tab.content}\n          </TabsContent>\n        ))}\n      </Tabs>\n    </div>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/layout/form-stepper.tsx",
      "content": "\"use client\";\nimport React, { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormStepperStep, FormStepperProps } from \"@/lib/formedible/types\";\n\n\nexport const FormStepper: React.FC<FormStepperProps> = ({\n  children,\n  steps,\n  currentStep = 0,\n  onStepChange,\n  onComplete,\n  className,\n  allowSkip = false,\n  showStepNumbers = true,\n}) => {\n  const [activeStep, setActiveStep] = useState(currentStep);\n  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());\n\n  const handleStepChange = (stepIndex: number) => {\n    setActiveStep(stepIndex);\n    onStepChange?.(stepIndex);\n  };\n\n  const markStepComplete = (stepIndex: number) => {\n    setCompletedSteps(prev => new Set(prev).add(stepIndex));\n  };\n\n  const handleNext = () => {\n    // Mark current step as completed when moving to next\n    markStepComplete(activeStep);\n    \n    if (activeStep < steps.length - 1) {\n      handleStepChange(activeStep + 1);\n    } else {\n      onComplete?.();\n    }\n  };\n\n\n\n  const handlePrevious = () => {\n    if (activeStep > 0) {\n      handleStepChange(activeStep - 1);\n    }\n  };\n\n  const handleSkip = () => {\n    if (allowSkip && steps[activeStep]?.optional) {\n      handleNext();\n    }\n  };\n\n  const canGoToStep = (stepIndex: number) => {\n    // Can go to current step, previous steps, or next step if current is completed\n    return stepIndex <= activeStep || completedSteps.has(stepIndex - 1);\n  };\n\n  const isStepCompleted = (stepIndex: number) => {\n    return completedSteps.has(stepIndex);\n  };\n\n  const isStepActive = (stepIndex: number) => {\n    return stepIndex === activeStep;\n  };\n\n  return (\n    <div className={cn(\"space-y-6\", className)}>\n      {children}\n      \n      {/* Step indicator */}\n      <div className=\"flex items-center justify-between\">\n        {steps.map((step, index) => (\n          <React.Fragment key={step.id}>\n            <div className=\"flex flex-col items-center\">\n              <button\n                type=\"button\"\n                onClick={() => canGoToStep(index) && handleStepChange(index)}\n                disabled={!canGoToStep(index)}\n                aria-label={`Go to step ${index + 1}: ${step.title}`}\n                aria-current={isStepActive(index) ? 'step' : undefined}\n                tabIndex={canGoToStep(index) ? 0 : -1}\n                className={cn(\n                  \"w-10 h-10 rounded-full border-2 flex items-center justify-center text-sm font-medium transition-colors\",\n                  isStepActive(index) && \"border-primary bg-primary text-primary-foreground\",\n                  isStepCompleted(index) && !isStepActive(index) && \"border-primary bg-primary text-primary-foreground\",\n                  !isStepActive(index) && !isStepCompleted(index) && \"border-muted-foreground text-muted-foreground\",\n                  canGoToStep(index) && \"cursor-pointer hover:border-primary\",\n                  !canGoToStep(index) && \"cursor-not-allowed opacity-50\"\n                )}\n              >\n                {isStepCompleted(index) ? (\n                  \"✓\"\n                ) : showStepNumbers ? (\n                  index + 1\n                ) : (\n                  \"○\"\n                )}\n              </button>\n              \n              <div className=\"mt-2 text-center\">\n                <div className={cn(\n                  \"text-sm font-medium\",\n                  isStepActive(index) && \"text-primary\",\n                  !isStepActive(index) && \"text-muted-foreground\"\n                )}>\n                  {step.title}\n                  {step.optional && (\n                    <span className=\"text-xs text-muted-foreground ml-1\">(optional)</span>\n                  )}\n                </div>\n                {step.description && (\n                  <div className=\"text-xs text-muted-foreground mt-1\">\n                    {step.description}\n                  </div>\n                )}\n              </div>\n            </div>\n            \n            {/* Connector line */}\n            {index < steps.length - 1 && (\n              <div className={cn(\n                \"flex-1 h-0.5 mx-4\",\n                isStepCompleted(index) ? \"bg-primary\" : \"bg-muted\"\n              )} />\n            )}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {/* Step content */}\n      <div className=\"min-h-[200px]\">\n        {steps[activeStep]?.content}\n      </div>\n\n      {/* Navigation buttons */}\n      <div className=\"flex justify-between\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={handlePrevious}\n          disabled={activeStep === 0}\n        >\n          Previous\n        </Button>\n\n        <div className=\"flex gap-2\">\n          {allowSkip && steps[activeStep]?.optional && (\n            <Button\n              type=\"button\"\n              variant=\"ghost\"\n              onClick={handleSkip}\n            >\n              Skip\n            </Button>\n          )}\n          \n          <Button\n            type=\"button\"\n            onClick={handleNext}\n          >\n            {activeStep === steps.length - 1 ? 'Complete' : 'Next'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/layout/form-grid.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormGridProps } from \"@/lib/formedible/types\";\n\nexport const FormGrid: React.FC<FormGridProps> = ({\n  children,\n  columns = 2,\n  gap = \"4\",\n  responsive = true,\n  className,\n}) => {\n  // Filter out null, undefined, and false children to prevent empty grid cells\n  const validChildren = React.Children.toArray(children).filter(\n    // @ts-expect-error raf de ta mr2\n    (child) => child !== null && child !== undefined && child !== false\n  );\n  // If no valid children, render nothing\n  if (validChildren.length === 0) {\n    return null;\n  }\n\n  // Determine the actual columns to use based on available children\n  const actualColumns = Math.min(columns, validChildren.length, 12);\n  const gapClasses = {\n    \"0\": \"gap-0\",\n    \"1\": \"gap-1\",\n    \"2\": \"gap-2\",\n    \"3\": \"gap-3\",\n    \"4\": \"gap-4\",\n    \"5\": \"gap-5\",\n    \"6\": \"gap-6\",\n    \"7\": \"gap-7\",\n    \"8\": \"gap-8\",\n    \"9\": \"gap-9\",\n    \"10\": \"gap-10\",\n    \"11\": \"gap-11\",\n    \"12\": \"gap-12\",\n  };\n\n  const gridColsClasses = {\n    1: \"grid-cols-1\",\n    2: \"grid-cols-2\",\n    3: \"grid-cols-3\",\n    4: \"grid-cols-4\",\n    5: \"grid-cols-5\",\n    6: \"grid-cols-6\",\n    7: \"grid-cols-7\",\n    8: \"grid-cols-8\",\n    9: \"grid-cols-9\",\n    10: \"grid-cols-10\",\n    11: \"grid-cols-11\",\n    12: \"grid-cols-12\",\n  };\n\n  const gridClasses = cn(\n    \"grid\",\n    gapClasses[gap as keyof typeof gapClasses],\n    responsive\n      ? {\n          \"grid-cols-1\": true,\n          \"md:grid-cols-2\": actualColumns >= 2,\n          \"lg:grid-cols-3\": actualColumns >= 3,\n          \"xl:grid-cols-4\": actualColumns >= 4 && columns >= 4,\n        }\n      : gridColsClasses[actualColumns as keyof typeof gridColsClasses],\n    className\n  );\n\n  return <div className={gridClasses}>{validChildren}</div>;\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/formedible/layout/form-accordion.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from \"@/components/ui/accordion\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormAccordionProps } from \"@/lib/formedible/types\";\n\n\nexport const FormAccordion: React.FC<FormAccordionProps> = ({\n  children,\n  sections,\n  type = 'single',\n  className,\n}) => {\n  return (\n    <div className={cn(\"space-y-4\", className)}>\n      {children}\n      \n      {type === 'single' ? (\n        <Accordion \n          type=\"single\" \n          defaultValue={sections.find(s => s.defaultOpen)?.id}\n          collapsible\n        >\n          {sections.map((section) => (\n            <AccordionItem key={section.id} value={section.id}>\n              <AccordionTrigger>{section.title}</AccordionTrigger>\n              <AccordionContent>\n                <div className=\"space-y-4\">\n                  {section.content}\n                </div>\n              </AccordionContent>\n            </AccordionItem>\n          ))}\n        </Accordion>\n      ) : (\n        <Accordion \n          type=\"multiple\" \n          defaultValue={sections.filter(s => s.defaultOpen).map(s => s.id)}\n        >\n          {sections.map((section) => (\n            <AccordionItem key={section.id} value={section.id}>\n              <AccordionTrigger>{section.title}</AccordionTrigger>\n              <AccordionContent>\n                <div className=\"space-y-4\">\n                  {section.content}\n                </div>\n              </AccordionContent>\n            </AccordionItem>\n          ))}\n        </Accordion>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component"
    }
  ]
}