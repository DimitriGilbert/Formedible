{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "formedible-parser",
  "type": "registry:block",
  "title": "Formedible Parser",
  "description": "Safe parser for Formedible form definitions - handles JSON, JavaScript object literals, and Zod schema expressions",
  "dependencies": [
    "react",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "textarea",
    "label",
    "card"
  ],
  "files": [
    {
      "path": "src/lib/formedible/formedible-parser.ts",
      "content": "\"use client\";\n\nimport { z } from 'zod';\nimport type {\n  UseFormedibleOptions,\n  FieldConfig,\n  ParserOptions,\n  ObjectConfig,\n  ParserError,\n  PageConfig,\n  EnhancedParserOptions,\n  EnhancedParserError,\n  SchemaInferenceOptions,\n  SchemaInferenceResult,\n  ValidationWithSuggestionsResult,\n} from \"./parser-types\";\n\n/**\n * FormedibleParser - A safe parser for Formedible form definitions\n *\n * This parser can handle:\n * - Pure JSON format\n * - JavaScript object literals (unquoted keys)\n * - Zod schema expressions (z.string(), z.number(), etc.)\n * - Nested and chained Zod validations (z.string().min(1).max(50))\n *\n * Features:\n * - Sanitizes dangerous code patterns\n * - Validates field types and structure\n * - Removes unknown/dangerous keys\n * - Handles balanced parentheses in Zod expressions\n * - Supports all 24 field types\n * - 100% backward compatibility with existing parser\n *\n * Usage:\n *   const parsed = FormedibleParser.parse(codeString);\n *\n * @version 2.0.0\n * @standalone-ready This class is designed as a standalone package\n */\nexport class FormedibleParser {\n  // All 24 supported field types in formedible\n  private static readonly ALLOWED_FIELD_TYPES = [\n    \"text\",\n    \"email\",\n    \"password\",\n    \"url\",\n    \"tel\",\n    \"textarea\",\n    \"select\",\n    \"checkbox\",\n    \"switch\",\n    \"number\",\n    \"date\",\n    \"slider\",\n    \"file\",\n    \"rating\",\n    \"phone\",\n    \"colorPicker\",\n    \"location\",\n    \"duration\",\n    \"multiSelect\",\n    \"autocomplete\",\n    \"masked\",\n    \"object\",\n    \"array\",\n    \"radio\",\n  ] as const;\n\n  // Allowed top-level keys in form definitions - configuration only, NO functions\n  private static readonly ALLOWED_KEYS = [\n    \"fields\",\n    \"schema\",\n    \"title\",\n    \"description\",\n    \"submitLabel\",\n    \"nextLabel\",\n    \"previousLabel\",\n    \"collapseLabel\",\n    \"expandLabel\",\n    \"formClassName\",\n    \"fieldClassName\",\n    \"labelClassName\",\n    \"buttonClassName\", \n    \"submitButtonClassName\",\n    \"autoScroll\",\n    \"pages\",\n    \"progress\",\n    \"tabs\",\n    \"autoSubmitOnChange\",\n    \"autoSubmitDebounceMs\",\n    \"disabled\",\n    \"loading\",\n    \"resetOnSubmitSuccess\",\n    \"showSubmitButton\",\n    \"crossFieldValidation\",\n    \"asyncValidation\",\n    \"analytics\",\n    \"layout\",\n    \"conditionalSections\",\n    \"persistence\",\n    \"formOptions\",\n  ] as const;\n\n  // Configuration for parser behavior\n  private static CONFIG = {\n    ZOD_PLACEHOLDER: \"__ZOD_SCHEMA__\",\n    MAX_RECURSION_DEPTH: 10,\n    ENABLE_STRICT_VALIDATION: true,\n    MAX_CODE_LENGTH: 1000000, // 1MB limit\n    MAX_NESTING_DEPTH: 50,\n  };\n\n  /**\n   * Main parser method - parses formedible form definition code\n   * @param code - The form definition code (JSON or JS object literal)\n   * @param options - Optional parsing configuration\n   * @returns Parsed and validated form definition\n   * @throws {ParserError} When parsing fails with detailed error information\n   */\n  static parse(\n    code: string,\n    options?: ParserOptions | EnhancedParserOptions\n  ): UseFormedibleOptions<Record<string, unknown>> {\n    if (!code || typeof code !== \"string\") {\n      throw this.createParserError(\n        \"Input code must be a non-empty string\",\n        \"INVALID_INPUT\"\n      );\n    }\n\n    if (code.length > this.CONFIG.MAX_CODE_LENGTH) {\n      throw this.createParserError(\n        `Code length exceeds maximum allowed size of ${this.CONFIG.MAX_CODE_LENGTH} characters`,\n        \"CODE_TOO_LARGE\"\n      );\n    }\n\n    try {\n      // Apply configuration overrides\n      if (options?.strictValidation !== undefined) {\n        this.CONFIG.ENABLE_STRICT_VALIDATION = options.strictValidation;\n      }\n\n      // Remove any potential function calls or dangerous patterns\n      const sanitizedCode = this.sanitizeCode(code);\n\n      // Parse the JSON-like structure\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n\n      // Validate and sanitize the parsed object\n      return this.validateAndSanitize(parsed);\n    } catch (error) {\n      if (error instanceof Error && error.name === \"ParserError\") {\n        throw error;\n      }\n\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      throw this.createParserError(\n        `Failed to parse form definition. ${errorMessage}`,\n        \"PARSE_ERROR\",\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Validates if a field type is supported\n   * @param type - The field type to validate\n   * @returns True if the field type is valid\n   */\n  static isValidFieldType(type: string): boolean {\n    return this.ALLOWED_FIELD_TYPES.includes(type as any);\n  }\n\n  /**\n   * Gets all supported field types\n   * @returns Array of supported field types\n   */\n  static getSupportedFieldTypes(): readonly string[] {\n    return [...this.ALLOWED_FIELD_TYPES];\n  }\n\n  /**\n   * Validates a form configuration without parsing code\n   * @param config - The form configuration to validate\n   * @returns Validation result with errors if any\n   */\n  static validateConfig(config: unknown): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    try {\n      this.validateAndSanitize(config as Record<string, unknown>);\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  }\n\n  /**\n   * Creates a standardized parser error with additional metadata and AI-friendly suggestions\n   * @private\n   */\n  private static createParserError(\n    message: string,\n    code: string,\n    metadata?: Record<string, unknown>\n  ): ParserError {\n    // Enhance error message with helpful context and suggestions\n    let enhancedMessage = message;\n    \n    switch (code) {\n      case \"INVALID_INPUT\":\n        enhancedMessage = `‚ùå Invalid Input: ${message}\n\nüîß How to fix:\n‚Ä¢ Provide a non-empty string containing your form definition\n‚Ä¢ Make sure you're passing the form code as a string, not an object\n\nüìù Example:\nconst formCode = \\`{\n  fields: [\n    { name: \"email\", type: \"email\", label: \"Email Address\" }\n  ]\n}\\`;\nconst parsed = FormedibleParser.parse(formCode);`;\n        break;\n        \n      case \"CODE_TOO_LARGE\":\n        enhancedMessage = `‚ùå Code Too Large: ${message}\n\nüîß How to fix:\n‚Ä¢ Reduce the size of your form definition\n‚Ä¢ Split large forms into multiple smaller forms\n‚Ä¢ Remove unnecessary comments or whitespace\n\nüí° Tips:\n‚Ä¢ Consider using arrays for repetitive field configurations\n‚Ä¢ Use object field types to group related fields`;\n        break;\n        \n      case \"SYNTAX_ERROR\":\n        enhancedMessage = `‚ùå Syntax Error: ${message}\n\nüîß Common fixes:\n‚Ä¢ Use double quotes around object keys: { \"name\": \"value\" }\n‚Ä¢ Remove trailing commas: [item1, item2] not [item1, item2,]\n‚Ä¢ Check for balanced brackets and parentheses\n‚Ä¢ Escape quotes in strings: \"It's working\" ‚Üí \"It\\\\'s working\"\n\nüìù Valid formats:\nJSON: { \"fields\": [{ \"name\": \"email\", \"type\": \"email\" }] }\nJS Object: { fields: [{ name: \"email\", type: \"email\" }] }`;\n        break;\n        \n      case \"INVALID_DEFINITION\":\n        enhancedMessage = `‚ùå Invalid Definition: ${message}\n\nüîß How to fix:\n‚Ä¢ Ensure your form definition is a JavaScript object or valid JSON\n‚Ä¢ Must contain at least a 'fields' array\n\nüìù Minimum required structure:\n{\n  fields: [\n    { name: \"fieldName\", type: \"text\" }\n  ]\n}`;\n        break;\n        \n      case \"INVALID_FIELDS\":\n        enhancedMessage = `‚ùå Invalid Fields: ${message}\n\nüîß How to fix:\n‚Ä¢ The 'fields' property must be an array\n‚Ä¢ Each field must be an object with 'name' and 'type' properties\n\nüìù Example:\n{\n  fields: [\n    { name: \"firstName\", type: \"text\", label: \"First Name\" },\n    { name: \"email\", type: \"email\", label: \"Email Address\" }\n  ]\n}`;\n        break;\n        \n      case \"INVALID_FIELD\":\n        const fieldIndex = metadata?.fieldIndex;\n        enhancedMessage = `‚ùå Invalid Field${fieldIndex !== undefined ? ` at position ${fieldIndex}` : ''}: ${message}\n\nüîß How to fix:\n‚Ä¢ Each field must be an object, not a string or number\n‚Ä¢ Check that field #${fieldIndex || 0} is properly formatted\n\nüìù Field structure:\n{\n  name: \"fieldName\",     // Required: unique field identifier\n  type: \"text\",          // Required: field type\n  label: \"Display Name\", // Optional: user-friendly label\n  required: true         // Optional: validation\n}`;\n        break;\n        \n      case \"MISSING_REQUIRED_FIELD\":\n        const missingFieldIndex = metadata?.fieldIndex;\n        enhancedMessage = `‚ùå Missing Required Properties${missingFieldIndex !== undefined ? ` in field #${missingFieldIndex}` : ''}: ${message}\n\nüîß How to fix:\n‚Ä¢ Every field MUST have both 'name' and 'type' properties\n‚Ä¢ The 'name' should be a unique identifier for the field\n‚Ä¢ The 'type' should be one of the supported field types\n\nüìù Fix field #${missingFieldIndex || 0}:\n{\n  name: \"uniqueFieldName\",  // ‚úÖ Required\n  type: \"text\",             // ‚úÖ Required  \n  label: \"Display Label\"    // ‚úÖ Recommended\n}`;\n        break;\n        \n      case \"UNSUPPORTED_FIELD_TYPE\":\n        const fieldType = metadata?.fieldType;\n        const supportedTypes = this.ALLOWED_FIELD_TYPES.join(', ');\n        enhancedMessage = `‚ùå Unsupported Field Type: ${message}\n\nüîß How to fix:\n‚Ä¢ Change field type from \"${fieldType}\" to one of the supported types\n‚Ä¢ Check for typos in the field type name\n\n‚úÖ Supported field types:\n${supportedTypes}\n\nüìù Common field types:\n‚Ä¢ \"text\" - Single line text input\n‚Ä¢ \"email\" - Email address with validation  \n‚Ä¢ \"number\" - Numeric input with validation\n‚Ä¢ \"select\" - Dropdown selection\n‚Ä¢ \"checkbox\" - Boolean checkbox\n‚Ä¢ \"date\" - Date picker\n‚Ä¢ \"textarea\" - Multi-line text area`;\n        break;\n        \n      case \"INVALID_ARRAY_CONFIG\":\n        enhancedMessage = `‚ùå Invalid Array Configuration: ${message}\n\nüîß How to fix:\n‚Ä¢ Array field configuration must be an object\n‚Ä¢ Provide arrayConfig with proper structure\n\nüìù Example array field:\n{\n  name: \"items\",\n  type: \"array\",\n  arrayConfig: {\n    itemType: \"text\",           // Type of each array item\n    itemLabel: \"Item\",          // Label for each item\n    minItems: 1,               // Minimum number of items\n    maxItems: 10,              // Maximum number of items\n    addButtonLabel: \"Add Item\" // Custom add button text\n  }\n}`;\n        break;\n        \n      case \"INVALID_OBJECT_CONFIG\":\n        enhancedMessage = `‚ùå Invalid Object Configuration: ${message}\n\nüîß How to fix:\n‚Ä¢ Object field configuration must be an object\n‚Ä¢ Provide objectConfig with fields array\n\nüìù Example object field:\n{\n  name: \"address\",\n  type: \"object\",\n  objectConfig: {\n    title: \"Address Information\",\n    fields: [\n      { name: \"street\", type: \"text\", label: \"Street\" },\n      { name: \"city\", type: \"text\", label: \"City\" }\n    ]\n  }\n}`;\n        break;\n        \n      case \"PARSE_ERROR\":\n        enhancedMessage = `‚ùå Parsing Failed: ${message}\n\nüîß Common causes and fixes:\n‚Ä¢ **Syntax Issues**: Check for missing quotes, brackets, or commas\n‚Ä¢ **Invalid JavaScript**: Ensure object literal syntax is correct\n‚Ä¢ **Zod Expressions**: Make sure Zod schemas are properly formatted\n\nüìù Debugging steps:\n1. Validate your JSON syntax using an online JSON validator\n2. Check that all object keys are quoted: { \"name\": \"value\" }\n3. Remove trailing commas: [item1, item2] not [item1, item2,]\n4. Verify Zod expressions: z.string().min(1) not z.string.min(1)\n\nüí° Example working format:\n{\n  fields: [\n    {\n      name: \"email\",\n      type: \"email\", \n      label: \"Email Address\",\n      validation: \"z.string().email()\"\n    }\n  ],\n  schema: \"z.object({ email: z.string().email() })\"\n}`;\n        break;\n        \n      default:\n        enhancedMessage = `‚ùå Parser Error: ${message}\n\nüîß General troubleshooting:\n‚Ä¢ Check JSON/JavaScript syntax\n‚Ä¢ Verify all required properties are present\n‚Ä¢ Ensure field types are supported\n‚Ä¢ Check for typos in property names\n\nüí° Need help? Provide the exact form code that's causing issues for specific assistance.`;\n    }\n    \n    const error = new Error(enhancedMessage) as ParserError;\n    error.name = \"ParserError\";\n    error.code = code;\n\n    if (metadata) {\n      Object.assign(error, metadata);\n    }\n\n    return error;\n  }\n\n  /**\n   * Enhanced code sanitization with better security measures\n   * @private\n   */\n  private static sanitizeCode(code: string): string {\n    // Remove comments first\n    let sanitized = code\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Block comments\n      .replace(/\\/\\/.*$/gm, \"\"); // Line comments\n\n    // Remove dangerous patterns more aggressively\n    const dangerousPatterns = [\n      /\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g,\n      /\\b(document|window|global|process)\\b/g,\n      /\\b__proto__\\b/g,\n      /\\bconstructor\\b/g,\n      /\\bprototype\\b/g,\n    ];\n\n    dangerousPatterns.forEach((pattern) => {\n      sanitized = sanitized.replace(pattern, '\"\"');\n    });\n\n    // Remove any arrow functions or function expressions more thoroughly\n    sanitized = sanitized.replace(/=>\\s*[\\{]?[^}]*[\\}]?/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n\n    // Handle Date objects more safely\n    sanitized = sanitized.replace(\n      /new\\s+Date\\(\\)\\.toISOString\\(\\)\\.split\\('[^']*'\\)\\[0\\]/g,\n      '\"2024-01-01\"'\n    );\n    sanitized = sanitized.replace(/new\\s+Date\\(\\)/g, '\"2024-01-01T00:00:00Z\"');\n\n    // Remove any remaining 'new' keyword usage\n    sanitized = sanitized.replace(/\\bnew\\s+\\w+\\(/g, '\"\"');\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced object literal parsing with better error handling\n   * @private\n   */\n  private static parseObjectLiteral(code: string): Record<string, unknown> {\n    try {\n      // First try direct JSON parsing\n      return JSON.parse(code);\n    } catch (jsonError) {\n      // If that fails, try to convert JS object literal to JSON\n      let processedCode = code.trim();\n\n      try {\n        // Replace Zod expressions with placeholder strings - handle nested structures\n        processedCode = this.replaceZodExpressions(processedCode);\n\n        // Convert unquoted keys to quoted keys with better regex\n        processedCode = processedCode.replace(\n          /([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g,\n          '$1\"$2\":'\n        );\n\n        // Remove trailing commas more thoroughly\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n        // Convert single quotes to double quotes (but preserve escaped quotes)\n        processedCode = processedCode.replace(/(?<!\\\\)'/g, '\"');\n\n        // Handle undefined values\n        processedCode = processedCode.replace(/:\\s*undefined/g, \": null\");\n\n        const result = JSON.parse(processedCode);\n        return result;\n      } catch (conversionError) {\n        // Enhanced error reporting\n        const originalPreview =\n          code.substring(0, 200) + (code.length > 200 ? \"...\" : \"\");\n        const processedPreview =\n          processedCode.substring(0, 200) +\n          (processedCode.length > 200 ? \"...\" : \"\");\n\n        throw this.createParserError(\n          `Invalid syntax. Please use valid JSON format or JavaScript object literal syntax.`,\n          \"SYNTAX_ERROR\",\n          {\n            originalCode: originalPreview,\n            processedCode: processedPreview,\n            jsonError:\n              jsonError instanceof Error\n                ? jsonError.message\n                : String(jsonError),\n            conversionError:\n              conversionError instanceof Error\n                ? conversionError.message\n                : String(conversionError),\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Enhanced Zod expression replacement with better handling of complex expressions\n   * @private\n   */\n  private static replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 100; // Prevent infinite loops\n\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      // Match z.method( and find the matching closing parenthesis\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        // Find the matching closing parenthesis with better depth tracking\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n        let stringChar: string | null = null;\n        let escaped = false;\n\n        while (endIndex < result.length && depth > 0) {\n          const char = result[endIndex];\n\n          // Handle string literals to avoid counting parentheses inside strings\n          if (!escaped && (char === '\"' || char === \"'\")) {\n            if (!stringChar) {\n              stringChar = char;\n            } else if (stringChar === char) {\n              stringChar = null;\n            }\n          } else if (!stringChar) {\n            if (char === \"(\") {\n              depth++;\n            } else if (char === \")\") {\n              depth--;\n            }\n          }\n\n          escaped = char === \"\\\\\" && !escaped;\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          // Check for chained methods like .min().max()\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              // Find the closing parenthesis for this chained method\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n              let chainStringChar: string | null = null;\n              let chainEscaped = false;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                const char = result[chainEndIndex];\n\n                if (!chainEscaped && (char === '\"' || char === \"'\")) {\n                  if (!chainStringChar) {\n                    chainStringChar = char;\n                  } else if (chainStringChar === char) {\n                    chainStringChar = null;\n                  }\n                } else if (!chainStringChar) {\n                  if (char === \"(\") {\n                    chainDepth++;\n                  } else if (char === \")\") {\n                    chainDepth--;\n                  }\n                }\n\n                chainEscaped = char === \"\\\\\" && !chainEscaped;\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          // Replace the entire Zod expression with a placeholder\n          result =\n            result.slice(0, startIndex) +\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"` +\n            result.slice(chainEnd);\n          changed = true;\n        } else {\n          // If we can't find matching parentheses, just replace the method name\n          result = result.replace(\n            /z\\.[a-zA-Z]+/,\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n          );\n          changed = true;\n        }\n      }\n    }\n\n    // Handle standalone z.enum() calls and other complex patterns\n    result = result.replace(\n      /z\\.enum\\(\\[[^\\]]*\\]\\)/g,\n      `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n    );\n    result = result.replace(/z\\.\\w+/g, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n\n    return result;\n  }\n\n  /**\n   * Enhanced validation and sanitization with comprehensive field type support\n   * @private\n   */\n  private static validateAndSanitize(\n    obj: Record<string, unknown>\n  ): UseFormedibleOptions<Record<string, unknown>> {\n    if (typeof obj !== \"object\" || obj === null) {\n      throw this.createParserError(\n        \"Definition must be an object\",\n        \"INVALID_DEFINITION\"\n      );\n    }\n\n    const sanitized: UseFormedibleOptions<Record<string, unknown>> = {\n      fields: [],\n    };\n\n    // Validate top-level keys\n    for (const [key, value] of Object.entries(obj)) {\n      if (!this.ALLOWED_KEYS.includes(key as any)) {\n        if (this.CONFIG.ENABLE_STRICT_VALIDATION) {\n          console.warn(\n            `Unknown key '${key}' found in form definition, skipping`\n          );\n        }\n        continue; // Skip unknown keys\n      }\n\n      switch (key) {\n        case \"schema\":\n          // Pass through the schema - it's needed for validation\n          if (value && typeof value === 'object') {\n            sanitized.schema = value as any;\n          }\n          break;\n\n        case \"fields\":\n          if (!Array.isArray(value)) {\n            throw this.createParserError(\n              \"Fields must be an array\",\n              \"INVALID_FIELDS\"\n            );\n          }\n          sanitized.fields = this.validateFields(value);\n          break;\n\n        case \"pages\":\n          if (Array.isArray(value)) {\n            sanitized.pages = value.map((page, index) =>\n              this.validatePage(page, index)\n            );\n          }\n          break;\n\n        case \"title\":\n        case \"description\":\n          // These aren't in UseFormedibleOptions but might be used by consuming apps\n          // Store them as additional properties\n          (sanitized as any)[key] = typeof value === \"string\" ? value : undefined;\n          break;\n\n        case \"submitLabel\":\n          if (typeof value === \"string\") {\n            sanitized.submitLabel = value;\n          }\n          break;\n\n        case \"nextLabel\":\n          if (typeof value === \"string\") {\n            sanitized.nextLabel = value;\n          }\n          break;\n\n        case \"previousLabel\":\n          if (typeof value === \"string\") {\n            sanitized.previousLabel = value;\n          }\n          break;\n\n        case \"formClassName\":\n          if (typeof value === \"string\") {\n            sanitized.formClassName = value;\n          }\n          break;\n\n        case \"fieldClassName\":\n          if (typeof value === \"string\") {\n            sanitized.fieldClassName = value;\n          }\n          break;\n\n        case \"progress\":\n          if (value && typeof value === \"object\") {\n            sanitized.progress = value as UseFormedibleOptions<Record<string, unknown>>[\"progress\"];\n          }\n          break;\n\n        case \"formOptions\":\n          if (value && typeof value === \"object\") {\n            sanitized.formOptions = value as UseFormedibleOptions<Record<string, unknown>>[\"formOptions\"];\n          }\n          break;\n\n        case \"layout\":\n          if (value && typeof value === \"object\") {\n            sanitized.layout = value as UseFormedibleOptions<Record<string, unknown>>[\"layout\"];\n          }\n          break;\n\n        case \"tabs\":\n          if (Array.isArray(value)) {\n            sanitized.tabs = value as UseFormedibleOptions<Record<string, unknown>>[\"tabs\"];\n          }\n          break;\n\n        case \"collapseLabel\":\n          if (typeof value === \"string\") {\n            sanitized.collapseLabel = value;\n          }\n          break;\n\n        case \"expandLabel\":\n          if (typeof value === \"string\") {\n            sanitized.expandLabel = value;\n          }\n          break;\n\n        case \"labelClassName\":\n          if (typeof value === \"string\") {\n            sanitized.labelClassName = value;\n          }\n          break;\n\n        case \"buttonClassName\":\n          if (typeof value === \"string\") {\n            sanitized.buttonClassName = value;\n          }\n          break;\n\n        case \"submitButtonClassName\":\n          if (typeof value === \"string\") {\n            sanitized.submitButtonClassName = value;\n          }\n          break;\n\n        // Components and functions are not supported by parser - skipped\n\n        case \"autoScroll\":\n          if (typeof value === \"boolean\") {\n            sanitized.autoScroll = value;\n          }\n          break;\n\n        case \"autoSubmitOnChange\":\n          if (typeof value === \"boolean\") {\n            sanitized.autoSubmitOnChange = value;\n          }\n          break;\n\n        case \"autoSubmitDebounceMs\":\n          if (typeof value === \"number\") {\n            sanitized.autoSubmitDebounceMs = value;\n          }\n          break;\n\n        case \"disabled\":\n          if (typeof value === \"boolean\") {\n            sanitized.disabled = value;\n          }\n          break;\n\n        case \"loading\":\n          if (typeof value === \"boolean\") {\n            sanitized.loading = value;\n          }\n          break;\n\n        case \"resetOnSubmitSuccess\":\n          if (typeof value === \"boolean\") {\n            sanitized.resetOnSubmitSuccess = value;\n          }\n          break;\n\n        case \"showSubmitButton\":\n          if (typeof value === \"boolean\") {\n            sanitized.showSubmitButton = value;\n          }\n          break;\n\n        case \"crossFieldValidation\":\n          if (Array.isArray(value)) {\n            sanitized.crossFieldValidation = value;\n          }\n          break;\n\n        case \"asyncValidation\":\n          if (value && typeof value === \"object\") {\n            sanitized.asyncValidation = value as any;\n          }\n          break;\n\n        case \"analytics\":\n          if (value && typeof value === \"object\") {\n            sanitized.analytics = value as Record<string, unknown>;\n          }\n          break;\n\n        case \"persistence\":\n          if (value && typeof value === \"object\") {\n            sanitized.persistence = value as any;\n          }\n          break;\n\n        case \"conditionalSections\":\n          if (Array.isArray(value)) {\n            sanitized.conditionalSections = value;\n          }\n          break;\n\n        case \"defaultComponents\":\n          // Skip - components can't be parsed from text\n          break;\n\n        // Components and functions are not supported by parser - skipped\n\n        // All function handlers are not supported by parser - skipped\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced field validation with support for all 24 field types\n   * @private\n   */\n  private static validateFields(fields: unknown[]): FieldConfig[] {\n    return fields.map((field, index): FieldConfig => {\n      if (typeof field !== \"object\" || field === null) {\n        throw this.createParserError(\n          `Field at index ${index} must be an object`,\n          \"INVALID_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      const fieldObj = field as Record<string, unknown>;\n\n      // Ensure required fields\n      if (!fieldObj.name || !fieldObj.type) {\n        throw this.createParserError(\n          `Field at index ${index} must have 'name' and 'type' properties`,\n          \"MISSING_REQUIRED_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (\n        typeof fieldObj.name !== \"string\" ||\n        typeof fieldObj.type !== \"string\"\n      ) {\n        throw this.createParserError(\n          `Field at index ${index} must have string 'name' and 'type' properties`,\n          \"INVALID_FIELD_TYPE\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (!this.ALLOWED_FIELD_TYPES.includes(fieldObj.type as any)) {\n        throw this.createParserError(\n          `Field at index ${index} has invalid type '${\n            fieldObj.type\n          }'. Supported types: ${this.ALLOWED_FIELD_TYPES.join(\", \")}`,\n          \"UNSUPPORTED_FIELD_TYPE\",\n          { fieldIndex: index, fieldType: fieldObj.type }\n        );\n      }\n\n      // Build properly typed field config\n      const validatedField: FieldConfig = {\n        name: fieldObj.name,\n        type: fieldObj.type,\n      };\n\n      // Add optional properties with proper type checks\n      this.addOptionalStringProperty(validatedField, fieldObj, \"label\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"placeholder\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"description\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"tab\");\n\n      if (typeof fieldObj.required === \"boolean\") {\n        validatedField.required = fieldObj.required;\n      }\n\n      if (typeof fieldObj.page === \"number\") {\n        validatedField.page = fieldObj.page;\n      }\n\n      if (fieldObj.defaultValue !== undefined) {\n        validatedField.defaultValue = fieldObj.defaultValue;\n      }\n\n      // Numeric properties\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"min\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"max\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"step\");\n\n      // Handle complex configurations for different field types\n      this.addFieldSpecificConfigurations(validatedField, fieldObj, index);\n\n      // Handle options array\n      if (fieldObj.options && Array.isArray(fieldObj.options)) {\n        validatedField.options = this.validateOptions(fieldObj.options);\n      }\n\n      // Skip validation assignment - let it remain undefined to avoid type conflicts\n\n      return validatedField;\n    });\n  }\n\n  /**\n   * Adds field-specific configurations based on field type\n   * @private\n   */\n  private static addFieldSpecificConfigurations(\n    validatedField: FieldConfig,\n    fieldObj: Record<string, unknown>,\n    index: number\n  ): void {\n    const fieldType = validatedField.type;\n\n    // Array field configuration\n    if (fieldType === \"array\" && fieldObj.arrayConfig) {\n      validatedField.arrayConfig = this.validateArrayConfig(\n        fieldObj.arrayConfig,\n        index\n      );\n    }\n\n    // Object field configuration\n    if (fieldType === \"object\" && fieldObj.objectConfig) {\n      validatedField.objectConfig = this.validateObjectConfig(\n        fieldObj.objectConfig,\n        index\n      );\n    }\n\n    // Multi-select configuration\n    if (fieldType === \"multiSelect\" && fieldObj.multiSelectConfig) {\n      validatedField.multiSelectConfig = this.validateMultiSelectConfig(\n        fieldObj.multiSelectConfig\n      );\n    }\n\n    // Color picker configuration\n    if (fieldType === \"colorPicker\" && fieldObj.colorConfig) {\n      validatedField.colorConfig = this.validateColorConfig(\n        fieldObj.colorConfig\n      );\n    }\n\n    // Rating configuration\n    if (fieldType === \"rating\" && fieldObj.ratingConfig) {\n      validatedField.ratingConfig = this.validateRatingConfig(\n        fieldObj.ratingConfig\n      );\n    }\n\n    // Phone configuration\n    if (fieldType === \"phone\" && fieldObj.phoneConfig) {\n      validatedField.phoneConfig = this.validatePhoneConfig(\n        fieldObj.phoneConfig\n      );\n    }\n\n    // Datalist configuration\n    if (fieldObj.datalist) {\n      validatedField.datalist = this.validateDatalistConfig(fieldObj.datalist);\n    }\n\n    // Pass through other configurations with validation\n    const configKeys = [\n      \"sliderConfig\",\n      \"fileConfig\",\n      \"locationConfig\",\n      \"durationConfig\",\n      \"autocompleteConfig\",\n      \"maskedConfig\",\n      \"dateConfig\",\n      \"textareaConfig\",\n      \"passwordConfig\",\n      \"emailConfig\",\n      \"numberConfig\",\n    ];\n\n    configKeys.forEach((configKey) => {\n      if (fieldObj[configKey] && typeof fieldObj[configKey] === \"object\") {\n        (validatedField as any)[configKey] = fieldObj[configKey];\n      }\n    });\n  }\n\n  /**\n   * Helper methods for adding optional properties\n   * @private\n   */\n  private static addOptionalStringProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (source[key] && typeof source[key] === \"string\") {\n      target[key] = source[key];\n    }\n  }\n\n  private static addOptionalNumberProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (typeof source[key] === \"number\") {\n      target[key] = source[key];\n    }\n  }\n\n  /**\n   * Configuration validators\n   * @private\n   */\n  private static validateArrayConfig(\n    config: unknown,\n    fieldIndex: number\n  ): FieldConfig[\"arrayConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Array config at field index ${fieldIndex} must be an object`,\n        \"INVALID_ARRAY_CONFIG\"\n      );\n    }\n\n    const arrayConfig = config as Record<string, unknown>;\n    const validated: FieldConfig[\"arrayConfig\"] = {\n      itemType: \"text\",\n    };\n\n    if (arrayConfig.itemType && typeof arrayConfig.itemType === \"string\") {\n      validated.itemType = arrayConfig.itemType;\n    }\n\n    // Add other array config properties\n    [\n      \"itemLabel\",\n      \"itemPlaceholder\",\n      \"addButtonLabel\",\n      \"removeButtonLabel\",\n    ].forEach((key) => {\n      if (arrayConfig[key] && typeof arrayConfig[key] === \"string\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    [\"minItems\", \"maxItems\"].forEach((key) => {\n      if (typeof arrayConfig[key] === \"number\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    if (typeof arrayConfig.sortable === \"boolean\") {\n      validated.sortable = arrayConfig.sortable;\n    }\n\n    if (arrayConfig.objectConfig) {\n      validated.objectConfig = this.validateObjectConfig(\n        arrayConfig.objectConfig,\n        fieldIndex\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateObjectConfig(\n    config: unknown,\n    fieldIndex: number\n  ): ObjectConfig {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Object config at field index ${fieldIndex} must be an object`,\n        \"INVALID_OBJECT_CONFIG\"\n      );\n    }\n\n    const objectConfig = config as Record<string, unknown>;\n    const validated: ObjectConfig = {\n      fields: [],\n    };\n\n    if (objectConfig.fields && Array.isArray(objectConfig.fields)) {\n      validated.fields = objectConfig.fields.map((field) => {\n        if (typeof field !== \"object\" || !field) {\n          return { name: \"\", type: \"text\" };\n        }\n        const f = field as Record<string, unknown>;\n        const validatedField: ObjectConfig[\"fields\"][0] = {\n          name: typeof f.name === \"string\" ? f.name : \"\",\n          type: typeof f.type === \"string\" ? f.type : \"text\",\n        };\n\n        if (typeof f.label === \"string\") validatedField.label = f.label;\n        if (typeof f.placeholder === \"string\")\n          validatedField.placeholder = f.placeholder;\n        if (typeof f.description === \"string\")\n          validatedField.description = f.description;\n        if (typeof f.min === \"number\") validatedField.min = f.min;\n        if (typeof f.max === \"number\") validatedField.max = f.max;\n        if (typeof f.step === \"number\") validatedField.step = f.step;\n\n        if (\n          f.options &&\n          (Array.isArray(f.options) || typeof f.options === \"function\")\n        ) {\n          validatedField.options =\n            f.options as ObjectConfig[\"fields\"][0][\"options\"];\n        }\n\n        return validatedField;\n      });\n    }\n\n    // Add other object config properties\n    [\"title\", \"description\", \"collapseLabel\", \"expandLabel\"].forEach((key) => {\n      if (objectConfig[key] && typeof objectConfig[key] === \"string\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    [\"collapsible\", \"defaultExpanded\", \"showCard\"].forEach((key) => {\n      if (typeof objectConfig[key] === \"boolean\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    if (\n      objectConfig.layout &&\n      [\"vertical\", \"horizontal\", \"grid\"].includes(objectConfig.layout as string)\n    ) {\n      validated.layout = objectConfig.layout as ObjectConfig[\"layout\"];\n    }\n\n    if (typeof objectConfig.columns === \"number\") {\n      validated.columns = objectConfig.columns;\n    }\n\n    return validated;\n  }\n\n  private static validateMultiSelectConfig(\n    config: unknown\n  ): FieldConfig[\"multiSelectConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const multiSelectConfig = config as Record<string, unknown>;\n    const validated: NonNullable<FieldConfig[\"multiSelectConfig\"]> = {};\n\n    if (typeof multiSelectConfig.maxSelections === \"number\") {\n      validated.maxSelections = multiSelectConfig.maxSelections;\n    }\n\n    [\"searchable\", \"creatable\"].forEach((key) => {\n      if (typeof multiSelectConfig[key] === \"boolean\") {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    [\"placeholder\", \"noOptionsText\", \"loadingText\"].forEach((key) => {\n      if (\n        multiSelectConfig[key] &&\n        typeof multiSelectConfig[key] === \"string\"\n      ) {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateColorConfig(\n    config: unknown\n  ): FieldConfig[\"colorConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const colorConfig = config as Record<string, unknown>;\n    const validated: NonNullable<FieldConfig[\"colorConfig\"]> = {};\n\n    if (\n      colorConfig.format &&\n      [\"hex\", \"rgb\", \"hsl\"].includes(colorConfig.format as string)\n    ) {\n      validated.format = colorConfig.format as \"hex\" | \"rgb\" | \"hsl\";\n    }\n\n    [\"showPreview\", \"showAlpha\", \"allowCustom\"].forEach((key) => {\n      if (typeof colorConfig[key] === \"boolean\") {\n        (validated as any)[key] = colorConfig[key];\n      }\n    });\n\n    if (Array.isArray(colorConfig.presetColors)) {\n      validated.presetColors = colorConfig.presetColors.filter(\n        (color) => typeof color === \"string\"\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateRatingConfig(\n    config: unknown\n  ): FieldConfig[\"ratingConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const ratingConfig = config as Record<string, unknown>;\n    const validated: NonNullable<FieldConfig[\"ratingConfig\"]> = {};\n\n    if (typeof ratingConfig.max === \"number\") {\n      validated.max = ratingConfig.max;\n    }\n\n    [\"allowHalf\", \"allowClear\", \"showValue\"].forEach((key) => {\n      if (typeof ratingConfig[key] === \"boolean\") {\n        (validated as any)[key] = ratingConfig[key];\n      }\n    });\n\n    if (\n      ratingConfig.icon &&\n      [\"star\", \"heart\", \"thumbs\"].includes(ratingConfig.icon as string)\n    ) {\n      validated.icon = ratingConfig.icon as \"star\" | \"heart\" | \"thumbs\";\n    }\n\n    if (\n      ratingConfig.size &&\n      [\"sm\", \"md\", \"lg\", \"small\", \"medium\", \"large\"].includes(\n        ratingConfig.size as string\n      )\n    ) {\n      validated.size = ratingConfig.size as\n        | \"sm\"\n        | \"md\"\n        | \"lg\"\n        | \"small\"\n        | \"medium\"\n        | \"large\";\n    }\n\n    return validated;\n  }\n\n  private static validatePhoneConfig(\n    config: unknown\n  ): FieldConfig[\"phoneConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const phoneConfig = config as Record<string, unknown>;\n    const validated: NonNullable<FieldConfig[\"phoneConfig\"]> = {};\n\n    if (\n      phoneConfig.defaultCountry &&\n      typeof phoneConfig.defaultCountry === \"string\"\n    ) {\n      validated.defaultCountry = phoneConfig.defaultCountry;\n    }\n\n    [\"preferredCountries\", \"onlyCountries\", \"excludeCountries\"].forEach(\n      (key) => {\n        if (Array.isArray(phoneConfig[key])) {\n          (validated as any)[key] = phoneConfig[key].filter(\n            (item: unknown) => typeof item === \"string\"\n          );\n        }\n      }\n    );\n\n    if (\n      phoneConfig.format &&\n      [\"national\", \"international\"].includes(phoneConfig.format as string)\n    ) {\n      validated.format = phoneConfig.format as \"national\" | \"international\";\n    }\n\n    return validated;\n  }\n\n  private static validateDatalistConfig(\n    config: unknown\n  ): FieldConfig[\"datalist\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const datalistConfig = config as Record<string, unknown>;\n    const validated: NonNullable<FieldConfig[\"datalist\"]> = {};\n\n    if (Array.isArray(datalistConfig.options)) {\n      validated.options = datalistConfig.options.filter(\n        (option) => typeof option === \"string\"\n      );\n    }\n\n    [\"debounceMs\", \"minChars\", \"maxResults\"].forEach((key) => {\n      if (typeof datalistConfig[key] === \"number\") {\n        (validated as any)[key] = datalistConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateOptions(\n    options: unknown[]\n  ): Array<{ value: string; label: string }> {\n    return options\n      .filter(\n        (option) =>\n          typeof option === \"object\" &&\n          option !== null &&\n          typeof (option as any).value === \"string\" &&\n          typeof (option as any).label === \"string\"\n      )\n      .map((option) => ({\n        value: (option as any).value,\n        label: (option as any).label,\n      }));\n  }\n\n  private static validatePage(page: unknown, index: number): PageConfig {\n    if (typeof page !== \"object\" || !page) {\n      return { page: index };\n    }\n\n    const pageObj = page as Record<string, unknown>;\n    const validated: PageConfig = {\n      page: typeof pageObj.page === \"number\" ? pageObj.page : index,\n    };\n\n    if (pageObj.title && typeof pageObj.title === \"string\") {\n      validated.title = pageObj.title;\n    }\n\n    if (pageObj.description && typeof pageObj.description === \"string\") {\n      validated.description = pageObj.description;\n    }\n\n    return validated;\n  }\n\n  // Phase 2: Enhanced Features\n\n  /**\n   * Parses form definition with schema inference capabilities\n   * @param code - The form definition code to parse\n   * @param options - Schema inference options\n   * @returns Parsing result with inferred schema information\n   */\n  static parseWithSchemaInference(\n    code: string,\n    options?: SchemaInferenceOptions\n  ): SchemaInferenceResult {\n    const config = this.parse(code);\n\n    // Basic schema inference implementation\n    let confidence = 0.5; // Base confidence\n    let inferredSchema = null;\n\n    if (options?.enabled) {\n      try {\n        const schemaBuilder: Record<string, string> = {};\n\n        for (const field of config.fields || []) {\n          const zodType = this.inferZodTypeFromField(field);\n          if (zodType) {\n            schemaBuilder[field.name] = zodType;\n            confidence += 0.1; // Increase confidence for each successful inference\n          }\n        }\n\n        // Create a basic schema representation\n        inferredSchema = {\n          type: \"object\",\n          properties: schemaBuilder,\n          isInferred: true,\n        };\n\n        confidence = Math.min(confidence, 1.0);\n      } catch (error) {\n        console.warn(\"Schema inference failed:\", error);\n        confidence = 0.1;\n      }\n    }\n\n    return {\n      config,\n      inferredSchema,\n      confidence,\n    };\n  }\n\n  /**\n   * Merges a parsed configuration with a base schema\n   * @param parsedConfig - The parsed form configuration\n   * @param baseSchema - Base schema to merge with\n   * @param strategy - Merge strategy to use\n   * @returns Enhanced form configuration\n   */\n  static mergeSchemas(\n    parsedConfig: UseFormedibleOptions<Record<string, unknown>>,\n    baseSchema: unknown,\n    strategy: \"extend\" | \"override\" | \"intersect\" = \"extend\"\n  ): UseFormedibleOptions<Record<string, unknown>> {\n    const merged = { ...parsedConfig };\n\n    if (!baseSchema || typeof baseSchema !== \"object\") {\n      return merged;\n    }\n\n    try {\n      // Extract field information from base schema if it has properties\n      const baseSchemaObj = baseSchema as Record<string, unknown>;\n\n      if (strategy === \"extend\" && baseSchemaObj.properties) {\n        // Add missing fields from base schema\n        const existingFieldNames = new Set((merged.fields || []).map((f) => f.name));\n        const baseProperties = baseSchemaObj.properties as Record<\n          string,\n          unknown\n        >;\n\n        for (const [fieldName, fieldSchema] of Object.entries(baseProperties)) {\n          if (!existingFieldNames.has(fieldName)) {\n            const inferredField = this.createFieldFromSchema(\n              fieldName,\n              fieldSchema\n            );\n            if (inferredField && merged.fields) {\n              merged.fields.push(inferredField);\n            }\n          }\n        }\n      } else if (strategy === \"override\") {\n        // Override existing schema completely\n        if (baseSchema && typeof baseSchema === 'object' && '_def' in baseSchema) {\n          // Check if it's a Zod schema by looking for the _def property\n          merged.schema = baseSchema as z.ZodSchema<Record<string, unknown>>;\n        }\n      } else if (strategy === \"intersect\") {\n        // Keep only fields that exist in both\n        const baseProperties =\n          (baseSchemaObj.properties as Record<string, unknown>) || {};\n        merged.fields = (merged.fields || []).filter((field) =>\n          Object.prototype.hasOwnProperty.call(baseProperties, field.name)\n        );\n      }\n\n      // Update the schema property only if it's actually a Zod schema\n      if (strategy !== \"override\" && baseSchema && typeof baseSchema === 'object' && '_def' in baseSchema) {\n        merged.schema = baseSchema as z.ZodSchema<Record<string, unknown>>;\n      }\n    } catch (error) {\n      console.warn(\"Schema merging failed:\", error);\n    }\n\n    return merged;\n  }\n\n  /**\n   * Validates form definition code with AI-friendly error suggestions\n   * @param code - The form definition code to validate\n   * @returns Validation result with detailed errors and suggestions\n   */\n  static validateWithSuggestions(\n    code: string\n  ): ValidationWithSuggestionsResult {\n    const errors: EnhancedParserError[] = [];\n    const suggestions: string[] = [];\n\n    try {\n      // Attempt to parse the code\n      this.parse(code);\n      return { isValid: true, errors: [], suggestions: [] };\n    } catch (error) {\n      let errorType: EnhancedParserError[\"type\"] = \"syntax\";\n      let message = \"Unknown parsing error\";\n      let suggestion = \"\";\n      let examples: string[] = [];\n\n      if (error instanceof Error) {\n        message = error.message;\n\n        // Analyze error types and provide specific suggestions\n        if (\n          message.includes(\"Invalid syntax\") ||\n          message.includes(\"JSON.parse\")\n        ) {\n          errorType = \"syntax\";\n          suggestion =\n            \"Check for missing quotes around object keys or trailing commas\";\n          examples = [\n            '{ \"name\": \"field1\", \"type\": \"text\" }',\n            '{ fields: [{ name: \"field1\", type: \"text\" }] }',\n          ];\n          suggestions.push(\"Use double quotes around object keys\");\n          suggestions.push(\"Remove trailing commas before closing brackets\");\n        } else if (message.includes(\"invalid type\")) {\n          errorType = \"field_type\";\n          suggestion = `Use one of the supported field types: ${this.ALLOWED_FIELD_TYPES.join(\n            \", \"\n          )}`;\n          examples = [\n            '{ name: \"email\", type: \"email\" }',\n            '{ name: \"age\", type: \"number\" }',\n          ];\n          suggestions.push(\"Check field type spelling\");\n          suggestions.push(\"Refer to supported field types list\");\n        } else if (message.includes(\"must have\")) {\n          errorType = \"validation\";\n          suggestion = \"Ensure all required properties are present\";\n          examples = [\n            '{ name: \"required-field\", type: \"text\", label: \"Required Field\" }',\n          ];\n          suggestions.push(\"Add missing required properties: name, type\");\n        } else if (message.includes(\"schema\")) {\n          errorType = \"schema\";\n          suggestion = \"Check Zod schema syntax and structure\";\n          examples = [\n            \"schema: z.object({ name: z.string(), email: z.string().email() })\",\n          ];\n          suggestions.push(\"Verify Zod schema syntax\");\n        }\n      }\n\n      errors.push({\n        type: errorType,\n        message,\n        suggestion,\n        examples,\n        location: this.extractErrorLocation(code, error),\n      });\n\n      // Add general suggestions\n      suggestions.push(\"Validate JSON syntax using a JSON validator\");\n      suggestions.push(\"Check for balanced parentheses and brackets\");\n      suggestions.push(\"Ensure all string values are properly quoted\");\n\n      return { isValid: false, errors, suggestions };\n    }\n  }\n\n  /**\n   * Infers Zod type from a field configuration\n   * @private\n   */\n  private static inferZodTypeFromField(\n    field: FieldConfig\n  ): string | null {\n    const typeMapping: Record<string, string> = {\n      text: \"z.string()\",\n      email: \"z.string().email()\",\n      password: \"z.string().min(1)\",\n      url: \"z.string().url()\",\n      tel: \"z.string()\",\n      textarea: \"z.string()\",\n      number: \"z.number()\",\n      date: \"z.string().datetime()\",\n      checkbox: \"z.boolean()\",\n      switch: \"z.boolean()\",\n      select: \"z.string()\",\n      radio: \"z.string()\",\n      multiSelect: \"z.array(z.string())\",\n      file: \"z.instanceof(File)\",\n      slider: \"z.number()\",\n      rating: \"z.number()\",\n      phone: \"z.string()\",\n      colorPicker: \"z.string()\",\n      location: \"z.object({ lat: z.number(), lng: z.number() })\",\n      duration: \"z.number()\",\n      autocomplete: \"z.string()\",\n      masked: \"z.string()\",\n      array: \"z.array(z.unknown())\",\n      object: \"z.object({})\",\n    };\n\n    let baseType = typeMapping[field.type];\n    if (!baseType) return null;\n\n    // Add validation constraints\n    if (field.type === \"text\" || field.type === \"textarea\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().max(${field.max})`\n        );\n      }\n    }\n\n    if (field.type === \"number\" || field.type === \"slider\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().max(${field.max})`\n        );\n      }\n    }\n\n    // Handle required/optional\n    if (field.required === false) {\n      baseType += \".optional()\";\n    }\n\n    return baseType;\n  }\n\n  /**\n   * Creates a field configuration from a schema definition\n   * @private\n   */\n  private static createFieldFromSchema(\n    name: string,\n    schema: unknown\n  ): FieldConfig | null {\n    // Basic implementation - would need more sophisticated schema analysis\n    try {\n      const schemaObj = schema as Record<string, unknown>;\n      let type = \"text\"; // default\n\n      // Very basic type inference from schema structure\n      if (schemaObj.type === \"string\") {\n        type = \"text\";\n      } else if (schemaObj.type === \"number\") {\n        type = \"number\";\n      } else if (schemaObj.type === \"boolean\") {\n        type = \"checkbox\";\n      }\n\n      return {\n        name,\n        type,\n        label:\n          name.charAt(0).toUpperCase() +\n          name.slice(1).replace(/([A-Z])/g, \" $1\"),\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Extracts error location information from parsing error\n   * @private\n   */\n  private static extractErrorLocation(\n    code: string,\n    error: unknown\n  ): EnhancedParserError[\"location\"] | undefined {\n    try {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      // Try to extract line/column info from JSON parse errors\n      const positionMatch = errorMessage.match(/at position (\\d+)/i);\n      if (positionMatch) {\n        const position = parseInt(positionMatch[1], 10);\n        const lines = code.substring(0, position).split(\"\\n\");\n        return {\n          line: lines.length,\n          column: lines[lines.length - 1].length + 1,\n        };\n      }\n\n      // Try to extract field information from validation errors\n      const fieldMatch = errorMessage.match(/field at index (\\d+)/i);\n      if (fieldMatch) {\n        return {\n          field: `field[${fieldMatch[1]}]`,\n        };\n      }\n    } catch {\n      // Ignore extraction errors\n    }\n\n    return undefined;\n  }\n}\n\n// Export types for external use\nexport type { UseFormedibleOptions, FieldConfig, ParserOptions, ObjectConfig, ParserError, PageConfig };\n",
      "type": "registry:lib",
      "target": "lib/formedible/formedible-parser.ts"
    },
    {
      "path": "src/lib/formedible/parser-types.ts",
      "content": "\"use client\";\n\n// Import ALL types from main formedible package to eliminate duplicates\nimport type { \n  FieldConfig,\n  DynamicText,\n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig,\n  UseFormedibleOptions,\n  LayoutConfig,\n  ConditionalSection,\n  FormAnalytics,\n  CrossFieldValidation,\n  AsyncValidation,\n  // Field-specific configs\n  TextareaConfig,\n  PasswordConfig,\n  EmailConfig,\n  NumberConfig,\n  MultiSelectConfig,\n  DateFieldProps,\n  SliderFieldProps,\n  FileUploadFieldProps,\n  LocationConfig,\n  DurationConfig,\n  AutocompleteConfig,\n  MaskedInputConfig,\n  ColorPickerFieldProps,\n  RatingFieldProps,\n  PhoneFieldProps,\n  ArrayFieldProps\n} from \"./types\";\n\nexport type { \n  FieldConfig,\n  DynamicText,\n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig,\n  UseFormedibleOptions,\n  LayoutConfig,\n  ConditionalSection,\n  FormAnalytics,\n  CrossFieldValidation,\n  AsyncValidation,\n  // Field-specific configs\n  TextareaConfig,\n  PasswordConfig,\n  EmailConfig,\n  NumberConfig,\n  MultiSelectConfig,\n  DateFieldProps,\n  SliderFieldProps,\n  FileUploadFieldProps,\n  LocationConfig,\n  DurationConfig,\n  AutocompleteConfig,\n  MaskedInputConfig,\n  ColorPickerFieldProps,\n  RatingFieldProps,\n  PhoneFieldProps,\n  ArrayFieldProps\n};\n\n// Use real FieldConfig from main formedible package - no duplicates!\nexport type ParsedFieldConfig = FieldConfig;\n\n\n// Parser config - picks only the serializable parts of UseFormedibleOptions\n// Excludes functions and React components that can't be parsed from text\nexport type ParsedFormConfig = Pick<UseFormedibleOptions<Record<string, unknown>>, \n  | 'fields'\n  | 'schema' \n  | 'pages'\n  | 'tabs'\n  | 'layout'\n  | 'progress'\n  | 'submitLabel'\n  | 'nextLabel' \n  | 'previousLabel'\n  | 'collapseLabel'\n  | 'expandLabel'\n  | 'formClassName'\n  | 'fieldClassName'\n  | 'labelClassName'\n  | 'buttonClassName'\n  | 'submitButtonClassName'\n  | 'autoScroll'\n  | 'autoSubmitOnChange'\n  | 'autoSubmitDebounceMs'\n  | 'disabled'\n  | 'loading'\n  | 'resetOnSubmitSuccess'\n  | 'showSubmitButton'\n  | 'crossFieldValidation'\n  | 'asyncValidation'\n  | 'analytics'\n  | 'conditionalSections'\n  | 'persistence'\n  | 'formOptions'\n>;\n\nexport interface ParserOptions {\n  strictValidation?: boolean;\n}\n\nexport interface ParserError extends Error {\n  code?: string;\n  field?: string;\n  line?: number;\n  column?: number;\n}\n\n// Phase 2: Enhanced Parser Types\n\n/**\n * Enhanced parser options for Phase 2 features\n */\nexport interface EnhancedParserOptions extends ParserOptions {\n  baseSchema?: unknown; // z.ZodSchema in actual usage\n  mergeStrategy?: 'extend' | 'override' | 'intersect';\n  predefinedHandlers?: {\n    onSubmit?: (data: unknown) => void;\n    specificFields?: Record<string, ParsedFieldConfig>;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Enhanced error type with AI-friendly suggestions\n */\nexport interface EnhancedParserError {\n  type: 'syntax' | 'validation' | 'field_type' | 'schema';\n  message: string;\n  suggestion?: string;\n  location?: {\n    line?: number;\n    column?: number;\n    field?: string;\n  };\n  examples?: string[];\n}\n\n/**\n * Schema inference configuration options\n */\nexport interface SchemaInferenceOptions {\n  enabled?: boolean;\n  fieldTypeMapping?: Record<string, unknown>; // z.ZodType in actual usage\n  defaultValidation?: boolean;\n  inferFromValues?: boolean;\n}\n\n/**\n * Result of schema inference parsing\n */\nexport interface SchemaInferenceResult {\n  config: ParsedFormConfig;\n  inferredSchema: unknown; // z.ZodSchema in actual usage\n  confidence: number;\n}\n\n/**\n * Result of validation with suggestions\n */\nexport interface ValidationWithSuggestionsResult {\n  isValid: boolean;\n  errors: EnhancedParserError[];\n  suggestions: string[];\n}",
      "type": "registry:lib",
      "target": "lib/formedible/parser-types.ts"
    },
    {
      "path": "src/lib/formedible/types.ts",
      "content": "import React from \"react\";\nimport type { AnyFieldApi } from \"@tanstack/react-form\";\nimport type {\n  FormApi,\n  ValidationError,\n  FormState,\n  AnyFormApi,\n} from \"@tanstack/form-core\";\nimport { z } from \"zod\";\n\n// Strict type definitions for better type safety\nexport interface StrictFieldApi<T = unknown> {\n  name: string;\n  value: T;\n  errors: ValidationError[];\n  touched: boolean;\n  setValue: (value: T) => void;\n  setTouched: (touched: boolean) => void;\n  validate: () => Promise<ValidationError[]>;\n}\n\nexport interface TypedFormState<TFormData = Record<string, unknown>> {\n  values: TFormData;\n  errors: Record<keyof TFormData, ValidationError[]>;\n  touched: Record<keyof TFormData, boolean>;\n  isSubmitting: boolean;\n  isValidating: boolean;\n  canSubmit: boolean;\n}\n\nexport interface TypedFormSubscriptionSelector<\n  TFormData = Record<string, unknown>,\n  TSelected = unknown\n> {\n  (\n    state: FormState<\n      TFormData,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined\n    >\n  ): TSelected;\n}\n\n// Validation error types based on TanStack Form\nexport type FormedibleValidationError = ValidationError;\n\n// Validation error that can be a string, Error object, or custom validation result\nexport type FieldValidationError = string | Error | ValidationError;\n\n// Array of validation errors for a field\nexport type FieldValidationErrors = FieldValidationError[];\n\n// Dynamic text types for template interpolation\nexport type DynamicText =\n  | string\n  | ((values: Record<string, unknown>) => string);\nexport type OptionalDynamicText = DynamicText | undefined;\n\n// Type alias for our FormApi - use the core FormApi type which is what useForm actually returns\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\n  TFormData,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  never\n>;\n\n// Option types for select, radio, and multi-select fields\nexport type FieldOption = {\n  value: string;\n  label: string;\n  disabled?: boolean;\n  description?: string;\n};\n\nexport type FieldOptions = string[] | FieldOption[];\n\n// Normalize options to consistent format\nexport type NormalizedFieldOption = FieldOption;\n\n// Props that all basic field components rendered by FormedibleRoot will receive\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  description?: string;\n  placeholder?: string;\n  inputClassName?: string; // For the <Input /> component itself\n  labelClassName?: string; // For the <Label /> component\n  wrapperClassName?: string; // For the div wrapping label and input\n}\n\n// Specific field component prop types\nexport interface SelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n}\n\nexport interface RadioFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n}\n\nexport interface MultiSelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n  maxSelections?: number;\n}\n\n// Shared object configuration interface - DRY!\nexport interface ObjectConfig {\n  title?: string;\n  description?: string;\n  fields: Array<{\n    name: string;\n    type: string;\n    label?: DynamicText;\n    placeholder?: DynamicText;\n    description?: DynamicText;\n    options?:\n      | string[]\n      | Array<{ value: string; label: string }>\n      | ((\n          values: Record<string, unknown>\n        ) => string[] | Array<{ value: string; label: string }>);\n    min?: number;\n    max?: number;\n    step?: number;\n    [key: string]: unknown;\n  }>;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n  showCard?: boolean;\n  layout?: \"grid\" | \"vertical\" | \"horizontal\" | (string & {});\n  columns?: number;\n  collapseLabel?: string;\n  expandLabel?: string;\n}\n\nexport interface ArrayFieldProps extends BaseFieldProps {\n  arrayConfig: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    itemComponent?: React.ComponentType<BaseFieldProps>;\n    itemProps?: Record<string, unknown>;\n    // Use the shared ObjectConfig - DRY!\n    objectConfig?: ObjectConfig;\n  };\n}\n\nexport interface TextFieldProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\";\n  datalist?: string[];\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  autoComplete?: string;\n}\n\nexport interface NumberFieldProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  precision?: number;\n}\n\nexport interface DateFieldProps extends BaseFieldProps {\n  dateConfig?: {\n    format?: string;\n    minDate?: Date;\n    maxDate?: Date;\n    disabledDates?: Date[];\n    showTime?: boolean;\n    timeFormat?: string;\n  };\n}\n\nexport interface SliderFieldProps extends BaseFieldProps {\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    // Value mapping between slider value (int) and display value (arbitrary)\n    valueMapping?: Array<{\n      sliderValue: number;\n      displayValue: string | number;\n      label?: string;\n    }>;\n    // Gradient colors for the slider\n    gradientColors?: {\n      start: string;\n      end: string;\n      direction?: \"horizontal\" | \"vertical\";\n    };\n    // Custom visualization component for each step\n    visualizationComponent?: React.ComponentType<{\n      value: number;\n      displayValue: string | number;\n      label?: string;\n      isActive: boolean;\n    }>;\n    // Legacy and additional config\n    valueLabelPrefix?: string;\n    valueLabelSuffix?: string;\n    valueDisplayPrecision?: number;\n    showRawValue?: boolean;\n    showValue?: boolean;\n    showTooltip?: boolean;\n    showTicks?: boolean;\n    orientation?: \"horizontal\" | \"vertical\";\n    marks?: Array<{ value: number; label: string }>;\n  };\n}\n\nexport interface FileUploadFieldProps extends BaseFieldProps {\n  fileConfig?: {\n    accept?: string;\n    multiple?: boolean;\n    maxSize?: number;\n    maxFiles?: number;\n    allowedTypes?: string[];\n    uploadUrl?: string;\n    onUpload?: (files: File[]) => Promise<string[]>;\n  };\n}\n\nexport interface LocationPickerFieldProps extends BaseFieldProps {\n  locationConfig?: LocationConfig;\n}\n\nexport interface DurationPickerFieldProps extends BaseFieldProps {\n  durationConfig?: DurationConfig;\n}\n\nexport interface AutocompleteFieldProps extends BaseFieldProps {\n  autocompleteConfig?: AutocompleteConfig;\n}\n\nexport interface MaskedInputFieldProps extends BaseFieldProps {\n  maskedConfig?: MaskedInputConfig;\n}\n\nexport interface ColorPickerFieldProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: \"hex\" | \"rgb\" | \"hsl\";\n    showPreview?: boolean; // Show color preview\n    showAlpha?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n  };\n}\n\nexport interface RatingFieldProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    allowClear?: boolean;\n    icon?: \"star\" | \"heart\" | \"thumbs\" | React.ComponentType;\n    size?: \"sm\" | \"md\" | \"lg\" | \"small\" | \"medium\" | \"large\";\n    showValue?: boolean;\n  };\n}\n\nexport interface PhoneFieldProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    preferredCountries?: string[];\n    onlyCountries?: string[];\n    excludeCountries?: string[];\n    format?: \"national\" | \"international\";\n  };\n}\n\nexport interface ObjectFieldProps extends BaseFieldProps {\n  objectConfig?: ObjectConfig;\n  disabled?: boolean;\n  form?: AnyFormApi;\n}\n\n// Field-specific interfaces moved from field components for centralization\nexport interface TextFieldSpecificProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\" | \"datetime-local\";\n  datalist?: {\n    options?: string[];\n    asyncOptions?: (query: string) => Promise<string[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n  };\n}\n\nexport interface NumberFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nexport interface TextareaFieldSpecificProps extends BaseFieldProps {\n  rows?: number;\n}\n\nexport interface RadioFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  direction?: \"horizontal\" | \"vertical\";\n}\n\nexport interface PhoneFieldSpecificProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    format?: \"national\" | \"international\";\n    allowedCountries?: string[];\n    placeholder?: string;\n    excludedCountries?: string[];\n  };\n}\n\nexport interface MultiSelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n}\n\nexport interface ColorPickerFieldSpecificProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: \"hex\" | \"rgb\" | \"hsl\";\n    showPreview?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n    showAlpha?: boolean;\n  };\n}\n\nexport interface RatingFieldSpecificProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    icon?: \"star\" | \"heart\" | \"thumbs\";\n    size?: \"sm\" | \"md\" | \"lg\";\n    allowClear?: boolean;\n    showValue?: boolean;\n  };\n}\n\nexport interface SliderFieldSpecificProps extends BaseFieldProps {\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    // Value mapping between slider value (int) and display value (arbitrary)\n    valueMapping?: Array<{\n      sliderValue: number;\n      displayValue: string | number;\n      label?: string;\n    }>;\n    // Gradient colors for the slider\n    gradientColors?: {\n      start: string;\n      end: string;\n      direction?: \"horizontal\" | \"vertical\";\n    };\n    // Custom visualization component for each step\n    visualizationComponent?: React.ComponentType<{\n      value: number;\n      displayValue: string | number;\n      label?: string;\n      isActive: boolean;\n    }>;\n    // Legacy support\n    valueLabelPrefix?: string;\n    valueLabelSuffix?: string;\n    valueDisplayPrecision?: number;\n    showRawValue?: boolean;\n    showValue?: boolean;\n    showTooltip?: boolean;\n    orientation?: \"horizontal\" | \"vertical\";\n    marks?: Array<{ value: number; label: string }>;\n  };\n  // Direct props for backwards compatibility\n  min?: number;\n  max?: number;\n  step?: number;\n  valueLabelPrefix?: string;\n  valueLabelSuffix?: string;\n  valueDisplayPrecision?: number;\n  showRawValue?: boolean;\n}\n\n// Layout component interfaces moved from layout components for centralization\nexport interface FormGridProps {\n  children: React.ReactNode;\n  columns?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n  gap?:\n    | \"0\"\n    | \"1\"\n    | \"2\"\n    | \"3\"\n    | \"4\"\n    | \"5\"\n    | \"6\"\n    | \"7\"\n    | \"8\"\n    | \"9\"\n    | \"10\"\n    | \"11\"\n    | \"12\";\n  responsive?: boolean;\n  className?: string;\n}\n\nexport interface FormTabsProps {\n  children?: React.ReactNode;\n  tabs: {\n    id: string;\n    label: string;\n    content: React.ReactNode;\n  }[];\n  activeTab: string; // CONTROLLED - NO INTERNAL STATE\n  className?: string;\n  onTabChange: (tabId: string) => void; // REQUIRED - PARENT CONTROLS STATE\n}\n\nexport interface FormAccordionProps {\n  children?: React.ReactNode;\n  sections: {\n    id: string;\n    title: string;\n    content: React.ReactNode;\n    defaultOpen?: boolean;\n  }[];\n  type?: \"single\" | \"multiple\";\n  className?: string;\n}\n\nexport interface FormStepperStep {\n  id: string;\n  title: string;\n  description?: string;\n  content: React.ReactNode;\n  optional?: boolean;\n}\n\nexport interface FormStepperProps {\n  children?: React.ReactNode;\n  steps: FormStepperStep[];\n  currentStep?: number;\n  onStepChange?: (stepIndex: number) => void;\n  onComplete?: () => void;\n  className?: string;\n  allowSkip?: boolean;\n  showStepNumbers?: boolean;\n}\n\n// Wrapper component interfaces moved from field components for centralization\nexport interface FieldWrapperProps extends BaseFieldProps {\n  children: React.ReactNode;\n  htmlFor?: string;\n  showErrors?: boolean;\n}\n\nexport interface InlineValidationWrapperProps {\n  children: React.ReactNode;\n  fieldApi: AnyFieldApi;\n  inlineValidation?: {\n    enabled?: boolean;\n    debounceMs?: number;\n    showSuccess?: boolean;\n    asyncValidator?: (value: unknown) => Promise<string | null>;\n  };\n  className?: string;\n}\n\n// Union type for all possible field component props - using intersection for flexibility\nexport type FieldComponentProps = BaseFieldProps & {\n  // Optional props that specific field types might need\n  options?: FieldOptions;\n  arrayConfig?: ArrayFieldProps[\"arrayConfig\"];\n  objectConfig?: ObjectConfig;\n  type?: TextFieldProps[\"type\"];\n  datalist?: string[];\n  dateConfig?: DateFieldProps[\"dateConfig\"];\n  sliderConfig?: SliderFieldProps[\"sliderConfig\"];\n  fileConfig?: FileUploadFieldProps[\"fileConfig\"];\n  locationConfig?: LocationPickerFieldProps[\"locationConfig\"];\n  durationConfig?: DurationPickerFieldProps[\"durationConfig\"];\n  autocompleteConfig?: AutocompleteFieldProps[\"autocompleteConfig\"];\n  maskedConfig?: MaskedInputFieldProps[\"maskedConfig\"];\n  colorConfig?: ColorPickerFieldProps[\"colorConfig\"];\n  ratingConfig?: RatingFieldProps[\"ratingConfig\"];\n  phoneConfig?: PhoneFieldProps[\"phoneConfig\"];\n  // Legacy support for existing configurations\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n  maskedInputConfig?: MaskedInputConfig;\n  // Allow additional props for extensibility\n  [key: string]: unknown;\n};\n\n// Cross-field validation configuration\nexport interface CrossFieldValidation<TFormValues = Record<string, unknown>> {\n  fields: (keyof TFormValues)[];\n  validator: (values: Partial<TFormValues>) => string | null;\n  message: string;\n}\n\n// Async validation configuration\nexport interface AsyncValidation {\n  validator: (value: unknown) => Promise<string | null>;\n  debounceMs?: number;\n  loadingMessage?: string;\n}\n\n// Enhanced form analytics and tracking configuration\nexport interface FormAnalytics {\n  // Field-level analytics\n  onFieldFocus?: (fieldName: string, timestamp: number) => void;\n  onFieldBlur?: (fieldName: string, timeSpent: number) => void;\n  onFieldChange?: (\n    fieldName: string,\n    value: unknown,\n    timestamp: number\n  ) => void;\n  onFieldComplete?: (\n    fieldName: string,\n    isValid: boolean,\n    timeSpent: number\n  ) => void;\n  onFieldError?: (\n    fieldName: string,\n    errors: string[],\n    timestamp: number\n  ) => void;\n\n  // Form-level analytics\n  onFormStart?: (timestamp: number) => void;\n  onFormComplete?: (timeSpent: number, formData: unknown) => void;\n  onFormAbandon?: (\n    completionPercentage: number,\n    context?: {\n      currentPage?: number;\n      currentTab?: string;\n      lastActiveField?: string;\n    }\n  ) => void;\n  onFormReset?: (timestamp: number, reason?: string) => void;\n\n  // Page-level analytics (for multi-page forms)\n  onPageChange?: (\n    fromPage: number,\n    toPage: number,\n    timeSpent: number,\n    pageValidationState?: { hasErrors: boolean; completionPercentage: number }\n  ) => void;\n  onPageComplete?: (\n    pageNumber: number,\n    timeSpent: number,\n    fieldsCompleted: number,\n    totalFields: number\n  ) => void;\n  onPageAbandon?: (\n    pageNumber: number,\n    completionPercentage: number,\n    timeSpent: number\n  ) => void;\n  onPageValidationError?: (\n    pageNumber: number,\n    errors: Record<string, string[]>,\n    timestamp: number\n  ) => void;\n\n  // Tab-level analytics (for tabbed forms)\n  onTabChange?: (\n    fromTab: string,\n    toTab: string,\n    timeSpent: number,\n    tabCompletionState?: { completionPercentage: number; hasErrors: boolean }\n  ) => void;\n  onTabComplete?: (\n    tabId: string,\n    timeSpent: number,\n    fieldsCompleted: number,\n    totalFields: number\n  ) => void;\n  onTabAbandon?: (\n    tabId: string,\n    completionPercentage: number,\n    timeSpent: number\n  ) => void;\n  onTabValidationError?: (\n    tabId: string,\n    errors: Record<string, string[]>,\n    timestamp: number\n  ) => void;\n  onTabFirstVisit?: (tabId: string, timestamp: number) => void;\n\n  // Performance analytics\n  onRenderPerformance?: (\n    componentName: string,\n    renderTime: number,\n    rerenderCount: number\n  ) => void;\n  onValidationPerformance?: (\n    fieldName: string,\n    validationType: \"sync\" | \"async\",\n    duration: number\n  ) => void;\n  onSubmissionPerformance?: (\n    submissionTime: number,\n    validationTime: number,\n    processingTime: number\n  ) => void;\n}\n\n// Tab analytics state tracking\nexport interface TabAnalyticsState {\n  tabId: string;\n  startTime: number;\n  visitCount: number;\n  fieldsCompleted: number;\n  totalFields: number;\n  hasErrors: boolean;\n  lastActiveField?: string;\n  completionPercentage: number;\n}\n\n// Page analytics state tracking\nexport interface PageAnalyticsState {\n  pageNumber: number;\n  startTime: number;\n  visitCount: number;\n  fieldsCompleted: number;\n  totalFields: number;\n  hasErrors: boolean;\n  lastActiveField?: string;\n  completionPercentage: number;\n  validationErrors: Record<string, string[]>;\n}\n\n// Performance tracking metrics\nexport interface PerformanceMetrics {\n  renderCount: number;\n  lastRenderTime: number;\n  averageRenderTime: number;\n  validationDurations: Record<string, number[]>;\n  submissionMetrics: {\n    totalTime: number;\n    validationTime: number;\n    processingTime: number;\n  };\n}\n\n// Analytics context for tracking form interaction patterns\nexport interface AnalyticsContext {\n  sessionId: string;\n  formId: string;\n  userId?: string;\n  currentPage?: number;\n  currentTab?: string;\n  startTime: number;\n  pageStates: Record<number, PageAnalyticsState>;\n  tabStates: Record<string, TabAnalyticsState>;\n  performanceMetrics: PerformanceMetrics;\n  fieldInteractions: Record<\n    string,\n    {\n      focusCount: number;\n      totalTimeSpent: number;\n      changeCount: number;\n      errorCount: number;\n      isCompleted: boolean;\n    }\n  >;\n}\n\n// Layout configuration for forms\nexport interface LayoutConfig {\n  type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n  columns?: number;\n  gap?: string;\n  responsive?: boolean;\n  className?: string;\n}\n\n// Conditional sections configuration\nexport interface ConditionalSection<TFormValues = Record<string, unknown>> {\n  condition: (values: TFormValues) => boolean;\n  fields: string[];\n  layout?: LayoutConfig;\n}\n\n// Location picker configuration\nexport interface LocationValue {\n  lat: number;\n  lng: number;\n  address?: string;\n  country?: string;\n  city?: string;\n  state?: string;\n  postalCode?: string;\n  [key: string]: any; // Allow additional properties from different services\n}\n\nexport interface LocationSearchResult extends LocationValue {\n  id: string | number;\n  relevance?: number;\n  bounds?: {\n    northeast: { lat: number; lng: number };\n    southwest: { lat: number; lng: number };\n  };\n}\n\nexport interface LocationConfig {\n  // Basic configuration\n  defaultLocation?: { lat: number; lng: number };\n  zoom?: number;\n  searchPlaceholder?: string;\n  enableSearch?: boolean;\n  enableGeolocation?: boolean;\n  enableManualEntry?: boolean;\n  showMap?: boolean;\n\n  // Map provider - determines which map component to render\n  mapProvider?:\n    | \"google\"\n    | \"openstreetmap\"\n    | \"bing\"\n    | \"custom\"\n    | \"cartodb\"\n    | \"stamen\"\n    | \"satellite\";\n\n  // User-defined search function\n  // This function should handle the API calls to your preferred geocoding service\n  searchCallback?: (\n    query: string,\n    options?: {\n      // Optional parameters that can be passed to the search\n      limit?: number;\n      countryCode?: string;\n      bounds?: {\n        northeast: { lat: number; lng: number };\n        southwest: { lat: number; lng: number };\n      };\n      [key: string]: any;\n    }\n  ) => Promise<LocationSearchResult[]>;\n\n  // User-defined reverse geocoding function\n  // This function should convert coordinates back to an address\n  reverseGeocodeCallback?: (lat: number, lng: number) => Promise<LocationValue>;\n\n  // Map rendering callback - allows complete customization of map display\n  mapRenderCallback?: (params: {\n    location: LocationValue | null;\n    onLocationSelect: (location: LocationValue) => void;\n    mapContainer: HTMLDivElement;\n    zoom: number;\n    readonly: boolean;\n    defaultLocation?: { lat: number; lng: number };\n  }) => {\n    // Return cleanup function\n    cleanup?: () => void;\n    // Update location on map\n    updateLocation?: (location: LocationValue) => void;\n  };\n\n  // Provider-specific configuration\n  googleMaps?: {\n    apiKey: string;\n    libraries?: string[];\n    mapOptions?: any; // Google Maps MapOptions\n    searchOptions?: any; // Google Places search options\n  };\n\n  openStreetMap?: {\n    tileServer?: string; // Custom tile server URL\n    attribution?: string;\n    nominatimEndpoint?: string; // Custom Nominatim endpoint\n    searchOptions?: {\n      countrycodes?: string;\n      addressdetails?: boolean;\n      limit?: number;\n      [key: string]: any;\n    };\n  };\n\n  bingMaps?: {\n    apiKey: string;\n    mapOptions?: any; // Bing Maps options\n    searchOptions?: any; // Bing geocoding options\n  };\n\n  // Custom provider configuration\n  custom?: {\n    [key: string]: any;\n  };\n\n  // Search behavior\n  searchOptions?: {\n    debounceMs?: number;\n    minQueryLength?: number;\n    maxResults?: number;\n    countryCode?: string; // ISO country code to restrict search\n    bounds?: {\n      northeast: { lat: number; lng: number };\n      southwest: { lat: number; lng: number };\n    };\n    [key: string]: any;\n  };\n\n  // UI customization\n  ui?: {\n    showCoordinates?: boolean;\n    showAddress?: boolean;\n    mapHeight?: number;\n    searchInputClassName?: string;\n    mapClassName?: string;\n    coordinatesFormat?: \"decimal\" | \"dms\"; // Decimal degrees or degrees/minutes/seconds\n    [key: string]: any;\n  };\n}\n\n// Duration picker configuration\nexport interface DurationValue {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  totalSeconds?: number;\n}\n\nexport interface DurationConfig {\n  format?: \"hms\" | \"hm\" | \"ms\" | \"hours\" | \"minutes\" | \"seconds\";\n  maxHours?: number;\n  maxMinutes?: number;\n  maxSeconds?: number;\n  showLabels?: boolean;\n  allowNegative?: boolean;\n}\n\n// Autocomplete configuration\nexport interface AutocompleteConfig {\n  options?: string[] | { value: string; label: string }[];\n  asyncOptions?: (\n    query: string\n  ) => Promise<string[] | { value: string; label: string }[]>;\n  debounceMs?: number;\n  minChars?: number;\n  maxResults?: number;\n  allowCustom?: boolean;\n  placeholder?: string;\n  noOptionsText?: string;\n  loadingText?: string;\n}\n\n// Masked input configuration\nexport interface MaskedInputConfig {\n  mask: string | ((value: string) => string);\n  placeholder?: string;\n  showMask?: boolean;\n  guide?: boolean;\n  keepCharPositions?: boolean;\n  pipe?: (\n    conformedValue: string,\n    config: unknown\n  ) => false | string | { value: string; indexesOfPipedChars: number[] };\n}\n\n// Field validation configuration\nexport interface FieldValidationConfig {\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  custom?: string;\n  includes?: string;\n  startsWith?: string;\n  endsWith?: string;\n  email?: boolean;\n  url?: boolean;\n  uuid?: boolean;\n  transform?: string;\n  refine?: string;\n  customMessages?: Record<string, string>;\n}\n\n// Help configuration for fields\nexport interface FieldHelpConfig {\n  text?: string;\n  tooltip?: string;\n  position?: \"top\" | \"bottom\" | \"left\" | \"right\";\n  link?: { url: string; text: string };\n}\n\n// Inline validation configuration\nexport interface InlineValidationConfig {\n  enabled?: boolean;\n  debounceMs?: number;\n  showSuccess?: boolean;\n  asyncValidator?: (value: unknown) => Promise<string | null>;\n}\n\n// Section configuration\nexport interface SectionConfig {\n  title?: string;\n  description?: string;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n}\n\n// Datalist configuration\nexport interface DatalistConfig {\n  options?: string[];\n  asyncOptions?: (query: string) => Promise<string[]>;\n  debounceMs?: number;\n  minChars?: number;\n  maxResults?: number;\n}\n\n// Textarea configuration\nexport interface TextareaConfig {\n  rows?: number;\n  cols?: number;\n  resize?: \"none\" | \"vertical\" | \"horizontal\" | \"both\";\n  maxLength?: number;\n  showWordCount?: boolean;\n}\n\n// Password configuration\nexport interface PasswordConfig {\n  showToggle?: boolean;\n  strengthMeter?: boolean;\n  minStrength?: number;\n  requirements?: {\n    minLength?: number;\n    requireUppercase?: boolean;\n    requireLowercase?: boolean;\n    requireNumbers?: boolean;\n    requireSymbols?: boolean;\n  };\n}\n\n// Email configuration\nexport interface EmailConfig {\n  allowedDomains?: string | string[];\n  blockedDomains?: string | string[];\n  suggestions?: string | string[];\n  validateMX?: boolean;\n}\n\n// Number configuration\nexport interface NumberConfig {\n  min?: number;\n  max?: number;\n  step?: number;\n  precision?: number;\n  allowNegative?: boolean;\n  showSpinButtons?: boolean;\n}\n\n// Multi-select configuration\nexport interface MultiSelectConfig {\n  maxSelections?: number;\n  searchable?: boolean;\n  creatable?: boolean;\n  placeholder?: string;\n  noOptionsText?: string;\n  loadingText?: string;\n}\n\n// Hook interfaces moved from use-formedible.tsx for centralization\nexport interface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  // HTML form attributes\n  action?: string;\n  method?: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  encType?:\n    | \"application/x-www-form-urlencoded\"\n    | \"multipart/form-data\"\n    | \"text/plain\";\n  target?: \"_blank\" | \"_self\" | \"_parent\" | \"_top\" | string;\n  autoComplete?: \"on\" | \"off\";\n  noValidate?: boolean;\n  acceptCharset?: string;\n  // Event handlers\n  onReset?: (e: React.FormEvent) => void;\n  onInput?: (e: React.FormEvent) => void;\n  onInvalid?: (e: React.FormEvent) => void;\n  onKeyDown?: (e: React.KeyboardEvent) => void;\n  onKeyUp?: (e: React.KeyboardEvent) => void;\n  onFocus?: (e: React.FocusEvent) => void;\n  onBlur?: (e: React.FocusEvent) => void;\n  // Accessibility\n  role?: string;\n  \"aria-label\"?: string;\n  \"aria-labelledby\"?: string;\n  \"aria-describedby\"?: string;\n  tabIndex?: number;\n}\n\nexport interface ConditionalFieldsSubscriptionProps<\n  TFormValues extends Record<string, unknown> = Record<string, unknown>\n> {\n  form: any;\n  fields: FieldConfig[];\n  conditionalSections: Array<{\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }>;\n  children: (currentValues: Record<string, unknown>) => React.ReactNode;\n}\n\nexport interface FieldConditionalRendererProps {\n  form: any;\n  fieldConfig: FieldConfig;\n  children: (shouldRender: boolean) => React.ReactNode;\n}\n\nexport interface SectionRendererProps {\n  sectionKey: string;\n  sectionData: {\n    section?: {\n      title?: string;\n      description?: string;\n      collapsible?: boolean;\n      defaultExpanded?: boolean;\n    };\n    groups: Record<string, FieldConfig[]>;\n  };\n  renderField: (field: FieldConfig) => React.ReactNode;\n}\n\nexport interface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  schema?: z.ZodSchema<TFormValues>;\n  title?: string;\n  description?: string;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  // Translation support for section buttons\n  collapseLabel?: string;\n  expandLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  labelClassName?: string;\n  buttonClassName?: string;\n  submitButtonClassName?: string;\n  // Auto scroll configuration\n  autoScroll?: boolean;\n  submitButton?: React.ComponentType<\n    React.ButtonHTMLAttributes<HTMLButtonElement> & {\n      children?: React.ReactNode;\n    }\n  >;\n  pages?: PageConfig[];\n  progress?: ProgressConfig;\n  tabs?: {\n    id: string;\n    label: string;\n    description?: string;\n  }[];\n  defaultComponents?: {\n    [key: string]: React.ComponentType<FieldComponentProps>;\n  };\n  globalWrapper?: React.ComponentType<{\n    children: React.ReactNode;\n    field: FieldConfig;\n  }>;\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => unknown | Promise<unknown>;\n    onSubmitInvalid: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onChange?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onBlur?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onFocus?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    onReset?: (props: {\n      value: TFormValues;\n      formApi: FormedibleFormApi<TFormValues>;\n    }) => void;\n    asyncDebounceMs: number;\n    canSubmitWhenInvalid: boolean;\n  }>;\n  onPageChange?: (page: number, direction: \"next\" | \"previous\") => void;\n  autoSubmitOnChange?: boolean;\n  autoSubmitDebounceMs?: number;\n  disabled?: boolean;\n  loading?: boolean;\n  resetOnSubmitSuccess?: boolean;\n  showSubmitButton?: boolean;\n  // Form-level event handlers\n  onFormReset?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormInput?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormInvalid?: (\n    e: React.FormEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormKeyDown?: (\n    e: React.KeyboardEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormKeyUp?: (\n    e: React.KeyboardEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormFocus?: (\n    e: React.FocusEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  onFormBlur?: (\n    e: React.FocusEvent,\n    formApi: FormedibleFormApi<TFormValues>\n  ) => void;\n  // Advanced validation features\n  crossFieldValidation?: {\n    fields: (keyof TFormValues)[];\n    validator: (values: Partial<TFormValues>) => string | null;\n    message: string;\n  }[];\n  asyncValidation?: {\n    [fieldName: string]: {\n      validator: (value: unknown) => Promise<string | null>;\n      debounceMs?: number;\n      loadingMessage?: string;\n    };\n  };\n  // Form analytics and tracking\n  analytics?: FormAnalytics;\n  // Layout configuration\n  layout?: {\n    type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n    columns?: number;\n    gap?: string;\n    responsive?: boolean;\n    className?: string;\n  };\n  // Conditional sections\n  conditionalSections?: {\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: \"grid\" | \"flex\" | \"tabs\" | \"accordion\" | \"stepper\";\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }[];\n  // Form persistence\n  persistence?: {\n    key: string;\n    storage: \"localStorage\" | \"sessionStorage\";\n    debounceMs?: number;\n    exclude?: string[];\n    restoreOnMount?: boolean;\n  };\n}\n\n// Main FieldConfig interface - DRY version using existing types\nexport interface FieldConfig {\n  name: string;\n  type: string;\n  label?: DynamicText;\n  placeholder?: DynamicText;\n  description?: DynamicText;\n  required?: boolean;\n  defaultValue?: unknown;\n  options?:\n    | string[]\n    | { value: string; label: string }[]\n    | ((\n        values: Record<string, unknown>\n      ) => string[] | { value: string; label: string }[]);\n  min?: number;\n  max?: number;\n  step?: number;\n  accept?: string;\n  multiple?: boolean;\n  component?: React.ComponentType<FieldComponentProps>;\n  wrapper?: React.ComponentType<{\n    children: React.ReactNode;\n    field: FieldConfig;\n  }>;\n  page?: number;\n  tab?: string;\n  validation?: z.ZodSchema<unknown>;\n  dependencies?: string[];\n  conditional?: (values: Record<string, unknown>) => boolean;\n  group?: string;\n\n  // Grid positioning properties\n  gridColumn?: number; // Specific column to place this field (1-based)\n  gridRow?: number; // Specific row to place this field (1-based)\n  gridColumnSpan?: number; // How many columns this field should span\n  gridRowSpan?: number; // How many rows this field should span\n  gridArea?: string; // CSS grid-area value for advanced positioning\n\n  // Configuration objects using existing types\n  arrayConfig?: ArrayFieldProps[\"arrayConfig\"];\n  ratingConfig?: RatingFieldProps[\"ratingConfig\"];\n  phoneConfig?: PhoneFieldProps[\"phoneConfig\"];\n  colorConfig?: ColorPickerFieldProps[\"colorConfig\"];\n  multiSelectConfig?: MultiSelectConfig;\n  locationConfig?: LocationConfig;\n  durationConfig?: DurationConfig;\n  autocompleteConfig?: AutocompleteConfig;\n  maskedInputConfig?: MaskedInputConfig;\n  objectConfig?: ObjectConfig;\n  sliderConfig?: SliderFieldProps[\"sliderConfig\"];\n  numberConfig?: NumberConfig;\n  dateConfig?: DateFieldProps[\"dateConfig\"];\n  fileConfig?: FileUploadFieldProps[\"fileConfig\"];\n  textareaConfig?: TextareaConfig;\n  passwordConfig?: PasswordConfig;\n  emailConfig?: EmailConfig;\n\n  // Additional configurations\n  datalist?: DatalistConfig;\n  help?: FieldHelpConfig;\n  inlineValidation?: InlineValidationConfig;\n  section?: SectionConfig;\n  validationConfig?: FieldValidationConfig;\n\n  // Allow additional unknown configurations for extensibility\n  [key: string]: unknown;\n}\n\n// Page configuration for multi-page forms\nexport interface PageConfig {\n  page: number;\n  title?: string;\n  description?: string;\n  component?: React.ComponentType<{\n    children: React.ReactNode;\n    title?: string;\n    description?: string;\n    page: number;\n    totalPages: number;\n  }>;\n  conditional?: (values: Record<string, unknown>) => boolean;\n}\n\n// Progress configuration for multi-page forms\nexport interface ProgressConfig {\n  component?: React.ComponentType<{\n    value: number;\n    currentPage: number;\n    totalPages: number;\n    className?: string;\n  }>;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n  className?: string;\n}\n",
      "type": "registry:lib",
      "target": "lib/formedible/types.ts"
    },
    {
      "path": "src/lib/formedible/parser-config-schema.ts",
      "content": "\"use client\";\n\n/**\n * Parser Configuration Schema for Settings UI\n *\n * This file provides a formedible-compatible schema for configuring\n * parser settings through a UI form. It includes types and field\n * configurations for all parser options.\n */\n\n// Note: In actual usage, this would import from 'zod', but for standalone\n// compatibility, we define the schema structure that can be used with zod\n\n/**\n * Parser configuration options\n */\nexport interface ParserConfig {\n  strictValidation: boolean;\n  enableSchemaInference: boolean;\n  mergeStrategy: \"extend\" | \"override\" | \"intersect\";\n  fieldTypeValidation: boolean;\n  customInstructions?: string;\n  maxCodeLength: number;\n  maxNestingDepth: number;\n  enableZodParsing: boolean;\n  showDetailedErrors: boolean;\n  selectFields: boolean;\n  systemPromptFields: string[];\n  includeTabFormatting: boolean;\n  includePageFormatting: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * Zod schema definition structure (for use with actual zod when available)\n * This represents what the schema would look like when used with zod\n */\nexport const parserConfigSchemaDefinition = {\n  strictValidation: {\n    type: \"boolean\",\n    default: true,\n    description: \"Enable strict validation of form definitions\",\n  },\n  enableSchemaInference: {\n    type: \"boolean\",\n    default: false,\n    description: \"Automatically infer Zod schemas from field definitions\",\n  },\n  mergeStrategy: {\n    type: \"enum\",\n    values: [\"extend\", \"override\", \"intersect\"],\n    default: \"extend\",\n    description: \"Strategy for merging with base schemas\",\n  },\n  fieldTypeValidation: {\n    type: \"boolean\",\n    default: true,\n    description: \"Validate field types against supported types\",\n  },\n  customInstructions: {\n    type: \"string\",\n    optional: true,\n    description: \"Custom parsing instructions or constraints\",\n  },\n  maxCodeLength: {\n    type: \"number\",\n    default: 1000000,\n    min: 1000,\n    max: 10000000,\n    description: \"Maximum allowed code length in characters\",\n  },\n  maxNestingDepth: {\n    type: \"number\",\n    default: 50,\n    min: 5,\n    max: 200,\n    description: \"Maximum nesting depth for object structures\",\n  },\n  enableZodParsing: {\n    type: \"boolean\",\n    default: true,\n    description: \"Enable parsing of Zod schema expressions\",\n  },\n  showDetailedErrors: {\n    type: \"boolean\",\n    default: true,\n    description: \"Show detailed error information in parser output\",\n  },\n};\n\n/**\n * Default parser configuration\n */\nexport const defaultParserConfig: ParserConfig = {\n  strictValidation: true,\n  enableSchemaInference: false,\n  mergeStrategy: \"extend\",\n  fieldTypeValidation: true,\n  customInstructions: undefined,\n  maxCodeLength: 1000000,\n  maxNestingDepth: 50,\n  enableZodParsing: true,\n  showDetailedErrors: true,\n  selectFields: false,\n  // Default to the set of formedible field types used as examples in the UI\n  systemPromptFields: [\n    \"text\",\n    \"email\",\n    \"url\",\n    \"textarea\",\n    \"number\",\n    \"select\",\n    \"multiSelect\",\n    \"radio\",\n    \"checkbox\",\n    \"switch\",\n    \"date\",\n    \"file\",\n    \"slider\",\n    \"rating\",\n    \"phone\",\n    \"colorPicker\",\n    \"password\",\n    \"duration\",\n    \"autocomplete\",\n    \"maskedInput\",\n    \"array\",\n    \"object\",\n  ],\n  includeTabFormatting: true,\n  includePageFormatting: true,\n};\n\n/**\n * Type-safe field examples for each field type - aligned with formedible documentation\n */\nconst fieldExamples = {\n  text: { name: \"fullName\", type: \"text\", label: \"Full Name\", required: true },\n  email: {\n    name: \"email\",\n    type: \"email\",\n    label: \"Email Address\",\n    required: true,\n  },\n  url: { name: \"website\", type: \"url\", label: \"Website URL\" },\n  textarea: {\n    name: \"message\",\n    type: \"textarea\",\n    label: \"Message\",\n    textareaConfig: { rows: 4, maxLength: 500, showWordCount: true },\n  },\n  number: {\n    name: \"age\",\n    type: \"number\",\n    label: \"Age\",\n    numberConfig: { min: 18, max: 120, allowNegative: false },\n  },\n  select: {\n    name: \"country\",\n    type: \"select\",\n    label: \"Country\",\n    options: [\n      { value: \"us\", label: \"United States\" },\n      { value: \"uk\", label: \"United Kingdom\" },\n      { value: \"ca\", label: \"Canada\" },\n    ],\n  },\n  multiSelect: {\n    name: \"skills\",\n    type: \"multiSelect\",\n    label: \"Skills\",\n    options: [\"React\", \"Vue\", \"Angular\", \"Node.js\"],\n    multiSelectConfig: { maxSelections: 3, searchable: true, creatable: true },\n  },\n  radio: {\n    name: \"plan\",\n    type: \"radio\",\n    label: \"Plan\",\n    options: [\n      { value: \"free\", label: \"Free Plan\" },\n      { value: \"pro\", label: \"Pro Plan\" },\n      { value: \"enterprise\", label: \"Enterprise Plan\" },\n    ],\n  },\n  checkbox: {\n    name: \"newsletter\",\n    type: \"checkbox\",\n    label: \"Subscribe to Newsletter\",\n  },\n  switch: {\n    name: \"notifications\",\n    type: \"switch\",\n    label: \"Enable Notifications\",\n  },\n  date: {\n    name: \"birthDate\",\n    type: \"date\",\n    label: \"Birth Date\",\n    dateConfig: { format: \"yyyy-MM-dd\", showTime: false },\n  },\n  file: {\n    name: \"resume\",\n    type: \"file\",\n    label: \"Resume\",\n    fileConfig: {\n      accept: \".pdf,.doc,.docx\",\n      maxSize: 5000000,\n      multiple: false,\n    },\n  },\n  slider: {\n    name: \"experience\",\n    type: \"slider\",\n    label: \"Years Experience\",\n    sliderConfig: { min: 0, max: 20, step: 1 },\n  },\n  rating: {\n    name: \"satisfaction\",\n    type: \"rating\",\n    label: \"Satisfaction Rating\",\n    ratingConfig: { max: 5, allowHalf: true, icon: \"star\" },\n  },\n  phone: {\n    name: \"phone\",\n    type: \"phone\",\n    label: \"Phone Number\",\n    phoneConfig: { defaultCountry: \"US\", format: \"national\" },\n  },\n  colorPicker: {\n    name: \"brandColor\",\n    type: \"colorPicker\",\n    label: \"Brand Color\",\n    colorConfig: {\n      format: \"hex\",\n      presetColors: [\"#ff0000\", \"#00ff00\", \"#0000ff\"],\n      allowCustom: true,\n    },\n  },\n  password: {\n    name: \"password\",\n    type: \"password\",\n    label: \"Password\",\n    passwordConfig: { showToggle: true, strengthMeter: true },\n  },\n  duration: {\n    name: \"workHours\",\n    type: \"duration\",\n    label: \"Work Hours\",\n    durationConfig: { format: \"hm\", showLabels: true },\n  },\n  autocomplete: {\n    name: \"city\",\n    type: \"autocomplete\",\n    label: \"City\",\n    autocompleteConfig: {\n      options: [\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\"],\n      minChars: 2,\n      allowCustom: true,\n    },\n  },\n  maskedInput: {\n    name: \"ssn\",\n    type: \"maskedInput\",\n    label: \"SSN\",\n    maskedInputConfig: { mask: \"000-00-0000\", guide: true },\n  },\n  array: {\n    name: \"team\",\n    type: \"array\",\n    label: \"Team Members\",\n    arrayConfig: {\n      itemType: \"object\",\n      itemLabel: \"Team Member\",\n      minItems: 1,\n      maxItems: 10,\n      sortable: true,\n      addButtonLabel: \"Add Member\",\n      removeButtonLabel: \"Remove\",\n      objectConfig: {\n        fields: [\n          { name: \"name\", type: \"text\", label: \"Full Name\", required: true },\n          {\n            name: \"role\",\n            type: \"select\",\n            label: \"Role\",\n            options: [\"Developer\", \"Designer\", \"Manager\"],\n          },\n          { name: \"email\", type: \"email\", label: \"Email\", required: true },\n        ],\n      },\n    },\n  },\n  object: {\n    name: \"address\",\n    type: \"object\",\n    label: \"Address\",\n    objectConfig: {\n      title: \"Mailing Address\",\n      collapsible: true,\n      layout: \"vertical\",\n      fields: [\n        {\n          name: \"street\",\n          type: \"text\",\n          label: \"Street Address\",\n          required: true,\n        },\n        { name: \"city\", type: \"text\", label: \"City\", required: true },\n        {\n          name: \"state\",\n          type: \"select\",\n          label: \"State\",\n          options: [\"CA\", \"NY\", \"TX\", \"FL\"],\n        },\n        { name: \"zip\", type: \"text\", label: \"ZIP Code\", required: true },\n      ],\n    },\n  },\n} as const;\n\n/**\n * Formedible field configurations for the parser settings UI\n * These can be used to generate a settings form using formedible\n */\nexport const parserConfigFields = [\n  {\n    name: \"strictValidation\",\n    type: \"switch\",\n    label: \"Strict Validation\",\n    description:\n      \"Enable strict validation of form definitions. When enabled, unknown properties are rejected.\",\n    defaultValue: true,\n  },\n  {\n    name: \"enableSchemaInference\",\n    type: \"switch\",\n    label: \"Schema Inference\",\n    description:\n      \"Automatically infer Zod schemas from field definitions to provide better type safety.\",\n    defaultValue: false,\n  },\n  {\n    name: \"mergeStrategy\",\n    type: \"select\",\n    label: \"Schema Merge Strategy\",\n    description: \"How to merge parsed configurations with base schemas.\",\n    defaultValue: \"extend\",\n    options: [\n      {\n        value: \"extend\",\n        label: \"Extend - Add missing fields from base schema\",\n      },\n      { value: \"override\", label: \"Override - Replace schema completely\" },\n      { value: \"intersect\", label: \"Intersect - Keep only common fields\" },\n    ],\n  },\n  {\n    name: \"fieldTypeValidation\",\n    type: \"switch\",\n    label: \"Field Type Validation\",\n    description:\n      \"Validate field types against the list of supported field types.\",\n    defaultValue: true,\n  },\n  {\n    name: \"customInstructions\",\n    type: \"textarea\",\n    label: \"Custom Instructions\",\n    description:\n      \"Optional custom parsing instructions or constraints to apply.\",\n    placeholder: \"Enter any custom parsing rules or requirements...\",\n    required: false,\n  },\n  {\n    name: \"maxCodeLength\",\n    type: \"number\",\n    label: \"Maximum Code Length\",\n    description:\n      \"Maximum allowed length for form definition code (in characters).\",\n    defaultValue: 1000000,\n    min: 1000,\n    max: 10000000,\n    step: 1000,\n  },\n  {\n    name: \"maxNestingDepth\",\n    type: \"number\",\n    label: \"Maximum Nesting Depth\",\n    description:\n      \"Maximum allowed nesting depth for object and array structures.\",\n    defaultValue: 50,\n    min: 5,\n    max: 200,\n    step: 5,\n  },\n  {\n    name: \"enableZodParsing\",\n    type: \"switch\",\n    label: \"Zod Expression Parsing\",\n    description:\n      \"Enable parsing and handling of Zod schema expressions in form definitions.\",\n    defaultValue: true,\n  },\n  {\n    name: \"showDetailedErrors\",\n    type: \"switch\",\n    label: \"Detailed Error Information\",\n    description:\n      \"Include detailed error context and location information in parser output.\",\n    defaultValue: true,\n  },\n  {\n    name: \"selectFields\",\n    type: \"switch\",\n    label: \"Select Fields\",\n    defaultValue: false,\n  },\n  {\n    name: \"systemPromptFields\",\n    type: \"multiSelect\",\n    label: \"Field Types\",\n    description:\n      \"Select which formedible field types to include as examples in the system prompt.\",\n    options: Object.keys(fieldExamples).map((fieldType) => ({\n      value: fieldType,\n      label: fieldType.charAt(0).toUpperCase() + fieldType.slice(1),\n    })),\n    defaultValue: Object.keys(fieldExamples),\n  },\n  {\n    name: \"includeTabFormatting\",\n    type: \"switch\",\n    label: \"Tab Formatting\",\n    description: \"Include tab-based form structure in the system prompt.\",\n    defaultValue: true,\n  },\n  {\n    name: \"includePageFormatting\",\n    type: \"switch\",\n    label: \"Page Formatting\",\n    description: \"Include multi-page form structure in the system prompt.\",\n    defaultValue: true,\n  },\n];\n\n/**\n * Parser configuration form definition\n * Complete formedible form configuration for parser settings\n */\nexport const parserConfigFormDefinition = {\n  title: \"Parser Configuration\",\n  description: \"Configure how the Formedible parser processes form definitions\",\n  fields: parserConfigFields,\n  submitLabel: \"Save Configuration\",\n  formOptions: {\n    defaultValues: defaultParserConfig,\n  },\n};\n\n/**\n * Helper function to validate parser configuration\n */\nexport function validateParserConfig(config: unknown): config is ParserConfig {\n  if (!config || typeof config !== \"object\") {\n    return false;\n  }\n\n  const c = config as Record<string, unknown>;\n\n  return (\n    typeof c.strictValidation === \"boolean\" &&\n    typeof c.enableSchemaInference === \"boolean\" &&\n    (c.mergeStrategy === \"extend\" ||\n      c.mergeStrategy === \"override\" ||\n      c.mergeStrategy === \"intersect\") &&\n    typeof c.fieldTypeValidation === \"boolean\" &&\n    (c.customInstructions === undefined ||\n      typeof c.customInstructions === \"string\") &&\n    typeof c.maxCodeLength === \"number\" &&\n    typeof c.maxNestingDepth === \"number\" &&\n    typeof c.enableZodParsing === \"boolean\" &&\n    typeof c.showDetailedErrors === \"boolean\" &&\n    typeof c.selectFields === \"boolean\" &&\n    Array.isArray(c.systemPromptFields) &&\n    c.systemPromptFields.every((field) => typeof field === \"string\") &&\n    typeof c.includeTabFormatting === \"boolean\" &&\n    typeof c.includePageFormatting === \"boolean\"\n  );\n}\n\n/**\n * Helper function to merge parser configuration with defaults\n */\nexport function mergeParserConfig(config: Partial<ParserConfig>): ParserConfig {\n  return {\n    ...defaultParserConfig,\n    ...config,\n  };\n}\n\n/**\n * Generate a dynamic system prompt based on selected configuration fields\n */\nexport function generateSystemPrompt(config: ParserConfig): string {\n  const fieldDescriptions: Record<string, string> = {\n    strictValidation: config.strictValidation\n      ? \"Use strict validation - reject unknown properties and enforce schema compliance\"\n      : \"Use permissive validation - allow unknown properties and be flexible with schema\",\n    fieldTypeValidation: config.fieldTypeValidation\n      ? \"Validate all field types against the 24 supported formedible field types\"\n      : \"Allow flexible field types without strict validation\",\n    enableSchemaInference: config.enableSchemaInference\n      ? \"Automatically infer Zod schemas from field definitions for better type safety\"\n      : \"Use manual schema definition without automatic inference\",\n    mergeStrategy: `Use \"${\n      config.mergeStrategy\n    }\" strategy when merging schemas - ${\n      config.mergeStrategy === \"extend\"\n        ? \"add missing fields from base schema\"\n        : config.mergeStrategy === \"override\"\n        ? \"replace schema completely\"\n        : \"keep only fields that exist in both schemas\"\n    }`,\n    maxCodeLength: `Maximum allowed form definition length: ${config.maxCodeLength.toLocaleString()} characters`,\n    maxNestingDepth: `Maximum nesting depth for object and array structures: ${config.maxNestingDepth} levels`,\n    enableZodParsing: config.enableZodParsing\n      ? \"Parse and handle Zod schema expressions (z.string(), z.number(), etc.)\"\n      : \"Treat Zod expressions as plain text without parsing\",\n    showDetailedErrors: config.showDetailedErrors\n      ? \"Include detailed error context, location information, and debugging details\"\n      : \"Provide minimal error information\",\n    ...(config.customInstructions\n      ? {\n          customInstructions: `Additional instructions: ${config.customInstructions}`,\n        }\n      : {}),\n  };\n\n  const selectedConfigFields = Object.entries(fieldDescriptions)\n    .filter(([_key, desc]) => Boolean(desc))\n    .map(([_key, desc]) => desc);\n\n  if (\n    !selectedConfigFields.length &&\n    !config.includeTabFormatting &&\n    !config.includePageFormatting\n  ) {\n    return \"\";\n  }\n\n  let prompt = `# Formedible Parser Configuration\n\nYou are working with a Formedible form parser that has been configured with the following settings:\n\n${selectedConfigFields.map((desc, index) => `${index + 1}. ${desc}`).join(\"\\n\")}\n\n## Key Guidelines\n- Follow the configured validation and parsing rules strictly\n- Generate forms that respect the maximum limits and nesting depth\n- Use the specified error message style and detail level\n- Apply the configured schema inference and merging strategies\n\n## CRITICAL: Formedible Library Compliance\n- Generate CONFIGURATION OBJECTS for formedible, NOT executable code\n- Use this format: { fields: [...], formOptions: { defaultValues: {...} }, ... }\n- DO NOT include function implementations in onSubmit - use placeholder comments\n- DO NOT include validation strings like \"z.string()\" - validation is handled by the schema\n- DO NOT use 'condition' property - conditional fields are not supported in parser mode\n- DO NOT use string schemas like 'schema: \"z.object(...)\"' - omit schema property or use actual Zod objects  \n- Use proper field config properties: min/max directly on fields, not in config objects for basic types\n- AVOID conditional fields entirely - parser cannot handle function strings in JSON format\n- For object fields, use proper objectConfig with nested fields array\n- Respect UseFormedibleOptions interface: title, description, fields, formOptions, submitLabel, etc.`;\n\n  // Add formatting guidelines\n  if (config.includeTabFormatting || config.includePageFormatting) {\n    prompt += `\n\n## Form Structure Guidelines`;\n\n    if (config.includeTabFormatting) {\n      prompt += `\n- **Tab Layout**: Use the \\`layout: { type: 'tabs' }\\` configuration for organizing forms into logical sections\n- **Tab Structure**: Each tab should group related fields together for better user experience\n- **Tab Navigation**: Ensure tab titles are descriptive and help users understand the content`;\n    }\n\n    if (config.includePageFormatting) {\n      prompt += `\n- **Multi-Page Forms**: Use the \\`pages\\` array to create multi-step forms for complex data collection\n- **Page Structure**: Each page should have a clear purpose and logical flow\n- **Page Navigation**: Include appropriate navigation controls with \\`nextLabel\\`, \\`previousLabel\\`, and \\`submitLabel\\`\n- **Progress Indication**: Consider adding progress indicators for multi-page forms using the \\`progress\\` configuration`;\n    }\n  }\n\n  // Create a comprehensive, realistic form example\n  let basicExample: any = {\n    title: \"User Registration Form\",\n    description: \"Complete user registration with validation\",\n    fields: [\n      {\n        name: \"fullName\",\n        type: \"text\",\n        label: \"Full Name\",\n        placeholder: \"Enter your full name\",\n        required: true\n      },\n      {\n        name: \"email\",\n        type: \"email\", \n        label: \"Email Address\",\n        placeholder: \"your@email.com\",\n        required: true\n      },\n      {\n        name: \"password\",\n        type: \"password\",\n        label: \"Password\",\n        required: true,\n        passwordConfig: { showToggle: true, strengthMeter: true }\n      },\n      {\n        name: \"age\",\n        type: \"number\",\n        label: \"Age\",\n        required: true,\n        min: 18,\n        max: 120\n      },\n      {\n        name: \"country\",\n        type: \"select\",\n        label: \"Country\",\n        required: true,\n        options: [\n          { value: \"us\", label: \"United States\" },\n          { value: \"uk\", label: \"United Kingdom\" },\n          { value: \"ca\", label: \"Canada\" },\n          { value: \"au\", label: \"Australia\" }\n        ]\n      },\n      {\n        name: \"newsletter\",\n        type: \"checkbox\",\n        label: \"Subscribe to Newsletter\",\n        description: \"Receive updates about new features and promotions\"\n      }\n    ],\n    formOptions: {\n      defaultValues: {\n        fullName: \"\",\n        email: \"\",\n        password: \"\",\n        age: 18,\n        country: \"\",\n        newsletter: false\n      }\n      // onSubmit, onSubmitInvalid handlers will be provided by the application\n    },\n    submitLabel: \"Create Account\",\n    layout: {\n      type: \"grid\",\n      columns: 2,\n      gap: \"md\"\n    }\n  };\n\n  if (config.includeTabFormatting && config.includePageFormatting) {\n    // Both tabs and pages - comprehensive multi-step form with tabs\n    basicExample = {\n      title: \"Complete Profile Setup\",\n      description: \"Multi-step registration with organized sections\",\n      layout: { type: \"stepper\" },\n      pages: [\n        { title: \"Personal Information\", description: \"Basic details about you\" },\n        { title: \"Account Preferences\", description: \"Customize your experience\" },\n        { title: \"Review & Submit\", description: \"Confirm your information\" }\n      ],\n      tabs: [\n        { id: \"basic\", label: \"Basic Info\", description: \"Name and contact\" },\n        { id: \"address\", label: \"Address\", description: \"Location details\" },\n        { id: \"settings\", label: \"Settings\", description: \"Account preferences\" }\n      ],\n      fields: [\n        {\n          name: \"firstName\",\n          type: \"text\",\n          label: \"First Name\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n        },\n        {\n          name: \"lastName\", \n          type: \"text\",\n          label: \"Last Name\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n        },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email\",\n          required: true,\n          page: 1,\n          tab: \"basic\",\n        },\n        {\n          name: \"address\",\n          type: \"object\",\n          label: \"Address\",\n          page: 1,\n          tab: \"address\",\n          objectConfig: {\n            title: \"Mailing Address\",\n            fields: [\n              { name: \"street\", type: \"text\", label: \"Street Address\", required: true },\n              { name: \"city\", type: \"text\", label: \"City\", required: true },\n              { name: \"zipCode\", type: \"text\", label: \"ZIP Code\", required: true }\n            ]\n          }\n        },\n        {\n          name: \"notifications\",\n          type: \"switch\",\n          label: \"Email Notifications\",\n          page: 2,\n          tab: \"settings\"\n        },\n        {\n          name: \"theme\",\n          type: \"select\",\n          label: \"Preferred Theme\",\n          page: 2,\n          tab: \"settings\",\n          options: [\n            { value: \"light\", label: \"Light\" },\n            { value: \"dark\", label: \"Dark\" },\n            { value: \"auto\", label: \"Auto\" }\n          ]\n        }\n      ],\n      schema: \"z.object({ firstName: z.string().min(1), lastName: z.string().min(1), email: z.string().email(), address: z.object({ street: z.string(), city: z.string(), zipCode: z.string() }), notifications: z.boolean().optional(), theme: z.enum(['light', 'dark', 'auto']).optional() })\",\n      formOptions: {\n        defaultValues: {\n          firstName: \"\",\n          lastName: \"\",\n          email: \"\",\n          address: { street: \"\", city: \"\", zipCode: \"\" },\n          notifications: true,\n          theme: \"auto\"\n        },\n        // onSubmit handler will be provided by the application\n      },\n      nextLabel: \"Continue\",\n      previousLabel: \"Back\",\n      submitLabel: \"Complete Setup\"\n    };\n  } else if (config.includeTabFormatting) {\n    // Tab-based form with organized sections\n    basicExample = {\n      title: \"Project Application Form\",\n      description: \"Comprehensive application with tabbed organization\",\n      layout: { type: \"tabs\" },\n      tabs: [\n        { id: \"personal\", label: \"Personal Info\", description: \"Your basic information\" },\n        { id: \"project\", label: \"Project Details\", description: \"About your project\" },\n        { id: \"experience\", label: \"Experience\", description: \"Your background\" }\n      ],\n      fields: [\n        {\n          name: \"fullName\",\n          type: \"text\",\n          label: \"Full Name\",\n          required: true,\n          tab: \"personal\",\n          },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email Address\",\n          required: true,\n          tab: \"personal\",\n          },\n        {\n          name: \"phone\",\n          type: \"phone\",\n          label: \"Phone Number\",\n          tab: \"personal\",\n          phoneConfig: { defaultCountry: \"US\", format: \"national\" }\n        },\n        {\n          name: \"projectTitle\",\n          type: \"text\",\n          label: \"Project Title\",\n          required: true,\n          tab: \"project\",\n          },\n        {\n          name: \"projectDescription\",\n          type: \"textarea\",\n          label: \"Project Description\",\n          required: true,\n          tab: \"project\",\n          textareaConfig: { rows: 6, maxLength: 1000, showWordCount: true },\n          },\n        {\n          name: \"budget\",\n          type: \"select\",\n          label: \"Budget Range\",\n          required: true,\n          tab: \"project\",\n          options: [\n            { value: \"under-5k\", label: \"Under $5,000\" },\n            { value: \"5k-15k\", label: \"$5,000 - $15,000\" },\n            { value: \"15k-50k\", label: \"$15,000 - $50,000\" },\n            { value: \"over-50k\", label: \"Over $50,000\" }\n          ]\n        },\n        {\n          name: \"yearsExperience\",\n          type: \"slider\",\n          label: \"Years of Experience\",\n          tab: \"experience\",\n          sliderConfig: { min: 0, max: 30, step: 1 }\n        },\n        {\n          name: \"skills\",\n          type: \"multiSelect\",\n          label: \"Skills\",\n          tab: \"experience\",\n          options: [\"JavaScript\", \"TypeScript\", \"React\", \"Node.js\", \"Python\", \"Design\"],\n          multiSelectConfig: { maxSelections: 5, searchable: true }\n        }\n      ],\n      schema: \"z.object({ fullName: z.string().min(2), email: z.string().email(), phone: z.string().optional(), projectTitle: z.string().min(5), projectDescription: z.string().min(50), budget: z.enum(['under-5k', '5k-15k', '15k-50k', 'over-50k']), yearsExperience: z.number().min(0).max(30).optional(), skills: z.array(z.string()).optional() })\",\n      formOptions: {\n        defaultValues: {\n          fullName: \"\",\n          email: \"\",\n          phone: \"\",\n          projectTitle: \"\",\n          projectDescription: \"\",\n          budget: \"\",\n          yearsExperience: 0,\n          skills: []\n        },\n        // onSubmit handler will be provided by the application\n      },\n      submitLabel: \"Submit Application\"\n    };\n  } else if (config.includePageFormatting) {\n    // Multi-page form with step-by-step progression\n    basicExample = {\n      title: \"Customer Onboarding\",\n      description: \"Complete your account setup in simple steps\",\n      layout: { type: \"stepper\" },\n      pages: [\n        { title: \"Account Details\", description: \"Create your account credentials\" },\n        { title: \"Personal Information\", description: \"Tell us about yourself\" },\n        { title: \"Preferences\", description: \"Customize your experience\" },\n        { title: \"Confirmation\", description: \"Review and confirm your information\" }\n      ],\n      fields: [\n        {\n          name: \"username\",\n          type: \"text\",\n          label: \"Username\",\n          required: true,\n          page: 1,\n          placeholder: \"Choose a unique username\",\n          },\n        {\n          name: \"email\",\n          type: \"email\",\n          label: \"Email Address\",\n          required: true,\n          page: 1,\n          },\n        {\n          name: \"password\",\n          type: \"password\",\n          label: \"Password\",\n          required: true,\n          page: 1,\n          passwordConfig: { showToggle: true, strengthMeter: true },\n          },\n        {\n          name: \"firstName\",\n          type: \"text\",\n          label: \"First Name\",\n          required: true,\n          page: 2,\n        },\n        {\n          name: \"lastName\",\n          type: \"text\",\n          label: \"Last Name\",\n          required: true,\n          page: 2,\n        },\n        {\n          name: \"birthDate\",\n          type: \"date\",\n          label: \"Date of Birth\",\n          page: 2,\n          dateConfig: { format: \"yyyy-MM-dd\", showTime: false }\n        },\n        {\n          name: \"company\",\n          type: \"text\",\n          label: \"Company (Optional)\",\n          page: 2\n        },\n        {\n          name: \"notifications\",\n          type: \"switch\",\n          label: \"Email Notifications\",\n          description: \"Receive product updates and newsletters\",\n          page: 3\n        },\n        {\n          name: \"language\",\n          type: \"select\",\n          label: \"Preferred Language\",\n          page: 3,\n          options: [\n            { value: \"en\", label: \"English\" },\n            { value: \"es\", label: \"Spanish\" },\n            { value: \"fr\", label: \"French\" },\n            { value: \"de\", label: \"German\" }\n          ],\n          },\n        {\n          name: \"interests\",\n          type: \"multiSelect\",\n          label: \"Interests\",\n          page: 3,\n          options: [\"Technology\", \"Design\", \"Marketing\", \"Sales\", \"Finance\", \"Education\"],\n          multiSelectConfig: { maxSelections: 3, searchable: true }\n        }\n      ],\n      schema: \"z.object({ username: z.string().min(3), email: z.string().email(), password: z.string().min(8), firstName: z.string().min(1), lastName: z.string().min(1), birthDate: z.date().optional(), company: z.string().optional(), notifications: z.boolean().optional(), language: z.enum(['en', 'es', 'fr', 'de']).optional(), interests: z.array(z.string()).optional() })\",\n      formOptions: {\n        defaultValues: {\n          username: \"\",\n          email: \"\",\n          password: \"\",\n          firstName: \"\",\n          lastName: \"\",\n          birthDate: undefined,\n          company: \"\",\n          notifications: true,\n          language: \"en\",\n          interests: []\n        },\n        // onSubmit handler will be provided by the application\n      },\n      nextLabel: \"Continue\",\n      previousLabel: \"Back\",\n      submitLabel: \"Complete Setup\",\n      progress: {\n        showProgress: true,\n        showStepNumbers: true\n      }\n    };\n  }\n\n  // Filter field examples based on selected field types\n  const selectedFieldExamples = Object.entries(fieldExamples)\n    .filter(([type]) => config.systemPromptFields.includes(type));\n\n  if (selectedFieldExamples.length > 0) {\n    prompt += `\n\n## Field Examples\n\nEach field type has a complete example configuration:\n\n### Available Field Types (Selected: ${config.systemPromptFields.join(', ')})\n${selectedFieldExamples\n  .map(\n    ([type, example]) => `**${type}**: \\`${JSON.stringify(example, null, 2)}\\``\n  )\n  .join(\"\\n\\n\")}`;\n  } else {\n    prompt += `\n\n## Field Examples\n\nNo specific field types selected. Use the default formedible field types as needed.`;\n  }\n\n  prompt += `\n\n## Complete Form Example\n\nBased on your current configuration:\n\n\\`\\`\\`json\n${JSON.stringify(basicExample, null, 2)}\n\\`\\`\\`\n\nWhen generating forms, use these field examples and adapt the structure based on the configuration options above.`;\n\n  return prompt;\n}\n",
      "type": "registry:lib",
      "target": "lib/formedible/parser-config-schema.ts"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}