{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-formedible",
  "type": "registry:hook",
  "title": "Use Formedible",
  "description": "A powerful React hook for creating schema-driven forms with TanStack Form and shadcn/ui components",
  "dependencies": [
    "@tanstack/react-form",
    "@radix-ui/react-checkbox",
    "@radix-ui/react-label",
    "@radix-ui/react-select",
    "@radix-ui/react-switch",
    "date-fns",
    "react-day-picker",
    "lucide-react",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "calendar",
    "popover",
    "badge",
    "slider",
    "radio-group",
    "progress",
    "dialog",
    "tabs",
    "accordion",
    "progress",
    "sonner"
  ],
  "files": [
    {
      "path": "src/hooks/use-formedible.tsx",
      "content": "\"use client\";\nimport React, { useState, useMemo, memo } from \"react\";\nimport { useForm } from \"@tanstack/react-form\";\nimport { z } from \"zod\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormedibleFormApi, FieldComponentProps, BaseFieldProps } from \"@/lib/formedible/types\";\nimport { Button } from \"@/components/ui/button\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { TextField } from \"@/components/formedible/fields/text-field\";\nimport { TextareaField } from \"@/components/formedible/fields/textarea-field\";\nimport { SelectField } from \"@/components/formedible/fields/select-field\";\nimport { CheckboxField } from \"@/components/formedible/fields/checkbox-field\";\nimport { SwitchField } from \"@/components/formedible/fields/switch-field\";\nimport { NumberField } from \"@/components/formedible/fields/number-field\";\nimport { DateField } from \"@/components/formedible/fields/date-field\";\nimport { SliderField } from \"@/components/formedible/fields/slider-field\";\nimport { FileUploadField } from \"@/components/formedible/fields/file-upload-field\";\nimport { ArrayField } from \"@/components/formedible/fields/array-field\";\nimport { RadioField } from \"@/components/formedible/fields/radio-field\";\nimport { FormTabs } from \"@/components/formedible/layout/form-tabs\";\nimport { MultiSelectField } from \"@/components/formedible/fields/multi-select-field\";\nimport { ColorPickerField } from \"@/components/formedible/fields/color-picker-field\";\nimport { RatingField } from \"@/components/formedible/fields/rating-field\";\nimport { PhoneField } from \"@/components/formedible/fields/phone-field\";\nimport { LocationPickerField } from \"@/components/formedible/fields/location-picker-field\";\nimport { DurationPickerField } from \"@/components/formedible/fields/duration-picker-field\";\nimport { AutocompleteField } from \"@/components/formedible/fields/autocomplete-field\";\nimport { MaskedInputField } from \"@/components/formedible/fields/masked-input-field\";\nimport { ObjectField } from \"@/components/formedible/fields/object-field\";\nimport { InlineValidationWrapper } from \"@/components/formedible/fields/inline-validation-wrapper\";\nimport { FieldHelp } from \"@/components/formedible/fields/field-help\";\n\ninterface FormProps {\n  className?: string;\n  children?: React.ReactNode;\n  onSubmit?: (e: React.FormEvent) => void;\n  // HTML form attributes\n  action?: string;\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  encType?: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'text/plain';\n  target?: '_blank' | '_self' | '_parent' | '_top' | string;\n  autoComplete?: 'on' | 'off';\n  noValidate?: boolean;\n  acceptCharset?: string;\n  // Event handlers\n  onReset?: (e: React.FormEvent) => void;\n  onInput?: (e: React.FormEvent) => void;\n  onInvalid?: (e: React.FormEvent) => void;\n  onKeyDown?: (e: React.KeyboardEvent) => void;\n  onKeyUp?: (e: React.KeyboardEvent) => void;\n\n  onFocus?: (e: React.FocusEvent) => void;\n  onBlur?: (e: React.FocusEvent) => void;\n  // Accessibility\n  role?: string;\n  'aria-label'?: string;\n  'aria-labelledby'?: string;\n  'aria-describedby'?: string;\n  tabIndex?: number;\n}\n\n// TanStack Form Best Practice: Reusable subscription component for conditional fields\ninterface ConditionalFieldsSubscriptionProps<TFormValues extends Record<string, unknown> = Record<string, unknown>> {\n  form: any;\n  fields: FieldConfig[];\n  conditionalSections: Array<{\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: 'grid' | 'flex' | 'tabs' | 'accordion' | 'stepper';\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }>;\n  children: (currentValues: Record<string, unknown>) => React.ReactNode;\n}\n\nconst ConditionalFieldsSubscription = <TFormValues extends Record<string, unknown> = Record<string, unknown>>({\n  form,\n  fields: _fields,\n  conditionalSections: _conditionalSections,\n  children\n}: ConditionalFieldsSubscriptionProps<TFormValues>) => {\n  // For now, subscribe to all form values since we don't have explicit dependencies\n  // This could be optimized further by analyzing the condition functions\n  return (\n    <form.Subscribe\n      selector={(state: { values: TFormValues }) => state.values}\n    >\n      {(values: TFormValues) => children(values as Record<string, unknown>)}\n    </form.Subscribe>\n  );\n};\n\n// TanStack Form Best Practice: Individual field conditional renderer\ninterface FieldConditionalRendererProps<TFormValues extends Record<string, unknown> = Record<string, unknown>> {\n  form: any;\n  fieldConfig: FieldConfig;\n  children: (shouldRender: boolean) => React.ReactNode;\n}\n\nconst FieldConditionalRenderer = <TFormValues extends Record<string, unknown> = Record<string, unknown>>({\n  form,\n  fieldConfig,\n  children\n}: FieldConditionalRendererProps<TFormValues>) => {\n  const { conditional } = fieldConfig;\n  \n  // If no conditional logic, always render\n  if (!conditional) {\n    return <>{children(true)}</>;\n  }\n\n  // TanStack Form Best Practice: Use subscription with minimal selector\n  // This prevents parent re-renders by only subscribing to form state changes\n  return (\n    <form.Subscribe\n      selector={(state: any) => state.values}\n    >\n      {(values: any) => children(conditional(values))}\n    </form.Subscribe>\n  );\n};\n\n\n\nexport interface FieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  description?: string;\n  options?: string[] | { value: string; label: string }[] | ((values: Record<string, unknown>) => string[] | { value: string; label: string }[]);\n  min?: number;\n  max?: number;\n  step?: number;\n  accept?: string;\n  multiple?: boolean;\n  component?: React.ComponentType<FieldComponentProps>;\n  wrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>;\n  page?: number;\n  tab?: string;\n  validation?: z.ZodSchema<unknown>;\n  dependencies?: string[];\n  conditional?: (values: Record<string, unknown>) => boolean;\n  // Array field configuration\n  arrayConfig?: {\n    itemType: string; // Type of items in the array ('text', 'email', 'number', etc.)\n    itemLabel?: string; // Label for each item (e.g., \"Email Address\")\n    itemPlaceholder?: string; // Placeholder for each item\n    itemValidation?: z.ZodSchema<unknown>; // Validation for each item\n    minItems?: number; // Minimum number of items\n    maxItems?: number; // Maximum number of items\n    addButtonLabel?: string; // Label for add button\n    removeButtonLabel?: string; // Label for remove button\n    addLabel?: string; // Alternative name for add button label\n    removeLabel?: string; // Alternative name for remove button label\n    itemComponent?: React.ComponentType<FieldComponentProps>; // Custom component for each item\n    sortable?: boolean; // Whether items can be reordered\n    defaultValue?: unknown; // Default value for new items\n  };\n  // Datalist configuration for text inputs\n  datalist?: {\n    options?: string[]; // Static options\n    asyncOptions?: (query: string) => Promise<string[]>; // Async function for dynamic options\n    debounceMs?: number; // Debounce time for async calls\n    minChars?: number; // Minimum characters to trigger async search\n    maxResults?: number; // Maximum number of results to show\n  };\n  // Help and tooltip configuration\n  help?: {\n    text?: string; // Help text displayed below field\n    tooltip?: string; // Tooltip text on hover/focus\n    position?: 'top' | 'bottom' | 'left' | 'right'; // Tooltip position\n    link?: { url: string; text: string }; // Help link\n  };\n  // Inline validation configuration\n  inlineValidation?: {\n    enabled?: boolean; // Enable inline validation\n    debounceMs?: number; // Debounce time for validation\n    showSuccess?: boolean; // Show success state\n    asyncValidator?: (value: unknown) => Promise<string | null>; // Async validation function\n  };\n  // Field grouping\n  group?: string; // Group name for organizing fields\n  section?: {\n    title: string; // Section title\n    description?: string; // Section description\n    collapsible?: boolean; // Whether section can be collapsed\n    defaultExpanded?: boolean; // Default expansion state\n  };\n  // Rating field specific\n  ratingConfig?: {\n    max?: number; // Maximum rating (default 5)\n    allowHalf?: boolean; // Allow half ratings\n    icon?: 'star' | 'heart' | 'thumbs'; // Rating icon type\n    size?: 'sm' | 'md' | 'lg'; // Icon size\n    showValue?: boolean; // Show numeric value\n  };\n  // Phone field specific\n  phoneConfig?: {\n    defaultCountry?: string; // Default country code\n    format?: 'national' | 'international'; // Phone format\n    allowedCountries?: string[]; // Allowed country codes\n    placeholder?: string; // Custom placeholder\n  };\n  // Color picker specific\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl'; // Color format\n    showPreview?: boolean; // Show color preview\n    presetColors?: string[]; // Preset color options\n    allowCustom?: boolean; // Allow custom colors\n  };\n  // Multi-select specific\n  multiSelectConfig?: {\n    maxSelections?: number; // Maximum selections\n    searchable?: boolean; // Enable search\n    creatable?: boolean; // Allow creating new options\n    placeholder?: string; // Placeholder text\n    noOptionsText?: string; // Text when no options\n    loadingText?: string; // Loading text\n  };\n  // Location picker specific\n  locationConfig?: {\n    apiKey?: string;\n    defaultLocation?: { lat: number; lng: number };\n    zoom?: number;\n    searchPlaceholder?: string;\n    enableSearch?: boolean;\n    enableGeolocation?: boolean;\n    mapProvider?: 'google' | 'openstreetmap';\n  };\n  // Duration picker specific\n  durationConfig?: {\n    format?: 'hms' | 'hm' | 'ms' | 'hours' | 'minutes' | 'seconds';\n    maxHours?: number;\n    maxMinutes?: number;\n    maxSeconds?: number;\n    showLabels?: boolean;\n    allowNegative?: boolean;\n  };\n  // Autocomplete specific\n  autocompleteConfig?: {\n    options?: string[] | { value: string; label: string }[] | ((values: Record<string, unknown>) => string[] | { value: string; label: string }[]);\n    asyncOptions?: (query: string) => Promise<string[] | { value: string; label: string }[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n    allowCustom?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n  // Masked input specific\n  maskedInputConfig?: {\n    mask: string | ((value: string) => string);\n    placeholder?: string;\n    showMask?: boolean;\n    guide?: boolean;\n    keepCharPositions?: boolean;\n    pipe?: (conformedValue: string, config: unknown) => false | string | { value: string; indexesOfPipedChars: number[] };\n  };\n  // Object field specific\n  objectConfig?: {\n    title?: string;\n    description?: string;\n    fields: Array<{\n      name: string;\n      type: string;\n      label?: string;\n      placeholder?: string;\n      description?: string;\n      options?: Array<{ value: string; label: string }> | ((values: Record<string, unknown>) => Array<{ value: string; label: string }>);\n      min?: number;\n      max?: number;\n      step?: number;\n      [key: string]: unknown;\n    }>;\n    collapsible?: boolean;\n    defaultExpanded?: boolean;\n    showCard?: boolean;\n    layout?: \"vertical\" | \"horizontal\" | \"grid\";\n    columns?: number;\n  };\n  // Slider field specific\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    marks?: Array<{ value: number; label: string }>;\n    showTooltip?: boolean;\n    showValue?: boolean;\n    orientation?: \"horizontal\" | \"vertical\";\n  };\n  // Number field specific\n  numberConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    precision?: number;\n    allowNegative?: boolean;\n    showSpinButtons?: boolean;\n  };\n  // Date field specific\n  dateConfig?: {\n    format?: string;\n    minDate?: Date;\n    maxDate?: Date;\n    disabledDates?: Date[];\n    showTime?: boolean;\n    timeFormat?: string;\n  };\n  // File upload specific\n  fileConfig?: {\n    accept?: string;\n    multiple?: boolean;\n    maxSize?: number;\n    maxFiles?: number;\n    allowedTypes?: string[];\n  };\n  // Textarea specific\n  textareaConfig?: {\n    rows?: number;\n    cols?: number;\n    resize?: \"none\" | \"vertical\" | \"horizontal\" | \"both\";\n    maxLength?: number;\n    showWordCount?: boolean;\n  };\n  // Password field specific\n  passwordConfig?: {\n    showToggle?: boolean;\n    strengthMeter?: boolean;\n    minStrength?: number;\n    requirements?: {\n      minLength?: number;\n      requireUppercase?: boolean;\n      requireLowercase?: boolean;\n      requireNumbers?: boolean;\n      requireSymbols?: boolean;\n    };\n  };\n  // Email field specific\n  emailConfig?: {\n    allowedDomains?: string | string[];\n    blockedDomains?: string | string[];\n    suggestions?: string | string[];\n    validateMX?: boolean;\n  };\n  // Simplified validation configuration for builder\n  validationConfig?: {\n    min?: number;\n    max?: number;\n    minLength?: number;\n    maxLength?: number;\n    pattern?: string;\n    custom?: string;\n    includes?: string;\n    startsWith?: string;\n    endsWith?: string;\n    email?: boolean;\n    url?: boolean;\n    uuid?: boolean;\n    transform?: string;\n    refine?: string;\n    customMessages?: Record<string, string>;\n  };\n}\n\ninterface PageConfig {\n  page: number;\n  title?: string;\n  description?: string;\n  component?: React.ComponentType<{ \n    children: React.ReactNode; \n    title?: string; \n    description?: string; \n    page: number;\n    totalPages: number;\n  }>;\n}\n\ninterface ProgressConfig {\n  component?: React.ComponentType<{ \n    value: number; \n    currentPage: number; \n    totalPages: number; \n    className?: string;\n  }>;\n  showSteps?: boolean;\n  showPercentage?: boolean;\n  className?: string;\n}\n\ninterface UseFormedibleOptions<TFormValues> {\n  fields?: FieldConfig[];\n  schema?: z.ZodSchema<TFormValues>;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  pages?: PageConfig[];\n  progress?: ProgressConfig;\n  tabs?: {\n    id: string;\n    label: string;\n    description?: string;\n  }[];\n  defaultComponents?: {\n    [key: string]: React.ComponentType<FieldComponentProps>;\n  };\n  globalWrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>;\n  formOptions?: Partial<{\n    defaultValues: TFormValues;\n    onSubmit: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => unknown | Promise<unknown>;\n    onSubmitInvalid: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void;\n    onChange?: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void;\n    onBlur?: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void;\n    onFocus?: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void;\n    onReset?: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void;\n    asyncDebounceMs: number;\n    canSubmitWhenInvalid: boolean;\n\n  }>;\n  onPageChange?: (page: number, direction: 'next' | 'previous') => void;\n  autoSubmitOnChange?: boolean;\n  autoSubmitDebounceMs?: number;\n  disabled?: boolean;\n  loading?: boolean;\n  resetOnSubmitSuccess?: boolean;\n  showSubmitButton?: boolean;\n  // Form-level event handlers\n  onFormReset?: (e: React.FormEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormInput?: (e: React.FormEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormInvalid?: (e: React.FormEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormKeyDown?: (e: React.KeyboardEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormKeyUp?: (e: React.KeyboardEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormFocus?: (e: React.FocusEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  onFormBlur?: (e: React.FocusEvent, formApi: FormedibleFormApi<TFormValues>) => void;\n  // Advanced validation features\n  crossFieldValidation?: {\n    fields: (keyof TFormValues)[];\n    validator: (values: Partial<TFormValues>) => string | null;\n    message: string;\n  }[];\n  asyncValidation?: {\n    [fieldName: string]: {\n      validator: (value: unknown) => Promise<string | null>;\n      debounceMs?: number;\n      loadingMessage?: string;\n    };\n  };\n  // Form analytics and tracking\n  analytics?: {\n    onFieldFocus?: (fieldName: string, timestamp: number) => void;\n    onFieldBlur?: (fieldName: string, timeSpent: number) => void;\n    onFormAbandon?: (completionPercentage: number) => void;\n    onPageChange?: (fromPage: number, toPage: number, timeSpent: number) => void;\n    onFieldChange?: (fieldName: string, value: unknown, timestamp: number) => void;\n    onFormStart?: (timestamp: number) => void;\n    onFormComplete?: (timeSpent: number, formData: Record<string, unknown>) => void;\n  };\n  // Layout configuration\n  layout?: {\n    type: 'grid' | 'flex' | 'tabs' | 'accordion' | 'stepper';\n    columns?: number;\n    gap?: string;\n    responsive?: boolean;\n    className?: string;\n  };\n  // Conditional sections\n  conditionalSections?: {\n    condition: (values: TFormValues) => boolean;\n    fields: string[];\n    layout?: {\n      type: 'grid' | 'flex' | 'tabs' | 'accordion' | 'stepper';\n      columns?: number;\n      gap?: string;\n      responsive?: boolean;\n      className?: string;\n    };\n  }[];\n  // Form persistence\n  persistence?: {\n    key: string;\n    storage: 'localStorage' | 'sessionStorage';\n    debounceMs?: number;\n    exclude?: string[];\n    restoreOnMount?: boolean;\n  };\n}\n\n// Field components with proper typing - each component accepts FieldComponentProps\nconst defaultFieldComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  number: NumberField,\n  date: DateField,\n  slider: SliderField,\n  file: FileUploadField,\n  array: ArrayField,\n  radio: RadioField,\n  multiSelect: MultiSelectField,\n  colorPicker: ColorPickerField,\n  rating: RatingField,\n  phone: PhoneField,\n  location: LocationPickerField,\n  duration: DurationPickerField,\n  autocomplete: AutocompleteField,\n  masked: MaskedInputField,\n  object: ObjectField,\n};\n\nconst DefaultProgressComponent: React.FC<{\n  value: number;\n  currentPage: number;\n  totalPages: number;\n  className?: string;\n}> = memo(({ value, currentPage, totalPages, className }) => (\n  <div className={cn(\"space-y-2\", className)}>\n    <div className=\"flex justify-between text-sm text-muted-foreground\">\n      <span>Step {currentPage} of {totalPages}</span>\n      <span>{Math.round(value)}%</span>\n    </div>\n    <Progress value={value} className=\"h-2\" />\n  </div>\n));\n\nDefaultProgressComponent.displayName = 'DefaultProgressComponent';\n\nconst DefaultPageComponent: React.FC<{\n  children: React.ReactNode;\n  title?: string;\n  description?: string;\n  page: number;\n  totalPages: number;\n}> = ({ children, title, description }) => (\n  <div className=\"space-y-6\">\n    {(title || description) && (\n      <div className=\"space-y-2\">\n        {title && <h3 className=\"text-lg font-semibold\">{title}</h3>}\n        {description && <p className=\"text-muted-foreground\">{description}</p>}\n      </div>\n    )}\n    <div className=\"space-y-4\">\n      {children}\n    </div>\n  </div>\n);\n\ninterface SectionRendererProps {\n  sectionKey: string;\n  sectionData: {\n    section?: {\n      title: string;\n      description?: string;\n      collapsible?: boolean;\n      defaultExpanded?: boolean;\n    };\n    groups: Record<string, FieldConfig[]>;\n  };\n  renderField: (field: FieldConfig) => React.ReactNode;\n}\n\nconst SectionRenderer: React.FC<SectionRendererProps> = ({ sectionKey, sectionData, renderField }) => {\n  const { section, groups } = sectionData;\n  const [isExpanded, setIsExpanded] = React.useState(\n    section?.defaultExpanded !== false\n  );\n\n  const sectionContent = (\n    <div className=\"space-y-4\">\n      {Object.entries(groups).map(([groupKey, groupFields]) => (\n        <div key={groupKey} className={cn(\n          groupKey !== 'default' ? \"p-4 border rounded-lg bg-muted/20\" : \"\"\n        )}>\n          {groupKey !== 'default' && (\n            <h4 className=\"font-medium text-sm text-muted-foreground mb-3 uppercase tracking-wide\">\n              {groupKey}\n            </h4>\n          )}\n          <div className={cn(\n            groupKey !== 'default' ? \"space-y-3\" : \"space-y-4\"\n          )}>\n            {(groupFields as FieldConfig[]).map(field => renderField(field))}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n\n  if (section && sectionKey !== 'default') {\n    return (\n      <div key={sectionKey} className=\"space-y-4\">\n        <div className=\"space-y-2\">\n          <div className=\"flex items-center justify-between\">\n            <h3 className=\"text-lg font-semibold\">{section.title}</h3>\n            {section.collapsible && (\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={() => setIsExpanded(!isExpanded)}\n                className=\"text-muted-foreground hover:text-foreground\"\n              >\n                {isExpanded ? 'Collapse' : 'Expand'}\n              </Button>\n            )}\n          </div>\n          {section.description && (\n            <p className=\"text-muted-foreground text-sm\">{section.description}</p>\n          )}\n        </div>\n        \n        {(!section.collapsible || isExpanded) && sectionContent}\n      </div>\n    );\n  }\n\n  return sectionContent;\n};\n\nexport function useFormedible<TFormValues extends Record<string, unknown>>(\n  options: UseFormedibleOptions<TFormValues>\n) {\n  const {\n    fields = [],\n\n    submitLabel = \"Submit\",\n    nextLabel = \"Next\",\n    previousLabel = \"Previous\",\n    formClassName,\n    fieldClassName,\n    pages,\n    progress,\n    tabs,\n    defaultComponents,\n    globalWrapper,\n    formOptions,\n    onPageChange,\n    autoSubmitOnChange,\n    autoSubmitDebounceMs,\n    disabled,\n    loading,\n    resetOnSubmitSuccess,\n    showSubmitButton = true,\n    onFormReset,\n    onFormInput,\n    onFormInvalid,\n    onFormKeyDown,\n    onFormKeyUp,\n    onFormFocus,\n    onFormBlur,\n    // Advanced features\n    crossFieldValidation = [],\n    asyncValidation = {},\n    analytics,\n    conditionalSections = [],\n    persistence,\n  } = options;\n\n  const [currentPage, setCurrentPage] = useState(1);\n  \n  // Advanced features state\n  const [crossFieldErrors, setCrossFieldErrors] = useState<Record<string, string>>({});\n  const [asyncValidationStates, setAsyncValidationStates] = useState<Record<string, { loading: boolean; error?: string }>>({});\n  const formStartTime = React.useRef<number>(Date.now());\n  const fieldFocusTimes = React.useRef<Record<string, number>>({});\n  const pageStartTime = React.useRef<number>(Date.now());\n\n  // Combine default components with user overrides\n  const fieldComponents = { ...defaultFieldComponents, ...defaultComponents };\n\n  // Group fields by pages\n  const fieldsByPage = useMemo(() => {\n    const grouped: { [page: number]: FieldConfig[] } = {};\n    \n    fields.forEach(field => {\n      const page = field.page || 1;\n      if (!grouped[page]) grouped[page] = [];\n      grouped[page].push(field);\n    });\n\n    return grouped;\n  }, [fields]);\n\n  // Group fields by tabs\n  const fieldsByTab = useMemo(() => {\n    const grouped: { [tab: string]: FieldConfig[] } = {};\n    \n    fields.forEach(field => {\n      const tab = field.tab || 'default';\n      if (!grouped[tab]) grouped[tab] = [];\n      grouped[tab].push(field);\n    });\n\n    return grouped;\n  }, [fields]);\n\n  const totalPages = Math.max(...Object.keys(fieldsByPage).map(Number), 1);\n  const hasPages = totalPages > 1;\n  const hasTabs = tabs && tabs.length > 0;\n\n  // Calculate progress\n  const progressValue = hasPages ? ((currentPage - 1) / (totalPages - 1)) * 100 : 100;\n\n  // Create a ref to store the form instance for the onSubmit callback\n  const formRef = React.useRef<FormedibleFormApi<TFormValues> | null>(null);\n  \n  // Refs for async validation debouncing\n  const asyncValidationTimeouts = React.useRef<Record<string, ReturnType<typeof setTimeout>>>({});\n  \n  // Keep track of AbortControllers for async validations\n  const asyncValidationAbortControllers = React.useRef<Record<string, AbortController>>({});\n  \n  // Cross-field validation function\n  const validateCrossFields = React.useCallback((values: Partial<TFormValues>) => {\n    const errors: Record<string, string> = {};\n    \n    crossFieldValidation.forEach((validation) => {\n      const relevantValues = validation.fields.reduce((acc, field) => {\n        acc[field] = values[field];\n        return acc;\n      }, {} as Partial<TFormValues>);\n      \n      const error = validation.validator(relevantValues);\n      if (error) {\n        validation.fields.forEach(field => {\n          errors[field as string] = validation.message;\n        });\n      }\n    });\n    \n    setCrossFieldErrors(errors);\n    return errors;\n  }, [crossFieldValidation]);\n  \n  // Async validation function\n  const validateFieldAsync = React.useCallback(async (fieldName: string, value: unknown) => {\n    const asyncConfig = asyncValidation[fieldName];\n    if (!asyncConfig) return;\n    \n    // Cancel any existing validation for this field\n    if (asyncValidationAbortControllers.current[fieldName]) {\n      asyncValidationAbortControllers.current[fieldName].abort();\n    }\n    \n    // Create new abort controller\n    const abortController = new AbortController();\n    asyncValidationAbortControllers.current[fieldName] = abortController;\n    \n    // Clear existing timeout\n    if (asyncValidationTimeouts.current[fieldName]) {\n      clearTimeout(asyncValidationTimeouts.current[fieldName]);\n    }\n    \n    // Set loading state\n    setAsyncValidationStates(prev => ({\n      ...prev,\n      [fieldName]: { loading: true }\n    }));\n    \n    // Debounce the validation\n    asyncValidationTimeouts.current[fieldName] = setTimeout(async () => {\n      try {\n        if (abortController.signal.aborted) return;\n        \n        const error = await asyncConfig.validator(value);\n        \n        if (abortController.signal.aborted) return;\n        \n        setAsyncValidationStates(prev => ({\n          ...prev,\n          [fieldName]: { loading: false, error: error || undefined }\n        }));\n        \n        // Update form field error if needed\n        if (formRef.current) {\n          formRef.current?.setFieldMeta(fieldName, (prev) => ({\n            ...prev,\n            errors: error ? [error] : []\n          }));\n        }\n      } catch {\n        setAsyncValidationStates(prev => ({\n          ...prev,\n          [fieldName]: { loading: false, error: 'Validation failed' }\n        }));\n      }\n    }, asyncConfig.debounceMs || 500);\n  }, [asyncValidation]);\n\n  // Setup form with schema validation if provided\n  const formConfig = {\n    ...formOptions,\n    ...(resetOnSubmitSuccess && formOptions?.onSubmit && {\n      onSubmit: async (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => {\n        // Run cross-field validation before submit\n        const crossFieldErrors = validateCrossFields(props.value as Partial<TFormValues>);\n        if (Object.keys(crossFieldErrors).length > 0) {\n          throw new Error('Cross-field validation failed');\n        }\n        \n        // Call analytics if provided\n        if (analytics?.onFormComplete) {\n          const timeSpent = Date.now() - formStartTime.current;\n          analytics.onFormComplete(timeSpent, props.value);\n        }\n        \n        const result = await formOptions.onSubmit!(props);\n        \n        // Clear storage on successful submit\n        clearStorage();\n        \n        // Reset form on successful submit if option is enabled\n        if (formRef.current) {\n          formRef.current?.reset();\n        }\n        return result;\n      }\n    })\n  };\n\n  const form = useForm(formConfig);\n\n  // Store form reference for the onSubmit callback\n  React.useEffect(() => {\n    formRef.current = form;\n  }, [form]);\n\n  // Form persistence logic\n  const persistenceTimeout = React.useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  \n  const saveToStorage = React.useCallback((values: Partial<TFormValues>) => {\n    if (!persistence) return;\n    \n    try {\n      const storage = persistence.storage === 'localStorage' ? localStorage : sessionStorage;\n      const filteredValues = persistence.exclude \n        ? Object.fromEntries(\n            Object.entries(values as Record<string, unknown>).filter(([key]) => !persistence.exclude!.includes(key))\n          )\n        : values;\n      \n      storage.setItem(persistence.key, JSON.stringify({\n        values: filteredValues,\n        timestamp: Date.now(),\n        currentPage\n      }));\n    } catch (error) {\n      console.warn('Failed to save form data to storage:', error);\n    }\n  }, [persistence, currentPage]);\n  \n  const clearStorage = React.useCallback(() => {\n    if (!persistence) return;\n    \n    try {\n      const storage = persistence.storage === 'localStorage' ? localStorage : sessionStorage;\n      storage.removeItem(persistence.key);\n    } catch (error) {\n      console.warn('Failed to clear form data from storage:', error);\n    }\n  }, [persistence]);\n  \n  const loadFromStorage = React.useCallback(() => {\n    if (!persistence?.restoreOnMount) return null;\n    \n    try {\n      const storage = persistence.storage === 'localStorage' ? localStorage : sessionStorage;\n      const saved = storage.getItem(persistence.key);\n      if (saved) {\n        const parsed = JSON.parse(saved);\n        return parsed;\n      }\n    } catch (error) {\n      console.warn('Failed to load form data from storage:', error);\n    }\n    return null;\n  }, [persistence]);\n\n  // Restore form data on mount\n  React.useEffect(() => {\n    const savedData = loadFromStorage();\n    if (savedData && savedData.values) {\n      // Restore form values\n      Object.entries(savedData.values as Record<string, unknown>).forEach(([key, value]) => {\n        try {\n          form.setFieldValue(key as keyof TFormValues & string, value as any);\n        } catch (error) {\n          console.warn(`Failed to restore field value for ${key}:`, error);\n        }\n      });\n      \n      // Restore current page if it was saved\n      if (savedData.currentPage && savedData.currentPage <= totalPages) {\n        setCurrentPage(savedData.currentPage);\n      }\n    }\n  }, [loadFromStorage, form, totalPages]);\n\n  // Set up form event listeners if provided\n  React.useEffect(() => {\n    const unsubscribers: (() => void)[] = [];\n    let autoSubmitTimeout: ReturnType<typeof setTimeout>;\n    let onChangeTimeout: ReturnType<typeof setTimeout>;\n    let onBlurTimeout: ReturnType<typeof setTimeout>;\n\n    // Call analytics onFormStart if provided\n    if (analytics?.onFormStart) {\n      analytics.onFormStart(formStartTime.current);\n    }\n\n    if (formOptions?.onChange || autoSubmitOnChange || crossFieldValidation.length > 0 || analytics || persistence) {\n      const unsubscribe = form.store.subscribe(() => {\n        const formApi = form;\n        const values = formApi.state.values;\n        \n        // Run cross-field validation on change\n        if (crossFieldValidation.length > 0) {\n          validateCrossFields(values as Partial<TFormValues>);\n        }\n        \n        // Save to storage (debounced)\n        if (persistence) {\n          clearTimeout(persistenceTimeout.current);\n          persistenceTimeout.current = setTimeout(() => {\n            saveToStorage(values as Partial<TFormValues>);\n          }, persistence.debounceMs || 1000);\n        }\n        \n        // Call user's onChange handler only if form is valid (debounced)\n        if (formOptions?.onChange && formApi.state.isValid) {\n          clearTimeout(onChangeTimeout);\n          onChangeTimeout = setTimeout(() => {\n            formOptions.onChange!({ value: values as TFormValues, formApi });\n          }, 300); // 300ms debounce\n        }\n\n        // Handle auto-submit on change\n        if (autoSubmitOnChange && !disabled && !loading) {\n          clearTimeout(autoSubmitTimeout);\n          autoSubmitTimeout = setTimeout(() => {\n            if (form.state.canSubmit) {\n              form.handleSubmit();\n            }\n          }, autoSubmitDebounceMs);\n        }\n      });\n      unsubscribers.push(unsubscribe);\n    }\n\n    // Set up onBlur event listener and analytics tracking\n    if (formOptions?.onBlur || analytics) {\n      let lastFocusedField: string | null = null;\n      \n      const handleBlur = (event: FocusEvent) => {\n        const target = event.target as HTMLElement;\n        const fieldName = target.getAttribute('name');\n        \n        if (fieldName && lastFocusedField === fieldName) {\n          // Analytics tracking\n          if (analytics?.onFieldBlur && fieldFocusTimes.current[fieldName]) {\n            const timeSpent = Date.now() - fieldFocusTimes.current[fieldName];\n            analytics.onFieldBlur(fieldName, timeSpent);\n          }\n          \n          // User's onBlur handler\n          if (formOptions?.onBlur) {\n            clearTimeout(onBlurTimeout);\n            onBlurTimeout = setTimeout(() => {\n              const formApi = form;\n              const values = formApi.state.values;\n              formOptions.onBlur!({ value: values as TFormValues, formApi });\n            }, 100); // 100ms debounce for blur\n          }\n        }\n      };\n\n      const handleFocus = (event: FocusEvent) => {\n        const target = event.target as HTMLElement;\n        const fieldName = target.getAttribute('name');\n        lastFocusedField = fieldName;\n        \n        // Analytics tracking\n        if (fieldName && analytics?.onFieldFocus) {\n          const timestamp = Date.now();\n          fieldFocusTimes.current[fieldName] = timestamp;\n          analytics.onFieldFocus(fieldName, timestamp);\n        }\n      };\n\n      const handleChange = (event: Event) => {\n        const target = event.target as HTMLElement;\n        const fieldName = target.getAttribute('name');\n        \n        if (fieldName && analytics?.onFieldChange) {\n          const value = (target as HTMLInputElement).value;\n          analytics.onFieldChange(fieldName, value, Date.now());\n          \n          // Trigger async validation if configured\n          if (asyncValidation[fieldName]) {\n            validateFieldAsync(fieldName, value);\n          }\n        }\n      };\n\n      // Add event listeners to document for blur/focus/change events\n      document.addEventListener('blur', handleBlur, true);\n      document.addEventListener('focus', handleFocus, true);\n      document.addEventListener('change', handleChange, true);\n      document.addEventListener('input', handleChange, true);\n      \n      unsubscribers.push(() => {\n        document.removeEventListener('blur', handleBlur, true);\n        document.removeEventListener('focus', handleFocus, true);\n        document.removeEventListener('change', handleChange, true);\n        document.removeEventListener('input', handleChange, true);\n      });\n    }\n\n    // Clean up timeouts on unmount\n    unsubscribers.push(() => {\n      clearTimeout(autoSubmitTimeout);\n      clearTimeout(onChangeTimeout);\n      clearTimeout(onBlurTimeout);\n      clearTimeout(persistenceTimeout.current);\n      // Clear async validation timeouts\n      Object.values(asyncValidationTimeouts.current).forEach(timeout => {\n        clearTimeout(timeout);\n      });\n      \n      // Cancel all in-flight async validations\n      Object.values(asyncValidationAbortControllers.current).forEach(controller => {\n        controller.abort();\n      });\n    });\n\n    return () => {\n      unsubscribers.forEach(unsub => unsub());\n    };\n  }, [\n    form, \n    autoSubmitOnChange, \n    autoSubmitDebounceMs, \n    disabled, \n    loading, \n    formOptions?.onChange, \n    formOptions?.onBlur,\n    crossFieldValidation,\n    analytics,\n    asyncValidation,\n    validateFieldAsync,\n    persistence,\n    saveToStorage,\n    currentPage,\n    validateCrossFields\n  ]);\n\n  const getCurrentPageFields = () => {\n    if (hasTabs) {\n      // When using tabs, return all fields (tabs handle their own filtering)\n      return fields;\n    }\n    return fieldsByPage[currentPage] || [];\n  };\n\n  const getCurrentPageConfig = () => pages?.find(p => p.page === currentPage);\n\n  const goToNextPage = () => {\n    if (currentPage < totalPages) {\n      // Check if current page has validation errors\n      const currentPageFields = getCurrentPageFields();\n      const formState = form.state;\n      \n      const hasPageErrors = currentPageFields.some(field => {\n        const fieldState = formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n        return fieldState && fieldState.errors && fieldState.errors.length > 0;\n      });\n\n      if (hasPageErrors) {\n        // Mark all fields on current page as touched to show validation errors\n        currentPageFields.forEach(field => {\n          form.setFieldMeta(field.name, (prev) => ({ ...prev, isTouched: true }));\n        });\n        return; // Don't navigate if there are errors\n      }\n\n      const newPage = currentPage + 1;\n      \n      // Analytics tracking\n      if (analytics?.onPageChange) {\n        const timeSpent = Date.now() - pageStartTime.current;\n        analytics.onPageChange(currentPage, newPage, timeSpent);\n      }\n      \n      setCurrentPage(newPage);\n      pageStartTime.current = Date.now();\n      onPageChange?.(newPage, 'next');\n    }\n  };\n\n  const goToPreviousPage = () => {\n    if (currentPage > 1) {\n      const newPage = currentPage - 1;\n      \n      // Analytics tracking\n      if (analytics?.onPageChange) {\n        const timeSpent = Date.now() - pageStartTime.current;\n        analytics.onPageChange(currentPage, newPage, timeSpent);\n      }\n      \n      setCurrentPage(newPage);\n      pageStartTime.current = Date.now();\n      onPageChange?.(newPage, 'previous');\n    }\n  };\n\n  const isLastPage = currentPage === totalPages;\n  const isFirstPage = currentPage === 1;\n\n  // Validated setCurrentPage that checks all pages between current and target\n  const setCurrentPageWithValidation = (targetPage: number) => {\n    if (targetPage < 1 || targetPage > totalPages || targetPage === currentPage) {\n      return;\n    }\n\n    // If going forward, validate all pages between current and target\n    if (targetPage > currentPage) {\n      for (let page = currentPage; page < targetPage; page++) {\n        const pageFields = fieldsByPage[page] || [];\n        const formState = form.state;\n        \n        const hasPageErrors = pageFields.some(field => {\n        const fieldState = formState.fieldMeta[field.name as keyof typeof formState.fieldMeta];\n          return fieldState && fieldState.errors && fieldState.errors.length > 0;\n        });\n\n        if (hasPageErrors) {\n          // Mark all fields on this page as touched to show validation errors\n          pageFields.forEach(field => {\n            form.setFieldMeta(field.name, (prev) => ({ ...prev, isTouched: true }));\n          });\n          return; // Don't navigate if there are errors\n        }\n      }\n    }\n\n    // If validation passes or going backward, allow navigation\n    setCurrentPage(targetPage);\n    onPageChange?.(targetPage, targetPage > currentPage ? 'next' : 'previous');\n  };\n\n  const Form: React.FC<FormProps> = ({ \n    className, \n    children, \n    onSubmit,\n    // HTML form attributes\n    action,\n    method,\n    encType,\n    target,\n    autoComplete,\n    noValidate,\n    acceptCharset,\n    // Event handlers\n    onReset,\n    onInput,\n    onInvalid,\n    onKeyDown,\n    onKeyUp,\n\n    onFocus,\n    onBlur,\n    // Accessibility\n    role,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby,\n    'aria-describedby': ariaDescribedby,\n    tabIndex,\n  }) => {\n    const handleSubmit = (e: React.FormEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (onSubmit) {\n        onSubmit(e);\n      } else if (isLastPage) {\n        form.handleSubmit();\n      } else {\n        goToNextPage();\n      }\n    };\n\n    const handleReset = (e: React.FormEvent) => {\n      if (onReset) {\n        onReset(e);\n      }\n      if (onFormReset) {\n        onFormReset(e, form);\n      }\n      form.reset();\n    };\n\n    const handleInput = (e: React.FormEvent) => {\n      if (onInput) {\n        onInput(e);\n      }\n      if (onFormInput) {\n        onFormInput(e, form);\n      }\n    };\n\n    const handleInvalid = (e: React.FormEvent) => {\n      if (onInvalid) {\n        onInvalid(e);\n      }\n      if (onFormInvalid) {\n        onFormInvalid(e, form);\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n      if (onFormKeyDown) {\n        onFormKeyDown(e, form);\n      }\n    };\n\n    const handleKeyUp = (e: React.KeyboardEvent) => {\n      if (onKeyUp) {\n        onKeyUp(e);\n      }\n      if (onFormKeyUp) {\n        onFormKeyUp(e, form);\n      }\n    };\n\n    // Tab state for controlled FormTabs component\n    const [activeTab, setActiveTab] = useState(() => {\n      if (tabs && tabs.length > 0) return tabs[0].id;\n      return '';\n    });\n\n\n\n    const handleFocus = (e: React.FocusEvent) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      if (onFormFocus) {\n        onFormFocus(e, form);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      if (onFormBlur) {\n        onFormBlur(e, form);\n      }\n    };\n\n    const formClass = cn(\"space-y-6\", formClassName, className);\n\n    // Helper function to resolve options (static or dynamic)\n    const resolveOptions = React.useCallback((options: FieldConfig['options'], currentValues: Record<string, unknown>) => {\n      if (typeof options === 'function') {\n        return options(currentValues);\n      }\n      return options;\n    }, []);\n\n    const renderField = React.useCallback((fieldConfig: FieldConfig) => {\n      const { \n        name, \n        type, \n        label, \n        placeholder, \n        description, \n        options,\n        min,\n        max,\n        step,\n        accept,\n        multiple,\n        component: CustomComponent,\n        wrapper: CustomWrapper,\n        validation,\n        arrayConfig,\n        datalist,\n        help,\n        inlineValidation,\n\n        ratingConfig,\n        phoneConfig,\n        colorConfig,\n        multiSelectConfig,\n        locationConfig,\n        durationConfig,\n        autocompleteConfig,\n        maskedInputConfig,\n        objectConfig,\n        sliderConfig,\n        numberConfig,\n        dateConfig,\n        fileConfig,\n        textareaConfig,\n        passwordConfig,\n        emailConfig\n      } = fieldConfig;\n\n      return (\n        <form.Field \n          key={name} \n          name={name as keyof TFormValues & string}\n          validators={validation ? { \n            onChange: ({ value }) => {\n              const result = validation.safeParse(value);\n              return result.success ? undefined : result.error.errors[0]?.message || 'Invalid value';\n            }\n          } : undefined}\n        >\n          {(field) => {\n            // TanStack Form Best Practice: Use FieldConditionalRenderer to prevent parent re-renders\n            return (\n              <FieldConditionalRenderer\n                form={form}\n                fieldConfig={fieldConfig}\n              >\n                {(shouldRender) => {\n                  if (!shouldRender) {\n                    return null;\n                  }\n\n                  // Subscribe to form values for dynamic options\n                  return (\n                    <form.Subscribe\n                      selector={(state: any) => state.values}\n                    >\n                      {(currentValues: any) => {\n                        // Check for cross-field validation errors\n                        const crossFieldError = crossFieldErrors[name];\n                        const asyncValidationState = asyncValidationStates[name];\n\n                        // Resolve options (static or dynamic)\n                        const resolvedOptions = resolveOptions(options, currentValues);\n            \n                        const baseProps = {\n                          fieldApi: field,\n                          label,\n                          placeholder,\n                          description,\n                          wrapperClassName: fieldClassName,\n                          min,\n                          max,\n                          step,\n                          accept,\n                          multiple,\n                          disabled: disabled || loading || field.form.state.isSubmitting,\n                          crossFieldError,\n                          asyncValidationState,\n                        };\n\n                        // Select the component to use\n                        const FieldComponent = CustomComponent || fieldComponents[type] || TextField;\n\n                        // Add type-specific props\n                        let props: FieldComponentProps = { ...baseProps };\n                        \n                        // Normalize options to the expected format\n                        const normalizedOptions = resolvedOptions ? resolvedOptions.map(opt => \n                          typeof opt === 'string' ? { value: opt, label: opt } : opt\n                        ) : [];\n\n                        if (type === 'select') {\n                          props = { ...props, options: normalizedOptions };\n                        } else if (type === 'array') {\n                          const mappedArrayConfig = arrayConfig ? {\n                            itemType: arrayConfig.itemType || 'text',\n                            itemLabel: arrayConfig.itemLabel,\n                            itemPlaceholder: arrayConfig.itemPlaceholder,\n                            minItems: arrayConfig.minItems,\n                            maxItems: arrayConfig.maxItems,\n                            itemValidation: arrayConfig.itemValidation,\n                            itemComponent: arrayConfig.itemComponent as React.ComponentType<BaseFieldProps>,\n                            addButtonLabel: arrayConfig.addButtonLabel,\n                            removeButtonLabel: arrayConfig.removeButtonLabel,\n                            sortable: arrayConfig.sortable,\n                            defaultValue: arrayConfig.defaultValue\n                          } : undefined;\n                          props = { ...props, arrayConfig: mappedArrayConfig };\n                        } else if (['text', 'email', 'password', 'url', 'tel'].includes(type)) {\n                          props = { ...props, type: type as 'text' | 'email' | 'password' | 'url' | 'tel', datalist: datalist?.options };\n                        } else if (type === 'radio') {\n                          props = { ...props, options: normalizedOptions };\n                        } else if (type === 'multiSelect') {\n                          props = { ...props, options: normalizedOptions, multiSelectConfig };\n                        } else if (type === 'colorPicker') {\n                          props = { ...props, colorConfig };\n                        } else if (type === 'rating') {\n                          props = { ...props, ratingConfig };\n                        } else if (type === 'phone') {\n                          props = { ...props, phoneConfig };\n                        } else if (type === 'location') {\n                          props = { ...props, locationConfig };\n                        } else if (type === 'duration') {\n                          props = { ...props, durationConfig };\n                        } else if (type === 'autocomplete') {\n                          // Handle dynamic options for autocomplete\n                          const resolvedAutocompleteConfig = autocompleteConfig ? {\n                            ...autocompleteConfig,\n                            options: resolveOptions(autocompleteConfig.options, currentValues)\n                          } : undefined;\n                          props = { ...props, autocompleteConfig: resolvedAutocompleteConfig };\n                        } else if (type === 'masked') {\n                          props = { ...props, maskedInputConfig };\n                        } else if (type === 'object') {\n                          props = { ...props, objectConfig };\n                        } else if (type === 'slider') {\n                          props = { ...props, sliderConfig };\n                        } else if (type === 'number') {\n                          props = { ...props, numberConfig };\n                        } else if (type === 'date') {\n                          props = { ...props, dateConfig };\n                        } else if (type === 'file') {\n                          props = { ...props, fileConfig };\n                        } else if (type === 'textarea') {\n                          props = { ...props, textareaConfig };\n                        } else if (type === 'password') {\n                          props = { ...props, passwordConfig };\n                        } else if (type === 'email') {\n                          props = { ...props, emailConfig };\n                        }\n\n                        // Render the field component\n                        const fieldElement = <FieldComponent {...props} />;\n\n                        // Apply inline validation wrapper if enabled\n                        const wrappedFieldElement = inlineValidation?.enabled \n                          ? (\n                              <InlineValidationWrapper\n                                fieldApi={field}\n                                inlineValidation={inlineValidation}\n                              >\n                                {fieldElement}\n                              </InlineValidationWrapper>\n                            )\n                          : fieldElement;\n\n                        // Add field help if provided\n                        const fieldWithHelp = help ? (\n                          <div className=\"space-y-2\">\n                            {wrappedFieldElement}\n                            <FieldHelp help={help} />\n                          </div>\n                        ) : wrappedFieldElement;\n\n                        // Apply custom wrapper or global wrapper\n                        const Wrapper = CustomWrapper || globalWrapper;\n                        \n                        return Wrapper \n                          ? <Wrapper field={fieldConfig}>{fieldWithHelp}</Wrapper>\n                          : fieldWithHelp;\n                      }}\n                    </form.Subscribe>\n                  );\n                }}\n              </FieldConditionalRenderer>\n            );\n          }}\n        </form.Field>\n      );\n    }, [resolveOptions]);\n\n    const renderTabContent = React.useCallback((tabFields: FieldConfig[]) => {\n      // TanStack Form Best Practice: Use reusable subscription component\n      return (\n        <ConditionalFieldsSubscription\n          form={form}\n          fields={tabFields}\n          conditionalSections={conditionalSections}\n        >\n          {(currentValues) => {\n            // Filter fields based on conditional sections using subscribed values\n            const visibleFields = tabFields.filter(field => {\n              const conditionalSection = conditionalSections.find(section => \n                section.fields.includes(field.name)\n              );\n              \n              if (conditionalSection) {\n                return conditionalSection.condition(currentValues as TFormValues);\n              }\n              \n              return true;\n            });\n            \n            // Group fields by section and group\n            const groupedFields = visibleFields.reduce((acc, field) => {\n              const sectionKey = field.section?.title || 'default';\n              const groupKey = field.group || 'default';\n              \n              if (!acc[sectionKey]) {\n                acc[sectionKey] = {\n                  section: field.section,\n                  groups: {}\n                };\n              }\n              \n              if (!acc[sectionKey].groups[groupKey]) {\n                acc[sectionKey].groups[groupKey] = [];\n              }\n              \n              acc[sectionKey].groups[groupKey].push(field);\n              return acc;\n            }, {} as Record<string, { section?: { title: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\n\n            const renderSection = (sectionKey: string, sectionData: { section?: { title: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }) => (\n              <SectionRenderer\n                key={sectionKey}\n                sectionKey={sectionKey}\n                sectionData={sectionData}\n                renderField={renderField}\n              />\n            );\n\n            const sectionsToRender = Object.entries(groupedFields);\n            \n            return sectionsToRender.length === 1 && sectionsToRender[0][0] === 'default' \n              ? sectionsToRender[0][1].groups.default?.map((field: FieldConfig) => renderField(field))\n              : sectionsToRender.map(([sectionKey, sectionData]) => \n                  renderSection(sectionKey, sectionData)\n                );\n          }}\n        </ConditionalFieldsSubscription>\n      );\n    }, [renderField]);\n\n    const renderPageContent = React.useCallback(() => {\n      if (hasTabs) {\n        // Render tabs - memoize tab content to prevent rerenders\n        const tabsToRender = tabs!.map(tab => ({\n          id: tab.id,\n          label: tab.label,\n          content: renderTabContent(fieldsByTab[tab.id] || [])\n        }));\n\n        return (\n          <FormTabs\n            tabs={tabsToRender}\n            activeTab={activeTab}\n            onTabChange={setActiveTab}\n          />\n        );\n      }\n\n      // Original page rendering logic with TanStack Form best practices\n      const currentFields = getCurrentPageFields();\n      const pageConfig = getCurrentPageConfig();\n      \n      // For now, subscribe to all form values since we don't have explicit dependencies\n      // This could be optimized further by analyzing the condition functions\n\n      // TanStack Form Best Practice: Use targeted selector for minimal re-renders\n      return (\n        <form.Subscribe\n          selector={(state: any) => state.values}\n        >\n          {(currentValues: any) => {\n            // Filter fields based on conditional sections using subscribed values\n            const visibleFields = currentFields.filter(field => {\n              const conditionalSection = conditionalSections.find(section => \n                section.fields.includes(field.name)\n              );\n              \n              if (conditionalSection) {\n                return conditionalSection.condition(currentValues as TFormValues);\n              }\n              \n              return true;\n            });\n            \n            // Group fields by section and group\n            const groupedFields = visibleFields.reduce((acc, field) => {\n              const sectionKey = field.section?.title || 'default';\n              const groupKey = field.group || 'default';\n              \n              if (!acc[sectionKey]) {\n                acc[sectionKey] = {\n                  section: field.section,\n                  groups: {}\n                };\n              }\n              \n              if (!acc[sectionKey].groups[groupKey]) {\n                acc[sectionKey].groups[groupKey] = [];\n              }\n              \n              acc[sectionKey].groups[groupKey].push(field);\n              return acc;\n            }, {} as Record<string, { section?: { title: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }>);\n\n            const renderSection = (sectionKey: string, sectionData: { section?: { title: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean }; groups: Record<string, FieldConfig[]> }) => (\n              <SectionRenderer\n                key={sectionKey}\n                sectionKey={sectionKey}\n                sectionData={sectionData}\n                renderField={renderField}\n              />\n            );\n\n            const sectionsToRender = Object.entries(groupedFields);\n            \n            const PageComponent = pageConfig?.component || DefaultPageComponent;\n\n            return (\n              <PageComponent\n                title={pageConfig?.title}\n                description={pageConfig?.description}\n                page={currentPage}\n                totalPages={totalPages}\n              >\n                {sectionsToRender.length === 1 && sectionsToRender[0][0] === 'default' \n                               ? sectionsToRender[0][1].groups.default?.map((field: FieldConfig) => renderField(field))\n                  : sectionsToRender.map(([sectionKey, sectionData]) => \n                      renderSection(sectionKey, sectionData)\n                    )\n                }\n              </PageComponent>\n            );\n          }}\n        </form.Subscribe>\n      );\n    }, [renderTabContent, renderField, activeTab, setActiveTab, hasTabs, tabs]);\n\n    const renderProgress = () => {\n      if (!hasPages || !progress) return null;\n\n      const ProgressComponent = progress.component || DefaultProgressComponent;\n      \n      return (\n        <ProgressComponent\n          value={progressValue}\n          currentPage={currentPage}\n          totalPages={totalPages}\n          className={progress.className}\n        />\n      );\n    };\n\n    const renderNavigation = () => {\n      if (!showSubmitButton) return null;\n      if (!hasPages) {\n        return (\n          <form.Subscribe\n            selector={(state) => ({\n              canSubmit: state.canSubmit,\n              isSubmitting: state.isSubmitting,\n            })}\n          >\n            {(state) => {\n              const { canSubmit, isSubmitting } = state as { canSubmit: boolean; isSubmitting: boolean };\n              return (\n                <Button\n                  type=\"submit\"\n                  disabled={!canSubmit || isSubmitting || disabled || loading}\n                  className=\"w-full\"\n                >\n                  {loading ? \"Loading...\" : isSubmitting ? \"Submitting...\" : submitLabel}\n                </Button>\n              );\n            }}\n          </form.Subscribe>\n        );\n      }\n\n      return (\n        <form.Subscribe\n          selector={(state) => ({\n            canSubmit: state.canSubmit,\n            isSubmitting: state.isSubmitting,\n          })}\n        >\n          {(state) => {\n            const { canSubmit, isSubmitting } = state as { canSubmit: boolean; isSubmitting: boolean };\n            return (\n              <div className=\"flex justify-between gap-4\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={goToPreviousPage}\n                  disabled={isFirstPage || disabled || loading}\n                  className={isFirstPage ? \"invisible\" : \"\"}\n                >\n                  {previousLabel}\n                </Button>\n                \n                <Button\n                  type=\"submit\"\n                  disabled={(!canSubmit || isSubmitting || disabled || loading) && isLastPage}\n                  className=\"flex-1 max-w-xs\"\n                >\n                  {loading && isLastPage\n                    ? \"Loading...\"\n                    : isSubmitting && isLastPage\n                    ? \"Submitting...\"\n                    : isLastPage\n                    ? submitLabel\n                    : nextLabel}\n                </Button>\n              </div>\n            );\n          }}\n        </form.Subscribe>\n      );\n    };\n\n          return (\n        <form \n          onSubmit={handleSubmit} \n          className={formClass}\n          action={action}\n          method={method}\n          encType={encType}\n          target={target}\n          autoComplete={autoComplete}\n          noValidate={noValidate}\n          acceptCharset={acceptCharset}\n          onReset={handleReset}\n          onInput={handleInput}\n          onInvalid={handleInvalid}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n          role={role}\n          aria-label={ariaLabel}\n          aria-labelledby={ariaLabelledby}\n          aria-describedby={ariaDescribedby}\n          tabIndex={tabIndex}\n        >\n        {children || (\n          <>\n            {renderProgress()}\n            {renderPageContent()}\n            {renderNavigation()}\n          </>\n        )}\n      </form>\n    );\n  };\n\n  return {\n    form,\n    Form,\n    currentPage,\n    totalPages,\n    goToNextPage,\n    goToPreviousPage,\n    setCurrentPage: setCurrentPageWithValidation,\n    isFirstPage,\n    isLastPage,\n    progressValue,\n    // Advanced features\n    crossFieldErrors,\n    asyncValidationStates,\n    validateCrossFields,\n    validateFieldAsync,\n    saveToStorage,\n    loadFromStorage,\n    clearStorage,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-formedible.tsx"
    },
    {
      "path": "src/lib/formedible/types.ts",
      "content": "import React from 'react';\nimport type { AnyFieldApi } from '@tanstack/react-form';\nimport type { FormApi, ValidationError, FormState } from '@tanstack/form-core';\n\n// Strict type definitions for better type safety\nexport interface StrictFieldApi<T = unknown> {\n  name: string;\n  value: T;\n  errors: ValidationError[];\n  touched: boolean;\n  setValue: (value: T) => void;\n  setTouched: (touched: boolean) => void;\n  validate: () => Promise<ValidationError[]>;\n}\n\nexport interface TypedFormState<TFormData = Record<string, unknown>> {\n  values: TFormData;\n  errors: Record<keyof TFormData, ValidationError[]>;\n  touched: Record<keyof TFormData, boolean>;\n  isSubmitting: boolean;\n  isValidating: boolean;\n  canSubmit: boolean;\n}\n\nexport interface TypedFormSubscriptionSelector<TFormData = Record<string, unknown>, TSelected = unknown> {\n  (state: FormState<TFormData, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined>): TSelected;\n}\n\n// Validation error types based on TanStack Form\nexport type FormedibleValidationError = ValidationError;\n\n// Validation error that can be a string, Error object, or custom validation result\nexport type FieldValidationError = string | Error | ValidationError;\n\n// Array of validation errors for a field\nexport type FieldValidationErrors = FieldValidationError[];\n\n// Type alias for our FormApi - use the core FormApi type which is what useForm actually returns\nexport type FormedibleFormApi<TFormData = Record<string, unknown>> = FormApi<\n  TFormData,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  undefined\n>;\n\n// Option types for select, radio, and multi-select fields\nexport type FieldOption = {\n  value: string;\n  label: string;\n  disabled?: boolean;\n  description?: string;\n};\n\nexport type FieldOptions = string[] | FieldOption[];\n\n// Normalize options to consistent format\nexport type NormalizedFieldOption = FieldOption;\n\n// Props that all basic field components rendered by FormedibleRoot will receive\nexport interface BaseFieldProps {\n  fieldApi: AnyFieldApi;\n  label?: string;\n  description?: string;\n  placeholder?: string;\n  inputClassName?: string;   // For the <Input /> component itself\n  labelClassName?: string;   // For the <Label /> component\n  wrapperClassName?: string; // For the div wrapping label and input\n}\n\n// Specific field component prop types\nexport interface SelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n}\n\nexport interface RadioFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n}\n\nexport interface MultiSelectFieldProps extends BaseFieldProps {\n  options: FieldOptions;\n  placeholder?: string;\n  maxSelections?: number;\n}\n\nexport interface ArrayFieldProps extends BaseFieldProps {\n  arrayConfig: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    itemComponent?: React.ComponentType<BaseFieldProps>;\n    itemProps?: Record<string, unknown>;\n  };\n}\n\nexport interface TextFieldProps extends BaseFieldProps {\n  type?: 'text' | 'email' | 'password' | 'url' | 'tel';\n  datalist?: string[];\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  autoComplete?: string;\n}\n\nexport interface NumberFieldProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  precision?: number;\n}\n\nexport interface DateFieldProps extends BaseFieldProps {\n  dateConfig?: {\n    format?: string;\n    minDate?: Date;\n    maxDate?: Date;\n    disabledDates?: Date[];\n    showTime?: boolean;\n    timeFormat?: string;\n  };\n}\n\nexport interface SliderFieldProps extends BaseFieldProps {\n  sliderConfig?: {\n    min?: number;\n    max?: number;\n    step?: number;\n    showValue?: boolean;\n    showTicks?: boolean;\n    orientation?: 'horizontal' | 'vertical';\n  };\n}\n\nexport interface FileUploadFieldProps extends BaseFieldProps {\n  fileConfig?: {\n    accept?: string;\n    multiple?: boolean;\n    maxSize?: number;\n    maxFiles?: number;\n    allowedTypes?: string[];\n    uploadUrl?: string;\n    onUpload?: (files: File[]) => Promise<string[]>;\n  };\n}\n\nexport interface LocationPickerFieldProps extends BaseFieldProps {\n  locationConfig?: LocationConfig;\n}\n\nexport interface DurationPickerFieldProps extends BaseFieldProps {\n  durationConfig?: DurationConfig;\n}\n\nexport interface AutocompleteFieldProps extends BaseFieldProps {\n  autocompleteConfig?: AutocompleteConfig;\n}\n\nexport interface MaskedInputFieldProps extends BaseFieldProps {\n  maskedConfig?: MaskedInputConfig;\n}\n\nexport interface ColorPickerFieldProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showAlpha?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n  };\n}\n\nexport interface RatingFieldProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    allowClear?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs' | React.ComponentType;\n    size?: 'sm' | 'md' | 'lg' | 'small' | 'medium' | 'large';\n    showValue?: boolean;\n  };\n}\n\nexport interface PhoneFieldProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    preferredCountries?: string[];\n    onlyCountries?: string[];\n    excludeCountries?: string[];\n    format?: 'national' | 'international';\n  };\n}\n\n// Union type for all possible field component props - using intersection for flexibility\nexport type FieldComponentProps = BaseFieldProps & {\n  // Optional props that specific field types might need\n  options?: FieldOptions;\n  arrayConfig?: ArrayFieldProps['arrayConfig'];\n  type?: TextFieldProps['type'];\n  datalist?: string[];\n  dateConfig?: DateFieldProps['dateConfig'];\n  sliderConfig?: SliderFieldProps['sliderConfig'];\n  fileConfig?: FileUploadFieldProps['fileConfig'];\n  locationConfig?: LocationPickerFieldProps['locationConfig'];\n  durationConfig?: DurationPickerFieldProps['durationConfig'];\n  autocompleteConfig?: AutocompleteFieldProps['autocompleteConfig'];\n  maskedConfig?: MaskedInputFieldProps['maskedConfig'];\n  colorConfig?: ColorPickerFieldProps['colorConfig'];\n  ratingConfig?: RatingFieldProps['ratingConfig'];\n  phoneConfig?: PhoneFieldProps['phoneConfig'];\n  // Legacy support for existing configurations\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n  maskedInputConfig?: MaskedInputConfig;\n  // Allow additional props for extensibility\n  [key: string]: unknown;\n};\n\n// Cross-field validation configuration\nexport interface CrossFieldValidation<TFormValues = Record<string, unknown>> {\n  fields: (keyof TFormValues)[];\n  validator: (values: Partial<TFormValues>) => string | null;\n  message: string;\n}\n\n// Async validation configuration\nexport interface AsyncValidation {\n  validator: (value: unknown) => Promise<string | null>;\n  debounceMs?: number;\n  loadingMessage?: string;\n}\n\n// Form analytics and tracking configuration\nexport interface FormAnalytics {\n  onFieldFocus?: (fieldName: string, timestamp: number) => void;\n  onFieldBlur?: (fieldName: string, timeSpent: number) => void;\n  onFormAbandon?: (completionPercentage: number) => void;\n  onPageChange?: (fromPage: number, toPage: number, timeSpent: number) => void;\n  onFieldChange?: (fieldName: string, value: unknown, timestamp: number) => void;\n  onFormComplete?: (timeSpent: number, formData: unknown) => void;\n}\n\n// Layout configuration for forms\nexport interface LayoutConfig {\n  type: 'grid' | 'flex' | 'tabs' | 'accordion' | 'stepper';\n  columns?: number;\n  gap?: string;\n  responsive?: boolean;\n  className?: string;\n}\n\n// Conditional sections configuration\nexport interface ConditionalSection<TFormValues = Record<string, unknown>> {\n  condition: (values: TFormValues) => boolean;\n  fields: string[];\n  layout?: LayoutConfig;\n}\n\n// Location picker configuration\nexport interface LocationConfig {\n  apiKey?: string;\n  defaultLocation?: { lat: number; lng: number };\n  zoom?: number;\n  searchPlaceholder?: string;\n  enableSearch?: boolean;\n  enableGeolocation?: boolean;\n  mapProvider?: 'google' | 'openstreetmap';\n}\n\n// Duration picker configuration\nexport interface DurationConfig {\n  format?: 'hms' | 'hm' | 'ms' | 'hours' | 'minutes' | 'seconds';\n  maxHours?: number;\n  maxMinutes?: number;\n  maxSeconds?: number;\n  showLabels?: boolean;\n  allowNegative?: boolean;\n}\n\n// Autocomplete configuration\nexport interface AutocompleteConfig {\n  options?: string[] | { value: string; label: string }[];\n  asyncOptions?: (query: string) => Promise<string[] | { value: string; label: string }[]>;\n  debounceMs?: number;\n  minChars?: number;\n  maxResults?: number;\n  allowCustom?: boolean;\n  placeholder?: string;\n  noOptionsText?: string;\n  loadingText?: string;\n}\n\n// Masked input configuration\nexport interface MaskedInputConfig {\n  mask: string | ((value: string) => string);\n  placeholder?: string;\n  showMask?: boolean;\n  guide?: boolean;\n  keepCharPositions?: boolean;\n  pipe?: (conformedValue: string, config: unknown) => false | string | { value: string; indexesOfPipedChars: number[] };\n} ",
      "type": "registry:hook",
      "target": "lib/formedible/types.ts"
    },
    {
      "path": "src/components/formedible/fields/array-field.tsx",
      "content": "'use client';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { Button } from '@/components/ui/button';\n\nimport { Plus, Trash2, GripVertical } from 'lucide-react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\nimport { TextField } from './text-field';\nimport { NumberField } from './number-field';\nimport { TextareaField } from './textarea-field';\nimport { SelectField } from './select-field';\nimport { CheckboxField } from './checkbox-field';\nimport { SwitchField } from './switch-field';\nimport { DateField } from './date-field';\nimport { SliderField } from './slider-field';\nimport { FileUploadField } from './file-upload-field';\n\n// Map of field types to components\nconst fieldTypeComponents: Record<string, React.ComponentType<any>> = {\n  text: TextField,\n  email: TextField,\n  password: TextField,\n  url: TextField,\n  tel: TextField,\n  number: NumberField,\n  textarea: TextareaField,\n  select: SelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  date: DateField,\n  slider: SliderField,\n  file: FileUploadField,\n};\n\nexport interface ArrayFieldSpecificProps extends BaseFieldProps {\n  arrayConfig: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    itemComponent?: React.ComponentType<any>;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    // Additional props to pass to item components\n    itemProps?: Record<string, unknown>;\n  };\n}\n\nexport const ArrayField: React.FC<ArrayFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  arrayConfig,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  \n  const value = useMemo(() => (fieldApi.state?.value as unknown[]) || [], [fieldApi.state?.value]);\n  \n  const {\n    itemType,\n    itemLabel,\n    itemPlaceholder,\n    minItems = 0,\n    maxItems = 10,\n    addButtonLabel = \"Add Item\",\n    removeButtonLabel = \"Remove\",\n    itemComponent: CustomItemComponent,\n    sortable = false,\n    defaultValue = '',\n    itemProps = {},\n  } = arrayConfig || {};\n\n  // Get the component for rendering items\n  const ItemComponent = CustomItemComponent || fieldTypeComponents[itemType || 'text'] || TextField;\n\n  const addItem = useCallback(() => {\n    if (value.length >= maxItems) return;\n    \n    const newValue = [...value, defaultValue];\n    fieldApi.handleChange(newValue);\n  }, [value, maxItems, defaultValue, fieldApi.handleChange]);\n\n  const removeItem = useCallback((index: number) => {\n    if (value.length <= minItems) return;\n    \n    const newValue = value.filter((_, i) => i !== index);\n    fieldApi.handleChange(newValue);\n    fieldApi.handleBlur();\n  }, [value, minItems, fieldApi.handleChange, fieldApi.handleBlur]);\n\n  const updateItem = useCallback((index: number, newItemValue: unknown) => {\n    const newValue = [...value];\n    newValue[index] = newItemValue;\n    fieldApi.handleChange(newValue);\n  }, [value, fieldApi.handleChange]);\n\n  const moveItem = useCallback((fromIndex: number, toIndex: number) => {\n    if (!sortable) return;\n    if (fromIndex === toIndex) return;\n    \n    const newValue = [...value];\n    const [movedItem] = newValue.splice(fromIndex, 1);\n    newValue.splice(toIndex, 0, movedItem);\n    fieldApi.handleChange(newValue);\n  }, [value, fieldApi.handleChange, sortable]);\n\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\n\n\n\n  // Create a mock field API for each item\n  const createItemFieldApi = useCallback((index: number) => {\n    return {\n      name: `${name}[${index}]`,\n      state: {\n        value: value[index],\n        meta: {\n          errors: [],\n          isTouched: false,\n          isValidating: false,\n        },\n      },\n      handleChange: (newValue: unknown) => updateItem(index, newValue),\n      handleBlur: () => fieldApi.handleBlur(),\n      form: fieldApi.form,\n    };\n  }, [name, value, updateItem, fieldApi.handleBlur, fieldApi.form]);\n\n  const canAddMore = value.length < maxItems;\n  const canRemove = value.length > minItems;\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-4\">\n        <div className=\"space-y-3\">\n          {value.map((_, index) => (\n              <div\n                key={index}\n                className=\"flex items-start gap-2 p-3 border rounded-lg bg-card\"\n                onDragOver={sortable ? (e) => {\n                  e.preventDefault();\n                  e.dataTransfer.dropEffect = 'move';\n                } : undefined}\n                onDrop={sortable ? (e) => {\n                  e.preventDefault();\n                  if (draggedIndex !== null && draggedIndex !== index) {\n                    moveItem(draggedIndex, index);\n                  }\n                } : undefined}\n              >\n                {sortable && (\n                  <button\n                    type=\"button\"\n                    className=\"mt-2 p-1 hover:bg-muted rounded cursor-grab active:cursor-grabbing\"\n                    draggable\n                    onDragStart={(e) => {\n                      setDraggedIndex(index);\n                      e.dataTransfer.effectAllowed = 'move';\n                    }}\n                    onDragEnd={() => {\n                      setDraggedIndex(null);\n                    }}\n                    disabled={isDisabled}\n                  >\n                    <GripVertical className=\"h-4 w-4 text-muted-foreground\" />\n                  </button>\n                )}\n                \n                <div className=\"flex-1\">\n                  <ItemComponent\n                    fieldApi={createItemFieldApi(index)}\n                    label={itemLabel ? `${itemLabel} ${index + 1}` : undefined}\n                    placeholder={itemPlaceholder}\n                    wrapperClassName=\"mb-0\"\n                    {...itemProps}\n                    // Pass specific props based on item type\n                    {...(itemType === 'select' && { options: itemProps.options || [] })}\n                    {...(itemType === 'number' && { \n                      min: itemProps.min, \n                      max: itemProps.max, \n                      step: itemProps.step \n                    })}\n                    {...(itemType === 'slider' && { \n                      min: itemProps.min, \n                      max: itemProps.max, \n                      step: itemProps.step \n                    })}\n                    {...(itemType === 'file' && { \n                      accept: itemProps.accept,\n                      multiple: itemProps.multiple \n                    })}\n                    {...(itemType === 'date' && typeof itemProps.dateProps === 'object' && itemProps.dateProps ? itemProps.dateProps : {})}\n                    {...(['text', 'email', 'password', 'url', 'tel'].includes(itemType) && {\n                      type: itemType,\n                      datalist: itemProps.datalist,\n                    })}\n                  />\n                </div>\n                \n                {canRemove && (\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => removeItem(index)}\n                    className=\"mt-2 h-8 w-8 p-0 text-destructive hover:text-destructive\"\n                    title={removeButtonLabel}\n                    disabled={isDisabled}\n                  >\n                    <Trash2 className=\"h-4 w-4\" />\n                  </Button>\n                )}\n              </div>\n            ))}\n            \n            {value.length === 0 && (\n              <div className=\"text-center py-8 text-muted-foreground border-2 border-dashed rounded-lg\">\n                <p className=\"text-sm\">No items added yet</p>\n                <p className=\"text-xs mt-1\">Click &quot;{addButtonLabel}&quot; to add your first item</p>\n              </div>\n            )}\n          </div>\n          \n          {canAddMore && (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={addItem}\n              className=\"w-full\"\n              disabled={isDisabled}\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              {addButtonLabel}\n            </Button>\n          )}\n          \n          {minItems > 0 && value.length < minItems && (\n            <p className=\"text-xs text-muted-foreground\">\n              Minimum {minItems} item{minItems !== 1 ? 's' : ''} required\n            </p>\n          )}\n        </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/array-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/autocomplete-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { Input } from \"@/components/ui/input\";\nimport { Card } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface AutocompleteOption {\n  value: string;\n  label: string;\n}\n\ninterface AutocompleteFieldProps extends BaseFieldProps {\n  autocompleteConfig?: {\n    options?: string[] | AutocompleteOption[];\n    asyncOptions?: (query: string) => Promise<string[] | AutocompleteOption[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n    allowCustom?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n}\n\nexport const AutocompleteField: React.FC<AutocompleteFieldProps> = ({\n  fieldApi,\n  placeholder,\n  inputClassName,\n  autocompleteConfig = {},\n  ...wrapperProps\n}) => {\n  const {\n    options = [],\n    asyncOptions,\n    debounceMs = 300,\n    minChars = 1,\n    maxResults = 10,\n    allowCustom = true,\n    noOptionsText = \"No options found\",\n    loadingText = \"Loading...\"\n  } = autocompleteConfig;\n\n  const name = fieldApi.name;\n\n  const [inputValue, setInputValue] = useState(fieldApi.state?.value || \"\");\n  const [filteredOptions, setFilteredOptions] = useState<AutocompleteOption[]>([]);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [highlightedIndex, setHighlightedIndex] = useState(-1);\n  \n  const inputRef = useRef<HTMLInputElement>(null);\n  const listRef = useRef<HTMLDivElement>(null);\n  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // Normalize options to consistent format\n  const normalizeOptions = (opts: string[] | AutocompleteOption[]): AutocompleteOption[] => {\n    return opts.map(opt => \n      typeof opt === 'string' ? { value: opt, label: opt } : opt\n    );\n  };\n\n  // Filter static options\n  const filterStaticOptions = React.useCallback((query: string): AutocompleteOption[] => {\n    if (!query || query.length < minChars) return [];\n    \n    const normalizedOptions = normalizeOptions(options);\n    return normalizedOptions\n      .filter(option => \n        option.label.toLowerCase().includes(query.toLowerCase()) ||\n        option.value.toLowerCase().includes(query.toLowerCase())\n      )\n      .slice(0, maxResults);\n  }, [minChars, options, maxResults]);\n\n  // Handle async options\n  const fetchAsyncOptions = React.useCallback(async (query: string) => {\n    if (!asyncOptions || query.length < minChars) return;\n\n    setIsLoading(true);\n    try {\n      const results = await asyncOptions(query);\n      const normalizedResults = normalizeOptions(results);\n      setFilteredOptions(normalizedResults.slice(0, maxResults));\n    } catch (error) {\n      console.error('Autocomplete async options error:', error);\n      setFilteredOptions([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [asyncOptions, minChars, maxResults]);\n\n  // Debounced search\n  useEffect(() => {\n    if (debounceRef.current) {\n      clearTimeout(debounceRef.current);\n    }\n\n    debounceRef.current = setTimeout(() => {\n      if (asyncOptions) {\n        fetchAsyncOptions(inputValue);\n      } else {\n        setFilteredOptions(filterStaticOptions(inputValue));\n      }\n    }, debounceMs);\n\n    return () => {\n      if (debounceRef.current) {\n        clearTimeout(debounceRef.current);\n      }\n    };\n  }, [inputValue, asyncOptions, debounceMs, fetchAsyncOptions, filterStaticOptions]);\n\n  // Handle input change\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    setIsOpen(true);\n    setHighlightedIndex(-1);\n    \n    if (allowCustom) {\n      fieldApi.handleChange(value);\n    }\n  };\n\n  // Handle option selection\n  const handleOptionSelect = (option: AutocompleteOption) => {\n    setInputValue(option.label);\n    fieldApi.handleChange(option.value);\n    setIsOpen(false);\n    setHighlightedIndex(-1);\n    inputRef.current?.blur();\n  };\n\n  // Handle keyboard navigation\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!isOpen) {\n      if (e.key === 'ArrowDown' || e.key === 'Enter') {\n        setIsOpen(true);\n        return;\n      }\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setHighlightedIndex(prev => \n          prev < filteredOptions.length - 1 ? prev + 1 : prev\n        );\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setHighlightedIndex(prev => prev > 0 ? prev - 1 : -1);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {\n          handleOptionSelect(filteredOptions[highlightedIndex]);\n        } else if (allowCustom && inputValue) {\n          fieldApi.handleChange(inputValue);\n          setIsOpen(false);\n        }\n        break;\n      case 'Escape':\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n        inputRef.current?.blur();\n        break;\n    }\n  };\n\n  // Handle focus/blur\n  const handleFocus = () => {\n    if (inputValue.length >= minChars) {\n      setIsOpen(true);\n    }\n  };\n\n  const handleInputBlur = () => {\n    // Delay closing to allow option clicks\n    setTimeout(() => {\n      if (!listRef.current?.contains(document.activeElement)) {\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n      }\n    }, 150);\n  };\n\n  // Scroll highlighted option into view\n  useEffect(() => {\n    if (highlightedIndex >= 0 && listRef.current) {\n      const highlightedElement = listRef.current.children[highlightedIndex] as HTMLElement;\n      if (highlightedElement) {\n        highlightedElement.scrollIntoView({\n          block: 'nearest',\n          behavior: 'smooth'\n        });\n      }\n    }\n  }, [highlightedIndex]);\n\n  const showDropdown = isOpen && (filteredOptions.length > 0 || isLoading || (inputValue.length >= minChars && !isLoading));\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"relative\">\n        <Input\n          ref={inputRef}\n          id={fieldApi.name}\n          name={fieldApi.name}\n          value={inputValue}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={handleFocus}\n          onBlur={(e) => {\n            handleInputBlur();\n            fieldApi.handleBlur();\n          }}\n          placeholder={placeholder || autocompleteConfig.placeholder || \"Type to search...\"}\n          className={cn(inputClassName, isOpen && \"rounded-b-none\")}\n          autoComplete=\"off\"\n          disabled={isDisabled}\n        />\n\n        {showDropdown && (\n          <Card className=\"absolute top-full left-0 right-0 z-50 max-h-60 overflow-y-auto border-t-0 rounded-t-none\">\n            <div ref={listRef} className=\"p-1\">\n              {isLoading && (\n                <div className=\"px-3 py-2 text-sm text-muted-foreground\">\n                  {loadingText}\n                </div>\n              )}\n              \n              {!isLoading && filteredOptions.length === 0 && inputValue.length >= minChars && (\n                <div className=\"px-3 py-2 text-sm text-muted-foreground\">\n                  {noOptionsText}\n                  {allowCustom && (\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      className=\"ml-2 h-auto p-1 text-xs\"\n                      onClick={() => {\n                        fieldApi.handleChange(inputValue);\n                        setIsOpen(false);\n                      }}\n                      disabled={isDisabled}\n                    >\n                      Use \"{inputValue}\"\n                    </Button>\n                  )}\n                </div>\n              )}\n              \n              {!isLoading && filteredOptions.map((option, index) => (\n                <button\n                  key={`${option.value}-${index}`}\n                  type=\"button\"\n                  className={cn(\n                    \"w-full text-left px-3 py-2 text-sm rounded-sm transition-colors\",\n                    \"hover:bg-muted focus:bg-muted focus:outline-none\",\n                    highlightedIndex === index && \"bg-muted\"\n                  )}\n                  onClick={() => handleOptionSelect(option)}\n                  onMouseEnter={() => setHighlightedIndex(index)}\n                  disabled={isDisabled}\n                >\n                  <div className=\"font-medium\">{option.label}</div>\n                  {option.value !== option.label && (\n                    <div className=\"text-xs text-muted-foreground\">{option.value}</div>\n                  )}\n                </button>\n              ))}\n            </div>\n          </Card>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/autocomplete-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/checkbox-field.tsx",
      "content": "import React from 'react';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const CheckboxField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as boolean | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n\n  const onCheckedChange = (checked: boolean) => {\n    fieldApi.handleChange(checked);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\n    // because Checkbox components need the label positioned next to (not above) the control\n    <FieldWrapper \n      fieldApi={fieldApi} \n      label={undefined}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"flex items-center space-x-2\">\n        <Checkbox\n          id={name}\n          checked={!!value}\n          onCheckedChange={onCheckedChange}\n          onBlur={onBlur}\n          disabled={isDisabled}\n          aria-describedby={description ? `${name}-description` : undefined}\n        />\n        {label && (\n          <Label \n            htmlFor={name} \n            className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}\n          >\n            {label}\n          </Label>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/formedible/fields/checkbox-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/color-picker-field.tsx",
      "content": "'use client';\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { Palette, Check } from 'lucide-react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface ColorPickerFieldSpecificProps extends BaseFieldProps {\n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showPreview?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n  };\n}\n\nconst DEFAULT_PRESETS = [\n  '#FF0000', '#FF8000', '#FFFF00', '#80FF00', '#00FF00', '#00FF80',\n  '#00FFFF', '#0080FF', '#0000FF', '#8000FF', '#FF00FF', '#FF0080',\n  '#000000', '#404040', '#808080', '#C0C0C0', '#FFFFFF', '#8B4513'\n];\n\n// Color conversion utilities\nconst hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\n\n\nconst hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {\n  const rgb = hexToRgb(hex);\n  if (!rgb) return null;\n  \n  const { r, g, b } = rgb;\n  const rNorm = r / 255;\n  const gNorm = g / 255;\n  const bNorm = b / 255;\n  \n  const max = Math.max(rNorm, gNorm, bNorm);\n  const min = Math.min(rNorm, gNorm, bNorm);\n  const diff = max - min;\n  \n  let h = 0;\n  let s = 0;\n  const l = (max + min) / 2;\n  \n  if (diff !== 0) {\n    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);\n    \n    switch (max) {\n      case rNorm:\n        h = (gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0);\n        break;\n      case gNorm:\n        h = (bNorm - rNorm) / diff + 2;\n        break;\n      case bNorm:\n        h = (rNorm - gNorm) / diff + 4;\n        break;\n    }\n    h /= 6;\n  }\n  \n  return {\n    h: Math.round(h * 360),\n    s: Math.round(s * 100),\n    l: Math.round(l * 100)\n  };\n};\n\nconst formatColor = (hex: string, format: 'hex' | 'rgb' | 'hsl'): string => {\n  switch (format) {\n    case 'rgb': {\n      const rgb = hexToRgb(hex);\n      return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\n    }\n    case 'hsl': {\n      const hsl = hexToHsl(hex);\n      return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\n    }\n    default:\n      return hex;\n  }\n};\n\nexport const ColorPickerField: React.FC<ColorPickerFieldSpecificProps> = ({\n  fieldApi,\n  colorConfig = {},\n  inputClassName,\n  ...wrapperProps\n}) => {\n  const {\n    format = 'hex',\n    showPreview = true,\n    presetColors = DEFAULT_PRESETS,\n    allowCustom = true,\n  } = colorConfig;\n\n  const name = fieldApi.name;\n  \n  const value = (fieldApi.state?.value as string) || '#000000';\n  \n  const [isOpen, setIsOpen] = useState(false);\n  const [customInput, setCustomInput] = useState(value);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const colorInputRef = useRef<HTMLInputElement>(null);\n\n  // Ensure value is always a valid hex color\n  const normalizedValue = value.startsWith('#') ? value : `#${value}`;\n  const displayValue = formatColor(normalizedValue, format);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleColorSelect = (color: string) => {\n    const formattedColor = formatColor(color, format);\n    fieldApi.handleChange(formattedColor);\n    setCustomInput(color);\n    setIsOpen(false);\n    fieldApi.handleBlur();\n  };\n\n  const handleCustomInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    setCustomInput(inputValue);\n    \n    // Validate and update if it's a valid color\n    if (inputValue.match(/^#[0-9A-Fa-f]{6}$/)) {\n      const formattedColor = formatColor(inputValue, format);\n      fieldApi.handleChange(formattedColor);\n    }\n  };\n\n  const handleNativeColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const color = e.target.value;\n    const formattedColor = formatColor(color, format);\n    fieldApi.handleChange(formattedColor);\n    setCustomInput(color);\n  };\n\n  const isValidColor = (color: string): boolean => {\n    return /^#[0-9A-Fa-f]{6}$/.test(color);\n  };\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"relative space-y-2\" ref={containerRef}>\n        <div className=\"flex gap-2\">\n          {/* Color preview and trigger */}\n          <div className=\"relative\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              className={cn(\n                \"w-12 h-10 p-0 border-2\",\n                fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\",\n                inputClassName\n              )}\n              onClick={() => setIsOpen(!isOpen)}\n              disabled={isDisabled}\n              style={{ backgroundColor: normalizedValue }}\n            >\n              {!showPreview && <Palette className=\"h-4 w-4\" />}\n            </Button>\n            \n            {/* Native color input (hidden) */}\n            <input\n              ref={colorInputRef}\n              type=\"color\"\n              value={normalizedValue}\n              onChange={handleNativeColorChange}\n              onBlur={() => fieldApi.handleBlur()}\n              className=\"absolute inset-0 w-full h-full opacity-0 cursor-pointer\"\n              disabled={isDisabled}\n            />\n          </div>\n\n          {/* Color value input */}\n          <Input\n            value={displayValue}\n            onChange={(e) => {\n              const inputValue = e.target.value;\n              fieldApi.handleChange(inputValue);\n              // Try to extract hex value for internal use\n              if (inputValue.startsWith('#')) {\n                setCustomInput(inputValue);\n              }\n            }}\n            onBlur={() => {\n              fieldApi.handleBlur();\n            }}\n            placeholder={'#000000'}\n            className={cn(\n              \"flex-1\",\n              fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\"\n            )}\n            disabled={isDisabled}\n          />\n        </div>\n\n        {/* Color picker dropdown */}\n        {isOpen && (\n          <div className=\"absolute z-50 mt-1 p-4 bg-popover border rounded-md shadow-lg w-64\">\n            {/* Preset colors */}\n            <div className=\"mb-4\">\n              <h4 className=\"text-sm font-medium mb-2\">Preset Colors</h4>\n              <div className=\"grid grid-cols-6 gap-2\">\n                {presetColors.map((color, index) => (\n                  <button\n                    key={index}\n                    type=\"button\"\n                    className={cn(\n                      \"w-8 h-8 rounded border-2 hover:scale-110 transition-transform\",\n                      normalizedValue.toLowerCase() === color.toLowerCase() \n                        ? \"border-primary ring-2 ring-primary ring-offset-2\" \n                        : \"border-muted hover:border-primary\"\n                    )}\n                    style={{ backgroundColor: color }}\n                    onClick={() => handleColorSelect(color)}\n                    title={color}\n                  >\n                    {normalizedValue.toLowerCase() === color.toLowerCase() && (\n                      <Check className=\"h-4 w-4 text-white drop-shadow-lg\" />\n                    )}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Custom color input */}\n            {allowCustom && (\n              <div>\n                <h4 className=\"text-sm font-medium mb-2\">Custom Color</h4>\n                <div className=\"flex gap-2\">\n                  <Input\n                    value={customInput}\n                    onChange={handleCustomInputChange}\n                    placeholder=\"#000000\"\n                    className=\"flex-1 text-xs\"\n                  />\n                  <Button\n                    type=\"button\"\n                    size=\"sm\"\n                    onClick={() => handleColorSelect(customInput)}\n                    disabled={!isValidColor(customInput)}\n                  >\n                    Apply\n                  </Button>\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/color-picker-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/date-field.tsx",
      "content": "import React from 'react';\nimport { format, parseISO } from 'date-fns';\nimport { Calendar as CalendarIcon } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const DateField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const [isOpen, setIsOpen] = React.useState(false);\n\n  const value = fieldApi.state?.value;\n  const selectedDate = value\n    ? value instanceof Date\n      ? value\n      : typeof value === 'string'\n        ? parseISO(value)\n        : undefined\n    : undefined;\n\n  const handleDateSelect = (date: Date | undefined) => {\n    fieldApi.handleChange(date);\n    fieldApi.handleBlur();\n    setIsOpen(false);\n  };\n\n  const computedInputClassName = cn(\n    \"w-full justify-start text-left font-normal\",\n    !selectedDate && \"text-muted-foreground\",\n    hasErrors ? \"border-destructive\" : \"\",\n    inputClassName\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Popover open={isOpen} onOpenChange={setIsOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            variant=\"outline\"\n            className={computedInputClassName}\n            disabled={isDisabled}\n            onClick={() => setIsOpen(true)}\n          >\n            <CalendarIcon className=\"mr-2 h-4 w-4\" />\n            {selectedDate ? format(selectedDate, \"PPP\") : <span>{placeholder || \"Pick a date\"}</span>}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\">\n          <Calendar\n            mode=\"single\"\n            selected={selectedDate}\n            onSelect={handleDateSelect}\n            initialFocus\n            disabled={isDisabled}\n          />\n        </PopoverContent>\n      </Popover>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/formedible/fields/date-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/duration-picker-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DurationValue {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  totalSeconds?: number;\n}\n\ninterface DurationPickerFieldProps extends BaseFieldProps {\n  durationConfig?: {\n    format?: 'hms' | 'hm' | 'ms' | 'hours' | 'minutes' | 'seconds';\n    maxHours?: number;\n    maxMinutes?: number;\n    maxSeconds?: number;\n    showLabels?: boolean;\n    allowNegative?: boolean;\n  };\n}\n\nexport const DurationPickerField: React.FC<DurationPickerFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  durationConfig = {},\n}) => {\n  const name = fieldApi.name;\n\n  const {\n    format = 'hms',\n    maxHours = 23,\n    maxMinutes = 59,\n    maxSeconds = 59,\n    showLabels = true,\n    allowNegative: _allowNegative = false\n  } = durationConfig;\n\n  const [hours, setHours] = useState(0);\n  const [minutes, setMinutes] = useState(0);\n  const [seconds, setSeconds] = useState(0);\n\n  // Initialize from field value\n  useEffect(() => {\n    const value = fieldApi.state?.value;\n    if (value) {\n      if (typeof value === 'number') {\n        // Value is total seconds\n        const totalSeconds = Math.abs(value);\n        const newHours = Math.min(Math.floor(totalSeconds / 3600), maxHours);\n        const newMinutes = Math.min(Math.floor((totalSeconds % 3600) / 60), maxMinutes);\n        const newSeconds = Math.min(totalSeconds % 60, maxSeconds);\n        setHours(newHours);\n        setMinutes(newMinutes);\n        setSeconds(newSeconds);\n      } else if (typeof value === 'object') {\n        // Value is duration object\n        setHours(Math.min(value.hours || 0, maxHours));\n        setMinutes(Math.min(value.minutes || 0, maxMinutes));\n        setSeconds(Math.min(value.seconds || 0, maxSeconds));\n      }\n    }\n  }, [fieldApi.state?.value, maxHours, maxMinutes, maxSeconds]);\n\n  // Update field value when duration changes\n  useEffect(() => {\n    const totalSeconds = hours * 3600 + minutes * 60 + seconds;\n    const durationValue: DurationValue = {\n      hours,\n      minutes,\n      seconds,\n      totalSeconds\n    };\n\n    // Update field based on format\n    switch (format) {\n      case 'hours':\n        fieldApi.handleChange(hours + minutes / 60 + seconds / 3600);\n        break;\n      case 'minutes':\n        fieldApi.handleChange(hours * 60 + minutes + seconds / 60);\n        break;\n      case 'seconds':\n        fieldApi.handleChange(totalSeconds);\n        break;\n      default:\n        fieldApi.handleChange(durationValue);\n    }\n  }, [hours, minutes, seconds, format, fieldApi.handleChange]);\n\n  const formatDuration = () => {\n    const parts = [];\n    if (format.includes('h') && hours > 0) parts.push(`${hours}h`);\n    if (format.includes('m') && minutes > 0) parts.push(`${minutes}m`);\n    if (format.includes('s') && seconds > 0) parts.push(`${seconds}s`);\n    return parts.join(' ') || '0';\n  };\n\n  const renderTimeInput = (\n    value: number,\n    onChange: (value: number) => void,\n    max: number,\n    unit: string,\n    show: boolean\n  ) => {\n    if (!show) return null;\n\n    return (\n      <div className=\"flex flex-col space-y-1\">\n        {showLabels && (\n          <Label className=\"text-xs text-muted-foreground capitalize\">\n            {unit}\n          </Label>\n        )}\n        <Select\n          value={value.toString()}\n          onValueChange={(val) => onChange(parseInt(val))}\n        >\n          <SelectTrigger className={cn(\"w-20\", inputClassName)}>\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            {Array.from({ length: max + 1 }, (_, i) => (\n              <SelectItem key={i} value={i.toString()}>\n                {i.toString().padStart(2, '0')}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n    );\n  };\n\n  const renderManualInput = () => {\n    return (\n      <div className=\"space-y-2\">\n        <Input\n          id={name}\n          value={formatDuration()}\n          placeholder={placeholder || \"Enter duration (e.g., 1h 30m 45s)\"}\n          className={inputClassName}\n          onChange={(e) => {\n            const input = e.target.value;\n            // Parse manual input like \"1h 30m 45s\" or \"90m\" or \"3600s\"\n            const hourMatch = input.match(/(\\d+)h/i);\n            const minuteMatch = input.match(/(\\d+)m(?!s)/i); // Don't match 'ms'\n            const secondMatch = input.match(/(\\d+)s/i);\n            \n            const newHours = hourMatch ? Math.max(0, parseInt(hourMatch[1], 10)) : 0;\n            const newMinutes = minuteMatch ? Math.max(0, parseInt(minuteMatch[1], 10)) : 0;\n            const newSeconds = secondMatch ? Math.max(0, parseInt(secondMatch[1], 10)) : 0;\n            \n            if (newHours <= maxHours && newMinutes <= maxMinutes && newSeconds <= maxSeconds) {\n              setHours(newHours);\n              setMinutes(newMinutes);\n              setSeconds(newSeconds);\n            } else {\n              // Provide feedback for invalid input\n              console.warn('Duration values exceed maximum limits');\n            }\n          }}\n        />\n        <div className=\"text-xs text-muted-foreground\">\n          Format: {format === 'hms' ? '1h 30m 45s' : format === 'hm' ? '1h 30m' : format === 'ms' ? '30m 45s' : `${format} only`}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={labelClassName}>\n          {label}\n        </Label>\n      )}\n      \n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <div className=\"space-y-3\">\n        {/* Dropdown selectors */}\n        <div className=\"flex gap-3\">\n          {renderTimeInput(\n            hours,\n            setHours,\n            maxHours,\n            'hours',\n            format.includes('h')\n          )}\n          {renderTimeInput(\n            minutes,\n            setMinutes,\n            maxMinutes,\n            'minutes',\n            format.includes('m')\n          )}\n          {renderTimeInput(\n            seconds,\n            setSeconds,\n            maxSeconds,\n            'seconds',\n            format.includes('s')\n          )}\n        </div>\n\n        {/* Manual input alternative */}\n        {renderManualInput()}\n\n        {/* Duration display */}\n        <div className=\"text-sm text-muted-foreground\">\n          Total: {formatDuration()}\n          {format !== 'seconds' && ` (${hours * 3600 + minutes * 60 + seconds} seconds)`}\n        </div>\n      </div>\n\n      {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">\n          {fieldApi.state?.meta?.errors[0]}\n        </p>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/duration-picker-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/base-field-wrapper.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\nexport interface FieldWrapperProps extends BaseFieldProps {\n  children: React.ReactNode;\n  htmlFor?: string;\n  showErrors?: boolean;\n}\n\n// Simplified wrapper that doesn't interfere with TanStack Form's state management\nexport const FieldWrapper: React.FC<FieldWrapperProps> = ({\n  fieldApi,\n  label,\n  description,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  children,\n  htmlFor,\n  showErrors = true,\n}) => {\n  const name = fieldApi.name;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  return (\n    <div className={cn(\"space-y-1.5\", wrapperClassName)}>\n      {label && (\n        <Label \n          htmlFor={htmlFor || name} \n          className={cn(\"text-sm font-medium\", labelClassName)}\n        >\n          {label}\n        </Label>\n      )}\n      {description && (\n        <p className=\"text-xs text-muted-foreground\">{description}</p>\n      )}\n      \n      {children}\n      \n      {showErrors && hasErrors && (\n        <div className=\"text-xs text-destructive pt-1\">\n          {fieldApi.state?.meta?.errors?.map((err: string | Error, index: number) => (\n            <p key={index}>\n              {typeof err === 'string' ? err : (err as Error)?.message || 'Invalid'}\n            </p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/base-field-wrapper.tsx"
    },
    {
      "path": "src/components/formedible/fields/field-help.tsx",
      "content": "'use client';\nimport React, { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { HelpCircle, ExternalLink, Info } from 'lucide-react';\n\ninterface FieldHelpProps {\n  help?: {\n    text?: string;\n    tooltip?: string;\n    position?: 'top' | 'bottom' | 'left' | 'right';\n    link?: { url: string; text: string };\n  };\n  className?: string;\n}\n\nexport const FieldHelp: React.FC<FieldHelpProps> = ({\n  help,\n  className,\n}) => {\n  const [showTooltip, setShowTooltip] = useState(false);\n\n  if (!help || (!help.text && !help.tooltip && !help.link)) {\n    return null;\n  }\n\n  const { text, tooltip, position = 'top', link } = help;\n\n  return (\n    <div className={cn(\"space-y-2\", className)}>\n      {/* Help text */}\n      {text && (\n        <div className=\"flex items-start gap-2 text-xs text-muted-foreground\">\n          <Info className=\"h-3 w-3 mt-0.5 flex-shrink-0\" />\n          <p>{text}</p>\n        </div>\n      )}\n\n      {/* Tooltip trigger */}\n      {tooltip && (\n        <div className=\"relative inline-block\">\n          <Button\n            type=\"button\"\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"h-6 w-6 p-0 text-muted-foreground hover:text-foreground\"\n            onMouseEnter={() => setShowTooltip(true)}\n            onMouseLeave={() => setShowTooltip(false)}\n            onFocus={() => setShowTooltip(true)}\n            onBlur={() => setShowTooltip(false)}\n          >\n            <HelpCircle className=\"h-3 w-3\" />\n          </Button>\n\n          {/* Tooltip */}\n          {showTooltip && (\n            <div\n              className={cn(\n                \"absolute z-50 px-2 py-1 text-xs text-white bg-black rounded shadow-lg whitespace-nowrap\",\n                \"pointer-events-none\",\n                {\n                  'bottom-full left-1/2 -translate-x-1/2 mb-1': position === 'top',\n                  'top-full left-1/2 -translate-x-1/2 mt-1': position === 'bottom',\n                  'right-full top-1/2 -translate-y-1/2 mr-1': position === 'left',\n                  'left-full top-1/2 -translate-y-1/2 ml-1': position === 'right',\n                }\n              )}\n            >\n              {tooltip}\n              {/* Tooltip arrow */}\n              <div\n                className={cn(\n                  \"absolute w-0 h-0 border-2 border-transparent\",\n                  {\n                    'top-full left-1/2 -translate-x-1/2 border-t-black border-b-0': position === 'top',\n                    'bottom-full left-1/2 -translate-x-1/2 border-b-black border-t-0': position === 'bottom',\n                    'top-1/2 left-full -translate-y-1/2 border-l-black border-r-0': position === 'left',\n                    'top-1/2 right-full -translate-y-1/2 border-r-black border-l-0': position === 'right',\n                  }\n                )}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Help link */}\n      {link && (\n        <div className=\"flex items-center gap-1\">\n          <Button\n            type=\"button\"\n            variant=\"link\"\n            size=\"sm\"\n            className=\"h-auto p-0 text-xs text-primary hover:text-primary/80\"\n            onClick={() => window.open(link.url, '_blank', 'noopener,noreferrer')}\n          >\n            {link.text}\n            <ExternalLink className=\"h-3 w-3 ml-1\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/field-help.tsx"
    },
    {
      "path": "src/components/formedible/fields/field-registry.tsx",
      "content": "'use client';\nimport React from 'react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\n\n// Import all field components\nimport { TextField } from './text-field';\nimport { TextareaField } from './textarea-field';\nimport { NumberField } from './number-field';\nimport { SelectField } from './select-field';\nimport { MultiSelectField } from './multi-select-field';\nimport { CheckboxField } from './checkbox-field';\nimport { SwitchField } from './switch-field';\nimport { RadioField } from './radio-field';\nimport { SliderField } from './slider-field';\nimport { DateField } from './date-field';\nimport { RatingField } from './rating-field';\nimport { PhoneField } from './phone-field';\nimport { ColorPickerField } from './color-picker-field';\nimport { FileUploadField } from './file-upload-field';\nimport { ArrayField } from './array-field';\nimport { AutocompleteField } from './autocomplete-field';\nimport { DurationPickerField } from './duration-picker-field';\nimport { LocationPickerField } from './location-picker-field';\nimport { MaskedInputField } from './masked-input-field';\nimport { ObjectField } from './object-field';\n\n// Type-safe field component registry with flexible props\nexport interface FieldComponentProps extends BaseFieldProps {\n  [key: string]: unknown;\n}\n\nexport type FieldComponent = React.ComponentType<any>;\n\nexport const fieldComponents: Record<string, FieldComponent> = {\n  text: TextField,\n  textarea: TextareaField,\n  number: NumberField,\n  select: SelectField,\n  multiselect: MultiSelectField,\n  checkbox: CheckboxField,\n  switch: SwitchField,\n  radio: RadioField,\n  slider: SliderField,\n  date: DateField,\n  rating: RatingField,\n  phone: PhoneField,\n  color: ColorPickerField,\n  file: FileUploadField,\n  array: ArrayField,\n  autocomplete: AutocompleteField,\n  duration: DurationPickerField,\n  location: LocationPickerField,\n  masked: MaskedInputField,\n  object: ObjectField,\n};\n\n// Helper function to get field component with type safety\nexport const getFieldComponent = (type: string): FieldComponent | null => {\n  return fieldComponents[type] || null;\n};\n\n// Helper function to create properly typed field props\nexport const createFieldProps = (\n  baseProps: BaseFieldProps,\n  additionalProps: Record<string, unknown> = {}\n): FieldComponentProps => {\n  return {\n    ...baseProps,\n    ...additionalProps,\n  };\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/field-registry.tsx"
    },
    {
      "path": "src/components/formedible/fields/file-upload-field.tsx",
      "content": "import React from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport { PaperclipIcon, XIcon, UploadCloudIcon } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface FileUploadFieldSpecificProps extends BaseFieldProps {\n  accept?: string;\n  className?: string;\n}\n\nexport const FileUploadField: React.FC<FileUploadFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  accept,\n  className,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n  \n  const file = fieldApi.state?.value as File | null;\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFile = e.target.files?.[0] ?? null;\n    fieldApi.handleChange(selectedFile);\n    fieldApi.handleBlur();\n  };\n\n  const handleRemoveFile = () => {\n    fieldApi.handleChange(null);\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    if (inputElement) {\n      inputElement.value = \"\";\n    }\n    fieldApi.handleBlur();\n  };\n\n  const triggerFileInput = () => {\n    const inputElement = document.getElementById(name) as HTMLInputElement;\n    inputElement?.click();\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-1.5\">\n        <Input\n          id={name}\n          name={name}\n          type=\"file\"\n          accept={accept}\n          onChange={handleFileChange}\n          className=\"hidden\"\n          disabled={isDisabled}\n        />\n        {file ? (\n          <div\n            className=\"flex items-center justify-between p-2.5 border rounded-lg bg-muted/40 shadow-sm hover:shadow-md transition-shadow\"\n          >\n            <div className=\"flex items-center gap-2 text-sm overflow-hidden\">\n              <PaperclipIcon className=\"h-5 w-5 text-primary shrink-0\" />\n              <span className=\"truncate\" title={file.name}>{file.name}</span>\n              <span className=\"text-xs text-muted-foreground whitespace-nowrap\">\n                ({(file.size / 1024).toFixed(1)} KB)\n              </span>\n            </div>\n            <Button\n              type=\"button\"\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={handleRemoveFile}\n              className=\"h-7 w-7 text-destructive hover:bg-destructive/10 shrink-0\"\n              aria-label=\"Remove file\"\n              disabled={isDisabled}\n            >\n              <XIcon className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        ) : (\n          <button\n            type=\"button\"\n            onClick={triggerFileInput}\n            className={cn(\n              \"w-full flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-lg hover:border-primary transition-colors cursor-pointer bg-background hover:bg-muted/50\",\n              className,\n              hasErrors ? \"border-destructive hover:border-destructive\" : \"border-muted-foreground/50\",\n              isDisabled && \"opacity-50 cursor-not-allowed\"\n            )}\n            disabled={isDisabled}\n          >\n            <UploadCloudIcon className=\"h-8 w-8 text-muted-foreground mb-2\" />\n            <span className=\"text-sm font-medium text-muted-foreground\">\n              Click or drag and drop a file\n            </span>\n            {accept && <span className=\"text-xs text-muted-foreground/80 mt-1\">Accepted types: {accept}</span>}\n          </button>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/formedible/fields/file-upload-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/inline-validation-wrapper.tsx",
      "content": "'use client';\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Check, X, Loader2 } from 'lucide-react';\nimport type { AnyFieldApi } from '@tanstack/react-form';\n\n\ninterface InlineValidationWrapperProps {\n  children: React.ReactNode;\n  fieldApi: AnyFieldApi;\n  inlineValidation?: {\n    enabled?: boolean;\n    debounceMs?: number;\n    showSuccess?: boolean;\n    asyncValidator?: (value: unknown) => Promise<string | null>;\n  };\n  className?: string;\n}\n\nexport const InlineValidationWrapper: React.FC<InlineValidationWrapperProps> = ({\n  children,\n  fieldApi,\n  inlineValidation = {},\n  className,\n}) => {\n  const {\n    enabled = true,\n    debounceMs = 300,\n    showSuccess = true,\n    asyncValidator,\n  } = inlineValidation;\n\n  const [validationState, setValidationState] = useState<{\n    isValidating: boolean;\n    isValid: boolean | null;\n    message: string | null;\n  }>({\n    isValidating: false,\n    isValid: null,\n    message: null,\n  });\n\n  const { state } = fieldApi;\n  const value = state.value;\n  const hasErrors = state.meta.errors.length > 0;\n  const isTouched = state.meta.isTouched;\n\n  // Validation function\n  const validateValue = useCallback(async (currentValue: unknown) => {\n    if (!enabled || !asyncValidator) return;\n\n    setValidationState(prev => ({ ...prev, isValidating: true }));\n\n    try {\n      const result = await asyncValidator(currentValue);\n      \n      setValidationState({\n        isValidating: false,\n        isValid: result === null,\n        message: result,\n      });\n    } catch (error) {\n      setValidationState({\n        isValidating: false,\n        isValid: false,\n        message: error instanceof Error ? error.message : 'Validation failed',\n      });\n    }\n  }, [enabled, asyncValidator]);\n\n  // Debounced validation function\n  const debouncedValidate = useMemo(\n    () => debounce(validateValue, debounceMs),\n    [validateValue, debounceMs]\n  );\n\n  // Trigger validation when value changes\n  useEffect(() => {\n    if (enabled && isTouched && value !== undefined && value !== '') {\n      debouncedValidate(value);\n    } else {\n      setValidationState({\n        isValidating: false,\n        isValid: null,\n        message: null,\n      });\n    }\n  }, [value, isTouched, enabled, debouncedValidate]);\n\n  // Reset validation state when field is reset\n  useEffect(() => {\n    if (!isTouched) {\n      setValidationState({\n        isValidating: false,\n        isValid: null,\n        message: null,\n      });\n    }\n  }, [isTouched]);\n\n  const getValidationIcon = () => {\n    if (!enabled || !isTouched) return null;\n    \n    if (validationState.isValidating) {\n      return <Loader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />;\n    }\n\n    if (hasErrors) {\n      return <X className=\"h-4 w-4 text-destructive\" />;\n    }\n\n    if (validationState.isValid === false) {\n      return <X className=\"h-4 w-4 text-destructive\" />;\n    }\n\n    if (showSuccess && validationState.isValid === true) {\n      return <Check className=\"h-4 w-4 text-green-500\" />;\n    }\n\n    if (showSuccess && !hasErrors && isTouched && value) {\n      return <Check className=\"h-4 w-4 text-green-500\" />;\n    }\n\n    return null;\n  };\n\n  const getValidationMessage = () => {\n    if (!enabled || !isTouched) return null;\n\n    // Show form validation errors first\n    if (hasErrors) {\n      return state.meta.errors[0];\n    }\n\n    // Show async validation message\n    if (validationState.message) {\n      return validationState.message;\n    }\n\n    return null;\n  };\n\n  const validationIcon = getValidationIcon();\n  const validationMessage = getValidationMessage();\n\n  return (\n    <div className={cn(\"relative\", className)}>\n      {/* Field with validation icon */}\n      <div className=\"relative\">\n        {children}\n        {validationIcon && (\n          <div className=\"absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none\">\n            {validationIcon}\n          </div>\n        )}\n      </div>\n      \n      {/* Validation message */}\n      {validationMessage && (\n        <div className={cn(\n          \"text-xs mt-1 flex items-center gap-1\",\n          hasErrors || validationState.isValid === false\n            ? \"text-destructive\"\n            : \"text-muted-foreground\"\n        )}>\n          {typeof validationMessage === 'string' \n            ? validationMessage \n            : (validationMessage as Error)?.message || 'Validation error'\n          }\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Debounce utility function\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout>;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n} ",
      "type": "registry:component",
      "target": "components/formedible/fields/inline-validation-wrapper.tsx"
    },
    {
      "path": "src/components/formedible/fields/location-picker-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card } from \"@/components/ui/card\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\"\n\ninterface LocationValue {\n  lat: number;\n  lng: number;\n  address?: string;\n}\n\ninterface SearchResult extends LocationValue {\n  id: string | number;\n}\n\ninterface LocationPickerFieldProps extends BaseFieldProps {\n  locationConfig?: {\n    apiKey?: string;\n    defaultLocation?: { lat: number; lng: number };\n    zoom?: number;\n    searchPlaceholder?: string;\n    enableSearch?: boolean;\n    enableGeolocation?: boolean;\n    mapProvider?: 'google' | 'openstreetmap';\n  };\n}\n\nexport const LocationPickerField: React.FC<LocationPickerFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  locationConfig = {},\n}) => {\n  const {\n    defaultLocation = { lat: 40.7128, lng: -74.0060 }, // NYC default\n    searchPlaceholder = \"Search for a location...\",\n    enableSearch = true,\n    enableGeolocation = true\n  } = locationConfig;\n\n  const name = fieldApi.name;\n\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [isSearching, setIsSearching] = useState(false);\n  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);\n  const [showResults, setShowResults] = useState(false);\n  const [currentLocation, setCurrentLocation] = useState<LocationValue | null>(\n    fieldApi.state?.value || (defaultLocation ? { ...defaultLocation, address: \"Default Location\" } : null)\n  );\n  const mapRef = useRef<HTMLDivElement>(null);\n  const searchTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const [geoError, setGeoError] = useState<string | null>(null);\n\n  const [manualLat, setManualLat] = useState('');\n  const [manualLng, setManualLng] = useState('');\n\n  const handleManualCoordinatesSubmit = () => {\n    const lat = parseFloat(manualLat);\n    const lng = parseFloat(manualLng);\n    if (!isNaN(lat) && !isNaN(lng)) {\n      const location: LocationValue = {\n        lat,\n        lng,\n        address: `${lat}, ${lng}`\n      };\n      handleLocationSelect(location);\n\n    } else {\n      alert(\"Invalid coordinates. Please enter valid numbers.\");\n    }\n  };\n\n  // Initialize map (simplified version without external dependencies)\n{/* Map placeholder */}\n<div ref={mapRef} className=\"w-full h-48 border rounded-md\">\n  {currentLocation ? (\n    <div className=\"w-full h-48 bg-muted rounded-md flex items-center justify-center text-muted-foreground\">\n      <div className=\"text-center\">\n        <div className=\"text-sm font-medium\">\n          Location: {currentLocation.lat.toFixed(4)}, {currentLocation.lng.toFixed(4)}\n        </div>\n        {currentLocation.address && (\n          <div className=\"text-xs mt-1\">{currentLocation.address}</div>\n        )}\n      </div>\n    </div>\n  ) : (\n    <div className=\"w-full h-full bg-muted rounded-md flex items-center justify-center text-muted-foreground\">\n      <div className=\"text-center\">\n        <div className=\"text-sm\">No location selected</div>\n        <div className=\"text-xs mt-1\">Search or use current location</div>\n      </div>\n    </div>\n  )}\n</div>\n\n  // Handle search with debouncing\n  useEffect(() => {\n    if (!enableSearch || !searchQuery.trim()) {\n      setSearchResults([]);\n      setShowResults(false);\n      return;\n    }\n\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n\n    searchTimeoutRef.current = setTimeout(async () => {\n      setIsSearching(true);\n      try {\n        // Mock search results - in real implementation, this would call a geocoding API\n        const mockResults = [\n          {\n            id: 1,\n            address: `${searchQuery} Street, New York, NY`,\n            lat: 40.7128 + Math.random() * 0.01,\n            lng: -74.0060 + Math.random() * 0.01\n          },\n          {\n            id: 2,\n            address: `${searchQuery} Avenue, Brooklyn, NY`,\n            lat: 40.6782 + Math.random() * 0.01,\n            lng: -73.9442 + Math.random() * 0.01\n          }\n        ];\n        \n        setSearchResults(mockResults);\n        setShowResults(true);\n      } catch (error) {\n        console.error('Location search error:', error);\n        setSearchResults([]);\n      } finally {\n        setIsSearching(false);\n      }\n    }, 300);\n\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, [searchQuery, enableSearch]);\n\n  const handleLocationSelect = (location: LocationValue) => {\n    setCurrentLocation(location);\n    fieldApi.handleChange(location);\n    setShowResults(false);\n    setSearchQuery(location.address || `${location.lat}, ${location.lng}`);\n  };\n\n  const handleGetCurrentLocation = () => {\n    if (!enableGeolocation || !navigator.geolocation) {\n      setGeoError('Geolocation is not supported by your browser');\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const location: LocationValue = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          address: \"Current Location\"\n        };\n        handleLocationSelect(location);\n        setGeoError(null);\n      },\n      (error) => {\n        const errorMessages: Record<number, string> = {\n          1: 'Location access denied. Please enable location permissions.',\n          2: 'Location unavailable. Please try again.',\n          3: 'Location request timed out. Please try again.'\n        };\n        setGeoError(errorMessages[error.code] || 'Failed to get location');\n      }\n    );\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={labelClassName}>\n          {label}\n        </Label>\n      )}\n      \n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <div className=\"space-y-3\">\n        {enableSearch && (\n          <div className=\"relative\">\n            <Input\n              id={name}\n              value={searchQuery}\n              onChange={(e) => setSearchQuery(e.target.value)}\n              placeholder={placeholder || searchPlaceholder}\n              className={inputClassName}\n              onFocus={() => searchResults.length > 0 && setShowResults(true)}\n            />\n            \n            {showResults && searchResults.length > 0 && (\n              <Card className=\"absolute top-full left-0 right-0 z-10 mt-1 max-h-48 overflow-y-auto\">\n                <div className=\"p-2\">\n                  {isSearching && (\n                    <div className=\"text-sm text-muted-foreground p-2\">\n                      Searching...\n                    </div>\n                  )}\n                  {searchResults.map((result) => (\n                    <button\n                      key={result.id}\n                      type=\"button\"\n                      className=\"w-full text-left p-2 hover:bg-muted rounded-sm text-sm\"\n                      onClick={() => handleLocationSelect({\n                        lat: result.lat,\n                        lng: result.lng,\n                        address: result.address\n                      })}\n                    >\n                      {result.address}\n                    </button>\n                  ))}\n                </div>\n              </Card>\n            )}\n          </div>\n        )}\n\n        <div className=\"flex gap-2\">\n          {enableGeolocation && (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={handleGetCurrentLocation}\n            >\n              Use Current Location\n            </Button>\n          )}\n          \n          <Dialog>\n            <DialogTrigger asChild>\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                size=\"sm\"\n              >\n                Enter Coordinates\n              </Button>\n            </DialogTrigger>\n            <DialogContent className=\"sm:max-w-[425px]\">\n              <DialogHeader>\n                <DialogTitle>Enter Coordinates</DialogTitle>\n                <DialogDescription>\n                  Enter the latitude and longitude.\n                </DialogDescription>\n              </DialogHeader>\n              <div className=\"grid gap-4 py-4\">\n                <div className=\"grid grid-cols-4 items-center gap-4\">\n                  <Label htmlFor=\"latitude\" className=\"text-right\">\n                    Latitude\n                  </Label>\n                  <Input id=\"latitude\" value={manualLat} onChange={(e) => setManualLat(e.target.value)} className=\"col-span-3\" />\n                </div>\n                <div className=\"grid grid-cols-4 items-center gap-4\">\n                  <Label htmlFor=\"longitude\" className=\"text-right\">\n                    Longitude\n                  </Label>\n                  <Input id=\"longitude\" value={manualLng} onChange={(e) => setManualLng(e.target.value)} className=\"col-span-3\" />\n                </div>\n              </div>\n              <DialogFooter>\n                <Button type=\"button\" onClick={handleManualCoordinatesSubmit}>Save changes</Button>\n              </DialogFooter>\n            </DialogContent>\n          </Dialog>\n        </div>\n\n        {/* Map placeholder */}\n        <div ref={mapRef} className=\"w-full h-48 border rounded-md\">\n          {!currentLocation && (\n            <div className=\"w-full h-full bg-muted rounded-md flex items-center justify-center text-muted-foreground\">\n              <div className=\"text-center\">\n                <div className=\"text-sm\">No location selected</div>\n                <div className=\"text-xs mt-1\">Search or use current location</div>\n              </div>\n            </div>\n          )}\n        </div>\n\n        {currentLocation && (\n          <div className=\"text-sm text-muted-foreground\">\n            Selected: {currentLocation.address || `${currentLocation.lat}, ${currentLocation.lng}`}\n          </div>\n        )}\n      </div>\n\n      {geoError && (\n        <p className=\"text-sm text-destructive mt-2\">{geoError}</p>\n      )}\n\n      {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">\n          {fieldApi.state?.meta?.errors[0]}\n        </p>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/location-picker-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/masked-input-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\ninterface MaskedInputFieldProps extends BaseFieldProps {\n  maskedInputConfig?: {\n    mask: string | ((value: string) => string);\n    placeholder?: string;\n    showMask?: boolean;\n    guide?: boolean;\n    keepCharPositions?: boolean;\n    pipe?: (conformedValue: string, config: unknown) => false | string | { value: string; indexesOfPipedChars: number[] };\n  };\n}\n\n// Common mask patterns\nconst MASK_PATTERNS = {\n  phone: '(000) 000-0000',\n  ssn: '000-00-0000',\n  creditCard: '0000 0000 0000 0000',\n  date: '00/00/0000',\n  time: '00:00',\n  zipCode: '00000',\n  zipCodeExtended: '00000-0000',\n  currency: '$0,000.00',\n};\n\nexport const MaskedInputField: React.FC<MaskedInputFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  wrapperClassName,\n  labelClassName,\n  inputClassName,\n  maskedInputConfig = {},\n}) => {\n  const name = fieldApi.name;\n\n  const {\n    mask = '',\n    showMask = false,\n    guide = true,\n\n    pipe\n  } = maskedInputConfig;\n\n  const [displayValue, setDisplayValue] = useState('');\n  const [rawValue, setRawValue] = useState('');\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Apply mask to value\n  const applyMask = React.useCallback((value: string): string => {\n    if (!mask) return value;\n\n    if (typeof mask === 'function') {\n      return mask(value);\n    }\n\n    // Handle string mask patterns\n    let maskedValue = '';\n    let digitIndex = 0;\n    let letterIndex = 0;\n    const cleanDigits = value.replace(/\\D/g, ''); // Extract digits\n    const cleanLetters = value.replace(/[^a-zA-Z]/g, ''); // Extract letters\n\n    for (let i = 0; i < mask.length; i++) {\n      const maskChar = mask[i];\n      \n      if (maskChar === '0' || maskChar === '9') {\n        // Digit placeholder\n        if (digitIndex < cleanDigits.length) {\n          maskedValue += cleanDigits[digitIndex];\n          digitIndex++;\n        } else if (guide && showMask) {\n          maskedValue += '_';\n        } else {\n          break; // Stop if no more digits and not showing guide\n        }\n      } else if (maskChar === 'A' || maskChar === 'a') {\n        // Letter placeholder\n        if (letterIndex < cleanLetters.length) {\n          const char = cleanLetters[letterIndex];\n          maskedValue += maskChar === 'A' ? char.toUpperCase() : char.toLowerCase();\n          letterIndex++;\n        } else if (guide && showMask) {\n          maskedValue += '_';\n        } else {\n          break; // Stop if no more letters and not showing guide\n        }\n      } else {\n        // Literal character\n        maskedValue += maskChar;\n      }\n    }\n\n    // Apply pipe function if provided\n    if (pipe) {\n      const piped = pipe(maskedValue, { mask, guide, showMask });\n      if (piped === false) {\n        return displayValue; // Reject the change\n      }\n      if (typeof piped === 'string') {\n        return piped;\n      }\n      if (piped && typeof piped === 'object' && piped.value) {\n        return piped.value;\n      }\n    }\n\n    return maskedValue;\n  }, [mask, guide, showMask, pipe, displayValue]);\n\n  // Initialize from field value\n  useEffect(() => {\n    const value = fieldApi.state?.value || '';\n    setRawValue(value);\n    setDisplayValue(applyMask(value));\n  }, [fieldApi.state?.value, applyMask]);\n\n  // Extract raw value from masked value\n  const extractRawValue = (maskedValue: string): string => {\n    if (!mask || typeof mask === 'function') {\n      return maskedValue;\n    }\n\n    // For string masks, extract only the actual input characters\n    let rawValue = '';\n    let maskIndex = 0;\n\n    for (let i = 0; i < maskedValue.length && maskIndex < mask.length; i++) {\n      const char = maskedValue[i];\n      const maskChar = mask[maskIndex];\n\n      if (maskChar === '0' || maskChar === '9') {\n        if (/\\d/.test(char)) {\n          rawValue += char;\n        }\n        maskIndex++;\n      } else if (maskChar === 'A' || maskChar === 'a') {\n        if (/[a-zA-Z]/.test(char)) {\n          rawValue += char;\n        }\n        maskIndex++;\n      } else if (char === maskChar) {\n        // Skip literal characters\n        maskIndex++;\n      } else {\n        // Character doesn't match mask, skip it\n        continue;\n      }\n    }\n\n    return rawValue;\n  };\n\n  // Handle input change\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    const newRawValue = extractRawValue(inputValue);\n    const newDisplayValue = applyMask(newRawValue);\n\n    setRawValue(newRawValue);\n    setDisplayValue(newDisplayValue);\n    fieldApi.handleChange(newRawValue);\n  };\n\n  // Handle key down for better UX\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const input = e.target as HTMLInputElement;\n    const { selectionStart, selectionEnd } = input;\n\n    // Handle backspace to skip over literal characters\n    if (e.key === 'Backspace' && selectionStart !== null && selectionEnd !== null && selectionStart === selectionEnd && selectionStart > 0) {\n      const maskChar = typeof mask === 'string' ? mask[selectionStart - 1] : '';\n      \n      // If the previous character is a literal (not a placeholder), skip it\n      if (maskChar && maskChar !== '0' && maskChar !== '9' && maskChar !== 'A' && maskChar !== 'a') {\n        e.preventDefault();\n        const newCursorPos = selectionStart - 1;\n        setTimeout(() => {\n          if (inputRef.current) {\n            inputRef.current.setSelectionRange(newCursorPos, newCursorPos);\n          }\n        }, 0);\n      }\n    }\n  };\n\n  // Get placeholder text\n  const getPlaceholder = (): string => {\n    if (placeholder) return placeholder;\n    if (maskedInputConfig.placeholder) return maskedInputConfig.placeholder;\n    if (showMask && typeof mask === 'string') {\n      return mask.replace(/[09Aa]/g, '_');\n    }\n    return '';\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", wrapperClassName)}>\n      {label && (\n        <Label htmlFor={name} className={labelClassName}>\n          {label}\n        </Label>\n      )}\n      \n      {description && (\n        <p className=\"text-sm text-muted-foreground\">{description}</p>\n      )}\n\n      <Input\n        ref={inputRef}\n        id={name}\n        name={name}\n        value={displayValue}\n        onChange={handleInputChange}\n        onKeyDown={handleKeyDown}\n        placeholder={getPlaceholder()}\n        className={inputClassName}\n      />\n\n      {/* Show mask pattern hint */}\n      {mask && typeof mask === 'string' && (\n        <div className=\"text-xs text-muted-foreground\">\n          Format: {mask.replace(/[09]/g, '#').replace(/[Aa]/g, 'A')}\n        </div>\n      )}\n\n      {/* Show raw value for debugging */}\n      {process.env.NODE_ENV === 'development' && rawValue !== displayValue && (\n        <div className=\"text-xs text-muted-foreground\">\n          Raw value: {rawValue}\n        </div>\n      )}\n\n      {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n        <p className=\"text-sm text-destructive\">\n          {fieldApi.state?.meta?.errors[0]}\n        </p>\n      )}\n    </div>\n  );\n};\n\n// Export common mask patterns for convenience\nexport { MASK_PATTERNS };",
      "type": "registry:component",
      "target": "components/formedible/fields/masked-input-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/multi-select-field.tsx",
      "content": "'use client';\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\n\nimport { cn } from '@/lib/utils';\nimport { X, ChevronDown, Check } from 'lucide-react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface MultiSelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n  };\n}\n\nexport const MultiSelectField: React.FC<MultiSelectFieldSpecificProps> = ({\n  fieldApi,\n  options = [],\n  multiSelectConfig = {},\n  \n  ...wrapperProps\n}) => {\n  const {\n    maxSelections = Infinity,\n    searchable = true,\n    creatable = false,\n    placeholder = 'Select options...',\n    noOptionsText = 'No options found',\n  } = multiSelectConfig;\n\n  const name = fieldApi.name;\n  const selectedValues = Array.isArray(fieldApi.state?.value) ? (fieldApi.state?.value as string[]) : [];\n  \n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const containerRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const normalizedOptions = options.map(option => \n    typeof option === 'string' \n      ? { value: option, label: option }\n      : option\n  );\n\n  // Filter options based on search query\n  const filteredOptions = normalizedOptions.filter(option =>\n    option.label.toLowerCase().includes(searchQuery.toLowerCase()) ||\n    option.value.toLowerCase().includes(searchQuery.toLowerCase())\n  );\n\n  // Add create option if enabled and query doesn't match existing options\n  const canCreate = creatable && \n    searchQuery.trim() && \n    !normalizedOptions.some(opt => \n      opt.value.toLowerCase() === searchQuery.toLowerCase() ||\n      opt.label.toLowerCase() === searchQuery.toLowerCase()\n    ) &&\n    !selectedValues.includes(searchQuery.trim());\n\n  const displayOptions = [...filteredOptions];\n  if (canCreate) {\n    displayOptions.unshift({\n      value: searchQuery.trim(),\n      label: `Create \"${searchQuery.trim()}\"`,\n      isCreateOption: true\n    } as { value: string; label: string; isCreateOption: true });\n  }\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n        setSearchQuery('');\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleSelect = (optionValue: string) => {\n    if (selectedValues.includes(optionValue)) {\n      // Remove if already selected\n      const newValues = selectedValues.filter(v => v !== optionValue);\n      fieldApi.handleChange(newValues);\n    } else if (selectedValues.length < maxSelections) {\n      // Add if not at max selections\n      const newValues = [...selectedValues, optionValue];\n      fieldApi.handleChange(newValues);\n    }\n    \n    setSearchQuery('');\n    if (!searchable) {\n      setIsOpen(false);\n    }\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (valueToRemove: string) => {\n    const newValues = selectedValues.filter(v => v !== valueToRemove);\n    fieldApi.handleChange(newValues);\n    fieldApi.handleBlur();\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Backspace' && !searchQuery && selectedValues.length > 0) {\n      // Remove last selected item on backspace\n      handleRemove(selectedValues[selectedValues.length - 1]);\n    } else if (e.key === 'Enter' && canCreate) {\n      e.preventDefault();\n      handleSelect(searchQuery.trim());\n    } else if (e.key === 'Escape') {\n      setIsOpen(false);\n      setSearchQuery('');\n    }\n  };\n\n  const getSelectedLabels = () => {\n    return selectedValues.map(value => {\n      const option = normalizedOptions.find(opt => opt.value === value);\n      return option ? option.label : value;\n    });\n  };\n\n  const isDisabled = fieldApi.form.state.isSubmitting;\n\n  return (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"space-y-2\" ref={containerRef}>\n        {wrapperProps.label && maxSelections < Infinity && (\n          <div className=\"text-sm text-muted-foreground\">\n            ({selectedValues.length}/{maxSelections})\n          </div>\n        )}\n\n        <div className=\"relative\">\n          {/* Selected items display */}\n          <div\n            className={cn(\n              \"min-h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background\",\n              \"focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2\",\n              fieldApi.state?.meta?.errors.length ? \"border-destructive\" : \"\",\n              isDisabled ? \"opacity-50 cursor-not-allowed\" : \"cursor-text\"\n            )}\n            onClick={() => {\n              if (!isDisabled) {\n                setIsOpen(true);\n                inputRef.current?.focus();\n              }\n            }}\n          >\n          <div className=\"flex flex-wrap gap-1 items-center\">\n            {/* Selected tags */}\n            {selectedValues.map((value, index) => {\n              const label = getSelectedLabels()[index];\n              return (\n                <Badge\n                  key={value}\n                  variant=\"secondary\"\n                  className=\"text-xs h-6 px-2 gap-1\"\n                >\n                  {label}\n                  <Button\n                    type=\"button\"\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-3 w-3 p-0 hover:bg-destructive hover:text-destructive-foreground\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleRemove(value);\n                    }}\n                    disabled={isDisabled}\n                  >\n                    <X className=\"h-2 w-2\" />\n                  </Button>\n                </Badge>\n              );\n            })}\n            \n            {/* Search input */}\n            {searchable && (\n              <Input\n                ref={inputRef}\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                onKeyDown={handleKeyDown}\n                onFocus={() => setIsOpen(true)}\n                onBlur={fieldApi.handleBlur}\n                placeholder={selectedValues.length === 0 ? placeholder : ''}\n                className=\"border-0 p-0 h-6 focus-visible:ring-0 focus-visible:ring-offset-0 bg-transparent\"\n                disabled={isDisabled || selectedValues.length >= maxSelections}\n              />\n            )}\n            \n            {/* Dropdown indicator */}\n            <ChevronDown \n              className={cn(\n                \"h-4 w-4 text-muted-foreground transition-transform ml-auto\",\n                isOpen ? \"rotate-180\" : \"\"\n              )} \n            />\n          </div>\n        </div>\n\n        {/* Dropdown */}\n        {isOpen && (\n          <div className=\"absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto\">\n            {displayOptions.length === 0 ? (\n              <div className=\"p-2 text-sm text-muted-foreground text-center\">\n                {noOptionsText}\n              </div>\n            ) : (\n              displayOptions.map((option: { value: string; label: string; isCreateOption?: boolean }, index) => {\n                const isSelected = selectedValues.includes(option.value);\n                const isDisabled = !isSelected && selectedValues.length >= maxSelections;\n                \n                return (\n                  <button\n                    key={`${option.value}-${index}`}\n                    type=\"button\"\n                    className={cn(\n                      \"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\",\n                      \"flex items-center justify-between\",\n                      isSelected ? \"bg-accent\" : \"\",\n                      isDisabled ? \"opacity-50 cursor-not-allowed\" : \"\",\n                      option.isCreateOption ? \"font-medium text-primary\" : \"\"\n                    )}\n                    onClick={() => !isDisabled && handleSelect(option.value)}\n                    disabled={isDisabled}\n                  >\n                    <span>{option.label}</span>\n                    {isSelected && <Check className=\"h-4 w-4\" />}\n                  </button>\n                );\n              })\n            )}\n          </div>\n        )}\n      </div>\n\n      </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/multi-select-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/number-field.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Input } from '@/components/ui/input';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface NumberFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nexport const NumberField: React.FC<NumberFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  min,\n  max,\n  step,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as number | string | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value;\n    let parsedValue: number | string | undefined;\n    \n    if (val === '') {\n      parsedValue = undefined;\n    } else {\n      const num = parseFloat(val);\n      parsedValue = isNaN(num) ? val : num;\n    }\n    \n    fieldApi.handleChange(parsedValue);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  let displayValue: string | number = '';\n  if (typeof value === 'number') {\n    displayValue = value;\n  } else if (typeof value === 'string') {\n    displayValue = value;\n  }\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Input\n        id={name}\n        name={name}\n        type=\"number\"\n        value={displayValue}\n        onBlur={onBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        className={computedInputClassName}\n        disabled={isDisabled}\n        min={min}\n        max={max}\n        step={step}\n      />\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/number-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/object-field.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\n\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\n// Note: Import individual field components directly to avoid circular dependency\nimport { TextField } from \"./text-field\";\nimport { NumberField } from \"./number-field\";\nimport { SelectField } from \"./select-field\";\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface ObjectFieldConfig {\n  title?: string;\n  description?: string;\n  fields: Array<{\n    name: string;\n    type: string;\n    label?: string;\n    placeholder?: string;\n    description?: string;\n    options?: Array<{ value: string; label: string }>;\n    min?: number;\n    max?: number;\n    step?: number;\n    [key: string]: unknown;\n  }>;\n  collapsible?: boolean;\n  defaultExpanded?: boolean;\n  showCard?: boolean;\n  layout?: \"vertical\" | \"horizontal\" | \"grid\";\n  columns?: number;\n}\n\ninterface ObjectFieldProps extends BaseFieldProps {\n  objectConfig?: ObjectFieldConfig;\n  disabled?: boolean;\n}\n\nexport const ObjectField: React.FC<ObjectFieldProps> = ({\n  fieldApi,\n  objectConfig,\n  disabled,\n  ...wrapperProps\n}) => {\n  const name = fieldApi.name;\n  const [isExpanded, setIsExpanded] = React.useState(\n    objectConfig?.defaultExpanded !== false\n  );\n\n  // Create a properly typed mockFieldApi that includes the form property\n  const createMockFieldApi = (fieldName: string, fieldValue: unknown) => {\n    return {\n      name: `${fieldApi.name}.${fieldName}`,\n      form: fieldApi.form, // Include the form property to fix the bug\n      state: {\n        ...fieldApi.state,\n        value: fieldValue,\n        meta: {\n          ...fieldApi.state.meta,\n          errors: [], // Reset errors for subfield\n          isTouched: false, // Reset touched state for subfield\n        }\n      },\n      handleChange: (value: unknown) => {\n        const currentValue = fieldApi.state?.value || {};\n        fieldApi.handleChange({\n          ...currentValue,\n          [fieldName]: value\n        });\n      },\n      handleBlur: fieldApi.handleBlur,\n    };\n  };\n\n  const renderField = (fieldConfig: ObjectFieldConfig['fields'][0]) => {\n    // Map field types to components directly to avoid circular dependency\n    const fieldComponentMap = {\n      text: TextField,\n      number: NumberField,\n      select: SelectField,\n    };\n    \n    const FieldComponent = fieldComponentMap[fieldConfig.type as keyof typeof fieldComponentMap];\n    \n    if (!FieldComponent) {\n      console.warn(`Object field: Unknown field type \"${fieldConfig.type}\"`);\n      return null;\n    }\n\n    const fieldValue = fieldApi.state?.value?.[fieldConfig.name] || '';\n    const mockFieldApi = createMockFieldApi(fieldConfig.name, fieldValue) as unknown as BaseFieldProps['fieldApi'];\n\n    // Create properly typed field props using the helper\n    const baseProps: BaseFieldProps = {\n      fieldApi: mockFieldApi,\n      label: fieldConfig.label,\n      placeholder: fieldConfig.placeholder,\n      description: fieldConfig.description,\n    };\n\n    const additionalProps: Record<string, unknown> = {\n      ...(fieldConfig.min !== undefined && { min: fieldConfig.min }),\n      ...(fieldConfig.max !== undefined && { max: fieldConfig.max }),\n      ...(fieldConfig.step !== undefined && { step: fieldConfig.step }),\n      ...(disabled !== undefined && { disabled }),\n    };\n\n    // Handle fields that require options with proper typing\n    if (['select', 'radio', 'multiselect'].includes(fieldConfig.type)) {\n      additionalProps.options = fieldConfig.options || [];\n    }\n\n    const fieldProps: any = {\n      ...baseProps,\n      ...additionalProps,\n    };\n\n    // Ensure required props are provided for each field type\n    if (fieldConfig.type === 'select') {\n      fieldProps.options = fieldConfig.options || [];\n    }\n\n    return (\n      <div key={fieldConfig.name}>\n        <FieldComponent {...fieldProps} />\n      </div>\n    );\n  };\n\n  const getLayoutClasses = () => {\n    const layout = objectConfig?.layout || \"vertical\";\n    const columns = objectConfig?.columns || 2;\n    \n    switch (layout) {\n      case \"horizontal\":\n        return \"flex flex-wrap gap-4\";\n      case \"grid\":\n        return `grid grid-cols-1 md:grid-cols-${columns} gap-4`;\n      default:\n        return \"space-y-4\";\n    }\n  };\n\n  const content = (\n    <FieldWrapper fieldApi={fieldApi} {...wrapperProps}>\n      <div className=\"space-y-4\">\n        {/* Object title and description */}\n        {(objectConfig?.title || objectConfig?.description) && (\n          <div className=\"space-y-1\">\n            {objectConfig?.title && (\n              <div className=\"flex items-center justify-between\">\n                <h4 className=\"text-sm font-medium text-muted-foreground\">\n                  {objectConfig.title}\n                </h4>\n                {objectConfig?.collapsible && (\n                  <button\n                    type=\"button\"\n                    onClick={() => setIsExpanded(!isExpanded)}\n                    className=\"text-xs text-muted-foreground hover:text-foreground\"\n                  >\n                    {isExpanded ? \"Collapse\" : \"Expand\"}\n                  </button>\n                )}\n              </div>\n            )}\n            {objectConfig?.description && (\n              <p className=\"text-xs text-muted-foreground\">\n                {objectConfig.description}\n              </p>\n            )}\n          </div>\n        )}\n\n        {/* Fields */}\n        {(!objectConfig?.collapsible || isExpanded) && (\n          <>\n            {objectConfig?.title && <div className=\"border-t my-4\" />}\n            <div className={getLayoutClasses()}>\n              {objectConfig?.fields?.map(renderField)}\n            </div>\n          </>\n        )}\n\n        {/* Show field errors */}\n        {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n          <div className=\"text-sm text-destructive\">\n            {fieldApi.state?.meta?.errors.join(\", \")}\n          </div>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n\n  // Wrap in card if specified\n  if (objectConfig?.showCard) {\n    return (\n      <Card className=\"w-full\">\n        {(objectConfig?.title || objectConfig?.description) && (\n          <CardHeader className=\"pb-3\">\n            {objectConfig?.title && (\n              <div className=\"flex items-center justify-between\">\n                <CardTitle className=\"text-base\">{objectConfig.title}</CardTitle>\n                {objectConfig?.collapsible && (\n                  <button\n                    type=\"button\"\n                    onClick={() => setIsExpanded(!isExpanded)}\n                    className=\"text-xs text-muted-foreground hover:text-foreground\"\n                  >\n                    {isExpanded ? \"Collapse\" : \"Expand\"}\n                  </button>\n                )}\n              </div>\n            )}\n            {objectConfig?.description && (\n              <p className=\"text-sm text-muted-foreground mt-1\">\n                {objectConfig.description}\n              </p>\n            )}\n          </CardHeader>\n        )}\n        <CardContent className=\"pt-0\">\n          {(!objectConfig?.collapsible || isExpanded) && (\n            <div className={getLayoutClasses()}>\n              {objectConfig?.fields?.map(renderField)}\n            </div>\n          )}\n          \n          {/* Show field errors */}\n          {fieldApi.state?.meta?.errors && fieldApi.state?.meta?.errors.length > 0 && (\n            <div className=\"text-sm text-destructive mt-4\">\n              {fieldApi.state?.meta?.errors.join(\", \")}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return content;\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/object-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/phone-field.tsx",
      "content": "'use client';\nimport React, { useState, useEffect } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { cn } from '@/lib/utils';\nimport { ChevronDown, Phone } from 'lucide-react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface PhoneFieldSpecificProps extends BaseFieldProps {\n  phoneConfig?: {\n    defaultCountry?: string;\n    format?: 'national' | 'international';\n    allowedCountries?: string[];\n    placeholder?: string;\n  };\n}\n\n// Common country codes and their formatting\nconst COUNTRY_CODES = {\n  US: { code: '+1', name: 'United States', flag: '🇺🇸', format: '(###) ###-####' },\n  CA: { code: '+1', name: 'Canada', flag: '🇨🇦', format: '(###) ###-####' },\n  GB: { code: '+44', name: 'United Kingdom', flag: '🇬🇧', format: '#### ### ####' },\n  FR: { code: '+33', name: 'France', flag: '🇫🇷', format: '## ## ## ## ##' },\n  DE: { code: '+49', name: 'Germany', flag: '🇩🇪', format: '### ### ####' },\n  IT: { code: '+39', name: 'Italy', flag: '🇮🇹', format: '### ### ####' },\n  ES: { code: '+34', name: 'Spain', flag: '🇪🇸', format: '### ### ###' },\n  AU: { code: '+61', name: 'Australia', flag: '🇦🇺', format: '#### ### ###' },\n  JP: { code: '+81', name: 'Japan', flag: '🇯🇵', format: '##-####-####' },\n  CN: { code: '+86', name: 'China', flag: '🇨🇳', format: '### #### ####' },\n  IN: { code: '+91', name: 'India', flag: '🇮🇳', format: '##### #####' },\n  BR: { code: '+55', name: 'Brazil', flag: '🇧🇷', format: '(##) #####-####' },\n  MX: { code: '+52', name: 'Mexico', flag: '🇲🇽', format: '## #### ####' },\n  RU: { code: '+7', name: 'Russia', flag: '🇷🇺', format: '### ###-##-##' },\n  KR: { code: '+82', name: 'South Korea', flag: '🇰🇷', format: '##-####-####' },\n};\n\nconst formatPhoneNumber = (value: string, format: string): string => {\n  // Remove all non-digits\n  const digits = value.replace(/\\D/g, '');\n  \n  // Apply format pattern\n  let formatted = '';\n  let digitIndex = 0;\n  \n  for (const char of format) {\n    if (char === '#' && digitIndex < digits.length) {\n      formatted += digits[digitIndex];\n      digitIndex++;\n    } else if (char !== '#') {\n      formatted += char;\n    } else {\n      break;\n    }\n  }\n  \n  return formatted;\n};\n\nconst extractDigits = (value: string): string => {\n  return value.replace(/\\D/g, '');\n};\n\nexport const PhoneField: React.FC<PhoneFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder: fieldPlaceholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  phoneConfig = {},\n}) => {\n  const {\n    defaultCountry = 'US',\n    format = 'national',\n    allowedCountries,\n    placeholder,\n  } = phoneConfig;\n\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n  \n  const [selectedCountry, setSelectedCountry] = useState(defaultCountry);\n  const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);\n  const [phoneNumber, setPhoneNumber] = useState('');\n\n  const availableCountries = allowedCountries \n    ? Object.entries(COUNTRY_CODES).filter(([code]) => allowedCountries.includes(code))\n    : Object.entries(COUNTRY_CODES);\n\n  const currentCountry = COUNTRY_CODES[selectedCountry as keyof typeof COUNTRY_CODES];\n\n  // Parse existing value on mount\n  useEffect(() => {\n    if (value) {\n      // Try to extract country code and phone number\n      const digits = extractDigits(value);\n      \n      // Find matching country code\n      const matchingCountry = Object.entries(COUNTRY_CODES).find(([_, country]) => {\n        const countryDigits = extractDigits(country.code);\n        return digits.startsWith(countryDigits);\n      });\n\n      if (matchingCountry) {\n        const [countryCode, countryData] = matchingCountry;\n        setSelectedCountry(countryCode);\n        \n        const countryCodeDigits = extractDigits(countryData.code);\n        const phoneDigits = digits.slice(countryCodeDigits.length);\n        setPhoneNumber(formatPhoneNumber(phoneDigits, countryData.format));\n      } else {\n        setPhoneNumber(value);\n      }\n    }\n  }, [value]);\n\n  const handlePhoneNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    const digits = extractDigits(inputValue);\n    \n    // Format the phone number according to country format\n    const formatted = formatPhoneNumber(digits, currentCountry.format);\n    setPhoneNumber(formatted);\n    \n    // Create the final value based on format preference\n    const finalValue = format === 'international' \n      ? `${currentCountry.code} ${formatted}`.trim()\n      : formatted;\n    \n    fieldApi.handleChange(finalValue);\n  };\n\n  const handleCountryChange = (countryCode: string) => {\n    setSelectedCountry(countryCode);\n    setIsCountryDropdownOpen(false);\n    \n    // Update the value with new country code\n    const newCountry = COUNTRY_CODES[countryCode as keyof typeof COUNTRY_CODES];\n    const digits = extractDigits(phoneNumber);\n    const formatted = formatPhoneNumber(digits, newCountry.format);\n    \n    const finalValue = format === 'international' \n      ? `${newCountry.code} ${formatted}`.trim()\n      : formatted;\n    \n    fieldApi.handleChange(finalValue);\n  };\n\n  const getPlaceholder = (): string => {\n    if (placeholder) return placeholder;\n    \n    const exampleNumber = formatPhoneNumber('1234567890', currentCountry.format);\n    return format === 'international' \n      ? `${currentCountry.code} ${exampleNumber}`\n      : exampleNumber;\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-2\">\n        <div className=\"flex\">\n          {/* Country selector */}\n          <div className=\"relative\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              className={cn(\n                \"rounded-r-none border-r-0 px-3 h-10 min-w-[80px]\",\n                hasErrors ? \"border-destructive\" : \"\"\n              )}\n              onClick={() => setIsCountryDropdownOpen(!isCountryDropdownOpen)}\n              disabled={isDisabled}\n            >\n              <span className=\"flex items-center gap-2\">\n                <span className=\"text-base\">{currentCountry.flag}</span>\n                {format === 'international' && (\n                  <span className=\"text-xs text-muted-foreground\">\n                    {currentCountry.code}\n                  </span>\n                )}\n                <ChevronDown className=\"h-3 w-3\" />\n              </span>\n            </Button>\n\n            {/* Country dropdown */}\n            {isCountryDropdownOpen && (\n              <div className=\"absolute z-50 top-full left-0 mt-1 bg-popover border rounded-md shadow-lg max-h-60 overflow-y-auto min-w-[200px]\">\n                {availableCountries.map(([code, country]) => (\n                  <button\n                    key={code}\n                    type=\"button\"\n                    className={cn(\n                      \"w-full px-3 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground\",\n                      \"flex items-center gap-3\",\n                      selectedCountry === code ? \"bg-accent\" : \"\"\n                    )}\n                    onClick={() => handleCountryChange(code)}\n                  >\n                    <span className=\"text-base\">{country.flag}</span>\n                    <div className=\"flex-1\">\n                      <div className=\"font-medium\">{country.name}</div>\n                      <div className=\"text-xs text-muted-foreground\">{country.code}</div>\n                    </div>\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Phone number input */}\n          <Input\n            value={phoneNumber}\n            onChange={handlePhoneNumberChange}\n            onBlur={() => fieldApi.handleBlur()}\n            placeholder={getPlaceholder()}\n            className={cn(\n              \"rounded-l-none flex-1\",\n              hasErrors ? \"border-destructive\" : \"\",\n              inputClassName\n            )}\n            disabled={isDisabled}\n          />\n        </div>\n\n        {/* Format hint */}\n        <div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\n          <Phone className=\"h-3 w-3\" />\n          <span>\n            Format: {currentCountry.format.replace(/#/g, '0')}\n            {format === 'international' && ` (${currentCountry.code})`}\n          </span>\n        </div>\n      </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/phone-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/radio-field.tsx",
      "content": "'use client';\nimport React from 'react';\nimport { Label } from '@/components/ui/label';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface RadioFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n  direction?: 'horizontal' | 'vertical';\n}\n\nexport const RadioField: React.FC<RadioFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  options = [],\n  direction = 'vertical',\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as string | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const normalizedOptions = options.map(option => \n    typeof option === 'string' \n      ? { value: option, label: option }\n      : option\n  );\n\n  const onValueChange = (value: string) => {\n    fieldApi.handleChange(value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <RadioGroup\n        value={value || ''}\n        onValueChange={onValueChange}\n        onBlur={onBlur}\n        disabled={isDisabled}\n        className={cn(\n          direction === 'horizontal' \n            ? \"flex flex-wrap gap-6\" \n            : \"flex flex-col space-y-2\",\n          inputClassName\n        )}\n      >\n        {normalizedOptions.map((option, index) => (\n          <div key={`${option.value}-${index}`} className=\"flex items-center space-x-2\">\n            <RadioGroupItem\n              value={option.value}\n              id={`${name}-${option.value}`}\n              className={cn(\n                hasErrors ? \"border-destructive\" : \"\"\n              )}\n            />\n            <Label\n              htmlFor={`${name}-${option.value}`}\n              className=\"text-sm font-normal cursor-pointer\"\n            >\n              {option.label}\n            </Label>\n          </div>\n        ))}\n      </RadioGroup>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/radio-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/rating-field.tsx",
      "content": "'use client';\nimport React, { useState } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Star, Heart, ThumbsUp } from 'lucide-react';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface RatingFieldSpecificProps extends BaseFieldProps {\n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs';\n    size?: 'sm' | 'md' | 'lg';\n    showValue?: boolean;\n  };\n}\n\nconst ICON_COMPONENTS = {\n  star: Star,\n  heart: Heart,\n  thumbs: ThumbsUp,\n};\n\nconst SIZE_CLASSES = {\n  sm: 'h-4 w-4',\n  md: 'h-6 w-6',\n  lg: 'h-8 w-8',\n};\n\nexport const RatingField: React.FC<RatingFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  ratingConfig = {},\n}) => {\n  const {\n    max = 5,\n    allowHalf = false,\n    icon = 'star',\n    size = 'md',\n    showValue = false,\n  } = ratingConfig;\n\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as number) || 0;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  \n  const [hoverValue, setHoverValue] = useState<number | null>(null);\n  const IconComponent = ICON_COMPONENTS[icon];\n  const iconSizeClass = SIZE_CLASSES[size];\n\n  const handleRatingClick = (rating: number) => {\n    fieldApi.handleChange(rating);\n    fieldApi.handleBlur();\n  };\n\n  const handleMouseEnter = (rating: number) => {\n    if (!fieldApi.form.state.isSubmitting) {\n      setHoverValue(rating);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    setHoverValue(null);\n  };\n\n  const getRatingValue = (index: number, isHalf: boolean = false): number => {\n    return isHalf ? index + 0.5 : index + 1;\n  };\n\n  const shouldShowFilled = (index: number, isHalf: boolean = false): boolean => {\n    const ratingValue = getRatingValue(index, isHalf);\n    const currentValue = hoverValue !== null ? hoverValue : value;\n    \n    if (isHalf) {\n      return currentValue >= ratingValue;\n    } else {\n      return currentValue >= ratingValue || (allowHalf && currentValue >= ratingValue - 0.5);\n    }\n  };\n\n  const shouldShowHalfFilled = (index: number): boolean => {\n    if (!allowHalf) return false;\n    \n    const currentValue = hoverValue !== null ? hoverValue : value;\n    const fullRating = index + 1;\n    const halfRating = index + 0.5;\n    \n    return currentValue >= halfRating && currentValue < fullRating;\n  };\n\n\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"space-y-2\">\n        {showValue && (\n          <div className=\"text-xs text-muted-foreground\">\n            ({value}/{max})\n          </div>\n        )}\n        \n        <div className=\"flex items-center gap-1\">\n          {Array.from({ length: max }, (_, index) => (\n            <div key={index} className=\"relative\">\n              {/* Full star/icon button */}\n              <button\n                type=\"button\"\n                className={cn(\n                  \"relative transition-all duration-150 hover:scale-110\",\n                  isDisabled \n                    ? \"cursor-not-allowed opacity-50\" \n                    : \"cursor-pointer\"\n                )}\n                onClick={() => !isDisabled && handleRatingClick(getRatingValue(index, false))}\n                onMouseEnter={() => !isDisabled && handleMouseEnter(getRatingValue(index, false))}\n                onMouseLeave={handleMouseLeave}\n                onBlur={() => fieldApi.handleBlur()}\n                disabled={isDisabled}\n                title={`Rate ${getRatingValue(index, false)} ${icon}${getRatingValue(index, false) !== 1 ? 's' : ''}`}\n              >\n                  <IconComponent\n                    className={cn(\n                      iconSizeClass,\n                      \"transition-colors duration-150\",\n                      shouldShowFilled(index, false)\n                        ? icon === 'star' \n                          ? \"fill-yellow-400 text-yellow-400\" \n                          : icon === 'heart'\n                          ? \"fill-red-500 text-red-500\"\n                          : \"fill-blue-500 text-blue-500\"\n                        : \"text-muted-foreground hover:text-muted-foreground/80\"\n                    )}\n                  />\n                  \n                  {/* Half-fill overlay for half ratings */}\n                  {allowHalf && shouldShowHalfFilled(index) && (\n                    <div className=\"absolute inset-0 overflow-hidden\" style={{ width: '50%' }}>\n                      <IconComponent\n                        className={cn(\n                          iconSizeClass,\n                          icon === 'star' \n                            ? \"fill-yellow-400 text-yellow-400\" \n                            : icon === 'heart'\n                            ? \"fill-red-500 text-red-500\"\n                            : \"fill-blue-500 text-blue-500\"\n                        )}\n                      />\n                    </div>\n                  )}\n                </button>\n\n                {/* Half star/icon button (if half ratings allowed) */}\n                {allowHalf && (\n                  <button\n                    type=\"button\"\n                    className={cn(\n                      \"absolute inset-0 w-1/2 transition-all duration-150\",\n                      isDisabled \n                        ? \"cursor-not-allowed\" \n                        : \"cursor-pointer\"\n                    )}\n                    onClick={() => !isDisabled && handleRatingClick(getRatingValue(index, true))}\n                    onMouseEnter={() => !isDisabled && handleMouseEnter(getRatingValue(index, true))}\n                    onMouseLeave={handleMouseLeave}\n                    disabled={isDisabled}\n                    title={`Rate ${getRatingValue(index, true)} ${icon}s`}\n                  />\n                )}\n              </div>\n            ))}\n            \n            {/* Clear rating button */}\n            {value > 0 && (\n              <button\n                type=\"button\"\n                className={cn(\n                  \"ml-2 text-xs text-muted-foreground hover:text-foreground transition-colors\",\n                  isDisabled ? \"cursor-not-allowed opacity-50\" : \"cursor-pointer\"\n                )}\n                onClick={() => !isDisabled && handleRatingClick(0)}\n                disabled={isDisabled}\n                title=\"Clear rating\"\n              >\n                Clear\n              </button>\n            )}\n          </div>\n        </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/rating-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/select-field.tsx",
      "content": "import React from 'react';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\ninterface SelectFieldSpecificProps extends BaseFieldProps {\n  options: Array<{ value: string; label: string }> | string[];\n}\n\nexport const SelectField: React.FC<SelectFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  options = [],\n}) => {\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onValueChange = (value: string) => {\n    fieldApi.handleChange(value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Select\n        value={value}\n        onValueChange={onValueChange}\n        disabled={isDisabled}\n      >\n        <SelectTrigger\n          id={name + \"-trigger\"}\n          onBlur={onBlur}\n          className={computedInputClassName}\n        >\n          <SelectValue placeholder={placeholder || \"Select an option\"} />\n        </SelectTrigger>\n        <SelectContent>\n          {options.map((option, index) => {\n            const optionValue = typeof option === 'string' ? option : option.value;\n            const optionLabel = typeof option === 'string' ? option : option.label;\n            return (\n              <SelectItem key={optionValue + index} value={optionValue}>\n                {optionLabel}\n              </SelectItem>\n            );\n          })}\n        </SelectContent>\n      </Select>\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/select-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/slider-field.tsx",
      "content": "import React from 'react';\nimport { Slider } from '@/components/ui/slider';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface SliderFieldSpecificProps extends BaseFieldProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  valueLabelPrefix?: string; // E.g., \"Temperature\"\n  valueLabelSuffix?: string; // E.g., \"FPS\" \n  valueDisplayPrecision?: number; // For toFixed()\n  showRawValue?: boolean; // Optionally show raw value next to formatted one\n}\n\nexport const SliderField: React.FC<SliderFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  min = 0,\n  max = 100,\n  step = 1,\n  valueLabelPrefix = '',\n  valueLabelSuffix = '',\n  valueDisplayPrecision = 0,\n  showRawValue = false,\n}) => {\n  const name = fieldApi.name;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const fieldValue = typeof fieldApi.state?.value === 'number' ? fieldApi.state?.value : min;\n  const displayValue = fieldValue.toFixed(valueDisplayPrecision);\n\n  const onValueChange = (valueArray: number[]) => {\n    const newValue = valueArray[0];\n    fieldApi.handleChange(newValue);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  // Custom label with value display\n  const customLabel = label \n    ? `${label} (${valueLabelPrefix}${displayValue}${valueLabelSuffix})`\n    : undefined;\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={customLabel}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div>\n        {showRawValue && (\n          <div className=\"text-xs text-muted-foreground mb-2\">\n            Raw: {fieldApi.state?.value}\n          </div>\n        )}\n        <Slider\n          id={name}\n          name={name}\n          value={[fieldValue]}\n          onValueChange={onValueChange}\n          onBlur={onBlur}\n          disabled={isDisabled}\n          min={min}\n          max={max}\n          step={step}\n          className={cn(inputClassName)}\n        />\n      </div>\n    </FieldWrapper>\n  );\n}; ",
      "type": "registry:component",
      "target": "components/formedible/fields/slider-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/switch-field.tsx",
      "content": "import React from 'react';\nimport { Switch } from '@/components/ui/switch';\nimport { Label } from '@/components/ui/label';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport const SwitchField: React.FC<BaseFieldProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as boolean | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n\n  const onCheckedChange = (checked: boolean) => {\n    fieldApi.handleChange(checked);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  return (\n    // Note: We pass label={undefined} to FieldWrapper and render the label manually\n    // because Switch components need the label positioned next to (not above) the control\n    <FieldWrapper \n      fieldApi={fieldApi} \n      label={undefined}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"flex items-center space-x-2\">\n        <Switch\n          id={name}\n          checked={!!value}\n          onCheckedChange={onCheckedChange}\n          onBlur={onBlur}\n          disabled={isDisabled}\n          aria-describedby={description ? `${name}-description` : undefined}\n        />\n        {label && (\n          <Label \n            htmlFor={name} \n            className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", labelClassName)}\n          >\n            {label}\n          </Label>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/formedible/fields/switch-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/text-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport type { BaseFieldProps } from \"@/lib/formedible/types\";\nimport { FieldWrapper } from \"./base-field-wrapper\";\n\nexport interface TextFieldSpecificProps extends BaseFieldProps {\n  type?: \"text\" | \"email\" | \"password\" | \"url\" | \"tel\" | \"datetime-local\";\n  datalist?: {\n    options?: string[];\n    asyncOptions?: (query: string) => Promise<string[]>;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n  };\n}\n\nexport const TextField: React.FC<TextFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  type = \"text\",\n  datalist,\n}) => {\n  const name = fieldApi.name;\n  const value = fieldApi.state?.value as string | number | undefined;\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  // Datalist state\n  const [datalistOptions, setDatalistOptions] = useState<string[]>(\n    datalist?.options || []\n  );\n  const [isLoadingOptions, setIsLoadingOptions] = useState(false);\n  const [lastQuery, setLastQuery] = useState(\"\");\n\n  // Debounced async options fetching\n  const fetchAsyncOptions = useCallback(\n    async (query: string) => {\n      if (!datalist?.asyncOptions) return;\n\n      const minChars = datalist.minChars || 1;\n      if (query.length < minChars) {\n        setDatalistOptions(datalist.options || []);\n        return;\n      }\n\n      if (query === lastQuery) return;\n\n      setIsLoadingOptions(true);\n      setLastQuery(query);\n\n      try {\n        const results = await datalist.asyncOptions(query);\n        const maxResults = datalist.maxResults || 10;\n        const limitedResults = results.slice(0, maxResults);\n\n        // Combine static options with async results\n        const staticOptions = datalist.options || [];\n        const combinedOptions = [...staticOptions, ...limitedResults];\n\n        // Remove duplicates\n        const uniqueOptions = Array.from(new Set(combinedOptions));\n\n        setDatalistOptions(uniqueOptions);\n      } catch (error) {\n        console.error(\"Error fetching datalist options:\", error);\n        // Fallback to static options on error\n        setDatalistOptions(datalist.options || []);\n      } finally {\n        setIsLoadingOptions(false);\n      }\n    },\n    [datalist, lastQuery]\n  );\n\n  // Debounced effect for async options\n  useEffect(() => {\n    if (!datalist?.asyncOptions) return;\n\n    const debounceMs = datalist.debounceMs || 300;\n    const currentValue = String(value || \"\");\n\n    const timeoutId = setTimeout(() => {\n      fetchAsyncOptions(currentValue);\n    }, debounceMs);\n\n    return () => clearTimeout(timeoutId);\n  }, [value, fetchAsyncOptions, datalist]);\n\n  // Generate unique datalist id\n  const datalistId = useMemo(\n    () => (datalist ? `${name}-datalist` : undefined),\n    [name, datalist]\n  );\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    fieldApi.handleChange(e.target.value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\",\n    isLoadingOptions ? \"pr-8\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <div className=\"relative\">\n        <Input\n          id={name}\n          name={name}\n          type={type}\n          value={value === undefined || value === null ? \"\" : String(value)}\n          onBlur={onBlur}\n          onChange={onChange}\n          placeholder={placeholder}\n          className={computedInputClassName}\n          disabled={isDisabled}\n          list={datalistId}\n          autoComplete={datalist ? \"off\" : undefined}\n        />\n        {isLoadingOptions && (\n          <div className=\"absolute right-2 top-1/2 transform -translate-y-1/2\">\n            <span className=\"text-xs text-muted-foreground\">Loading...</span>\n          </div>\n        )}\n        {datalist && datalistOptions.length > 0 && (\n          <datalist id={datalistId}>\n            {datalistOptions.map((option, index) => (\n              <option key={`${option}-${index}`} value={option} />\n            ))}\n          </datalist>\n        )}\n      </div>\n    </FieldWrapper>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/formedible/fields/text-field.tsx"
    },
    {
      "path": "src/components/formedible/fields/textarea-field.tsx",
      "content": "import React from 'react';\nimport { Textarea } from '@/components/ui/textarea';\nimport { cn } from '@/lib/utils';\nimport type { BaseFieldProps } from '@/lib/formedible/types';\nimport { FieldWrapper } from './base-field-wrapper';\n\nexport interface TextareaFieldSpecificProps extends BaseFieldProps {\n  rows?: number;\n}\n\nexport const TextareaField: React.FC<TextareaFieldSpecificProps> = ({\n  fieldApi,\n  label,\n  description,\n  placeholder,\n  inputClassName,\n  labelClassName,\n  wrapperClassName,\n  rows = 3,\n}) => {\n  const name = fieldApi.name;\n  const value = (fieldApi.state?.value as string) || '';\n  const isDisabled = fieldApi.form?.state?.isSubmitting ?? false;\n  const hasErrors = fieldApi.state?.meta?.isTouched && fieldApi.state?.meta?.errors?.length > 0;\n\n  const onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    fieldApi.handleChange(e.target.value);\n  };\n\n  const onBlur = () => {\n    fieldApi.handleBlur();\n  };\n\n  const computedInputClassName = cn(\n    inputClassName,\n    hasErrors ? \"border-destructive\" : \"\"\n  );\n\n  return (\n    <FieldWrapper\n      fieldApi={fieldApi}\n      label={label}\n      description={description}\n      inputClassName={inputClassName}\n      labelClassName={labelClassName}\n      wrapperClassName={wrapperClassName}\n    >\n      <Textarea\n        id={name}\n        name={name}\n        value={value}\n        onBlur={onBlur}\n        onChange={onChange}\n        placeholder={placeholder}\n        rows={rows}\n        className={computedInputClassName}\n        disabled={isDisabled}\n      />\n    </FieldWrapper>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/fields/textarea-field.tsx"
    },
    {
      "path": "src/components/formedible/layout/form-tabs.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { cn } from \"@/lib/utils\";\n\ninterface FormTabsProps {\n  children?: React.ReactNode;\n  tabs: {\n    id: string;\n    label: string;\n    content: React.ReactNode;\n  }[];\n  activeTab: string; // CONTROLLED - NO INTERNAL STATE\n  className?: string;\n  onTabChange: (tabId: string) => void; // REQUIRED - PARENT CONTROLS STATE\n}\n\n// PURE DISPLAY COMPONENT - NO STATE, NO RERENDERS\nexport const FormTabs: React.FC<FormTabsProps> = ({\n  children,\n  tabs,\n  activeTab,\n  className,\n  onTabChange,\n}) => {\n  return (\n    <div className={cn(\"space-y-4\", className)}>\n      {children}\n      \n      <Tabs value={activeTab} onValueChange={onTabChange}>\n        <TabsList className=\"grid w-full\" style={{ gridTemplateColumns: `repeat(${tabs.length}, 1fr)` }}>\n          {tabs.map((tab) => (\n            <TabsTrigger key={tab.id} value={tab.id}>\n              {tab.label}\n            </TabsTrigger>\n          ))}\n        </TabsList>\n        \n        {tabs.map((tab) => (\n          <TabsContent key={tab.id} value={tab.id} className=\"space-y-4\">\n            {tab.content}\n          </TabsContent>\n        ))}\n      </Tabs>\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/layout/form-tabs.tsx"
    },
    {
      "path": "src/components/formedible/layout/form-stepper.tsx",
      "content": "\"use client\";\nimport React, { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\n\ninterface Step {\n  id: string;\n  title: string;\n  description?: string;\n  content: React.ReactNode;\n  optional?: boolean;\n}\n\ninterface FormStepperProps {\n  children?: React.ReactNode;\n  steps: Step[];\n  currentStep?: number;\n  onStepChange?: (stepIndex: number) => void;\n  onComplete?: () => void;\n  className?: string;\n  allowSkip?: boolean;\n  showStepNumbers?: boolean;\n}\n\nexport const FormStepper: React.FC<FormStepperProps> = ({\n  children,\n  steps,\n  currentStep = 0,\n  onStepChange,\n  onComplete,\n  className,\n  allowSkip = false,\n  showStepNumbers = true,\n}) => {\n  const [activeStep, setActiveStep] = useState(currentStep);\n  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());\n\n  const handleStepChange = (stepIndex: number) => {\n    setActiveStep(stepIndex);\n    onStepChange?.(stepIndex);\n  };\n\n  const markStepComplete = (stepIndex: number) => {\n    setCompletedSteps(prev => new Set(prev).add(stepIndex));\n  };\n\n  const handleNext = () => {\n    // Mark current step as completed when moving to next\n    markStepComplete(activeStep);\n    \n    if (activeStep < steps.length - 1) {\n      handleStepChange(activeStep + 1);\n    } else {\n      onComplete?.();\n    }\n  };\n\n\n\n  const handlePrevious = () => {\n    if (activeStep > 0) {\n      handleStepChange(activeStep - 1);\n    }\n  };\n\n  const handleSkip = () => {\n    if (allowSkip && steps[activeStep]?.optional) {\n      handleNext();\n    }\n  };\n\n  const canGoToStep = (stepIndex: number) => {\n    // Can go to current step, previous steps, or next step if current is completed\n    return stepIndex <= activeStep || completedSteps.has(stepIndex - 1);\n  };\n\n  const isStepCompleted = (stepIndex: number) => {\n    return completedSteps.has(stepIndex);\n  };\n\n  const isStepActive = (stepIndex: number) => {\n    return stepIndex === activeStep;\n  };\n\n  return (\n    <div className={cn(\"space-y-6\", className)}>\n      {children}\n      \n      {/* Step indicator */}\n      <div className=\"flex items-center justify-between\">\n        {steps.map((step, index) => (\n          <React.Fragment key={step.id}>\n            <div className=\"flex flex-col items-center\">\n              <button\n                type=\"button\"\n                onClick={() => canGoToStep(index) && handleStepChange(index)}\n                disabled={!canGoToStep(index)}\n                aria-label={`Go to step ${index + 1}: ${step.title}`}\n                aria-current={isStepActive(index) ? 'step' : undefined}\n                tabIndex={canGoToStep(index) ? 0 : -1}\n                className={cn(\n                  \"w-10 h-10 rounded-full border-2 flex items-center justify-center text-sm font-medium transition-colors\",\n                  isStepActive(index) && \"border-primary bg-primary text-primary-foreground\",\n                  isStepCompleted(index) && !isStepActive(index) && \"border-primary bg-primary text-primary-foreground\",\n                  !isStepActive(index) && !isStepCompleted(index) && \"border-muted-foreground text-muted-foreground\",\n                  canGoToStep(index) && \"cursor-pointer hover:border-primary\",\n                  !canGoToStep(index) && \"cursor-not-allowed opacity-50\"\n                )}\n              >\n                {isStepCompleted(index) ? (\n                  \"✓\"\n                ) : showStepNumbers ? (\n                  index + 1\n                ) : (\n                  \"○\"\n                )}\n              </button>\n              \n              <div className=\"mt-2 text-center\">\n                <div className={cn(\n                  \"text-sm font-medium\",\n                  isStepActive(index) && \"text-primary\",\n                  !isStepActive(index) && \"text-muted-foreground\"\n                )}>\n                  {step.title}\n                  {step.optional && (\n                    <span className=\"text-xs text-muted-foreground ml-1\">(optional)</span>\n                  )}\n                </div>\n                {step.description && (\n                  <div className=\"text-xs text-muted-foreground mt-1\">\n                    {step.description}\n                  </div>\n                )}\n              </div>\n            </div>\n            \n            {/* Connector line */}\n            {index < steps.length - 1 && (\n              <div className={cn(\n                \"flex-1 h-0.5 mx-4\",\n                isStepCompleted(index) ? \"bg-primary\" : \"bg-muted\"\n              )} />\n            )}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {/* Step content */}\n      <div className=\"min-h-[200px]\">\n        {steps[activeStep]?.content}\n      </div>\n\n      {/* Navigation buttons */}\n      <div className=\"flex justify-between\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={handlePrevious}\n          disabled={activeStep === 0}\n        >\n          Previous\n        </Button>\n\n        <div className=\"flex gap-2\">\n          {allowSkip && steps[activeStep]?.optional && (\n            <Button\n              type=\"button\"\n              variant=\"ghost\"\n              onClick={handleSkip}\n            >\n              Skip\n            </Button>\n          )}\n          \n          <Button\n            type=\"button\"\n            onClick={handleNext}\n          >\n            {activeStep === steps.length - 1 ? 'Complete' : 'Next'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/layout/form-stepper.tsx"
    },
    {
      "path": "src/components/formedible/layout/form-grid.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface FormGridProps {\n  children: React.ReactNode;\n  columns?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n  gap?: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12';\n  responsive?: boolean;\n  className?: string;\n}\n\nexport const FormGrid: React.FC<FormGridProps> = ({\n  children,\n  columns = 2,\n  gap = \"4\",\n  responsive = true,\n  className,\n}) => {\n  const gapClasses = {\n    '0': 'gap-0', '1': 'gap-1', '2': 'gap-2', '3': 'gap-3', '4': 'gap-4',\n    '5': 'gap-5', '6': 'gap-6', '7': 'gap-7', '8': 'gap-8', '9': 'gap-9',\n    '10': 'gap-10', '11': 'gap-11', '12': 'gap-12'\n  };\n\n  const gridColsClasses = {\n    1: 'grid-cols-1', 2: 'grid-cols-2', 3: 'grid-cols-3', 4: 'grid-cols-4',\n    5: 'grid-cols-5', 6: 'grid-cols-6', 7: 'grid-cols-7', 8: 'grid-cols-8',\n    9: 'grid-cols-9', 10: 'grid-cols-10', 11: 'grid-cols-11', 12: 'grid-cols-12'\n  };\n\n  const gridClasses = cn(\n    \"grid\",\n    gapClasses[gap as keyof typeof gapClasses],\n    responsive ? {\n      \"grid-cols-1\": true,\n      \"md:grid-cols-2\": columns >= 2,\n      \"lg:grid-cols-3\": columns >= 3,\n      \"xl:grid-cols-4\": columns >= 4,\n    } : gridColsClasses[columns as keyof typeof gridColsClasses],\n    className\n  );\n\n  return (\n    <div className={gridClasses}>\n      {children}\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/layout/form-grid.tsx"
    },
    {
      "path": "src/components/formedible/layout/form-accordion.tsx",
      "content": "\"use client\";\nimport React from \"react\";\nimport { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from \"@/components/ui/accordion\";\nimport { cn } from \"@/lib/utils\";\n\ninterface FormAccordionProps {\n  children?: React.ReactNode;\n  sections: {\n    id: string;\n    title: string;\n    content: React.ReactNode;\n    defaultOpen?: boolean;\n  }[];\n  type?: 'single' | 'multiple';\n  className?: string;\n}\n\nexport const FormAccordion: React.FC<FormAccordionProps> = ({\n  children,\n  sections,\n  type = 'single',\n  className,\n}) => {\n  return (\n    <div className={cn(\"space-y-4\", className)}>\n      {children}\n      \n      {type === 'single' ? (\n        <Accordion \n          type=\"single\" \n          defaultValue={sections.find(s => s.defaultOpen)?.id}\n          collapsible\n        >\n          {sections.map((section) => (\n            <AccordionItem key={section.id} value={section.id}>\n              <AccordionTrigger>{section.title}</AccordionTrigger>\n              <AccordionContent>\n                <div className=\"space-y-4\">\n                  {section.content}\n                </div>\n              </AccordionContent>\n            </AccordionItem>\n          ))}\n        </Accordion>\n      ) : (\n        <Accordion \n          type=\"multiple\" \n          defaultValue={sections.filter(s => s.defaultOpen).map(s => s.id)}\n        >\n          {sections.map((section) => (\n            <AccordionItem key={section.id} value={section.id}>\n              <AccordionTrigger>{section.title}</AccordionTrigger>\n              <AccordionContent>\n                <div className=\"space-y-4\">\n                  {section.content}\n                </div>\n              </AccordionContent>\n            </AccordionItem>\n          ))}\n        </Accordion>\n      )}\n    </div>\n  );\n};",
      "type": "registry:component",
      "target": "components/formedible/layout/form-accordion.tsx"
    }
  ],
  "docs": "Make sure to install @tanstack/react-form and configure your shadcn/ui components before using this hook.",
  "categories": [
    "form",
    "hook"
  ]
}