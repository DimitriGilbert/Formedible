{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "formedible-parser",
  "type": "registry:block",
  "title": "Formedible Parser",
  "description": "Safe parser for Formedible form definitions - handles JSON, JavaScript object literals, and Zod schema expressions",
  "dependencies": [
    "react",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "textarea",
    "label",
    "card"
  ],
  "files": [
    {
      "path": "src/lib/formedible/formedible-parser.ts",
      "content": "\"use client\";\n\nimport type {\n  ParsedFieldConfig,\n  ParsedFormConfig,\n  ParserOptions,\n  ObjectConfig,\n  ParserError,\n  PageConfig,\n  EnhancedParserOptions,\n  EnhancedParserError,\n  SchemaInferenceOptions,\n  SchemaInferenceResult,\n  ValidationWithSuggestionsResult,\n} from \"./parser-types\";\n\n/**\n * FormedibleParser - A safe parser for Formedible form definitions\n *\n * This parser can handle:\n * - Pure JSON format\n * - JavaScript object literals (unquoted keys)\n * - Zod schema expressions (z.string(), z.number(), etc.)\n * - Nested and chained Zod validations (z.string().min(1).max(50))\n *\n * Features:\n * - Sanitizes dangerous code patterns\n * - Validates field types and structure\n * - Removes unknown/dangerous keys\n * - Handles balanced parentheses in Zod expressions\n * - Supports all 24 field types\n * - 100% backward compatibility with existing parser\n *\n * Usage:\n *   const parsed = FormedibleParser.parse(codeString);\n *\n * @version 2.0.0\n * @standalone-ready This class is designed as a standalone package\n */\nexport class FormedibleParser {\n  // All 24 supported field types in formedible\n  private static readonly ALLOWED_FIELD_TYPES = [\n    \"text\",\n    \"email\",\n    \"password\",\n    \"url\",\n    \"tel\",\n    \"textarea\",\n    \"select\",\n    \"checkbox\",\n    \"switch\",\n    \"number\",\n    \"date\",\n    \"slider\",\n    \"file\",\n    \"rating\",\n    \"phone\",\n    \"colorPicker\",\n    \"location\",\n    \"duration\",\n    \"multiSelect\",\n    \"autocomplete\",\n    \"masked\",\n    \"object\",\n    \"array\",\n    \"radio\",\n  ] as const;\n\n  // Allowed top-level keys in form definitions\n  private static readonly ALLOWED_KEYS = [\n    \"schema\",\n    \"fields\",\n    \"pages\",\n    \"progress\",\n    \"submitLabel\",\n    \"nextLabel\",\n    \"previousLabel\",\n    \"formClassName\",\n    \"fieldClassName\",\n    \"formOptions\",\n    \"title\",\n    \"description\",\n  ] as const;\n\n  // Configuration for parser behavior\n  private static CONFIG = {\n    ZOD_PLACEHOLDER: \"__ZOD_SCHEMA__\",\n    MAX_RECURSION_DEPTH: 10,\n    ENABLE_STRICT_VALIDATION: true,\n    MAX_CODE_LENGTH: 1000000, // 1MB limit\n    MAX_NESTING_DEPTH: 50,\n  };\n\n  /**\n   * Main parser method - parses formedible form definition code\n   * @param code - The form definition code (JSON or JS object literal)\n   * @param options - Optional parsing configuration\n   * @returns Parsed and validated form definition\n   * @throws {ParserError} When parsing fails with detailed error information\n   */\n  static parse(\n    code: string,\n    options?: ParserOptions | EnhancedParserOptions\n  ): ParsedFormConfig {\n    if (!code || typeof code !== \"string\") {\n      throw this.createParserError(\n        \"Input code must be a non-empty string\",\n        \"INVALID_INPUT\"\n      );\n    }\n\n    if (code.length > this.CONFIG.MAX_CODE_LENGTH) {\n      throw this.createParserError(\n        `Code length exceeds maximum allowed size of ${this.CONFIG.MAX_CODE_LENGTH} characters`,\n        \"CODE_TOO_LARGE\"\n      );\n    }\n\n    try {\n      // Apply configuration overrides\n      if (options?.strictValidation !== undefined) {\n        this.CONFIG.ENABLE_STRICT_VALIDATION = options.strictValidation;\n      }\n\n      // Remove any potential function calls or dangerous patterns\n      const sanitizedCode = this.sanitizeCode(code);\n\n      // Parse the JSON-like structure\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n\n      // Validate and sanitize the parsed object\n      return this.validateAndSanitize(parsed);\n    } catch (error) {\n      if (error instanceof Error && error.name === \"ParserError\") {\n        throw error;\n      }\n\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      throw this.createParserError(\n        `Failed to parse form definition - ${errorMessage}`,\n        \"PARSE_ERROR\",\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Validates if a field type is supported\n   * @param type - The field type to validate\n   * @returns True if the field type is valid\n   */\n  static isValidFieldType(type: string): boolean {\n    return this.ALLOWED_FIELD_TYPES.includes(type as any);\n  }\n\n  /**\n   * Gets all supported field types\n   * @returns Array of supported field types\n   */\n  static getSupportedFieldTypes(): readonly string[] {\n    return [...this.ALLOWED_FIELD_TYPES];\n  }\n\n  /**\n   * Validates a form configuration without parsing code\n   * @param config - The form configuration to validate\n   * @returns Validation result with errors if any\n   */\n  static validateConfig(config: unknown): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    try {\n      this.validateAndSanitize(config as Record<string, unknown>);\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  }\n\n  /**\n   * Creates a standardized parser error with additional metadata\n   * @private\n   */\n  private static createParserError(\n    message: string,\n    code: string,\n    metadata?: Record<string, unknown>\n  ): ParserError {\n    const error = new Error(message) as ParserError;\n    error.name = \"ParserError\";\n    error.code = code;\n\n    if (metadata) {\n      Object.assign(error, metadata);\n    }\n\n    return error;\n  }\n\n  /**\n   * Enhanced code sanitization with better security measures\n   * @private\n   */\n  private static sanitizeCode(code: string): string {\n    // Remove comments first\n    let sanitized = code\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Block comments\n      .replace(/\\/\\/.*$/gm, \"\"); // Line comments\n\n    // Remove dangerous patterns more aggressively\n    const dangerousPatterns = [\n      /\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g,\n      /\\b(document|window|global|process)\\b/g,\n      /\\b__proto__\\b/g,\n      /\\bconstructor\\b/g,\n      /\\bprototype\\b/g,\n    ];\n\n    dangerousPatterns.forEach((pattern) => {\n      sanitized = sanitized.replace(pattern, '\"\"');\n    });\n\n    // Remove any arrow functions or function expressions more thoroughly\n    sanitized = sanitized.replace(/=>\\s*[\\{]?[^}]*[\\}]?/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n\n    // Handle Date objects more safely\n    sanitized = sanitized.replace(\n      /new\\s+Date\\(\\)\\.toISOString\\(\\)\\.split\\('[^']*'\\)\\[0\\]/g,\n      '\"2024-01-01\"'\n    );\n    sanitized = sanitized.replace(/new\\s+Date\\(\\)/g, '\"2024-01-01T00:00:00Z\"');\n\n    // Remove any remaining 'new' keyword usage\n    sanitized = sanitized.replace(/\\bnew\\s+\\w+\\(/g, '\"\"');\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced object literal parsing with better error handling\n   * @private\n   */\n  private static parseObjectLiteral(code: string): Record<string, unknown> {\n    try {\n      // First try direct JSON parsing\n      return JSON.parse(code);\n    } catch (jsonError) {\n      // If that fails, try to convert JS object literal to JSON\n      let processedCode = code.trim();\n\n      try {\n        // Replace Zod expressions with placeholder strings - handle nested structures\n        processedCode = this.replaceZodExpressions(processedCode);\n\n        // Convert unquoted keys to quoted keys with better regex\n        processedCode = processedCode.replace(\n          /([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g,\n          '$1\"$2\":'\n        );\n\n        // Remove trailing commas more thoroughly\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n        // Convert single quotes to double quotes (but preserve escaped quotes)\n        processedCode = processedCode.replace(/(?<!\\\\)'/g, '\"');\n\n        // Handle undefined values\n        processedCode = processedCode.replace(/:\\s*undefined/g, \": null\");\n\n        const result = JSON.parse(processedCode);\n        return result;\n      } catch (conversionError) {\n        // Enhanced error reporting\n        const originalPreview =\n          code.substring(0, 200) + (code.length > 200 ? \"...\" : \"\");\n        const processedPreview =\n          processedCode.substring(0, 200) +\n          (processedCode.length > 200 ? \"...\" : \"\");\n\n        throw this.createParserError(\n          `Invalid syntax. Please use valid JSON format or JavaScript object literal syntax.`,\n          \"SYNTAX_ERROR\",\n          {\n            originalCode: originalPreview,\n            processedCode: processedPreview,\n            jsonError:\n              jsonError instanceof Error\n                ? jsonError.message\n                : String(jsonError),\n            conversionError:\n              conversionError instanceof Error\n                ? conversionError.message\n                : String(conversionError),\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Enhanced Zod expression replacement with better handling of complex expressions\n   * @private\n   */\n  private static replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 100; // Prevent infinite loops\n\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      // Match z.method( and find the matching closing parenthesis\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        // Find the matching closing parenthesis with better depth tracking\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n        let stringChar: string | null = null;\n        let escaped = false;\n\n        while (endIndex < result.length && depth > 0) {\n          const char = result[endIndex];\n\n          // Handle string literals to avoid counting parentheses inside strings\n          if (!escaped && (char === '\"' || char === \"'\")) {\n            if (!stringChar) {\n              stringChar = char;\n            } else if (stringChar === char) {\n              stringChar = null;\n            }\n          } else if (!stringChar) {\n            if (char === \"(\") {\n              depth++;\n            } else if (char === \")\") {\n              depth--;\n            }\n          }\n\n          escaped = char === \"\\\\\" && !escaped;\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          // Check for chained methods like .min().max()\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              // Find the closing parenthesis for this chained method\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n              let chainStringChar: string | null = null;\n              let chainEscaped = false;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                const char = result[chainEndIndex];\n\n                if (!chainEscaped && (char === '\"' || char === \"'\")) {\n                  if (!chainStringChar) {\n                    chainStringChar = char;\n                  } else if (chainStringChar === char) {\n                    chainStringChar = null;\n                  }\n                } else if (!chainStringChar) {\n                  if (char === \"(\") {\n                    chainDepth++;\n                  } else if (char === \")\") {\n                    chainDepth--;\n                  }\n                }\n\n                chainEscaped = char === \"\\\\\" && !chainEscaped;\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          // Replace the entire Zod expression with a placeholder\n          result =\n            result.slice(0, startIndex) +\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"` +\n            result.slice(chainEnd);\n          changed = true;\n        } else {\n          // If we can't find matching parentheses, just replace the method name\n          result = result.replace(\n            /z\\.[a-zA-Z]+/,\n            `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n          );\n          changed = true;\n        }\n      }\n    }\n\n    // Handle standalone z.enum() calls and other complex patterns\n    result = result.replace(\n      /z\\.enum\\(\\[[^\\]]*\\]\\)/g,\n      `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`\n    );\n    result = result.replace(/z\\.\\w+/g, `\"${this.CONFIG.ZOD_PLACEHOLDER}\"`);\n\n    return result;\n  }\n\n  /**\n   * Enhanced validation and sanitization with comprehensive field type support\n   * @private\n   */\n  private static validateAndSanitize(\n    obj: Record<string, unknown>\n  ): ParsedFormConfig {\n    if (typeof obj !== \"object\" || obj === null) {\n      throw this.createParserError(\n        \"Definition must be an object\",\n        \"INVALID_DEFINITION\"\n      );\n    }\n\n    const sanitized: ParsedFormConfig = {\n      fields: [],\n    };\n\n    // Validate top-level keys\n    for (const [key, value] of Object.entries(obj)) {\n      if (!this.ALLOWED_KEYS.includes(key as any)) {\n        if (this.CONFIG.ENABLE_STRICT_VALIDATION) {\n          console.warn(\n            `Unknown key '${key}' found in form definition, skipping`\n          );\n        }\n        continue; // Skip unknown keys\n      }\n\n      switch (key) {\n        case \"schema\":\n          // Pass through the schema - it's needed for validation\n          sanitized.schema = value;\n          break;\n\n        case \"fields\":\n          if (!Array.isArray(value)) {\n            throw this.createParserError(\n              \"Fields must be an array\",\n              \"INVALID_FIELDS\"\n            );\n          }\n          sanitized.fields = this.validateFields(value);\n          break;\n\n        case \"pages\":\n          if (Array.isArray(value)) {\n            sanitized.pages = value.map((page, index) =>\n              this.validatePage(page, index)\n            );\n          }\n          break;\n\n        case \"title\":\n          if (typeof value === \"string\") {\n            sanitized.title = value;\n          }\n          break;\n\n        case \"description\":\n          if (typeof value === \"string\") {\n            sanitized.description = value;\n          }\n          break;\n\n        case \"submitLabel\":\n          if (typeof value === \"string\") {\n            sanitized.submitLabel = value;\n          }\n          break;\n\n        case \"nextLabel\":\n          if (typeof value === \"string\") {\n            sanitized.nextLabel = value;\n          }\n          break;\n\n        case \"previousLabel\":\n          if (typeof value === \"string\") {\n            sanitized.previousLabel = value;\n          }\n          break;\n\n        case \"formClassName\":\n          if (typeof value === \"string\") {\n            sanitized.formClassName = value;\n          }\n          break;\n\n        case \"fieldClassName\":\n          if (typeof value === \"string\") {\n            sanitized.fieldClassName = value;\n          }\n          break;\n\n        case \"progress\":\n          if (value && typeof value === \"object\") {\n            sanitized.progress = value as ParsedFormConfig[\"progress\"];\n          }\n          break;\n\n        case \"formOptions\":\n          if (value && typeof value === \"object\") {\n            sanitized.formOptions = value as ParsedFormConfig[\"formOptions\"];\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Enhanced field validation with support for all 24 field types\n   * @private\n   */\n  private static validateFields(fields: unknown[]): ParsedFieldConfig[] {\n    return fields.map((field, index): ParsedFieldConfig => {\n      if (typeof field !== \"object\" || field === null) {\n        throw this.createParserError(\n          `Field at index ${index} must be an object`,\n          \"INVALID_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      const fieldObj = field as Record<string, unknown>;\n\n      // Ensure required fields\n      if (!fieldObj.name || !fieldObj.type) {\n        throw this.createParserError(\n          `Field at index ${index} must have 'name' and 'type' properties`,\n          \"MISSING_REQUIRED_FIELD\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (\n        typeof fieldObj.name !== \"string\" ||\n        typeof fieldObj.type !== \"string\"\n      ) {\n        throw this.createParserError(\n          `Field at index ${index} must have string 'name' and 'type' properties`,\n          \"INVALID_FIELD_TYPE\",\n          { fieldIndex: index }\n        );\n      }\n\n      if (!this.ALLOWED_FIELD_TYPES.includes(fieldObj.type as any)) {\n        throw this.createParserError(\n          `Field at index ${index} has invalid type '${\n            fieldObj.type\n          }'. Supported types: ${this.ALLOWED_FIELD_TYPES.join(\", \")}`,\n          \"UNSUPPORTED_FIELD_TYPE\",\n          { fieldIndex: index, fieldType: fieldObj.type }\n        );\n      }\n\n      // Build properly typed field config\n      const validatedField: ParsedFieldConfig = {\n        name: fieldObj.name,\n        type: fieldObj.type,\n      };\n\n      // Add optional properties with proper type checks\n      this.addOptionalStringProperty(validatedField, fieldObj, \"label\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"placeholder\");\n      this.addOptionalStringProperty(validatedField, fieldObj, \"description\");\n\n      if (typeof fieldObj.required === \"boolean\") {\n        validatedField.required = fieldObj.required;\n      }\n\n      if (fieldObj.defaultValue !== undefined) {\n        validatedField.defaultValue = fieldObj.defaultValue;\n      }\n\n      // Numeric properties\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"min\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"max\");\n      this.addOptionalNumberProperty(validatedField, fieldObj, \"step\");\n\n      // Handle complex configurations for different field types\n      this.addFieldSpecificConfigurations(validatedField, fieldObj, index);\n\n      // Handle options array\n      if (fieldObj.options && Array.isArray(fieldObj.options)) {\n        validatedField.options = this.validateOptions(fieldObj.options);\n      }\n\n      // Pass through validation configuration\n      if (fieldObj.validation !== undefined && fieldObj.validation !== null) {\n        validatedField.validation = fieldObj.validation;\n      }\n\n      return validatedField;\n    });\n  }\n\n  /**\n   * Adds field-specific configurations based on field type\n   * @private\n   */\n  private static addFieldSpecificConfigurations(\n    validatedField: ParsedFieldConfig,\n    fieldObj: Record<string, unknown>,\n    index: number\n  ): void {\n    const fieldType = validatedField.type;\n\n    // Array field configuration\n    if (fieldType === \"array\" && fieldObj.arrayConfig) {\n      validatedField.arrayConfig = this.validateArrayConfig(\n        fieldObj.arrayConfig,\n        index\n      );\n    }\n\n    // Object field configuration\n    if (fieldType === \"object\" && fieldObj.objectConfig) {\n      validatedField.objectConfig = this.validateObjectConfig(\n        fieldObj.objectConfig,\n        index\n      );\n    }\n\n    // Multi-select configuration\n    if (fieldType === \"multiSelect\" && fieldObj.multiSelectConfig) {\n      validatedField.multiSelectConfig = this.validateMultiSelectConfig(\n        fieldObj.multiSelectConfig\n      );\n    }\n\n    // Color picker configuration\n    if (fieldType === \"colorPicker\" && fieldObj.colorConfig) {\n      validatedField.colorConfig = this.validateColorConfig(\n        fieldObj.colorConfig\n      );\n    }\n\n    // Rating configuration\n    if (fieldType === \"rating\" && fieldObj.ratingConfig) {\n      validatedField.ratingConfig = this.validateRatingConfig(\n        fieldObj.ratingConfig\n      );\n    }\n\n    // Phone configuration\n    if (fieldType === \"phone\" && fieldObj.phoneConfig) {\n      validatedField.phoneConfig = this.validatePhoneConfig(\n        fieldObj.phoneConfig\n      );\n    }\n\n    // Datalist configuration\n    if (fieldObj.datalist) {\n      validatedField.datalist = this.validateDatalistConfig(fieldObj.datalist);\n    }\n\n    // Pass through other configurations with validation\n    const configKeys = [\n      \"sliderConfig\",\n      \"fileConfig\",\n      \"locationConfig\",\n      \"durationConfig\",\n      \"autocompleteConfig\",\n      \"maskedConfig\",\n      \"dateConfig\",\n      \"textareaConfig\",\n      \"passwordConfig\",\n      \"emailConfig\",\n      \"numberConfig\",\n    ];\n\n    configKeys.forEach((configKey) => {\n      if (fieldObj[configKey] && typeof fieldObj[configKey] === \"object\") {\n        (validatedField as any)[configKey] = fieldObj[configKey];\n      }\n    });\n  }\n\n  /**\n   * Helper methods for adding optional properties\n   * @private\n   */\n  private static addOptionalStringProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (source[key] && typeof source[key] === \"string\") {\n      target[key] = source[key];\n    }\n  }\n\n  private static addOptionalNumberProperty(\n    target: Record<string, unknown>,\n    source: Record<string, unknown>,\n    key: string\n  ): void {\n    if (typeof source[key] === \"number\") {\n      target[key] = source[key];\n    }\n  }\n\n  /**\n   * Configuration validators\n   * @private\n   */\n  private static validateArrayConfig(\n    config: unknown,\n    fieldIndex: number\n  ): ParsedFieldConfig[\"arrayConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Array config at field index ${fieldIndex} must be an object`,\n        \"INVALID_ARRAY_CONFIG\"\n      );\n    }\n\n    const arrayConfig = config as Record<string, unknown>;\n    const validated: ParsedFieldConfig[\"arrayConfig\"] = {\n      itemType: \"text\",\n    };\n\n    if (arrayConfig.itemType && typeof arrayConfig.itemType === \"string\") {\n      validated.itemType = arrayConfig.itemType;\n    }\n\n    // Add other array config properties\n    [\n      \"itemLabel\",\n      \"itemPlaceholder\",\n      \"addButtonLabel\",\n      \"removeButtonLabel\",\n    ].forEach((key) => {\n      if (arrayConfig[key] && typeof arrayConfig[key] === \"string\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    [\"minItems\", \"maxItems\"].forEach((key) => {\n      if (typeof arrayConfig[key] === \"number\") {\n        (validated as any)[key] = arrayConfig[key];\n      }\n    });\n\n    if (typeof arrayConfig.sortable === \"boolean\") {\n      validated.sortable = arrayConfig.sortable;\n    }\n\n    if (arrayConfig.objectConfig) {\n      validated.objectConfig = this.validateObjectConfig(\n        arrayConfig.objectConfig,\n        fieldIndex\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateObjectConfig(\n    config: unknown,\n    fieldIndex: number\n  ): ObjectConfig {\n    if (typeof config !== \"object\" || !config) {\n      throw this.createParserError(\n        `Object config at field index ${fieldIndex} must be an object`,\n        \"INVALID_OBJECT_CONFIG\"\n      );\n    }\n\n    const objectConfig = config as Record<string, unknown>;\n    const validated: ObjectConfig = {\n      fields: [],\n    };\n\n    if (objectConfig.fields && Array.isArray(objectConfig.fields)) {\n      validated.fields = objectConfig.fields.map((field) => {\n        if (typeof field !== \"object\" || !field) {\n          return { name: \"\", type: \"text\" };\n        }\n        const f = field as Record<string, unknown>;\n        const validatedField: ObjectConfig[\"fields\"][0] = {\n          name: typeof f.name === \"string\" ? f.name : \"\",\n          type: typeof f.type === \"string\" ? f.type : \"text\",\n        };\n\n        if (typeof f.label === \"string\") validatedField.label = f.label;\n        if (typeof f.placeholder === \"string\")\n          validatedField.placeholder = f.placeholder;\n        if (typeof f.description === \"string\")\n          validatedField.description = f.description;\n        if (typeof f.min === \"number\") validatedField.min = f.min;\n        if (typeof f.max === \"number\") validatedField.max = f.max;\n        if (typeof f.step === \"number\") validatedField.step = f.step;\n\n        if (\n          f.options &&\n          (Array.isArray(f.options) || typeof f.options === \"function\")\n        ) {\n          validatedField.options =\n            f.options as ObjectConfig[\"fields\"][0][\"options\"];\n        }\n\n        return validatedField;\n      });\n    }\n\n    // Add other object config properties\n    [\"title\", \"description\", \"collapseLabel\", \"expandLabel\"].forEach((key) => {\n      if (objectConfig[key] && typeof objectConfig[key] === \"string\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    [\"collapsible\", \"defaultExpanded\", \"showCard\"].forEach((key) => {\n      if (typeof objectConfig[key] === \"boolean\") {\n        (validated as any)[key] = objectConfig[key];\n      }\n    });\n\n    if (\n      objectConfig.layout &&\n      [\"vertical\", \"horizontal\", \"grid\"].includes(objectConfig.layout as string)\n    ) {\n      validated.layout = objectConfig.layout as ObjectConfig[\"layout\"];\n    }\n\n    if (typeof objectConfig.columns === \"number\") {\n      validated.columns = objectConfig.columns;\n    }\n\n    return validated;\n  }\n\n  private static validateMultiSelectConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"multiSelectConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const multiSelectConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"multiSelectConfig\"]> = {};\n\n    if (typeof multiSelectConfig.maxSelections === \"number\") {\n      validated.maxSelections = multiSelectConfig.maxSelections;\n    }\n\n    [\"searchable\", \"creatable\"].forEach((key) => {\n      if (typeof multiSelectConfig[key] === \"boolean\") {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    [\"placeholder\", \"noOptionsText\", \"loadingText\"].forEach((key) => {\n      if (\n        multiSelectConfig[key] &&\n        typeof multiSelectConfig[key] === \"string\"\n      ) {\n        (validated as any)[key] = multiSelectConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateColorConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"colorConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const colorConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"colorConfig\"]> = {};\n\n    if (\n      colorConfig.format &&\n      [\"hex\", \"rgb\", \"hsl\"].includes(colorConfig.format as string)\n    ) {\n      validated.format = colorConfig.format as \"hex\" | \"rgb\" | \"hsl\";\n    }\n\n    [\"showPreview\", \"showAlpha\", \"allowCustom\"].forEach((key) => {\n      if (typeof colorConfig[key] === \"boolean\") {\n        (validated as any)[key] = colorConfig[key];\n      }\n    });\n\n    if (Array.isArray(colorConfig.presetColors)) {\n      validated.presetColors = colorConfig.presetColors.filter(\n        (color) => typeof color === \"string\"\n      );\n    }\n\n    return validated;\n  }\n\n  private static validateRatingConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"ratingConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const ratingConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"ratingConfig\"]> = {};\n\n    if (typeof ratingConfig.max === \"number\") {\n      validated.max = ratingConfig.max;\n    }\n\n    [\"allowHalf\", \"allowClear\", \"showValue\"].forEach((key) => {\n      if (typeof ratingConfig[key] === \"boolean\") {\n        (validated as any)[key] = ratingConfig[key];\n      }\n    });\n\n    if (\n      ratingConfig.icon &&\n      [\"star\", \"heart\", \"thumbs\"].includes(ratingConfig.icon as string)\n    ) {\n      validated.icon = ratingConfig.icon as \"star\" | \"heart\" | \"thumbs\";\n    }\n\n    if (\n      ratingConfig.size &&\n      [\"sm\", \"md\", \"lg\", \"small\", \"medium\", \"large\"].includes(\n        ratingConfig.size as string\n      )\n    ) {\n      validated.size = ratingConfig.size as\n        | \"sm\"\n        | \"md\"\n        | \"lg\"\n        | \"small\"\n        | \"medium\"\n        | \"large\";\n    }\n\n    return validated;\n  }\n\n  private static validatePhoneConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"phoneConfig\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const phoneConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"phoneConfig\"]> = {};\n\n    if (\n      phoneConfig.defaultCountry &&\n      typeof phoneConfig.defaultCountry === \"string\"\n    ) {\n      validated.defaultCountry = phoneConfig.defaultCountry;\n    }\n\n    [\"preferredCountries\", \"onlyCountries\", \"excludeCountries\"].forEach(\n      (key) => {\n        if (Array.isArray(phoneConfig[key])) {\n          (validated as any)[key] = phoneConfig[key].filter(\n            (item: unknown) => typeof item === \"string\"\n          );\n        }\n      }\n    );\n\n    if (\n      phoneConfig.format &&\n      [\"national\", \"international\"].includes(phoneConfig.format as string)\n    ) {\n      validated.format = phoneConfig.format as \"national\" | \"international\";\n    }\n\n    return validated;\n  }\n\n  private static validateDatalistConfig(\n    config: unknown\n  ): ParsedFieldConfig[\"datalist\"] {\n    if (typeof config !== \"object\" || !config) {\n      return undefined;\n    }\n\n    const datalistConfig = config as Record<string, unknown>;\n    const validated: NonNullable<ParsedFieldConfig[\"datalist\"]> = {};\n\n    if (Array.isArray(datalistConfig.options)) {\n      validated.options = datalistConfig.options.filter(\n        (option) => typeof option === \"string\"\n      );\n    }\n\n    [\"debounceMs\", \"minChars\", \"maxResults\"].forEach((key) => {\n      if (typeof datalistConfig[key] === \"number\") {\n        (validated as any)[key] = datalistConfig[key];\n      }\n    });\n\n    return validated;\n  }\n\n  private static validateOptions(\n    options: unknown[]\n  ): Array<{ value: string; label: string }> {\n    return options\n      .filter(\n        (option) =>\n          typeof option === \"object\" &&\n          option !== null &&\n          typeof (option as any).value === \"string\" &&\n          typeof (option as any).label === \"string\"\n      )\n      .map((option) => ({\n        value: (option as any).value,\n        label: (option as any).label,\n      }));\n  }\n\n  private static validatePage(page: unknown, index: number): PageConfig {\n    if (typeof page !== \"object\" || !page) {\n      return { page: index };\n    }\n\n    const pageObj = page as Record<string, unknown>;\n    const validated: PageConfig = {\n      page: typeof pageObj.page === \"number\" ? pageObj.page : index,\n    };\n\n    if (pageObj.title && typeof pageObj.title === \"string\") {\n      validated.title = pageObj.title;\n    }\n\n    if (pageObj.description && typeof pageObj.description === \"string\") {\n      validated.description = pageObj.description;\n    }\n\n    return validated;\n  }\n\n  // Phase 2: Enhanced Features\n\n  /**\n   * Parses form definition with schema inference capabilities\n   * @param code - The form definition code to parse\n   * @param options - Schema inference options\n   * @returns Parsing result with inferred schema information\n   */\n  static parseWithSchemaInference(\n    code: string,\n    options?: SchemaInferenceOptions\n  ): SchemaInferenceResult {\n    const config = this.parse(code);\n\n    // Basic schema inference implementation\n    let confidence = 0.5; // Base confidence\n    let inferredSchema = null;\n\n    if (options?.enabled) {\n      try {\n        const schemaBuilder: Record<string, string> = {};\n\n        for (const field of config.fields) {\n          const zodType = this.inferZodTypeFromField(field);\n          if (zodType) {\n            schemaBuilder[field.name] = zodType;\n            confidence += 0.1; // Increase confidence for each successful inference\n          }\n        }\n\n        // Create a basic schema representation\n        inferredSchema = {\n          type: \"object\",\n          properties: schemaBuilder,\n          isInferred: true,\n        };\n\n        confidence = Math.min(confidence, 1.0);\n      } catch (error) {\n        console.warn(\"Schema inference failed:\", error);\n        confidence = 0.1;\n      }\n    }\n\n    return {\n      config,\n      inferredSchema,\n      confidence,\n    };\n  }\n\n  /**\n   * Merges a parsed configuration with a base schema\n   * @param parsedConfig - The parsed form configuration\n   * @param baseSchema - Base schema to merge with\n   * @param strategy - Merge strategy to use\n   * @returns Enhanced form configuration\n   */\n  static mergeSchemas(\n    parsedConfig: ParsedFormConfig,\n    baseSchema: unknown,\n    strategy: \"extend\" | \"override\" | \"intersect\" = \"extend\"\n  ): ParsedFormConfig {\n    const merged = { ...parsedConfig };\n\n    if (!baseSchema || typeof baseSchema !== \"object\") {\n      return merged;\n    }\n\n    try {\n      // Extract field information from base schema if it has properties\n      const baseSchemaObj = baseSchema as Record<string, unknown>;\n\n      if (strategy === \"extend\" && baseSchemaObj.properties) {\n        // Add missing fields from base schema\n        const existingFieldNames = new Set(merged.fields.map((f) => f.name));\n        const baseProperties = baseSchemaObj.properties as Record<\n          string,\n          unknown\n        >;\n\n        for (const [fieldName, fieldSchema] of Object.entries(baseProperties)) {\n          if (!existingFieldNames.has(fieldName)) {\n            const inferredField = this.createFieldFromSchema(\n              fieldName,\n              fieldSchema\n            );\n            if (inferredField) {\n              merged.fields.push(inferredField);\n            }\n          }\n        }\n      } else if (strategy === \"override\") {\n        // Override existing schema completely\n        merged.schema = baseSchema;\n      } else if (strategy === \"intersect\") {\n        // Keep only fields that exist in both\n        const baseProperties =\n          (baseSchemaObj.properties as Record<string, unknown>) || {};\n        merged.fields = merged.fields.filter((field) =>\n          Object.prototype.hasOwnProperty.call(baseProperties, field.name)\n        );\n      }\n\n      // Update the schema property\n      if (strategy !== \"override\") {\n        merged.schema = baseSchema;\n      }\n    } catch (error) {\n      console.warn(\"Schema merging failed:\", error);\n    }\n\n    return merged;\n  }\n\n  /**\n   * Validates form definition code with AI-friendly error suggestions\n   * @param code - The form definition code to validate\n   * @returns Validation result with detailed errors and suggestions\n   */\n  static validateWithSuggestions(\n    code: string\n  ): ValidationWithSuggestionsResult {\n    const errors: EnhancedParserError[] = [];\n    const suggestions: string[] = [];\n\n    try {\n      // Attempt to parse the code\n      this.parse(code);\n      return { isValid: true, errors: [], suggestions: [] };\n    } catch (error) {\n      let errorType: EnhancedParserError[\"type\"] = \"syntax\";\n      let message = \"Unknown parsing error\";\n      let suggestion = \"\";\n      let examples: string[] = [];\n\n      if (error instanceof Error) {\n        message = error.message;\n\n        // Analyze error types and provide specific suggestions\n        if (\n          message.includes(\"Invalid syntax\") ||\n          message.includes(\"JSON.parse\")\n        ) {\n          errorType = \"syntax\";\n          suggestion =\n            \"Check for missing quotes around object keys or trailing commas\";\n          examples = [\n            '{ \"name\": \"field1\", \"type\": \"text\" }',\n            '{ fields: [{ name: \"field1\", type: \"text\" }] }',\n          ];\n          suggestions.push(\"Use double quotes around object keys\");\n          suggestions.push(\"Remove trailing commas before closing brackets\");\n        } else if (message.includes(\"invalid type\")) {\n          errorType = \"field_type\";\n          suggestion = `Use one of the supported field types: ${this.ALLOWED_FIELD_TYPES.join(\n            \", \"\n          )}`;\n          examples = [\n            '{ name: \"email\", type: \"email\" }',\n            '{ name: \"age\", type: \"number\" }',\n          ];\n          suggestions.push(\"Check field type spelling\");\n          suggestions.push(\"Refer to supported field types list\");\n        } else if (message.includes(\"must have\")) {\n          errorType = \"validation\";\n          suggestion = \"Ensure all required properties are present\";\n          examples = [\n            '{ name: \"required-field\", type: \"text\", label: \"Required Field\" }',\n          ];\n          suggestions.push(\"Add missing required properties: name, type\");\n        } else if (message.includes(\"schema\")) {\n          errorType = \"schema\";\n          suggestion = \"Check Zod schema syntax and structure\";\n          examples = [\n            \"schema: z.object({ name: z.string(), email: z.string().email() })\",\n          ];\n          suggestions.push(\"Verify Zod schema syntax\");\n        }\n      }\n\n      errors.push({\n        type: errorType,\n        message,\n        suggestion,\n        examples,\n        location: this.extractErrorLocation(code, error),\n      });\n\n      // Add general suggestions\n      suggestions.push(\"Validate JSON syntax using a JSON validator\");\n      suggestions.push(\"Check for balanced parentheses and brackets\");\n      suggestions.push(\"Ensure all string values are properly quoted\");\n\n      return { isValid: false, errors, suggestions };\n    }\n  }\n\n  /**\n   * Infers Zod type from a field configuration\n   * @private\n   */\n  private static inferZodTypeFromField(\n    field: ParsedFieldConfig\n  ): string | null {\n    const typeMapping: Record<string, string> = {\n      text: \"z.string()\",\n      email: \"z.string().email()\",\n      password: \"z.string().min(1)\",\n      url: \"z.string().url()\",\n      tel: \"z.string()\",\n      textarea: \"z.string()\",\n      number: \"z.number()\",\n      date: \"z.string().datetime()\",\n      checkbox: \"z.boolean()\",\n      switch: \"z.boolean()\",\n      select: \"z.string()\",\n      radio: \"z.string()\",\n      multiSelect: \"z.array(z.string())\",\n      file: \"z.instanceof(File)\",\n      slider: \"z.number()\",\n      rating: \"z.number()\",\n      phone: \"z.string()\",\n      colorPicker: \"z.string()\",\n      location: \"z.object({ lat: z.number(), lng: z.number() })\",\n      duration: \"z.number()\",\n      autocomplete: \"z.string()\",\n      masked: \"z.string()\",\n      array: \"z.array(z.unknown())\",\n      object: \"z.object({})\",\n    };\n\n    let baseType = typeMapping[field.type];\n    if (!baseType) return null;\n\n    // Add validation constraints\n    if (field.type === \"text\" || field.type === \"textarea\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.string()\",\n          `z.string().max(${field.max})`\n        );\n      }\n    }\n\n    if (field.type === \"number\" || field.type === \"slider\") {\n      if (field.min && field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min}).max(${field.max})`\n        );\n      } else if (field.min) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().min(${field.min})`\n        );\n      } else if (field.max) {\n        baseType = baseType.replace(\n          \"z.number()\",\n          `z.number().max(${field.max})`\n        );\n      }\n    }\n\n    // Handle required/optional\n    if (field.required === false) {\n      baseType += \".optional()\";\n    }\n\n    return baseType;\n  }\n\n  /**\n   * Creates a field configuration from a schema definition\n   * @private\n   */\n  private static createFieldFromSchema(\n    name: string,\n    schema: unknown\n  ): ParsedFieldConfig | null {\n    // Basic implementation - would need more sophisticated schema analysis\n    try {\n      const schemaObj = schema as Record<string, unknown>;\n      let type = \"text\"; // default\n\n      // Very basic type inference from schema structure\n      if (schemaObj.type === \"string\") {\n        type = \"text\";\n      } else if (schemaObj.type === \"number\") {\n        type = \"number\";\n      } else if (schemaObj.type === \"boolean\") {\n        type = \"checkbox\";\n      }\n\n      return {\n        name,\n        type,\n        label:\n          name.charAt(0).toUpperCase() +\n          name.slice(1).replace(/([A-Z])/g, \" $1\"),\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Extracts error location information from parsing error\n   * @private\n   */\n  private static extractErrorLocation(\n    code: string,\n    error: unknown\n  ): EnhancedParserError[\"location\"] | undefined {\n    try {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      // Try to extract line/column info from JSON parse errors\n      const positionMatch = errorMessage.match(/at position (\\d+)/i);\n      if (positionMatch) {\n        const position = parseInt(positionMatch[1], 10);\n        const lines = code.substring(0, position).split(\"\\n\");\n        return {\n          line: lines.length,\n          column: lines[lines.length - 1].length + 1,\n        };\n      }\n\n      // Try to extract field information from validation errors\n      const fieldMatch = errorMessage.match(/field at index (\\d+)/i);\n      if (fieldMatch) {\n        return {\n          field: `field[${fieldMatch[1]}]`,\n        };\n      }\n    } catch {\n      // Ignore extraction errors\n    }\n\n    return undefined;\n  }\n}\n",
      "type": "registry:lib",
      "target": "lib/formedible/formedible-parser.ts"
    },
    {
      "path": "src/lib/formedible/parser-types.ts",
      "content": "\"use client\";\n\n// Import and re-export types from formedible to stay DRY\nimport type { \n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig\n} from \"./types\";\n\nexport type { \n  FieldOption,\n  FieldOptions,\n  ObjectConfig,\n  PageConfig,\n  ProgressConfig\n};\n\nexport interface ParsedFieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  placeholder?: string;\n  description?: string;\n  required?: boolean;\n  defaultValue?: unknown;\n  options?: Array<{ value: string; label: string }>;\n  min?: number;\n  max?: number;\n  step?: number;\n  validation?: unknown;\n  \n  // Field-specific configurations\n  arrayConfig?: {\n    itemType: string;\n    itemLabel?: string;\n    itemPlaceholder?: string;\n    itemValidation?: unknown;\n    minItems?: number;\n    maxItems?: number;\n    addButtonLabel?: string;\n    removeButtonLabel?: string;\n    sortable?: boolean;\n    defaultValue?: unknown;\n    objectConfig?: ObjectConfig;\n    [key: string]: unknown;\n  };\n  \n  objectConfig?: ObjectConfig;\n  \n  multiSelectConfig?: {\n    maxSelections?: number;\n    searchable?: boolean;\n    creatable?: boolean;\n    placeholder?: string;\n    noOptionsText?: string;\n    loadingText?: string;\n    [key: string]: unknown;\n  };\n  \n  colorConfig?: {\n    format?: 'hex' | 'rgb' | 'hsl';\n    showPreview?: boolean;\n    showAlpha?: boolean;\n    presetColors?: string[];\n    allowCustom?: boolean;\n    [key: string]: unknown;\n  };\n  \n  ratingConfig?: {\n    max?: number;\n    allowHalf?: boolean;\n    allowClear?: boolean;\n    icon?: 'star' | 'heart' | 'thumbs' | unknown;\n    size?: 'sm' | 'md' | 'lg' | 'small' | 'medium' | 'large';\n    showValue?: boolean;\n    [key: string]: unknown;\n  };\n  \n  phoneConfig?: {\n    defaultCountry?: string;\n    preferredCountries?: string[];\n    onlyCountries?: string[];\n    excludeCountries?: string[];\n    format?: 'national' | 'international';\n    [key: string]: unknown;\n  };\n  \n  datalist?: {\n    options?: string[];\n    asyncOptions?: unknown;\n    debounceMs?: number;\n    minChars?: number;\n    maxResults?: number;\n    [key: string]: unknown;\n  };\n  \n  // Allow additional unknown configurations\n  [key: string]: unknown;\n}\n\n\nexport interface ParsedFormConfig {\n  schema?: unknown;\n  fields: ParsedFieldConfig[];\n  pages?: PageConfig[];\n  title?: string;\n  description?: string;\n  submitLabel?: string;\n  nextLabel?: string;\n  previousLabel?: string;\n  formClassName?: string;\n  fieldClassName?: string;\n  progress?: ProgressConfig;\n  formOptions?: {\n    defaultValues?: Record<string, unknown>;\n    onSubmit?: (data: { value: Record<string, unknown> }) => void | Promise<void>;\n    [key: string]: unknown;\n  };\n}\n\nexport interface ParserOptions {\n  strictValidation?: boolean;\n}\n\nexport interface ParserError extends Error {\n  code?: string;\n  field?: string;\n  line?: number;\n  column?: number;\n}\n\n// Phase 2: Enhanced Parser Types\n\n/**\n * Enhanced parser options for Phase 2 features\n */\nexport interface EnhancedParserOptions extends ParserOptions {\n  baseSchema?: unknown; // z.ZodSchema in actual usage\n  mergeStrategy?: 'extend' | 'override' | 'intersect';\n  predefinedHandlers?: {\n    onSubmit?: (data: unknown) => void;\n    specificFields?: Record<string, ParsedFieldConfig>;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Enhanced error type with AI-friendly suggestions\n */\nexport interface EnhancedParserError {\n  type: 'syntax' | 'validation' | 'field_type' | 'schema';\n  message: string;\n  suggestion?: string;\n  location?: {\n    line?: number;\n    column?: number;\n    field?: string;\n  };\n  examples?: string[];\n}\n\n/**\n * Schema inference configuration options\n */\nexport interface SchemaInferenceOptions {\n  enabled?: boolean;\n  fieldTypeMapping?: Record<string, unknown>; // z.ZodType in actual usage\n  defaultValidation?: boolean;\n  inferFromValues?: boolean;\n}\n\n/**\n * Result of schema inference parsing\n */\nexport interface SchemaInferenceResult {\n  config: ParsedFormConfig;\n  inferredSchema: unknown; // z.ZodSchema in actual usage\n  confidence: number;\n}\n\n/**\n * Result of validation with suggestions\n */\nexport interface ValidationWithSuggestionsResult {\n  isValid: boolean;\n  errors: EnhancedParserError[];\n  suggestions: string[];\n}",
      "type": "registry:lib",
      "target": "lib/formedible/parser-types.ts"
    },
    {
      "path": "src/lib/formedible/parser-config-schema.ts",
      "content": "\"use client\";\n\n/**\n * Parser Configuration Schema for Settings UI\n * \n * This file provides a formedible-compatible schema for configuring\n * parser settings through a UI form. It includes types and field\n * configurations for all parser options.\n */\n\n// Note: In actual usage, this would import from 'zod', but for standalone\n// compatibility, we define the schema structure that can be used with zod\n\n/**\n * Parser configuration options\n */\nexport interface ParserConfig {\n  strictValidation: boolean;\n  enableSchemaInference: boolean;\n  mergeStrategy: 'extend' | 'override' | 'intersect';\n  fieldTypeValidation: boolean;\n  aiErrorMessages: boolean;\n  customInstructions?: string;\n  maxCodeLength: number;\n  maxNestingDepth: number;\n  enableZodParsing: boolean;\n  showDetailedErrors: boolean;\n}\n\n/**\n * Zod schema definition structure (for use with actual zod when available)\n * This represents what the schema would look like when used with zod\n */\nexport const parserConfigSchemaDefinition = {\n  strictValidation: {\n    type: 'boolean',\n    default: true,\n    description: 'Enable strict validation of form definitions'\n  },\n  enableSchemaInference: {\n    type: 'boolean', \n    default: false,\n    description: 'Automatically infer Zod schemas from field definitions'\n  },\n  mergeStrategy: {\n    type: 'enum',\n    values: ['extend', 'override', 'intersect'],\n    default: 'extend',\n    description: 'Strategy for merging with base schemas'\n  },\n  fieldTypeValidation: {\n    type: 'boolean',\n    default: true,\n    description: 'Validate field types against supported types'\n  },\n  aiErrorMessages: {\n    type: 'boolean',\n    default: true,\n    description: 'Provide AI-friendly error messages with suggestions'\n  },\n  customInstructions: {\n    type: 'string',\n    optional: true,\n    description: 'Custom parsing instructions or constraints'\n  },\n  maxCodeLength: {\n    type: 'number',\n    default: 1000000,\n    min: 1000,\n    max: 10000000,\n    description: 'Maximum allowed code length in characters'\n  },\n  maxNestingDepth: {\n    type: 'number',\n    default: 50,\n    min: 5,\n    max: 200,\n    description: 'Maximum nesting depth for object structures'\n  },\n  enableZodParsing: {\n    type: 'boolean',\n    default: true,\n    description: 'Enable parsing of Zod schema expressions'\n  },\n  showDetailedErrors: {\n    type: 'boolean',\n    default: true,\n    description: 'Show detailed error information in parser output'\n  }\n};\n\n/**\n * Default parser configuration\n */\nexport const defaultParserConfig: ParserConfig = {\n  strictValidation: true,\n  enableSchemaInference: false,\n  mergeStrategy: 'extend',\n  fieldTypeValidation: true,\n  aiErrorMessages: true,\n  customInstructions: undefined,\n  maxCodeLength: 1000000,\n  maxNestingDepth: 50,\n  enableZodParsing: true,\n  showDetailedErrors: true\n};\n\n/**\n * Formedible field configurations for the parser settings UI\n * These can be used to generate a settings form using formedible\n */\nexport const parserConfigFields = [\n  {\n    name: 'strictValidation',\n    type: 'switch',\n    label: 'Strict Validation',\n    description: 'Enable strict validation of form definitions. When enabled, unknown properties are rejected.',\n    defaultValue: true\n  },\n  {\n    name: 'enableSchemaInference',\n    type: 'switch',\n    label: 'Schema Inference',\n    description: 'Automatically infer Zod schemas from field definitions to provide better type safety.',\n    defaultValue: false\n  },\n  {\n    name: 'mergeStrategy',\n    type: 'select',\n    label: 'Schema Merge Strategy',\n    description: 'How to merge parsed configurations with base schemas.',\n    defaultValue: 'extend',\n    options: [\n      { value: 'extend', label: 'Extend - Add missing fields from base schema' },\n      { value: 'override', label: 'Override - Replace schema completely' },\n      { value: 'intersect', label: 'Intersect - Keep only common fields' }\n    ]\n  },\n  {\n    name: 'fieldTypeValidation',\n    type: 'switch',\n    label: 'Field Type Validation',\n    description: 'Validate field types against the list of supported field types.',\n    defaultValue: true\n  },\n  {\n    name: 'aiErrorMessages',\n    type: 'switch',\n    label: 'AI-Friendly Error Messages',\n    description: 'Generate detailed error messages with suggestions for AI systems.',\n    defaultValue: true\n  },\n  {\n    name: 'customInstructions',\n    type: 'textarea',\n    label: 'Custom Instructions',\n    description: 'Optional custom parsing instructions or constraints to apply.',\n    placeholder: 'Enter any custom parsing rules or requirements...',\n    required: false\n  },\n  {\n    name: 'maxCodeLength',\n    type: 'number',\n    label: 'Maximum Code Length',\n    description: 'Maximum allowed length for form definition code (in characters).',\n    defaultValue: 1000000,\n    min: 1000,\n    max: 10000000,\n    step: 1000\n  },\n  {\n    name: 'maxNestingDepth',\n    type: 'number',\n    label: 'Maximum Nesting Depth',\n    description: 'Maximum allowed nesting depth for object and array structures.',\n    defaultValue: 50,\n    min: 5,\n    max: 200,\n    step: 5\n  },\n  {\n    name: 'enableZodParsing',\n    type: 'switch',\n    label: 'Zod Expression Parsing',\n    description: 'Enable parsing and handling of Zod schema expressions in form definitions.',\n    defaultValue: true\n  },\n  {\n    name: 'showDetailedErrors',\n    type: 'switch',\n    label: 'Detailed Error Information',\n    description: 'Include detailed error context and location information in parser output.',\n    defaultValue: true\n  }\n];\n\n/**\n * Parser configuration form definition\n * Complete formedible form configuration for parser settings\n */\nexport const parserConfigFormDefinition = {\n  title: 'Parser Configuration',\n  description: 'Configure how the Formedible parser processes form definitions',\n  fields: parserConfigFields,\n  submitLabel: 'Save Configuration',\n  formOptions: {\n    defaultValues: defaultParserConfig\n  }\n};\n\n/**\n * Helper function to validate parser configuration\n */\nexport function validateParserConfig(config: unknown): config is ParserConfig {\n  if (!config || typeof config !== 'object') {\n    return false;\n  }\n\n  const c = config as Record<string, unknown>;\n  \n  return (\n    typeof c.strictValidation === 'boolean' &&\n    typeof c.enableSchemaInference === 'boolean' &&\n    (c.mergeStrategy === 'extend' || c.mergeStrategy === 'override' || c.mergeStrategy === 'intersect') &&\n    typeof c.fieldTypeValidation === 'boolean' &&\n    typeof c.aiErrorMessages === 'boolean' &&\n    (c.customInstructions === undefined || typeof c.customInstructions === 'string') &&\n    typeof c.maxCodeLength === 'number' &&\n    typeof c.maxNestingDepth === 'number' &&\n    typeof c.enableZodParsing === 'boolean' &&\n    typeof c.showDetailedErrors === 'boolean'\n  );\n}\n\n/**\n * Helper function to merge parser configuration with defaults\n */\nexport function mergeParserConfig(config: Partial<ParserConfig>): ParserConfig {\n  return {\n    ...defaultParserConfig,\n    ...config\n  };\n}",
      "type": "registry:lib",
      "target": "lib/formedible/parser-config-schema.ts"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}