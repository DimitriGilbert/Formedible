{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-builder",
  "type": "registry:block",
  "title": "Formedible AI Builder",
  "description": "An AI-powered form builder component that generates forms from natural language descriptions. Features chat interface, real-time form generation, and multiple AI provider support.",
  "dependencies": [
    "react",
    "lucide-react",
    "clsx",
    "tailwind-merge",
    "@ai-sdk/openai",
    "@ai-sdk/anthropic",
    "@ai-sdk/google",
    "@ai-sdk/mistral",
    "@ai-sdk/openai-compatible",
    "@openrouter/ai-sdk-provider",
    "ai",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "card",
    "tabs",
    "dialog",
    "dropdown-menu",
    "scroll-area",
    "badge",
    "alert",
    "skeleton",
    "https://formedible.dev/r/use-formedible.json",
    "https://formedible.dev/r/form-builder.json"
  ],
  "files": [
    {
      "path": "src/components/formedible/ai/ai-builder.tsx",
      "content": "\"use client\";\n\nimport { useState, useCallback, useEffect } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { ProviderSelection, type ProviderConfig } from \"./provider-selection\";\nimport { ChatInterface } from \"./chat-interface\";\nimport { FormPreview } from \"./form-preview\";\nimport { ConversationHistory, type Conversation } from \"./conversation-history\";\nimport { Button } from \"@/components/ui/button\";\nimport { Sparkles, ChevronDown, ChevronUp, Settings, History, ChevronLeft, ChevronRight, Eye, FileText } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\n\n// Create a client instance outside the component to avoid recreation\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      gcTime: 10 * 60 * 1000, // 10 minutes\n      retry: 1,\n    },\n  },\n});\n\nexport interface AIBuilderProps {\n  className?: string;\n  onFormGenerated?: (formCode: string) => void;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n}\n\nconst STORAGE_KEYS = {\n  PROVIDER_CONFIG: \"formedible-ai-builder-provider-config\",\n  CONVERSATIONS: \"formedible-ai-builder-conversations\",\n  UI_STATE: \"formedible-ai-builder-ui-state\",\n};\n\nfunction AIBuilderCore({ className, onFormGenerated, onFormSubmit }: AIBuilderProps) {\n  const [providerConfig, setProviderConfig] = useState<ProviderConfig | null>(null);\n  const [generatedForms, setGeneratedForms] = useState<Array<{ id: string; code: string; timestamp: Date }>>([]);\n  const [currentFormIndex, setCurrentFormIndex] = useState<number>(0);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [currentConversationId, setCurrentConversationId] = useState<string | undefined>();\n  const [currentMessages, setCurrentMessages] = useState<Message[]>([]);\n  const [isTopSectionCollapsed, setIsTopSectionCollapsed] = useState(false);\n\n  // Load saved data on mount\n  useEffect(() => {\n    try {\n      // Load provider config\n      const savedConfig = localStorage.getItem(STORAGE_KEYS.PROVIDER_CONFIG);\n      if (savedConfig) {\n        setProviderConfig(JSON.parse(savedConfig));\n      }\n\n      // Load conversations\n      const savedConversations = localStorage.getItem(STORAGE_KEYS.CONVERSATIONS);\n      if (savedConversations) {\n        const parsedConversations = JSON.parse(savedConversations);\n        setConversations(parsedConversations.map((c: any) => ({\n          ...c,\n          createdAt: new Date(c.createdAt),\n          updatedAt: new Date(c.updatedAt),\n        })));\n      }\n\n      // Load UI state\n      const savedUIState = localStorage.getItem(STORAGE_KEYS.UI_STATE);\n      if (savedUIState) {\n        const uiState = JSON.parse(savedUIState);\n        setIsTopSectionCollapsed(uiState.isTopSectionCollapsed || false);\n        setCurrentConversationId(uiState.currentConversationId);\n      }\n    } catch (error) {\n      console.warn(\"Failed to load saved AI Builder data:\", error);\n    }\n  }, []);\n\n  // Save provider config when it changes\n  useEffect(() => {\n    if (providerConfig) {\n      try {\n        localStorage.setItem(STORAGE_KEYS.PROVIDER_CONFIG, JSON.stringify(providerConfig));\n      } catch (error) {\n        console.warn(\"Failed to save provider config:\", error);\n      }\n    }\n  }, [providerConfig]);\n\n  // Save conversations when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));\n    } catch (error) {\n      console.warn(\"Failed to save conversations:\", error);\n    }\n  }, [conversations]);\n\n  // Save UI state when it changes\n  useEffect(() => {\n    try {\n      const uiState = {\n        isTopSectionCollapsed,\n        currentConversationId,\n      };\n      localStorage.setItem(STORAGE_KEYS.UI_STATE, JSON.stringify(uiState));\n    } catch (error) {\n      console.warn(\"Failed to save UI state:\", error);\n    }\n  }, [isTopSectionCollapsed, currentConversationId]);\n\n  const handleProviderConfigChange = useCallback((config: ProviderConfig | null) => {\n    setProviderConfig(config);\n  }, []);\n\n  const handleFormGenerated = useCallback((formCode: string) => {\n    const newForm = {\n      id: `form_${Date.now()}`,\n      code: formCode,\n      timestamp: new Date()\n    };\n    \n    setGeneratedForms(prev => {\n      const updated = [...prev, newForm];\n      setCurrentFormIndex(updated.length - 1); // Auto-navigate to newest form\n      return updated;\n    });\n    \n    onFormGenerated?.(formCode);\n  }, [onFormGenerated]);\n\n  const handleStreamingStateChange = useCallback((streaming: boolean) => {\n    setIsGenerating(streaming);\n  }, []);\n\n  const handleFormSubmit = useCallback((formData: Record<string, unknown>) => {\n    console.log(\"Form submitted:\", formData);\n    onFormSubmit?.(formData);\n  }, [onFormSubmit]);\n\n  const handleFormIndexChange = useCallback((index: number) => {\n    setCurrentFormIndex(index);\n  }, []);\n\n  const handleDeleteForm = useCallback((index: number) => {\n    setGeneratedForms(prev => {\n      const updated = prev.filter((_, i) => i !== index);\n      // Adjust current index if necessary\n      if (index <= currentFormIndex && currentFormIndex > 0) {\n        setCurrentFormIndex(currentFormIndex - 1);\n      } else if (index < currentFormIndex) {\n        // No change needed to currentFormIndex\n      } else if (updated.length === 0) {\n        setCurrentFormIndex(0);\n      } else if (currentFormIndex >= updated.length) {\n        setCurrentFormIndex(updated.length - 1);\n      }\n      return updated;\n    });\n  }, [currentFormIndex]);\n\n  const handleConversationUpdate = useCallback((messages: Message[], isStreamEnd: boolean = false) => {\n    // Always update current messages for UI\n    setCurrentMessages(messages);\n    \n    // Only create/update conversations when needed\n    if (messages.length > 0) {\n      if (!currentConversationId) {\n        // Create new conversation ONLY on first user message\n        const newConversationId = `conversation_${Date.now()}`;\n        const newConversation: Conversation = {\n          id: newConversationId,\n          title: \"\", // Will be generated from first message\n          messages,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        };\n        \n        setConversations(prev => [...prev, newConversation]);\n        setCurrentConversationId(newConversationId);\n      } else {\n        // ALWAYS update existing conversation with new messages (not just on stream end)\n        setConversations(prev => prev.map(conv => \n          conv.id === currentConversationId \n            ? { ...conv, messages, updatedAt: new Date() }\n            : conv\n        ));\n      }\n    }\n  }, [currentConversationId]);\n\n  const handleNewConversation = useCallback(() => {\n    setCurrentConversationId(undefined);\n    setCurrentMessages([]);\n  }, []);\n\n  // Remove automatic conversation creation\n\n  const handleSelectConversation = useCallback((conversation: Conversation) => {\n    setCurrentConversationId(conversation.id);\n    setCurrentMessages(conversation.messages);\n  }, []);\n\n  const handleDeleteConversation = useCallback((conversationId: string) => {\n    setConversations(prev => prev.filter(c => c.id !== conversationId));\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(undefined);\n    }\n  }, [currentConversationId]);\n\n  const handleExportConversation = useCallback((conversation: Conversation) => {\n    const dataStr = JSON.stringify(conversation, null, 2);\n    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\n\n    const exportFileDefaultName = `conversation-${conversation.id}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileDefaultName);\n    linkElement.click();\n  }, []);\n\n\n\n  return (\n    <div className={cn(\"flex flex-col h-full overflow-hidden\", className)}>\n      <div className=\"flex items-center gap-2 px-1 pb-2 flex-shrink-0\">\n        <Sparkles className=\"h-4 w-4 text-primary\" />\n        <h1 className=\"text-lg font-bold text-foreground\">AI Form Builder</h1>\n      </div>\n\n      {/* Compact Collapsible Settings & History */}\n      <div className=\"flex-shrink-0 pb-1\">\n        <div \n          className=\"flex items-center justify-between mb-1 p-2 bg-accent/10 hover:bg-accent/20 rounded-lg border-2 border-accent/20 hover:border-accent/30 transition-all duration-200 shadow-sm cursor-pointer\"\n          onClick={() => setIsTopSectionCollapsed(!isTopSectionCollapsed)}\n        >\n          <div className=\"flex items-center gap-2\">\n            <div className=\"p-1.5 bg-accent/20 rounded-md\">\n              <Settings className=\"h-4 w-4 text-accent-foreground\" />\n            </div>\n            <span className=\"text-sm font-semibold text-foreground\">Settings & History</span>\n          </div>\n          <div className=\"flex items-center gap-1 text-sm h-7 px-3\">\n            {isTopSectionCollapsed ? (\n              <>\n                <ChevronDown className=\"h-4 w-4\" />\n                <span className=\"font-medium\">Show</span>\n              </>\n            ) : (\n              <>\n                <ChevronUp className=\"h-4 w-4\" />\n                <span className=\"font-medium\">Hide</span>\n              </>\n            )}\n          </div>\n        </div>\n\n        {!isTopSectionCollapsed && (\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-2 mb-1\">\n            <ConversationHistory\n              conversations={conversations}\n              currentConversationId={currentConversationId}\n              onSelectConversation={handleSelectConversation}\n              onDeleteConversation={handleDeleteConversation}\n              onExportConversation={handleExportConversation}\n            />\n            <ProviderSelection\n              onConfigChange={handleProviderConfigChange}\n              initialConfig={providerConfig}\n            />\n          </div>\n        )}\n      </div>\n\n      {/* Chat Interface - Takes ALL Remaining Space */}\n      <div className=\"flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden\">\n        <ChatInterface\n          onFormGenerated={handleFormGenerated}\n          onStreamingStateChange={handleStreamingStateChange}\n          onConversationUpdate={handleConversationUpdate}\n          onNewConversation={handleNewConversation}\n          messages={currentMessages}\n          providerConfig={providerConfig}\n          className=\"h-full overflow-hidden\"\n        />\n\n        <FormPreview\n          forms={generatedForms}\n          currentFormIndex={currentFormIndex}\n          onFormIndexChange={handleFormIndexChange}\n          onDeleteForm={handleDeleteForm}\n          isStreaming={isGenerating}\n          onFormSubmit={handleFormSubmit}\n          className=\"h-full overflow-hidden\"\n        />\n      </div>\n    </div>\n  );\n}\n\n// Export the main component wrapped with QueryClientProvider\nexport function AIBuilder(props: AIBuilderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <AIBuilderCore {...props} />\n    </QueryClientProvider>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-builder.tsx"
    },
    {
      "path": "src/components/formedible/ai/provider-selection.tsx",
      "content": "\"use client\";\n\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { z } from \"zod\";\nimport { useState, useEffect } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\n\nexport type AIProvider =\n  | \"openai\"\n  | \"anthropic\"\n  | \"google\"\n  | \"mistral\"\n  | \"openrouter\"\n  | \"openai-compatible\";\n\nexport interface ProviderConfig {\n  provider: AIProvider;\n  apiKey: string;\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  endpoint?: string;\n}\n\nexport interface ProviderSelectionProps {\n  onConfigChange: (config: ProviderConfig | null) => void;\n  initialConfig?: ProviderConfig | null;\n  className?: string;\n}\n\nconst providerSchema = z.object({\n  provider: z\n    .enum([\n      \"openai\",\n      \"anthropic\",\n      \"google\",\n      \"mistral\",\n      \"openrouter\",\n      \"openai-compatible\",\n    ])\n    .optional(),\n  model: z.string().optional(),\n  apiKey: z.string().optional(),\n  temperature: z.number().min(0).max(2).default(0.7),\n  maxTokens: z.number().min(1).max(32768).default(16384),\n  endpoint: z.string().url().optional(),\n});\n\nconst PROVIDERS = [\n  { value: \"openai\", label: \"OpenAI\", requiresKey: true },\n  { value: \"anthropic\", label: \"Anthropic\", requiresKey: true },\n  { value: \"google\", label: \"Google Gemini\", requiresKey: true },\n  { value: \"mistral\", label: \"Mistral\", requiresKey: true },\n  { value: \"openrouter\", label: \"OpenRouter\", requiresKey: true },\n  {\n    value: \"openai-compatible\",\n    label: \"OpenAI Compatible\",\n    requiresKey: false,\n  },\n] as const;\n\n// Separate function to get model options based on provider\nconst getModelOptions = (\n  provider: AIProvider | undefined,\n  openRouterModels: Array<{ value: string; label: string }> = [],\n  openRouterLoading: boolean = false\n) => {\n  if (provider === \"openai\")\n    return [\n      { value: \"gpt-4o\", label: \"GPT-4o\" },\n      { value: \"gpt-4o-mini\", label: \"GPT-4o Mini\" },\n      { value: \"gpt-4-turbo\", label: \"GPT-4 Turbo\" },\n      { value: \"gpt-4\", label: \"GPT-4\" },\n      { value: \"gpt-3.5-turbo\", label: \"GPT-3.5 Turbo\" },\n      { value: \"gpt-4o-2024-08-06\", label: \"GPT-4o (2024-08-06)\" },\n      { value: \"gpt-4o-mini-2024-07-18\", label: \"GPT-4o Mini (2024-07-18)\" },\n    ];\n  if (provider === \"anthropic\")\n    return [\n      { value: \"claude-opus-4-1-20250805\", label: \"Claude Opus 4.1\" },\n      { value: \"claude-opus-4-20250514\", label: \"Claude Opus 4\" },\n      { value: \"claude-sonnet-4-20250514\", label: \"Claude Sonnet 4\" },\n      { value: \"claude-3-7-sonnet-20250219\", label: \"Claude 3.7 Sonnet\" },\n      { value: \"claude-3-5-haiku-20241022\", label: \"Claude 3.5 Haiku\" },\n      { value: \"claude-3-haiku-20240307\", label: \"Claude 3 Haiku\" },\n    ];\n  if (provider === \"google\")\n    return [\n      { value: \"gemini-2.5-pro\", label: \"Gemini 2.5 Pro\" },\n      { value: \"gemini-2.5-flash\", label: \"Gemini 2.5 Flash\" },\n      { value: \"gemini-2.5-flash-lite\", label: \"Gemini 2.5 Flash Lite\" },\n      { value: \"gemini-2.0-flash\", label: \"Gemini 2.0 Flash\" },\n    ];\n  if (provider === \"mistral\")\n    return [\n      { value: \"mistral-large-2411\", label: \"Mistral Large 2.1\" },\n      { value: \"mistral-medium-2508\", label: \"Mistral Medium 3.1\" },\n      { value: \"codestral-2508\", label: \"Codestral 2508\" },\n      { value: \"ministral-8b-2410\", label: \"Ministral 8B\" },\n      { value: \"ministral-3b-2410\", label: \"Ministral 3B\" },\n      { value: \"mistral-small-2506\", label: \"Mistral Small 3.2\" },\n    ];\n  if (provider === \"openrouter\") {\n    if (openRouterLoading) return [{ value: \"loading\", label: \"Loading models...\" }];\n    return openRouterModels.length > 0\n      ? openRouterModels.filter(model => model.value && model.value.trim() !== \"\")\n      : [\n          { value: \"openai/gpt-5\", label: \"OpenAI GPT-5\" },\n          { value: \"openai/gpt-5-mini\", label: \"OpenAI GPT-5 Mini\" },\n          { value: \"openai/o3-pro\", label: \"OpenAI o3 Pro\" },\n          { value: \"openai/o3-mini\", label: \"OpenAI o3 Mini\" },\n          {\n            value: \"anthropic/claude-opus-4.1\",\n            label: \"Anthropic Claude Opus 4.1\",\n          },\n          {\n            value: \"anthropic/claude-sonnet-4\",\n            label: \"Anthropic Claude Sonnet 4\",\n          },\n          { value: \"google/gemini-2.5-pro\", label: \"Google Gemini 2.5 Pro\" },\n          { value: \"deepseek/deepseek-r1\", label: \"DeepSeek R1\" },\n          {\n            value: \"mistralai/mistral-medium-3.1\",\n            label: \"Mistral Medium 3.1\",\n          },\n          { value: \"qwen/qwen3-235b-a22b\", label: \"Qwen Qwen3 235B A22B\" },\n        ];\n  }\n  return [];\n};\n\n// OpenRouter models fetcher\nconst fetchOpenRouterModels = async (apiKey: string) => {\n  const response = await fetch(\"https://openrouter.ai/api/v1/models\", {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.data\n    .filter((model: any) => model.id && model.name && model.id.trim() !== \"\")\n    .map((model: any) => ({\n      value: model.id,\n      label: `${model.name} (${model.id})`,\n    }))\n    .sort((a: any, b: any) => a.label.localeCompare(b.label));\n};\n\nexport function ProviderSelection({\n  onConfigChange,\n  initialConfig,\n  className,\n}: ProviderSelectionProps) {\n  const [currentApiKey, setCurrentApiKey] = useState<string>(initialConfig?.apiKey || \"\");\n  const [currentProvider, setCurrentProvider] = useState<AIProvider | undefined>(initialConfig?.provider);\n\n  // Use TanStack Query for OpenRouter models\n  const {\n    data: openRouterModels = [],\n    isLoading: openRouterLoading,\n    error: openRouterError,\n  } = useQuery({\n    queryKey: [\"openrouter-models\", currentApiKey],\n    queryFn: () => fetchOpenRouterModels(currentApiKey),\n    enabled: currentProvider === \"openrouter\" && !!currentApiKey && currentApiKey.length > 0,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    gcTime: 10 * 60 * 1000, // 10 minutes\n    retry: 1,\n  });\n\n  const { Form, form } = useFormedible({\n    schema: providerSchema,\n    layout: { type: \"grid\", columns: 2, gap: \"lg\" },\n    fields: [\n      // Field 1 - Provider\n      {\n        name: \"provider\",\n        type: \"select\",\n        label: \"AI Provider\",\n        placeholder: \"Select provider...\",\n        gridColumn: 1,\n        options: PROVIDERS.map((p) => ({ value: p.value, label: p.label })),\n      },\n      // Field 2 - API Key (MOVED BEFORE MODEL)\n      {\n        name: \"apiKey\",\n        type: \"text\",\n        label: \"API Key\",\n        placeholder: \"sk-...\",\n        gridColumn: 2,\n        conditional: (values) => !!values.provider,\n        help: {\n          tooltip:\n            \"Your API key is stored securely and never sent to our servers\",\n        },\n      },\n      // Field 3 - Model (NOW AFTER API KEY)\n      {\n        name: \"model\",\n        type: \"select\",\n        label: \"Model\",\n        placeholder: \"Select model...\",\n        gridColumn: 1,\n        options: (values) => {\n          const models = getModelOptions(\n            values.provider as AIProvider | undefined,\n            openRouterModels,\n            openRouterLoading\n          );\n          \n          // Show error state for OpenRouter if there's an error\n          if (values.provider === \"openrouter\" && openRouterError) {\n            return [{ value: \"error\", label: \"Failed to load models - check API key\" }];\n          }\n          \n          return models;\n        },\n        conditional: (values) => !!values.provider,\n      },\n      // Field 4 - Temperature\n      {\n        name: \"temperature\",\n        type: \"slider\",\n        label: \"Temperature\",\n        description: \"Controls randomness: 0 = focused, 2 = creative\",\n        gridColumn: 2,\n        sliderConfig: {\n          min: 0,\n          max: 2,\n          step: 0.1,\n          showValue: true,\n          marks: [\n            { value: 0, label: \"Focused\" },\n            { value: 1, label: \"Balanced\" },\n            { value: 2, label: \"Creative\" },\n          ],\n        },\n        conditional: (values) => !!values.provider,\n      },\n      // Field 5 - Endpoint\n      {\n        name: \"endpoint\",\n        type: \"text\",\n        label: \"API Endpoint\",\n        placeholder: \"https://api.example.com/v1\",\n        conditional: (values) => values.provider === \"openai-compatible\",\n        gridColumn: 1,\n        description: \"Base URL for OpenAI-compatible API\",\n      },\n      // Field 6 - Max Tokens\n      {\n        name: \"maxTokens\",\n        type: \"number\",\n        label: \"Max Tokens\",\n        placeholder: \"16384\",\n        description: \"Maximum response length\",\n        gridColumn: 2,\n        numberConfig: {\n          min: 1,\n          max: 32768,\n          step: 1,\n        },\n        conditional: (values) => !!values.provider,\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        provider: initialConfig?.provider,\n        model: initialConfig?.model || \"\",\n        apiKey: initialConfig?.apiKey || \"\",\n        endpoint: initialConfig?.endpoint || \"\",\n        temperature: initialConfig?.temperature || 0.7,\n        maxTokens: initialConfig?.maxTokens || 16384,\n      },\n      onSubmit: async ({ value }) => {\n        const config: ProviderConfig = {\n          provider: value.provider as AIProvider,\n          apiKey: value.apiKey || \"\",\n          model: value.model,\n          temperature: value.temperature,\n          maxTokens: value.maxTokens,\n          ...(value.endpoint && { endpoint: value.endpoint }),\n        };\n        onConfigChange(config);\n      },\n    },\n    submitLabel: \"💾 Save Configuration\",\n    showSubmitButton: true,\n    autoSubmitOnChange: false,\n  });\n\n  // Use TanStack Form subscriptions to watch specific fields without causing full rerenders\n  useEffect(() => {\n    const unsubscribeProvider = form.store.subscribe(() => {\n      const provider = form.state.values.provider;\n      if (provider !== currentProvider) {\n        setCurrentProvider(provider as AIProvider);\n      }\n    });\n\n    const unsubscribeApiKey = form.store.subscribe(() => {\n      const apiKey = form.state.values.apiKey;\n      if (apiKey && apiKey !== currentApiKey) {\n        setCurrentApiKey(apiKey);\n      }\n    });\n\n    return () => {\n      unsubscribeProvider();\n      unsubscribeApiKey();\n    };\n  }, [form, currentProvider, currentApiKey]);\n\n  return <Form />;\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/provider-selection.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-interface.tsx",
      "content": "\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { streamText } from \"ai\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createMistral } from \"@ai-sdk/mistral\";\nimport { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { createOpenAICompatible } from \"@ai-sdk/openai-compatible\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { AlertCircle, MessageSquare, Send, StopCircle, User, Bot, Loader2, ArrowDown, Plus } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { CodeBlock } from \"@/components/ui/code-block\";\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\n\n// MessageContent component to handle code blocks with syntax highlighting\ninterface MessageContentProps {\n  content: string;\n}\n\nfunction MessageContent({ content }: MessageContentProps) {\n  // Detect and render code blocks with syntax highlighting\n  const codeBlockRegex = /```(\\w+)?\\s*\\n([\\s\\S]*?)\\n```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      parts.push(\n        <span key={`text-${lastIndex}`} className=\"whitespace-pre-wrap break-words leading-relaxed\">\n          {content.slice(lastIndex, match.index)}\n        </span>\n      );\n    }\n\n    // Add code block with syntax highlighting\n    const language = match[1] || 'text';\n    const code = match[2];\n    parts.push(\n      <div key={`code-${match.index}`} className=\"my-2\">\n        <CodeBlock\n          code={code}\n          language={language}\n          showLineNumbers={false}\n          showCopyButton={true}\n          className=\"text-xs\"\n          darkMode={true}\n          scrollable={false}\n        />\n      </div>\n    );\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Add remaining text\n  if (lastIndex < content.length) {\n    parts.push(\n      <span key={`text-${lastIndex}`} className=\"whitespace-pre-wrap break-words leading-relaxed\">\n        {content.slice(lastIndex)}\n      </span>\n    );\n  }\n\n  return <div className=\"space-y-1\">{parts.length > 0 ? parts : <span className=\"whitespace-pre-wrap break-words leading-relaxed\">{content}</span>}</div>;\n}\n\nexport interface Message {\n  id: string;\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface ChatInterfaceProps {\n  onFormGenerated?: (formCode: string) => void;\n  onStreamingStateChange?: (isStreaming: boolean) => void;\n  onConversationUpdate?: (messages: Message[], isStreamEnd?: boolean) => void;\n  onNewConversation?: () => void;\n  messages?: Message[];\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n}\n\nexport function ChatInterface({ onFormGenerated, onStreamingStateChange, onConversationUpdate, onNewConversation, messages: externalMessages, className, providerConfig }: ChatInterfaceProps) {\n  const [input, setInput] = useState(\"\");\n  const [messages, setMessages] = useState<Message[]>(externalMessages || []);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [showScrollToBottom, setShowScrollToBottom] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const messagesContainerRef = useRef<HTMLDivElement>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Remove the automatic conversation completion\n\n  const scrollToBottom = useCallback(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, []);\n\n  const handleScroll = useCallback(() => {\n    if (!messagesContainerRef.current) return;\n    \n    const { scrollTop, scrollHeight, clientHeight } = messagesContainerRef.current;\n    const isAtBottom = scrollHeight - scrollTop - clientHeight < 100;\n    \n    setShowScrollToBottom(!isAtBottom && messages.length > 0);\n  }, [messages.length]);\n\n  // Sync with external messages only when switching conversations\n  useEffect(() => {\n    if (externalMessages && externalMessages.length > 0 && messages.length === 0) {\n      setMessages(externalMessages);\n    }\n  }, [externalMessages]);\n\n  // Remove the useEffect that was causing multiple updates\n\n  // Removed auto-scroll - let users control scrolling manually\n\n  useEffect(() => {\n    const container = messagesContainerRef.current;\n    if (!container) return;\n\n    container.addEventListener('scroll', handleScroll);\n    handleScroll(); // Check initial state\n\n    return () => container.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  const createModel = (config: ProviderConfig) => {\n    const { provider, apiKey, model, endpoint } = config;\n    \n    switch (provider) {\n      case 'openai':\n        const openaiProvider = createOpenAI({ apiKey });\n        return openaiProvider(model || 'gpt-4o');\n      \n      case 'anthropic':\n        const anthropicProvider = createAnthropic({ apiKey });\n        return anthropicProvider(model || 'claude-3-5-sonnet-20241022');\n      \n      case 'google':\n        const googleProvider = createGoogleGenerativeAI({ apiKey });\n        return googleProvider(model || 'gemini-1.5-pro');\n      \n      case 'mistral':\n        const mistralProvider = createMistral({ apiKey });\n        return mistralProvider(model || 'mistral-large-latest');\n      \n      case 'openrouter':\n        const openrouterProvider = createOpenRouter({ apiKey });\n        return openrouterProvider.chat(model || 'meta-llama/llama-3.2-3b-instruct:free');\n      \n      case 'openai-compatible':\n        if (!endpoint) throw new Error('Endpoint required for OpenAI-compatible providers');\n        const openaiCompatible = createOpenAICompatible({\n          name: 'openai-compatible',\n          baseURL: endpoint,\n          ...(apiKey && { apiKey }),\n        });\n        return openaiCompatible(model || 'gpt-3.5-turbo');\n      \n      default:\n        throw new Error('Unsupported provider');\n    }\n  };\n\n  const generateResponse = async (userMessage: string) => {\n    if (!providerConfig) {\n      setError(new Error('Provider configuration required'));\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n      onStreamingStateChange?.(true);\n\n      const userMsg: Message = {\n        id: Date.now().toString(),\n        role: 'user',\n        content: userMessage,\n      };\n\n      const newMessages = [...messages, userMsg];\n      setMessages(newMessages);\n      \n      // Immediately save user message\n      onConversationUpdate?.(newMessages, false);\n\n      const model = createModel(providerConfig);\n      \n      const systemPrompt = `You are a helpful AI assistant for form creation. You can chat naturally with users about forms, answer questions, and help them design forms.\n\n**IMPORTANT: Only show formedible code blocks when the user specifically asks to create, build, generate, or show a form.**\n\nWhen creating forms, use formedible code blocks with complete JavaScript object literal syntax including Zod schemas:\n\n\\`\\`\\`formedible\n{\n  schema: z.object({\n    firstName: z.string().min(1, 'First name is required'),\n    email: z.string().email('Please enter a valid email address'),\n    age: z.number().min(18, 'Must be 18 or older').optional(),\n    newsletter: z.boolean().default(false)\n  }),\n  fields: [\n    {\n      name: 'firstName',\n      type: 'text',\n      label: 'First Name',\n      placeholder: 'Enter your first name'\n    },\n    {\n      name: 'email',\n      type: 'email', \n      label: 'Email Address',\n      placeholder: 'your@email.com'\n    },\n    {\n      name: 'age',\n      type: 'number',\n      label: 'Age',\n      placeholder: '18+'\n    },\n    {\n      name: 'newsletter',\n      type: 'checkbox',\n      label: 'Subscribe to newsletter'\n    }\n  ],\n  formOptions: {\n    defaultValues: {\n      firstName: '',\n      email: '',\n      newsletter: false\n    }\n  }\n}\n\\`\\`\\`\n\n**CRITICAL REQUIREMENTS:**\n- ALWAYS include complete Zod schema with proper validation\n- Use JavaScript object literals (unquoted keys, single quotes for strings) \n- Match schema field names EXACTLY with field names\n- Include proper Zod validations: .min(), .max(), .email(), .optional(), .default()\n- Available field types: text, email, password, tel, textarea, select, checkbox, switch, number, date, slider, file, rating, phone, colorPicker, location, duration, multiSelect, autocomplete, masked, object, array, radio\n\n**Zod Schema Examples:**\n- z.string().min(1, 'Required') - required text\n- z.string().email('Invalid email') - email validation  \n- z.number().min(18, 'Must be 18+') - number with min\n- z.boolean().default(false) - checkbox with default\n- z.string().optional() - optional field\n- z.enum(['option1', 'option2']) - select options\n- z.array(z.string()) - multiSelect\n\n**ARRAY FIELDS - Use arrayConfig with proper configuration:**\n\nSimple string arrays:\n\\`\\`\\`javascript\n{\n  name: 'contactMethods',\n  type: 'array',\n  label: 'Contact Email Addresses',\n  arrayConfig: {\n    itemType: 'email',\n    itemLabel: 'Email Address',\n    itemPlaceholder: 'contact@company.com',\n    minItems: 1,\n    maxItems: 5,\n    addButtonLabel: 'Add Email',\n    removeButtonLabel: 'Remove',\n    defaultValue: ''\n  }\n}\n\\`\\`\\`\n\nComplex object arrays:\n\\`\\`\\`javascript\n{\n  name: 'teamMembers',\n  type: 'array',\n  label: 'Team Members',\n  arrayConfig: {\n    itemType: 'object',\n    itemLabel: 'Team Member',\n    minItems: 1,\n    maxItems: 10,\n    sortable: true,\n    addButtonLabel: 'Add Team Member',\n    removeButtonLabel: 'Remove Member',\n    defaultValue: {\n      name: '',\n      email: '',\n      role: 'developer'\n    },\n    objectConfig: {\n      fields: [\n        {\n          name: 'name',\n          type: 'text',\n          label: 'Name',\n          placeholder: 'Enter name'\n        },\n        {\n          name: 'email',\n          type: 'text',\n          label: 'Email',\n          placeholder: 'Enter email'\n        },\n        {\n          name: 'role',\n          type: 'select',\n          label: 'Role',\n          options: [\n            { value: 'developer', label: 'Developer' },\n            { value: 'designer', label: 'Designer' }\n          ]\n        }\n      ]\n    }\n  }\n}\n\\`\\`\\`\n\n**OBJECT FIELDS - Use objectConfig with fields:**\n\n\\`\\`\\`javascript\n{\n  name: 'roomDetails',\n  type: 'array',\n  label: 'Room Details',\n  arrayConfig: {\n    itemType: 'object',\n    itemLabel: 'Room',\n    defaultValue: {\n      hasEquipment: false,\n      equipmentList: ''\n    },\n    objectConfig: {\n      collapseLabel: 'Collapse',\n      expandLabel: 'Expand',\n      title: 'Room Configuration',\n      description: 'Define room characteristics',\n      collapsible: true,\n      defaultExpanded: true,\n      showCard: false,\n      columns: 2,\n      layout: 'grid',\n      fields: [\n        {\n          name: 'hasEquipment',\n          type: 'switch',\n          label: 'Has Equipment',\n          description: 'Does this room have special equipment?'\n        },\n        {\n          name: 'equipmentList',\n          type: 'textarea',\n          label: 'Equipment List',\n          placeholder: 'Describe equipment...',\n          conditional: (values) => values && values.hasEquipment === true\n        }\n      ]\n    }\n  }\n}\n\\`\\`\\`\n\n**Optional properties:**\n- pages: [...] for multi-page forms\n- progress: { showSteps: true, showPercentage: false }\n- submitLabel: 'Submit Form'\n- formOptions: { defaultValues: {...}, onSubmit: async (data) => {...} }\n\nChat naturally. Ask clarifying questions. Suggest improvements. Only output formedible blocks when specifically requested.`;\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      const result = await streamText({\n        model,\n        system: systemPrompt,\n        messages: [...messages, userMsg].map(msg => ({\n          role: msg.role,\n          content: msg.content,\n        })),\n        temperature: providerConfig.temperature || 0.7,\n        maxOutputTokens: providerConfig.maxTokens || 2000,\n        abortSignal: abortController.signal,\n      });\n\n      const assistantMsg: Message = {\n        id: (Date.now() + 1).toString(),\n        role: 'assistant',\n        content: '',\n      };\n\n      setMessages(prev => [...prev, assistantMsg]);\n\n      let fullResponse = '';\n      for await (const textPart of result.textStream) {\n        if (abortController.signal.aborted) break;\n        \n        fullResponse += textPart;\n        setMessages(prev => prev.map(msg => \n          msg.id === assistantMsg.id \n            ? { ...msg, content: fullResponse }\n            : msg\n        ));\n      }\n\n      // Extract and send formedible code blocks to preview\n      if (fullResponse && onFormGenerated) {\n        const formedibleMatch = fullResponse.match(/```formedible\\s*\\n([\\s\\S]*?)\\n```/);\n        if (formedibleMatch && formedibleMatch[1]) {\n          onFormGenerated(formedibleMatch[1].trim());\n        }\n      }\n\n      onStreamingStateChange?.(false);\n\n      // Save conversation to localStorage ONLY on stream end with complete messages\n      setMessages(currentMessages => {\n        // Use a microtask to defer the parent update until after current render cycle\n        Promise.resolve().then(() => {\n          onConversationUpdate?.(currentMessages, true);\n        });\n        return currentMessages;\n      });\n\n    } catch (err) {\n      console.error('AI Generation Error:', err);\n      setError(err instanceof Error ? err : new Error('Unknown error occurred'));\n    } finally {\n      setIsLoading(false);\n      onStreamingStateChange?.(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!input.trim() || isLoading || !providerConfig) return;\n    \n    const userInput = input;\n    setInput(\"\");\n    generateResponse(userInput);\n  };\n\n  const stop = () => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit(e);\n    }\n  };\n\n  return (\n    <Card className={cn(\"flex flex-col h-full border-2 border-accent/30 shadow-lg\", className)}>\n      <CardHeader className=\"pb-4 bg-gradient-to-r from-accent/10 to-transparent\">\n        <CardTitle className=\"flex items-center justify-between text-lg\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-accent/20 rounded-lg\">\n              <MessageSquare className=\"h-5 w-5 text-accent-foreground\" />\n            </div>\n            <span className=\"text-foreground font-semibold\">AI Form Builder Chat</span>\n          </div>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </CardTitle>\n      </CardHeader>\n      \n      <CardContent className=\"flex flex-col flex-1 p-6 min-h-0 relative\">\n        <div\n          ref={messagesContainerRef}\n          className=\"flex-1 overflow-y-auto space-y-4 mb-4 pr-2 min-h-0 max-h-full\"\n        >\n          {messages.length === 0 && (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground\">\n              <Bot className=\"h-12 w-12 mb-4 opacity-50\" />\n              <h3 className=\"text-lg font-medium mb-2\">Welcome to AI Form Builder</h3>\n              <p className=\"text-sm max-w-md\">\n                Describe the form you want to create and I'll generate it for you. \n                Try something like \"Create a contact form with name, email, and message fields\"\n              </p>\n            </div>\n          )}\n\n          {messages.map((message: Message) => (\n            <div\n              key={message.id}\n              className={cn(\n                \"flex gap-3 max-w-4xl\",\n                message.role === \"user\" ? \"ml-auto flex-row-reverse\" : \"mr-auto\"\n              )}\n            >\n              <div\n                className={cn(\n                  \"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-muted text-foreground border-border\"\n                )}\n              >\n                {message.role === \"user\" ? (\n                  <User className=\"h-4 w-4\" />\n                ) : (\n                  <Bot className=\"h-4 w-4\" />\n                )}\n              </div>\n              \n              <div\n                className={cn(\n                  \"flex flex-col gap-2 rounded-lg px-4 py-3 text-sm shadow-md border max-w-[85%]\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground border-primary/30\"\n                    : \"bg-background text-foreground border-border\"\n                )}\n              >\n                <MessageContent content={message.content} />\n              </div>\n            </div>\n          ))}\n\n          {isLoading && (\n            <div className=\"flex gap-3 max-w-4xl mr-auto\">\n              <div className=\"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border-2 shadow-md bg-muted text-foreground border-border\">\n                <Bot className=\"h-4 w-4\" />\n              </div>\n              <div className=\"flex items-center gap-2 rounded-lg px-4 py-3 text-sm shadow-md border bg-background text-foreground border-border\">\n                <Loader2 className=\"h-4 w-4 animate-spin text-primary\" />\n                <span>Generating response...</span>\n              </div>\n            </div>\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Scroll to bottom button */}\n        {showScrollToBottom && (\n          <Button\n            onClick={scrollToBottom}\n            className=\"absolute bottom-20 right-4 rounded-full w-10 h-10 p-0 shadow-lg z-10\"\n            variant=\"secondary\"\n            size=\"sm\"\n          >\n            <ArrowDown className=\"h-4 w-4\" />\n            <span className=\"sr-only\">Scroll to bottom</span>\n          </Button>\n        )}\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>\n              Failed to send message. Please check your configuration and try again.\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"flex gap-2\">\n          <Textarea\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Describe the form you want to create... (Shift+Enter for new line)\"\n            disabled={isLoading}\n            className=\"flex-1 min-h-[80px] resize-none\"\n            rows={3}\n          />\n          \n          {isLoading ? (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n              onClick={stop}\n              className=\"shrink-0\"\n            >\n              <StopCircle className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Stop generation</span>\n            </Button>\n          ) : (\n            <Button\n              type=\"submit\"\n              disabled={!input.trim()}\n              size=\"icon\"\n              className=\"shrink-0\"\n            >\n              <Send className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Send message</span>\n            </Button>\n          )}\n        </form>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-interface.tsx"
    },
    {
      "path": "src/components/formedible/ai/form-preview.tsx",
      "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { FormPreviewBase } from \"@/components/formedible/builder/form-preview-base\";\nimport { Eye, ChevronLeft, ChevronRight, Trash2 } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface GeneratedForm {\n  id: string;\n  code: string;\n  timestamp: Date;\n}\n\nexport interface FormPreviewProps {\n  forms: GeneratedForm[];\n  currentFormIndex: number;\n  onFormIndexChange: (index: number) => void;\n  onDeleteForm?: (index: number) => void;\n  isStreaming?: boolean;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  className?: string;\n}\n\nexport function FormPreview({ \n  forms, \n  currentFormIndex, \n  onFormIndexChange,\n  onDeleteForm,\n  isStreaming = false, \n  onFormSubmit, \n  className \n}: FormPreviewProps) {\n  const currentForm = forms[currentFormIndex];\n\n  if (forms.length === 0 && !isStreaming) {\n    return (\n      <FormPreviewBase \n        className={className}\n        title=\"Form Preview\"\n        emptyStateMessage=\"Start a conversation in the chat to generate your first form. The preview will appear here once the AI creates your form.\"\n      />\n    );\n  }\n\n  return (\n    <Card className={cn(\"flex flex-col h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"h-5 w-5\" />\n            Form Preview\n            {forms.length > 0 && (\n              <span className=\"text-sm font-normal text-muted-foreground\">\n                ({currentFormIndex + 1} of {forms.length})\n              </span>\n            )}\n          </CardTitle>\n          \n          {forms.length > 1 && (\n            <div className=\"flex items-center gap-1\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.max(0, currentFormIndex - 1))}\n                disabled={currentFormIndex === 0}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronLeft className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Previous form</span>\n              </Button>\n              \n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => onFormIndexChange(Math.min(forms.length - 1, currentFormIndex + 1))}\n                disabled={currentFormIndex === forms.length - 1}\n                className=\"h-8 w-8 p-0\"\n              >\n                <ChevronRight className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Next form</span>\n              </Button>\n\n              {onDeleteForm && forms.length > 1 && (\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => onDeleteForm(currentFormIndex)}\n                  className=\"h-8 w-8 p-0 text-destructive hover:text-destructive\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                  <span className=\"sr-only\">Delete form</span>\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"flex-1 overflow-hidden p-0\">\n        <FormPreviewBase \n          formCode={currentForm?.code}\n          isStreaming={isStreaming && !currentForm}\n          onFormSubmit={onFormSubmit}\n          className=\"border-0 h-full\"\n        />\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/form-preview.tsx"
    },
    {
      "path": "src/components/formedible/ai/ai-form-renderer.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useMemo, useCallback, memo } from \"react\";\nimport { z } from \"zod\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { FieldConfig, UseFormedibleOptions } from \"@/lib/formedible/types\";\n\nexport interface AiFormParseResult<TFormData = Record<string, unknown>> {\n  schema: z.ZodSchema<TFormData>;\n  formOptions: UseFormedibleOptions<TFormData>;\n  success: boolean;\n  error?: string;\n}\n\nexport interface AiParserConfig {\n  allowedFieldTypes?: string[];\n  allowedKeys?: string[];\n  allowedFieldKeys?: string[];\n  allowedPageKeys?: string[];\n  allowedProgressKeys?: string[];\n  allowedFormOptionsKeys?: string[];\n}\n\nexport interface AiFormRendererProps {\n  code: string;\n  isStreaming?: boolean;\n  onParseComplete?: (result: AiFormParseResult) => void;\n  onSubmit?: (formData: Record<string, unknown>) => void | Promise<void>;\n  className?: string;\n  parserConfig?: AiParserConfig;\n  debug?: boolean;\n}\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'email', 'password', 'url', 'tel', 'textarea', 'select', \n  'checkbox', 'switch', 'number', 'date', 'slider', 'file', 'rating',\n  'phone', 'colorPicker', 'location', 'duration', 'multiSelect',\n  'autocomplete', 'masked', 'object', 'array', 'radio'\n];\n\nconst DEFAULT_KEYS = [\n  'schema', 'fields', 'pages', 'progress', 'submitLabel', 'nextLabel', \n  'previousLabel', 'formClassName', 'fieldClassName', 'formOptions'\n];\n\nconst DEFAULT_FIELD_KEYS = [\n  'name', 'type', 'label', 'placeholder', 'description', 'options', \n  'min', 'max', 'step', 'accept', 'multiple', 'page', 'conditional',\n  'section', 'ratingConfig', 'phoneConfig', 'colorConfig', 'locationConfig',\n  'durationConfig', 'multiSelectConfig', 'sliderConfig', 'numberConfig',\n  'dateConfig', 'fileConfig', 'textareaConfig', 'passwordConfig', 'emailConfig',\n  'autocompleteConfig', 'maskedInputConfig', 'objectConfig', 'arrayConfig',\n  'validation', 'group', 'tab', 'help', 'inlineValidation', 'datalist'\n];\n\nconst DEFAULT_PAGE_KEYS = ['page', 'title', 'description'];\n\nconst DEFAULT_PROGRESS_KEYS = ['showSteps', 'showPercentage', 'className'];\n\nconst DEFAULT_FORM_OPTIONS_KEYS = [\n  'defaultValues', 'asyncDebounceMs', 'canSubmitWhenInvalid', 'onSubmit', 'onSubmitInvalid'\n];\n\nclass AiFormedibleParser {\n  private config: Required<AiParserConfig>;\n\n  constructor(config?: AiParserConfig) {\n    this.config = {\n      allowedFieldTypes: config?.allowedFieldTypes ?? DEFAULT_FIELD_TYPES,\n      allowedKeys: config?.allowedKeys ?? DEFAULT_KEYS,\n      allowedFieldKeys: config?.allowedFieldKeys ?? DEFAULT_FIELD_KEYS,\n      allowedPageKeys: config?.allowedPageKeys ?? DEFAULT_PAGE_KEYS,\n      allowedProgressKeys: config?.allowedProgressKeys ?? DEFAULT_PROGRESS_KEYS,\n      allowedFormOptionsKeys: config?.allowedFormOptionsKeys ?? DEFAULT_FORM_OPTIONS_KEYS,\n    };\n  }\n\n  parse(code: string): AiFormParseResult {\n    try {\n      const sanitizedCode = this.sanitizeCode(code);\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n      const sanitized = this.validateAndSanitize(parsed);\n      const { schema, formOptions } = this.createFormedibleConfig(sanitized);\n\n      return {\n        schema,\n        formOptions,\n        success: true,\n      };\n    } catch (error) {\n      return {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private sanitizeCode(code: string): string {\n    let sanitized = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '').replace(/\\/\\/.*$/gm, '');\n    sanitized = sanitized.replace(/\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g, '');\n    sanitized = sanitized.replace(/=>\\s*{[^}]*}/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n    return sanitized;\n  }\n\n  private parseObjectLiteral(code: string): unknown {\n    try {\n      return JSON.parse(code);\n    } catch {\n      try {\n        let processedCode = code.trim();\n        processedCode = this.replaceZodExpressions(processedCode);\n        processedCode = processedCode.replace(/([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g, '$1\"$2\":');\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, '$1');\n        processedCode = processedCode.replace(/'/g, '\"');\n        return JSON.parse(processedCode);\n      } catch (conversionError) {\n        throw new Error(`Invalid syntax: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);\n      }\n    }\n  }\n\n  private replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n\n        while (endIndex < result.length && depth > 0) {\n          if (result[endIndex] === '(') {\n            depth++;\n          } else if (result[endIndex] === ')') {\n            depth--;\n          }\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                if (result[chainEndIndex] === '(') {\n                  chainDepth++;\n                } else if (result[chainEndIndex] === ')') {\n                  chainDepth--;\n                }\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          result = result.slice(0, startIndex) + '\"__ZOD_SCHEMA__\"' + result.slice(chainEnd);\n          changed = true;\n        } else {\n          result = result.replace(/z\\.[a-zA-Z]+/, '\"__ZOD_SCHEMA__\"');\n          changed = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private validateAndSanitize(obj: unknown): Record<string, unknown> {\n    if (typeof obj !== 'object' || obj === null) {\n      throw new Error('Definition must be an object');\n    }\n\n    const sanitized: Record<string, unknown> = {};\n    const input = obj as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(input)) {\n      if (!this.config.allowedKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'schema':\n          break;\n        case 'fields':\n          sanitized[key] = this.validateFields(value);\n          break;\n        case 'pages':\n          sanitized[key] = this.validatePages(value);\n          break;\n        case 'progress':\n          sanitized[key] = this.validateProgress(value);\n          break;\n        case 'formOptions':\n          sanitized[key] = this.validateFormOptions(value);\n          break;\n        case 'submitLabel':\n        case 'nextLabel':\n        case 'previousLabel':\n        case 'formClassName':\n        case 'fieldClassName':\n          if (typeof value === 'string') {\n            sanitized[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private validateFields(fields: unknown): FieldConfig[] {\n    if (!Array.isArray(fields)) {\n      throw new Error('Fields must be an array');\n    }\n\n    return fields.map((field, index) => {\n      if (typeof field !== 'object' || field === null) {\n        throw new Error(`Field at index ${index} must be an object`);\n      }\n\n      const sanitizedField: Record<string, unknown> = {};\n      const fieldObj = field as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(fieldObj)) {\n        if (!this.config.allowedFieldKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'name':\n            if (typeof value === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'type':\n            if (typeof value === 'string' && this.config.allowedFieldTypes.includes(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'label':\n          case 'placeholder':\n          case 'description':\n          case 'accept':\n            if (typeof value === 'string') {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'options':\n            if (Array.isArray(value)) {\n              sanitizedField[key] = value.filter(opt => \n                typeof opt === 'string' || \n                (typeof opt === 'object' && opt !== null && \n                 typeof (opt as { value?: unknown }).value === 'string' && \n                 typeof (opt as { label?: unknown }).label === 'string')\n              );\n            }\n            break;\n          case 'min':\n          case 'max':\n          case 'step':\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'multiple':\n          case 'conditional':\n            if (typeof value === 'boolean') {\n              sanitizedField[key] = value;\n            }\n            break;\n          default:\n            if (typeof value === 'object' && value !== null) {\n              sanitizedField[key] = value;\n            }\n            break;\n        }\n      }\n\n      if (!sanitizedField.name || !sanitizedField.type) {\n        throw new Error(`Field at index ${index} must have 'name' and 'type' properties`);\n      }\n\n      return sanitizedField as unknown as FieldConfig;\n    });\n  }\n\n  private validatePages(pages: unknown): Array<{ page: number; title?: string; description?: string }> {\n    if (!Array.isArray(pages)) {\n      return [];\n    }\n\n    return pages.map(page => {\n      if (typeof page !== 'object' || page === null) {\n        return null;\n      }\n\n      const sanitizedPage: Record<string, unknown> = {};\n      const pageObj = page as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(pageObj)) {\n        if (!this.config.allowedPageKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedPage[key] = value;\n            }\n            break;\n          case 'title':\n          case 'description':\n            if (typeof value === 'string') {\n              sanitizedPage[key] = value;\n            }\n            break;\n        }\n      }\n\n      return sanitizedPage.page ? sanitizedPage : null;\n    }).filter(Boolean) as Array<{ page: number; title?: string; description?: string }>;\n  }\n\n  private validateProgress(progress: unknown): Record<string, unknown> {\n    if (typeof progress !== 'object' || progress === null) {\n      return {};\n    }\n\n    const sanitizedProgress: Record<string, unknown> = {};\n    const progressObj = progress as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(progressObj)) {\n      if (!this.config.allowedProgressKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'showSteps':\n        case 'showPercentage':\n          if (typeof value === 'boolean') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n        case 'className':\n          if (typeof value === 'string') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedProgress;\n  }\n\n  private validateFormOptions(formOptions: unknown): Record<string, unknown> {\n    if (typeof formOptions !== 'object' || formOptions === null) {\n      return {};\n    }\n\n    const sanitizedOptions: Record<string, unknown> = {};\n    const optionsObj = formOptions as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(optionsObj)) {\n      if (!this.config.allowedFormOptionsKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'defaultValues':\n          if (typeof value === 'object' && value !== null) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'asyncDebounceMs':\n          if (typeof value === 'number' && !isNaN(value)) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'canSubmitWhenInvalid':\n          if (typeof value === 'boolean') {\n            sanitizedOptions[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedOptions;\n  }\n\n  private createFormedibleConfig(sanitized: Record<string, unknown>): { \n    schema: z.ZodSchema<Record<string, unknown>>; \n    formOptions: UseFormedibleOptions<Record<string, unknown>>; \n  } {\n    const fields = sanitized.fields as FieldConfig[] || [];\n    const schema = this.createSchemaFromFields(fields);\n    const defaultValues = this.createDefaultValues(fields);\n\n    const formOptions: UseFormedibleOptions<Record<string, unknown>> = {\n      fields,\n      schema,\n      pages: sanitized.pages as UseFormedibleOptions<Record<string, unknown>>['pages'],\n      progress: sanitized.progress as UseFormedibleOptions<Record<string, unknown>>['progress'],\n      submitLabel: sanitized.submitLabel as string,\n      nextLabel: sanitized.nextLabel as string,\n      previousLabel: sanitized.previousLabel as string,\n      formClassName: sanitized.formClassName as string,\n      fieldClassName: sanitized.fieldClassName as string,\n      formOptions: {\n        defaultValues,\n        ...(sanitized.formOptions as Record<string, unknown>),\n      },\n    };\n\n    return { schema, formOptions };\n  }\n\n  private createSchemaFromFields(fields: FieldConfig[]): z.ZodSchema<Record<string, unknown>> {\n    const schemaObj: Record<string, z.ZodTypeAny> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'colorPicker':\n        case 'autocomplete':\n        case 'masked':\n        case 'radio':\n        case 'select':\n          schemaObj[field.name] = z.string();\n          break;\n        case 'number':\n        case 'slider':\n        case 'rating':\n          schemaObj[field.name] = z.number();\n          break;\n        case 'checkbox':\n        case 'switch':\n          schemaObj[field.name] = z.boolean();\n          break;\n        case 'date':\n          schemaObj[field.name] = z.date();\n          break;\n        case 'file':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'location':\n          schemaObj[field.name] = z.object({\n            lat: z.number(),\n            lng: z.number(),\n            address: z.string().optional(),\n            city: z.string().optional(),\n            country: z.string().optional(),\n          }).optional();\n          break;\n        case 'duration':\n          schemaObj[field.name] = z.object({\n            hours: z.number().min(0),\n            minutes: z.number().min(0),\n          }).optional();\n          break;\n        case 'multiSelect':\n          schemaObj[field.name] = z.array(z.string());\n          break;\n        case 'object':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'array':\n          schemaObj[field.name] = z.array(z.any());\n          break;\n        default:\n          schemaObj[field.name] = z.string();\n      }\n    });\n\n    return z.object(schemaObj);\n  }\n\n  private createDefaultValues(fields: FieldConfig[]): Record<string, unknown> {\n    const defaults: Record<string, unknown> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'autocomplete':\n        case 'masked':\n          defaults[field.name] = '';\n          break;\n        case 'number':\n        case 'slider':\n          defaults[field.name] = field.min || 0;\n          break;\n        case 'checkbox':\n        case 'switch':\n          defaults[field.name] = false;\n          break;\n        case 'date':\n          defaults[field.name] = new Date().toISOString().split('T')[0];\n          break;\n        case 'select':\n        case 'radio':\n          if (field.options && Array.isArray(field.options) && field.options.length > 0) {\n            const firstOption = field.options[0];\n            defaults[field.name] = typeof firstOption === 'string' ? firstOption : (firstOption as { value: string }).value;\n          } else {\n            defaults[field.name] = '';\n          }\n          break;\n        case 'file':\n          defaults[field.name] = null;\n          break;\n        case 'rating':\n          defaults[field.name] = 1;\n          break;\n        case 'colorPicker':\n          defaults[field.name] = '#000000';\n          break;\n        case 'location':\n          defaults[field.name] = undefined;\n          break;\n        case 'duration':\n          defaults[field.name] = { hours: 0, minutes: 0 };\n          break;\n        case 'multiSelect':\n          defaults[field.name] = [];\n          break;\n        case 'object':\n          defaults[field.name] = {};\n          break;\n        case 'array':\n          defaults[field.name] = [];\n          break;\n        default:\n          defaults[field.name] = '';\n      }\n    });\n\n    return defaults;\n  }\n}\n\nexport function parseAiToFormedible(\n  code: string, \n  config?: AiParserConfig\n): AiFormParseResult {\n  const parser = new AiFormedibleParser(config);\n  return parser.parse(code);\n}\n\nconst AiFormRendererComponent: React.FC<AiFormRendererProps> = ({\n  code,\n  isStreaming = false,\n  onParseComplete,\n  onSubmit,\n  className,\n  parserConfig,\n  debug = false,\n}) => {\n  const [parseResult, setParseResult] = useState<AiFormParseResult | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const parseFormDefinition = useCallback(async () => {\n    if (!code.trim() || isStreaming) return;\n\n    setIsLoading(true);\n\n    try {\n      const result = parseAiToFormedible(code, parserConfig);\n      setParseResult(result);\n      onParseComplete?.(result);\n\n      if (debug && result.error) {\n        console.error('AI Form Parser Error:', result.error);\n      }\n    } catch (err) {\n      const errorResult: AiFormParseResult = {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: err instanceof Error ? err.message : String(err),\n      };\n      setParseResult(errorResult);\n      onParseComplete?.(errorResult);\n\n      if (debug) {\n        console.error('AI Form Renderer Error:', err);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [code, isStreaming, onParseComplete, parserConfig, debug]);\n\n  useEffect(() => {\n    if (!isStreaming && code.trim()) {\n      parseFormDefinition();\n    }\n  }, [code, isStreaming, parseFormDefinition]);\n\n  const formConfig = useMemo(() => {\n    if (!parseResult?.success || !parseResult.formOptions.fields?.length) {\n      return null;\n    }\n\n    return {\n      ...parseResult.formOptions,\n      formOptions: {\n        ...parseResult.formOptions.formOptions,\n        onSubmit: async ({ value }: { value: Record<string, unknown> }) => {\n          await onSubmit?.(value);\n        },\n      },\n    };\n  }, [parseResult, onSubmit]);\n\n  const formedibleResult = useFormedible(formConfig || {\n    fields: [],\n    formOptions: { defaultValues: {} }\n  });\n\n  const renderedForm = useMemo(() => {\n    if (isLoading) {\n      return (\n        <div className=\"flex items-center justify-center p-8\">\n          <div className=\"text-sm text-muted-foreground\">Parsing form...</div>\n        </div>\n      );\n    }\n\n    if (parseResult && !parseResult.success) {\n      return (\n        <div className=\"p-4 border border-destructive/20 bg-destructive/10 rounded-md\">\n          <div className=\"text-sm text-destructive\">\n            <div className=\"font-medium\">Parse Error</div>\n            <div className=\"text-xs mt-1 opacity-80\">{parseResult.error}</div>\n          </div>\n        </div>\n      );\n    }\n\n    if (!formConfig || !parseResult?.success) {\n      return null;\n    }\n\n    return <formedibleResult.Form />;\n  }, [isLoading, parseResult, formConfig, formedibleResult]);\n\n  return (\n    <div className={className}>\n      {renderedForm}\n    </div>\n  );\n};\n\nexport const AiFormRenderer = memo(AiFormRendererComponent);",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-form-renderer.tsx"
    },
    {
      "path": "src/components/formedible/ai/conversation-history.tsx",
      "content": "\"use client\";\n\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { History, MessageSquare, Trash2, Download, Plus } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { Message } from \"./chat-interface\";\n\nexport interface Conversation {\n  id: string;\n  title: string;\n  messages: Message[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ConversationHistoryProps {\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onNewConversation?: () => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  className?: string;\n}\n\nexport function ConversationHistory({\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onNewConversation,\n  onExportConversation,\n  className,\n}: ConversationHistoryProps) {\n\n  const formatDate = (date: Date) => {\n    const now = new Date();\n    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);\n\n    if (diffInHours < 1) {\n      return \"Just now\";\n    } else if (diffInHours < 24) {\n      return `${Math.floor(diffInHours)}h ago`;\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n\n  const getConversationTitle = (conversation: Conversation) => {\n    if (conversation.title) return conversation.title;\n\n    // Generate title from first user message\n    const firstUserMessage = conversation.messages?.find(m => m.role === \"user\");\n    if (firstUserMessage?.content) {\n      const text = firstUserMessage.content;\n      return text.length > 50 ? text.substring(0, 50) + \"...\" : text;\n    }\n\n    return \"New Conversation\";\n  };\n\n  return (\n    <Card className={cn(\"h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <History className=\"h-5 w-5\" />\n            Conversation History\n            <Badge variant=\"secondary\">\n              {conversations.length}\n            </Badge>\n          </CardTitle>\n          {onNewConversation && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={onNewConversation}\n              className=\"h-8 w-8 p-0\"\n            >\n              <Plus className=\"h-4 w-4\" />\n              <span className=\"sr-only\">New conversation</span>\n            </Button>\n          )}\n        </div>\n      </CardHeader>\n      <CardContent className=\"p-4\">\n        <div className=\"h-[300px] overflow-y-auto\">\n          {conversations.length === 0 ? (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground py-8\">\n              <MessageSquare className=\"h-8 w-8 mb-2 opacity-50\" />\n              <p className=\"text-sm\">No conversations yet</p>\n              <p className=\"text-xs\">Start a chat to see your history</p>\n            </div>\n          ) : (\n            <div className=\"space-y-2\">\n              {conversations.map((conversation) => (\n                <div\n                  key={conversation.id}\n                  className={cn(\n                    \"group flex items-center gap-2 p-2 rounded-lg border transition-colors hover:bg-muted/50 cursor-pointer\",\n                    currentConversationId === conversation.id && \"bg-muted border-primary\"\n                  )}\n                  onClick={() => onSelectConversation(conversation)}\n                >\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <MessageSquare className=\"h-3 w-3 text-muted-foreground shrink-0\" />\n                      <span className=\"text-xs text-muted-foreground\">\n                        {formatDate(conversation.updatedAt)}\n                      </span>\n                    </div>\n                    <p className=\"text-sm font-medium truncate\">\n                      {getConversationTitle(conversation)}\n                    </p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {conversation.messages?.length || 0} messages\n                    </p>\n                  </div>\n                  <div className=\"flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity\">\n                    {onExportConversation && (\n                      <Button\n                        type=\"button\"\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        className=\"h-6 w-6\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          onExportConversation(conversation);\n                        }}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    )}\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-6 w-6 text-destructive hover:text-destructive\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        onDeleteConversation(conversation.id);\n                      }}\n                    >\n                      <Trash2 className=\"h-3 w-3\" />\n                    </Button>\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/conversation-history.tsx"
    }
  ]
}