{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-builder",
  "type": "registry:block",
  "title": "Formedible AI Builder",
  "description": "An AI-powered form builder component that generates forms from natural language descriptions. Features chat interface, real-time form generation, and multiple AI provider support.",
  "dependencies": [
    "react",
    "lucide-react",
    "clsx",
    "tailwind-merge",
    "@ai-sdk/openai",
    "@ai-sdk/anthropic",
    "@ai-sdk/google",
    "@ai-sdk/mistral",
    "@ai-sdk/openai-compatible",
    "@openrouter/ai-sdk-provider",
    "ai",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "select",
    "checkbox",
    "switch",
    "label",
    "card",
    "tabs",
    "dialog",
    "dropdown-menu",
    "scroll-area",
    "badge",
    "alert",
    "skeleton",
    "https://formedible.dev/r/use-formedible.json"
  ],
  "files": [
    {
      "path": "src/components/formedible/ai/ai-builder.tsx",
      "content": "\"use client\";\n\nimport { useState, useCallback } from \"react\";\nimport { ProviderSelection, type ProviderConfig } from \"./provider-selection\";\nimport { ChatInterface } from \"./chat-interface\";\nimport { FormPreview } from \"./form-preview\";\nimport { ConversationHistory, type Conversation } from \"./conversation-history\";\nimport { Button } from \"@/components/ui/button\";\nimport { Sparkles, ChevronDown, ChevronUp, Settings, History } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { UIMessage } from \"@ai-sdk/react\";\n\nexport interface AIBuilderProps {\n  className?: string;\n  onFormGenerated?: (formCode: string) => void;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n}\n\nexport function AIBuilder({ className, onFormGenerated, onFormSubmit }: AIBuilderProps) {\n  const [providerConfig, setProviderConfig] = useState<ProviderConfig | null>(null);\n  const [generatedFormCode, setGeneratedFormCode] = useState<string>(\"\");\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [currentConversationId, setCurrentConversationId] = useState<string | undefined>();\n  const [isTopSectionCollapsed, setIsTopSectionCollapsed] = useState(false);\n\n  const handleProviderConfigChange = useCallback((config: ProviderConfig | null) => {\n    setProviderConfig(config);\n  }, []);\n\n  const handleFormGenerated = useCallback((formCode: string) => {\n    setGeneratedFormCode(formCode);\n    setIsGenerating(false);\n    onFormGenerated?.(formCode);\n  }, [onFormGenerated]);\n\n  const handleFormSubmit = useCallback((formData: Record<string, unknown>) => {\n    console.log(\"Form submitted:\", formData);\n    onFormSubmit?.(formData);\n  }, [onFormSubmit]);\n\n  const handleNewConversation = useCallback((messages: UIMessage[]) => {\n    if (messages.length > 0) {\n      const newConversation: Conversation = {\n        id: Date.now().toString(),\n        title: \"\",\n        messages,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n      setConversations(prev => [newConversation, ...prev]);\n      setCurrentConversationId(newConversation.id);\n    }\n  }, []);\n\n  const handleSelectConversation = useCallback((conversation: Conversation) => {\n    setCurrentConversationId(conversation.id);\n    // Here you would typically load the conversation messages into the chat\n  }, []);\n\n  const handleDeleteConversation = useCallback((conversationId: string) => {\n    setConversations(prev => prev.filter(c => c.id !== conversationId));\n    if (currentConversationId === conversationId) {\n      setCurrentConversationId(undefined);\n    }\n  }, [currentConversationId]);\n\n  const handleExportConversation = useCallback((conversation: Conversation) => {\n    const dataStr = JSON.stringify(conversation, null, 2);\n    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\n\n    const exportFileDefaultName = `conversation-${conversation.id}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileDefaultName);\n    linkElement.click();\n  }, []);\n\n\n\n  return (\n    <div className={cn(\"flex flex-col h-full overflow-hidden\", className)}>\n      <div className=\"flex items-center gap-2 px-1 pb-2 flex-shrink-0\">\n        <Sparkles className=\"h-4 w-4 text-primary\" />\n        <h1 className=\"text-lg font-bold text-foreground\">AI Form Builder</h1>\n      </div>\n\n      {/* Compact Collapsible Settings & History */}\n      <div className=\"flex-shrink-0 pb-1\">\n        <div className=\"flex items-center justify-between mb-1 p-1 bg-muted/20 rounded border\">\n          <div className=\"flex items-center gap-2\">\n            <Settings className=\"h-3 w-3 text-primary\" />\n            <span className=\"text-xs font-medium text-foreground\">Settings</span>\n          </div>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setIsTopSectionCollapsed(!isTopSectionCollapsed)}\n            className=\"flex items-center gap-1 text-xs h-5 px-2\"\n          >\n            {isTopSectionCollapsed ? (\n              <>\n                <ChevronDown className=\"h-3 w-3\" />\n                Show\n              </>\n            ) : (\n              <>\n                <ChevronUp className=\"h-3 w-3\" />\n                Hide\n              </>\n            )}\n          </Button>\n        </div>\n\n        {!isTopSectionCollapsed && (\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-2 mb-1\">\n            <ConversationHistory\n              conversations={conversations}\n              currentConversationId={currentConversationId}\n              onSelectConversation={handleSelectConversation}\n              onDeleteConversation={handleDeleteConversation}\n              onExportConversation={handleExportConversation}\n            />\n            <ProviderSelection\n              onConfigChange={handleProviderConfigChange}\n            />\n          </div>\n        )}\n      </div>\n\n      {/* Chat Interface - Takes ALL Remaining Space */}\n      <div className=\"flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden\">\n        <ChatInterface\n          onFormGenerated={handleFormGenerated}\n          onMessagesUpdate={handleNewConversation}\n          apiEndpoint=\"/api/chat\"\n          providerConfig={providerConfig}\n          className=\"h-full overflow-hidden\"\n        />\n\n        <FormPreview\n          formCode={generatedFormCode}\n          isStreaming={isGenerating}\n          onFormSubmit={handleFormSubmit}\n          className=\"h-full overflow-hidden\"\n        />\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-builder.tsx"
    },
    {
      "path": "src/components/formedible/ai/provider-selection.tsx",
      "content": "\"use client\";\n\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport { z } from \"zod\";\nimport { useState } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\n\nexport type AIProvider =\n  | \"openai\"\n  | \"anthropic\"\n  | \"google\"\n  | \"mistral\"\n  | \"openrouter\"\n  | \"openai-compatible\";\n\nexport interface ProviderConfig {\n  provider: AIProvider;\n  apiKey: string;\n  endpoint?: string;\n}\n\nexport interface ProviderSelectionProps {\n  onConfigChange: (config: ProviderConfig | null) => void;\n  className?: string;\n}\n\nconst providerSchema = z.object({\n  provider: z\n    .enum([\n      \"openai\",\n      \"anthropic\",\n      \"google\",\n      \"mistral\",\n      \"openrouter\",\n      \"openai-compatible\",\n    ])\n    .optional(),\n  model: z.string().optional(),\n  apiKey: z.string().optional(),\n  temperature: z.number().min(0).max(2).default(0.7),\n  maxTokens: z.number().min(1).max(32768).default(16384),\n  endpoint: z.string().url().optional(),\n});\n\nconst PROVIDERS = [\n  { value: \"openai\", label: \"OpenAI\", requiresKey: true },\n  { value: \"anthropic\", label: \"Anthropic\", requiresKey: true },\n  { value: \"google\", label: \"Google Gemini\", requiresKey: true },\n  { value: \"mistral\", label: \"Mistral\", requiresKey: true },\n  { value: \"openrouter\", label: \"OpenRouter\", requiresKey: true },\n  {\n    value: \"openai-compatible\",\n    label: \"OpenAI Compatible\",\n    requiresKey: false,\n  },\n] as const;\n\n// Separate function to get model options based on provider\nconst getModelOptions = (\n  provider: AIProvider | undefined,\n  openRouterModels: Array<{ value: string; label: string }> = [],\n  openRouterLoading: boolean = false\n) => {\n  if (provider === \"openai\")\n    return [\n      { value: \"gpt-4o\", label: \"GPT-4o\" },\n      { value: \"gpt-4o-mini\", label: \"GPT-4o Mini\" },\n      { value: \"gpt-4-turbo\", label: \"GPT-4 Turbo\" },\n      { value: \"gpt-4\", label: \"GPT-4\" },\n      { value: \"gpt-3.5-turbo\", label: \"GPT-3.5 Turbo\" },\n      { value: \"gpt-4o-2024-08-06\", label: \"GPT-4o (2024-08-06)\" },\n      { value: \"gpt-4o-mini-2024-07-18\", label: \"GPT-4o Mini (2024-07-18)\" },\n    ];\n  if (provider === \"anthropic\")\n    return [\n      { value: \"claude-opus-4-1-20250805\", label: \"Claude Opus 4.1\" },\n      { value: \"claude-opus-4-20250514\", label: \"Claude Opus 4\" },\n      { value: \"claude-sonnet-4-20250514\", label: \"Claude Sonnet 4\" },\n      { value: \"claude-3-7-sonnet-20250219\", label: \"Claude 3.7 Sonnet\" },\n      { value: \"claude-3-5-haiku-20241022\", label: \"Claude 3.5 Haiku\" },\n      { value: \"claude-3-haiku-20240307\", label: \"Claude 3 Haiku\" },\n    ];\n  if (provider === \"google\")\n    return [\n      { value: \"gemini-2.5-pro\", label: \"Gemini 2.5 Pro\" },\n      { value: \"gemini-2.5-flash\", label: \"Gemini 2.5 Flash\" },\n      { value: \"gemini-2.5-flash-lite\", label: \"Gemini 2.5 Flash Lite\" },\n      { value: \"gemini-2.0-flash\", label: \"Gemini 2.0 Flash\" },\n    ];\n  if (provider === \"mistral\")\n    return [\n      { value: \"mistral-large-2411\", label: \"Mistral Large 2.1\" },\n      { value: \"mistral-medium-2508\", label: \"Mistral Medium 3.1\" },\n      { value: \"codestral-2508\", label: \"Codestral 2508\" },\n      { value: \"ministral-8b-2410\", label: \"Ministral 8B\" },\n      { value: \"ministral-3b-2410\", label: \"Ministral 3B\" },\n      { value: \"mistral-small-2506\", label: \"Mistral Small 3.2\" },\n    ];\n  if (provider === \"openrouter\") {\n    if (openRouterLoading) return [{ value: \"\", label: \"Loading models...\" }];\n    return openRouterModels.length > 0\n      ? openRouterModels\n      : [\n          { value: \"openai/gpt-5\", label: \"OpenAI GPT-5\" },\n          { value: \"openai/gpt-5-mini\", label: \"OpenAI GPT-5 Mini\" },\n          { value: \"openai/o3-pro\", label: \"OpenAI o3 Pro\" },\n          { value: \"openai/o3-mini\", label: \"OpenAI o3 Mini\" },\n          {\n            value: \"anthropic/claude-opus-4.1\",\n            label: \"Anthropic Claude Opus 4.1\",\n          },\n          {\n            value: \"anthropic/claude-sonnet-4\",\n            label: \"Anthropic Claude Sonnet 4\",\n          },\n          { value: \"google/gemini-2.5-pro\", label: \"Google Gemini 2.5 Pro\" },\n          { value: \"deepseek/deepseek-r1\", label: \"DeepSeek R1\" },\n          {\n            value: \"mistralai/mistral-medium-3.1\",\n            label: \"Mistral Medium 3.1\",\n          },\n          { value: \"qwen/qwen3-235b-a22b\", label: \"Qwen Qwen3 235B A22B\" },\n        ];\n  }\n  return [];\n};\n\n// OpenRouter models fetcher\nconst fetchOpenRouterModels = async (apiKey: string) => {\n  const response = await fetch(\"https://openrouter.ai/api/v1/models\", {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.data\n    .filter((model: any) => model.id && model.name)\n    .map((model: any) => ({\n      value: model.id,\n      label: `${model.name} (${model.id})`,\n    }))\n    .sort((a: any, b: any) => a.label.localeCompare(b.label));\n};\n\nexport function ProviderSelection({\n  onConfigChange,\n  className,\n}: ProviderSelectionProps) {\n  const [currentApiKey, setCurrentApiKey] = useState<string>(\"\");\n\n  // Use TanStack Query for OpenRouter models\n  const {\n    data: openRouterModels = [],\n    isLoading: openRouterLoading,\n    error: openRouterError,\n  } = useQuery({\n    queryKey: [\"openrouter-models\", currentApiKey],\n    queryFn: () => fetchOpenRouterModels(currentApiKey),\n    enabled: !!currentApiKey && currentApiKey.length > 0,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    gcTime: 10 * 60 * 1000, // 10 minutes\n    retry: 1,\n  });\n\n  // Update API key for React Query when form changes\n  const handleFormChange = (values: any) => {\n    if (\n      values.provider === \"openrouter\" &&\n      values.apiKey &&\n      values.apiKey !== currentApiKey\n    ) {\n      setCurrentApiKey(values.apiKey);\n    }\n  };\n\n  const { Form } = useFormedible({\n    schema: providerSchema,\n    layout: { type: \"grid\", columns: 2, gap: \"lg\" },\n    fields: [\n      // Field 1 - Provider\n      {\n        name: \"provider\",\n        type: \"select\",\n        label: \"AI Provider\",\n        placeholder: \"Select provider...\",\n        gridColumn: 1,\n        options: PROVIDERS.map((p) => ({ value: p.value, label: p.label })),\n      },\n      // Field 2 - Model\n      {\n        name: \"model\",\n        type: \"select\",\n        label: \"Model\",\n        placeholder: \"Select model...\",\n        gridColumn: 2,\n        options: (values) => {\n          const models = getModelOptions(\n            values.provider as AIProvider | undefined,\n            openRouterModels,\n            openRouterLoading\n          );\n          \n          // Show error state for OpenRouter if there's an error\n          if (values.provider === \"openrouter\" && openRouterError) {\n            return [{ value: \"\", label: \"Failed to load models - check API key\" }];\n          }\n          \n          return models;\n        },\n        conditional: (values) => !!values.provider,\n      },\n      // Field 3 - API Key\n      {\n        name: \"apiKey\",\n        type: \"text\",\n        label: \"API Key\",\n        placeholder: \"sk-...\",\n        gridColumn: 1,\n        conditional: (values) => !!values.provider,\n        help: {\n          tooltip:\n            \"Your API key is stored securely and never sent to our servers\",\n        },\n      },\n      // Field 4 - Temperature\n      {\n        name: \"temperature\",\n        type: \"slider\",\n        label: \"Temperature\",\n        description: \"Controls randomness: 0 = focused, 2 = creative\",\n        gridColumn: 2,\n        sliderConfig: {\n          min: 0,\n          max: 2,\n          step: 0.1,\n          showValue: true,\n          marks: [\n            { value: 0, label: \"Focused\" },\n            { value: 1, label: \"Balanced\" },\n            { value: 2, label: \"Creative\" },\n          ],\n        },\n        conditional: (values) => !!values.provider,\n      },\n      // Field 5 - Endpoint\n      {\n        name: \"endpoint\",\n        type: \"text\",\n        label: \"API Endpoint\",\n        placeholder: \"https://api.example.com/v1\",\n        conditional: (values) => values.provider === \"openai-compatible\",\n        gridColumn: 1,\n        description: \"Base URL for OpenAI-compatible API\",\n      },\n      // Field 6 - Max Tokens\n      {\n        name: \"maxTokens\",\n        type: \"number\",\n        label: \"Max Tokens\",\n        placeholder: \"16384\",\n        description: \"Maximum response length\",\n        gridColumn: 2,\n        numberConfig: {\n          min: 1,\n          max: 32768,\n          step: 1,\n        },\n        conditional: (values) => !!values.provider,\n      },\n    ],\n    formOptions: {\n      defaultValues: {\n        temperature: 0.7,\n        maxTokens: 16384,\n      },\n      onChange: handleFormChange,\n      onSubmit: async ({ value }) => {\n        const config: ProviderConfig = {\n          provider: value.provider as AIProvider,\n          apiKey: value.apiKey || \"\",\n          ...(value.endpoint && { endpoint: value.endpoint }),\n        };\n        onConfigChange(config);\n      },\n    },\n    submitLabel: \"ðŸ’¾ Save Configuration\",\n    showSubmitButton: true,\n    formClassName: \"space-y-6\",\n    autoSubmitOnChange: false,\n  });\n\n  return <Form />;\n}\n",
      "type": "registry:component",
      "target": "components/formedible/ai/provider-selection.tsx"
    },
    {
      "path": "src/components/formedible/ai/chat-interface.tsx",
      "content": "\"use client\";\n\nimport { useState, useRef, useEffect } from \"react\";\nimport { useChat, type UIMessage } from \"@ai-sdk/react\";\nimport { DefaultChatTransport } from \"ai\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { AlertCircle, MessageSquare, Send, StopCircle, User, Bot, Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { cn } from \"@/lib/utils\";\nimport type { ProviderConfig } from \"./provider-selection\";\n\nexport interface ChatInterfaceProps {\n  onFormGenerated?: (formCode: string) => void;\n  onMessagesUpdate?: (messages: UIMessage[]) => void;\n  apiEndpoint?: string;\n  className?: string;\n  providerConfig?: ProviderConfig | null;\n}\n\nexport function ChatInterface({ onFormGenerated, onMessagesUpdate, apiEndpoint = \"/api/chat\", className, providerConfig }: ChatInterfaceProps) {\n  const [input, setInput] = useState(\"\");\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const { messages, sendMessage, status, error, stop } = useChat({\n    transport: new DefaultChatTransport({\n      api: apiEndpoint,\n      body: providerConfig ? {\n        provider: providerConfig.provider,\n        apiKey: providerConfig.apiKey,\n        ...(providerConfig.endpoint && { endpoint: providerConfig.endpoint }),\n      } : {},\n    }),\n    onFinish: ({ message }: { message: UIMessage }) => {\n      const textContent = message.parts\n        .filter((part: any) => part.type === 'text')\n        .map((part: any) => part.text)\n        .join('');\n      if (textContent && onFormGenerated) {\n        onFormGenerated(textContent);\n      }\n    },\n  });\n\n  // Notify parent component when messages are updated\n  useEffect(() => {\n    if (onMessagesUpdate && messages.length > 0) {\n      onMessagesUpdate(messages);\n    }\n  }, [messages, onMessagesUpdate]);\n\n  const isLoading = status !== \"ready\";\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!input.trim() || isLoading) return;\n    \n    sendMessage({ text: input });\n    setInput(\"\");\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmit(e);\n    }\n  };\n\n  return (\n    <Card className={cn(\"flex flex-col h-full border-2 border-accent/30 shadow-lg\", className)}>\n      <CardHeader className=\"pb-4 bg-gradient-to-r from-accent/10 to-transparent\">\n        <CardTitle className=\"flex items-center gap-3 text-lg\">\n          <div className=\"p-2 bg-accent/20 rounded-lg\">\n            <MessageSquare className=\"h-5 w-5 text-accent-foreground\" />\n          </div>\n          <span className=\"text-foreground font-semibold\">AI Form Builder Chat</span>\n        </CardTitle>\n      </CardHeader>\n      \n      <CardContent className=\"flex flex-col flex-1 p-6\">\n        <div className=\"flex-1 overflow-y-auto space-y-4 mb-4 pr-2 min-h-0\">\n          {messages.length === 0 && (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground\">\n              <Bot className=\"h-12 w-12 mb-4 opacity-50\" />\n              <h3 className=\"text-lg font-medium mb-2\">Welcome to AI Form Builder</h3>\n              <p className=\"text-sm max-w-md\">\n                Describe the form you want to create and I'll generate it for you. \n                Try something like \"Create a contact form with name, email, and message fields\"\n              </p>\n            </div>\n          )}\n\n          {messages.map((message: UIMessage) => (\n            <div\n              key={message.id}\n              className={cn(\n                \"flex gap-3 max-w-4xl\",\n                message.role === \"user\" ? \"ml-auto flex-row-reverse\" : \"mr-auto\"\n              )}\n            >\n              <div\n                className={cn(\n                  \"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border shadow-sm\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground\"\n                    : \"bg-muted\"\n                )}\n              >\n                {message.role === \"user\" ? (\n                  <User className=\"h-4 w-4\" />\n                ) : (\n                  <Bot className=\"h-4 w-4\" />\n                )}\n              </div>\n              \n              <div\n                className={cn(\n                  \"flex flex-col gap-2 rounded-lg px-3 py-2 text-sm shadow-sm\",\n                  message.role === \"user\"\n                    ? \"bg-primary text-primary-foreground\"\n                    : \"bg-muted\"\n                )}\n              >\n                {message.parts.map((part: any, index: number) => {\n                  if (part.type === \"text\") {\n                    return (\n                      <div key={index} className=\"whitespace-pre-wrap break-words\">\n                        {part.text}\n                      </div>\n                    );\n                  }\n                  return null;\n                })}\n              </div>\n            </div>\n          ))}\n\n          {isLoading && (\n            <div className=\"flex gap-3 max-w-4xl mr-auto\">\n              <div className=\"flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full border shadow-sm bg-muted\">\n                <Bot className=\"h-4 w-4\" />\n              </div>\n              <div className=\"flex items-center gap-2 rounded-lg px-3 py-2 text-sm shadow-sm bg-muted\">\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n                <span>Generating form...</span>\n              </div>\n            </div>\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>\n              Failed to send message. Please check your configuration and try again.\n            </AlertDescription>\n          </Alert>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"flex gap-2\">\n          <Input\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Describe the form you want to create...\"\n            disabled={isLoading}\n            className=\"flex-1\"\n          />\n          \n          {isLoading ? (\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n              onClick={stop}\n              className=\"shrink-0\"\n            >\n              <StopCircle className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Stop generation</span>\n            </Button>\n          ) : (\n            <Button\n              type=\"submit\"\n              disabled={!input.trim()}\n              size=\"icon\"\n              className=\"shrink-0\"\n            >\n              <Send className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Send message</span>\n            </Button>\n          )}\n        </form>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/chat-interface.tsx"
    },
    {
      "path": "src/components/formedible/ai/form-preview.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Button } from \"@/components/ui/button\";\nimport { AiFormRenderer } from \"./ai-form-renderer\";\nimport { Eye, AlertCircle, Code2, Copy, Check, FileText } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface FormPreviewProps {\n  formCode?: string;\n  isStreaming?: boolean;\n  onFormSubmit?: (formData: Record<string, unknown>) => void;\n  className?: string;\n}\n\nexport function FormPreview({ formCode, isStreaming = false, onFormSubmit, className }: FormPreviewProps) {\n  const [showCode, setShowCode] = useState(false);\n  const [copied, setCopied] = useState(false);\n\n  const hasContent = formCode && formCode.trim().length > 0;\n\n  const handleCopyCode = async () => {\n    if (!formCode) return;\n    \n    try {\n      await navigator.clipboard.writeText(formCode);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (err) {\n      console.error(\"Failed to copy code:\", err);\n    }\n  };\n\n  useEffect(() => {\n    if (copied) {\n      const timer = setTimeout(() => setCopied(false), 2000);\n      return () => clearTimeout(timer);\n    }\n  }, [copied]);\n\n  if (!hasContent && !isStreaming) {\n    return (\n      <Card className={cn(\"flex flex-col h-full\", className)}>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"h-5 w-5\" />\n            Form Preview\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"flex-1 flex items-center justify-center\">\n          <div className=\"text-center text-muted-foreground\">\n            <FileText className=\"h-12 w-12 mb-4 opacity-50 mx-auto\" />\n            <h3 className=\"text-lg font-medium mb-2\">No Form Generated Yet</h3>\n            <p className=\"text-sm max-w-md\">\n              Start a conversation in the chat to generate your first form. \n              The preview will appear here once the AI creates your form.\n            </p>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Card className={cn(\"flex flex-col h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"h-5 w-5\" />\n            Form Preview\n          </CardTitle>\n          \n          {hasContent && (\n            <div className=\"flex items-center gap-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setShowCode(!showCode)}\n                className=\"gap-2\"\n              >\n                <Code2 className=\"h-4 w-4\" />\n                {showCode ? \"Preview\" : \"Code\"}\n              </Button>\n              \n              {showCode && (\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={handleCopyCode}\n                  className=\"gap-2\"\n                >\n                  {copied ? (\n                    <>\n                      <Check className=\"h-4 w-4\" />\n                      Copied\n                    </>\n                  ) : (\n                    <>\n                      <Copy className=\"h-4 w-4\" />\n                      Copy\n                    </>\n                  )}\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"flex-1 overflow-hidden\">\n        <div className=\"h-full overflow-y-auto\">\n          {showCode ? (\n            <div className=\"space-y-4\">\n              <div className=\"text-sm text-muted-foreground\">\n                Generated form configuration:\n              </div>\n              <pre className=\"bg-muted p-4 rounded-lg text-sm overflow-x-auto whitespace-pre-wrap break-words\">\n                <code>{formCode}</code>\n              </pre>\n            </div>\n          ) : (\n            <div className=\"space-y-4\">\n              {isStreaming && (\n                <Alert>\n                  <AlertCircle className=\"h-4 w-4\" />\n                  <AlertDescription>\n                    Form is being generated... Please wait for the AI to complete.\n                  </AlertDescription>\n                </Alert>\n              )}\n              \n              {hasContent && (\n                <div className=\"border rounded-lg p-4 bg-background\">\n                  <AiFormRenderer\n                    code={formCode}\n                    isStreaming={isStreaming}\n                    onSubmit={onFormSubmit}\n                    debug={process.env.NODE_ENV === \"development\"}\n                  />\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/form-preview.tsx"
    },
    {
      "path": "src/components/formedible/ai/ai-form-renderer.tsx",
      "content": "\"use client\";\nimport React, { useState, useEffect, useMemo, useCallback, memo } from \"react\";\nimport { z } from \"zod\";\nimport { useFormedible } from \"@/hooks/use-formedible\";\nimport type { FieldConfig, UseFormedibleOptions } from \"@/lib/formedible/types\";\n\nexport interface AiFormParseResult<TFormData = Record<string, unknown>> {\n  schema: z.ZodSchema<TFormData>;\n  formOptions: UseFormedibleOptions<TFormData>;\n  success: boolean;\n  error?: string;\n}\n\nexport interface AiParserConfig {\n  allowedFieldTypes?: string[];\n  allowedKeys?: string[];\n  allowedFieldKeys?: string[];\n  allowedPageKeys?: string[];\n  allowedProgressKeys?: string[];\n  allowedFormOptionsKeys?: string[];\n}\n\nexport interface AiFormRendererProps {\n  code: string;\n  isStreaming?: boolean;\n  onParseComplete?: (result: AiFormParseResult) => void;\n  onSubmit?: (formData: Record<string, unknown>) => void | Promise<void>;\n  className?: string;\n  parserConfig?: AiParserConfig;\n  debug?: boolean;\n}\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'email', 'password', 'url', 'tel', 'textarea', 'select', \n  'checkbox', 'switch', 'number', 'date', 'slider', 'file', 'rating',\n  'phone', 'colorPicker', 'location', 'duration', 'multiSelect',\n  'autocomplete', 'masked', 'object', 'array', 'radio'\n];\n\nconst DEFAULT_KEYS = [\n  'schema', 'fields', 'pages', 'progress', 'submitLabel', 'nextLabel', \n  'previousLabel', 'formClassName', 'fieldClassName', 'formOptions'\n];\n\nconst DEFAULT_FIELD_KEYS = [\n  'name', 'type', 'label', 'placeholder', 'description', 'options', \n  'min', 'max', 'step', 'accept', 'multiple', 'page', 'conditional',\n  'section', 'ratingConfig', 'phoneConfig', 'colorConfig', 'locationConfig',\n  'durationConfig', 'multiSelectConfig', 'sliderConfig', 'numberConfig',\n  'dateConfig', 'fileConfig', 'textareaConfig', 'passwordConfig', 'emailConfig',\n  'autocompleteConfig', 'maskedInputConfig', 'objectConfig', 'arrayConfig',\n  'validation', 'group', 'tab', 'help', 'inlineValidation', 'datalist'\n];\n\nconst DEFAULT_PAGE_KEYS = ['page', 'title', 'description'];\n\nconst DEFAULT_PROGRESS_KEYS = ['showSteps', 'showPercentage', 'className'];\n\nconst DEFAULT_FORM_OPTIONS_KEYS = [\n  'defaultValues', 'asyncDebounceMs', 'canSubmitWhenInvalid', 'onSubmit', 'onSubmitInvalid'\n];\n\nclass AiFormedibleParser {\n  private config: Required<AiParserConfig>;\n\n  constructor(config?: AiParserConfig) {\n    this.config = {\n      allowedFieldTypes: config?.allowedFieldTypes ?? DEFAULT_FIELD_TYPES,\n      allowedKeys: config?.allowedKeys ?? DEFAULT_KEYS,\n      allowedFieldKeys: config?.allowedFieldKeys ?? DEFAULT_FIELD_KEYS,\n      allowedPageKeys: config?.allowedPageKeys ?? DEFAULT_PAGE_KEYS,\n      allowedProgressKeys: config?.allowedProgressKeys ?? DEFAULT_PROGRESS_KEYS,\n      allowedFormOptionsKeys: config?.allowedFormOptionsKeys ?? DEFAULT_FORM_OPTIONS_KEYS,\n    };\n  }\n\n  parse(code: string): AiFormParseResult {\n    try {\n      const sanitizedCode = this.sanitizeCode(code);\n      const parsed = this.parseObjectLiteral(sanitizedCode);\n      const sanitized = this.validateAndSanitize(parsed);\n      const { schema, formOptions } = this.createFormedibleConfig(sanitized);\n\n      return {\n        schema,\n        formOptions,\n        success: true,\n      };\n    } catch (error) {\n      return {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  private sanitizeCode(code: string): string {\n    let sanitized = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '').replace(/\\/\\/.*$/gm, '');\n    sanitized = sanitized.replace(/\\b(eval|Function|setTimeout|setInterval|require|import)\\s*\\(/g, '');\n    sanitized = sanitized.replace(/=>\\s*{[^}]*}/g, '\"\"');\n    sanitized = sanitized.replace(/function\\s*\\([^)]*\\)\\s*{[^}]*}/g, '\"\"');\n    return sanitized;\n  }\n\n  private parseObjectLiteral(code: string): unknown {\n    try {\n      return JSON.parse(code);\n    } catch {\n      try {\n        let processedCode = code.trim();\n        processedCode = this.replaceZodExpressions(processedCode);\n        processedCode = processedCode.replace(/([{,]\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*:/g, '$1\"$2\":');\n        processedCode = processedCode.replace(/,(\\s*[}\\]])/g, '$1');\n        processedCode = processedCode.replace(/'/g, '\"');\n        return JSON.parse(processedCode);\n      } catch (conversionError) {\n        throw new Error(`Invalid syntax: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);\n      }\n    }\n  }\n\n  private replaceZodExpressions(code: string): string {\n    let result = code;\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n      const zodMatch = result.match(/z\\.[a-zA-Z]+\\(/);\n      if (zodMatch) {\n        const startIndex = zodMatch.index!;\n        const openParenIndex = startIndex + zodMatch[0].length - 1;\n\n        let depth = 1;\n        let endIndex = openParenIndex + 1;\n\n        while (endIndex < result.length && depth > 0) {\n          if (result[endIndex] === '(') {\n            depth++;\n          } else if (result[endIndex] === ')') {\n            depth--;\n          }\n          endIndex++;\n        }\n\n        if (depth === 0) {\n          let chainEnd = endIndex;\n          while (chainEnd < result.length) {\n            const chainMatch = result.slice(chainEnd).match(/^\\.[a-zA-Z]+\\(/);\n            if (chainMatch) {\n              let chainDepth = 1;\n              let chainParenIndex = chainEnd + chainMatch[0].length - 1;\n              let chainEndIndex = chainParenIndex + 1;\n\n              while (chainEndIndex < result.length && chainDepth > 0) {\n                if (result[chainEndIndex] === '(') {\n                  chainDepth++;\n                } else if (result[chainEndIndex] === ')') {\n                  chainDepth--;\n                }\n                chainEndIndex++;\n              }\n\n              if (chainDepth === 0) {\n                chainEnd = chainEndIndex;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          result = result.slice(0, startIndex) + '\"__ZOD_SCHEMA__\"' + result.slice(chainEnd);\n          changed = true;\n        } else {\n          result = result.replace(/z\\.[a-zA-Z]+/, '\"__ZOD_SCHEMA__\"');\n          changed = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private validateAndSanitize(obj: unknown): Record<string, unknown> {\n    if (typeof obj !== 'object' || obj === null) {\n      throw new Error('Definition must be an object');\n    }\n\n    const sanitized: Record<string, unknown> = {};\n    const input = obj as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(input)) {\n      if (!this.config.allowedKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'schema':\n          break;\n        case 'fields':\n          sanitized[key] = this.validateFields(value);\n          break;\n        case 'pages':\n          sanitized[key] = this.validatePages(value);\n          break;\n        case 'progress':\n          sanitized[key] = this.validateProgress(value);\n          break;\n        case 'formOptions':\n          sanitized[key] = this.validateFormOptions(value);\n          break;\n        case 'submitLabel':\n        case 'nextLabel':\n        case 'previousLabel':\n        case 'formClassName':\n        case 'fieldClassName':\n          if (typeof value === 'string') {\n            sanitized[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private validateFields(fields: unknown): FieldConfig[] {\n    if (!Array.isArray(fields)) {\n      throw new Error('Fields must be an array');\n    }\n\n    return fields.map((field, index) => {\n      if (typeof field !== 'object' || field === null) {\n        throw new Error(`Field at index ${index} must be an object`);\n      }\n\n      const sanitizedField: Record<string, unknown> = {};\n      const fieldObj = field as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(fieldObj)) {\n        if (!this.config.allowedFieldKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'name':\n            if (typeof value === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'type':\n            if (typeof value === 'string' && this.config.allowedFieldTypes.includes(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'label':\n          case 'placeholder':\n          case 'description':\n          case 'accept':\n            if (typeof value === 'string') {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'options':\n            if (Array.isArray(value)) {\n              sanitizedField[key] = value.filter(opt => \n                typeof opt === 'string' || \n                (typeof opt === 'object' && opt !== null && \n                 typeof (opt as { value?: unknown }).value === 'string' && \n                 typeof (opt as { label?: unknown }).label === 'string')\n              );\n            }\n            break;\n          case 'min':\n          case 'max':\n          case 'step':\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedField[key] = value;\n            }\n            break;\n          case 'multiple':\n          case 'conditional':\n            if (typeof value === 'boolean') {\n              sanitizedField[key] = value;\n            }\n            break;\n          default:\n            if (typeof value === 'object' && value !== null) {\n              sanitizedField[key] = value;\n            }\n            break;\n        }\n      }\n\n      if (!sanitizedField.name || !sanitizedField.type) {\n        throw new Error(`Field at index ${index} must have 'name' and 'type' properties`);\n      }\n\n      return sanitizedField as unknown as FieldConfig;\n    });\n  }\n\n  private validatePages(pages: unknown): Array<{ page: number; title?: string; description?: string }> {\n    if (!Array.isArray(pages)) {\n      return [];\n    }\n\n    return pages.map(page => {\n      if (typeof page !== 'object' || page === null) {\n        return null;\n      }\n\n      const sanitizedPage: Record<string, unknown> = {};\n      const pageObj = page as Record<string, unknown>;\n\n      for (const [key, value] of Object.entries(pageObj)) {\n        if (!this.config.allowedPageKeys.includes(key)) {\n          continue;\n        }\n\n        switch (key) {\n          case 'page':\n            if (typeof value === 'number' && !isNaN(value)) {\n              sanitizedPage[key] = value;\n            }\n            break;\n          case 'title':\n          case 'description':\n            if (typeof value === 'string') {\n              sanitizedPage[key] = value;\n            }\n            break;\n        }\n      }\n\n      return sanitizedPage.page ? sanitizedPage : null;\n    }).filter(Boolean) as Array<{ page: number; title?: string; description?: string }>;\n  }\n\n  private validateProgress(progress: unknown): Record<string, unknown> {\n    if (typeof progress !== 'object' || progress === null) {\n      return {};\n    }\n\n    const sanitizedProgress: Record<string, unknown> = {};\n    const progressObj = progress as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(progressObj)) {\n      if (!this.config.allowedProgressKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'showSteps':\n        case 'showPercentage':\n          if (typeof value === 'boolean') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n        case 'className':\n          if (typeof value === 'string') {\n            sanitizedProgress[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedProgress;\n  }\n\n  private validateFormOptions(formOptions: unknown): Record<string, unknown> {\n    if (typeof formOptions !== 'object' || formOptions === null) {\n      return {};\n    }\n\n    const sanitizedOptions: Record<string, unknown> = {};\n    const optionsObj = formOptions as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(optionsObj)) {\n      if (!this.config.allowedFormOptionsKeys.includes(key)) {\n        continue;\n      }\n\n      switch (key) {\n        case 'defaultValues':\n          if (typeof value === 'object' && value !== null) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'asyncDebounceMs':\n          if (typeof value === 'number' && !isNaN(value)) {\n            sanitizedOptions[key] = value;\n          }\n          break;\n        case 'canSubmitWhenInvalid':\n          if (typeof value === 'boolean') {\n            sanitizedOptions[key] = value;\n          }\n          break;\n      }\n    }\n\n    return sanitizedOptions;\n  }\n\n  private createFormedibleConfig(sanitized: Record<string, unknown>): { \n    schema: z.ZodSchema<Record<string, unknown>>; \n    formOptions: UseFormedibleOptions<Record<string, unknown>>; \n  } {\n    const fields = sanitized.fields as FieldConfig[] || [];\n    const schema = this.createSchemaFromFields(fields);\n    const defaultValues = this.createDefaultValues(fields);\n\n    const formOptions: UseFormedibleOptions<Record<string, unknown>> = {\n      fields,\n      schema,\n      pages: sanitized.pages as UseFormedibleOptions<Record<string, unknown>>['pages'],\n      progress: sanitized.progress as UseFormedibleOptions<Record<string, unknown>>['progress'],\n      submitLabel: sanitized.submitLabel as string,\n      nextLabel: sanitized.nextLabel as string,\n      previousLabel: sanitized.previousLabel as string,\n      formClassName: sanitized.formClassName as string,\n      fieldClassName: sanitized.fieldClassName as string,\n      formOptions: {\n        defaultValues,\n        ...(sanitized.formOptions as Record<string, unknown>),\n      },\n    };\n\n    return { schema, formOptions };\n  }\n\n  private createSchemaFromFields(fields: FieldConfig[]): z.ZodSchema<Record<string, unknown>> {\n    const schemaObj: Record<string, z.ZodTypeAny> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'colorPicker':\n        case 'autocomplete':\n        case 'masked':\n        case 'radio':\n        case 'select':\n          schemaObj[field.name] = z.string();\n          break;\n        case 'number':\n        case 'slider':\n        case 'rating':\n          schemaObj[field.name] = z.number();\n          break;\n        case 'checkbox':\n        case 'switch':\n          schemaObj[field.name] = z.boolean();\n          break;\n        case 'date':\n          schemaObj[field.name] = z.date();\n          break;\n        case 'file':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'location':\n          schemaObj[field.name] = z.object({\n            lat: z.number(),\n            lng: z.number(),\n            address: z.string().optional(),\n            city: z.string().optional(),\n            country: z.string().optional(),\n          }).optional();\n          break;\n        case 'duration':\n          schemaObj[field.name] = z.object({\n            hours: z.number().min(0),\n            minutes: z.number().min(0),\n          }).optional();\n          break;\n        case 'multiSelect':\n          schemaObj[field.name] = z.array(z.string());\n          break;\n        case 'object':\n          schemaObj[field.name] = z.any();\n          break;\n        case 'array':\n          schemaObj[field.name] = z.array(z.any());\n          break;\n        default:\n          schemaObj[field.name] = z.string();\n      }\n    });\n\n    return z.object(schemaObj);\n  }\n\n  private createDefaultValues(fields: FieldConfig[]): Record<string, unknown> {\n    const defaults: Record<string, unknown> = {};\n\n    fields.forEach(field => {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'url':\n        case 'tel':\n        case 'textarea':\n        case 'phone':\n        case 'autocomplete':\n        case 'masked':\n          defaults[field.name] = '';\n          break;\n        case 'number':\n        case 'slider':\n          defaults[field.name] = field.min || 0;\n          break;\n        case 'checkbox':\n        case 'switch':\n          defaults[field.name] = false;\n          break;\n        case 'date':\n          defaults[field.name] = new Date().toISOString().split('T')[0];\n          break;\n        case 'select':\n        case 'radio':\n          if (field.options && Array.isArray(field.options) && field.options.length > 0) {\n            const firstOption = field.options[0];\n            defaults[field.name] = typeof firstOption === 'string' ? firstOption : (firstOption as { value: string }).value;\n          } else {\n            defaults[field.name] = '';\n          }\n          break;\n        case 'file':\n          defaults[field.name] = null;\n          break;\n        case 'rating':\n          defaults[field.name] = 1;\n          break;\n        case 'colorPicker':\n          defaults[field.name] = '#000000';\n          break;\n        case 'location':\n          defaults[field.name] = undefined;\n          break;\n        case 'duration':\n          defaults[field.name] = { hours: 0, minutes: 0 };\n          break;\n        case 'multiSelect':\n          defaults[field.name] = [];\n          break;\n        case 'object':\n          defaults[field.name] = {};\n          break;\n        case 'array':\n          defaults[field.name] = [];\n          break;\n        default:\n          defaults[field.name] = '';\n      }\n    });\n\n    return defaults;\n  }\n}\n\nexport function parseAiToFormedible(\n  code: string, \n  config?: AiParserConfig\n): AiFormParseResult {\n  const parser = new AiFormedibleParser(config);\n  return parser.parse(code);\n}\n\nconst AiFormRendererComponent: React.FC<AiFormRendererProps> = ({\n  code,\n  isStreaming = false,\n  onParseComplete,\n  onSubmit,\n  className,\n  parserConfig,\n  debug = false,\n}) => {\n  const [parseResult, setParseResult] = useState<AiFormParseResult | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const parseFormDefinition = useCallback(async () => {\n    if (!code.trim() || isStreaming) return;\n\n    setIsLoading(true);\n\n    try {\n      const result = parseAiToFormedible(code, parserConfig);\n      setParseResult(result);\n      onParseComplete?.(result);\n\n      if (debug && result.error) {\n        console.error('AI Form Parser Error:', result.error);\n      }\n    } catch (err) {\n      const errorResult: AiFormParseResult = {\n        schema: z.object({}),\n        formOptions: { fields: [], formOptions: { defaultValues: {} } },\n        success: false,\n        error: err instanceof Error ? err.message : String(err),\n      };\n      setParseResult(errorResult);\n      onParseComplete?.(errorResult);\n\n      if (debug) {\n        console.error('AI Form Renderer Error:', err);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [code, isStreaming, onParseComplete, parserConfig, debug]);\n\n  useEffect(() => {\n    if (!isStreaming && code.trim()) {\n      parseFormDefinition();\n    }\n  }, [code, isStreaming, parseFormDefinition]);\n\n  const formConfig = useMemo(() => {\n    if (!parseResult?.success || !parseResult.formOptions.fields?.length) {\n      return null;\n    }\n\n    return {\n      ...parseResult.formOptions,\n      formOptions: {\n        ...parseResult.formOptions.formOptions,\n        onSubmit: async ({ value }: { value: Record<string, unknown> }) => {\n          await onSubmit?.(value);\n        },\n      },\n    };\n  }, [parseResult, onSubmit]);\n\n  const formedibleResult = useFormedible(formConfig || {\n    fields: [],\n    formOptions: { defaultValues: {} }\n  });\n\n  const renderedForm = useMemo(() => {\n    if (isLoading) {\n      return (\n        <div className=\"flex items-center justify-center p-8\">\n          <div className=\"text-sm text-muted-foreground\">Parsing form...</div>\n        </div>\n      );\n    }\n\n    if (parseResult && !parseResult.success) {\n      return (\n        <div className=\"p-4 border border-destructive/20 bg-destructive/10 rounded-md\">\n          <div className=\"text-sm text-destructive\">\n            <div className=\"font-medium\">Parse Error</div>\n            <div className=\"text-xs mt-1 opacity-80\">{parseResult.error}</div>\n          </div>\n        </div>\n      );\n    }\n\n    if (!formConfig || !parseResult?.success) {\n      return null;\n    }\n\n    return <formedibleResult.Form />;\n  }, [isLoading, parseResult, formConfig, formedibleResult.Form]);\n\n  return (\n    <div className={className}>\n      {renderedForm}\n    </div>\n  );\n};\n\nexport const AiFormRenderer = memo(AiFormRendererComponent);",
      "type": "registry:component",
      "target": "components/formedible/ai/ai-form-renderer.tsx"
    },
    {
      "path": "src/components/formedible/ai/conversation-history.tsx",
      "content": "\"use client\";\n\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { History, MessageSquare, Trash2, Download } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport type { UIMessage } from \"@ai-sdk/react\";\n\nexport interface Conversation {\n  id: string;\n  title: string;\n  messages: UIMessage[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ConversationHistoryProps {\n  conversations: Conversation[];\n  currentConversationId?: string;\n  onSelectConversation: (conversation: Conversation) => void;\n  onDeleteConversation: (conversationId: string) => void;\n  onExportConversation?: (conversation: Conversation) => void;\n  className?: string;\n}\n\nexport function ConversationHistory({\n  conversations,\n  currentConversationId,\n  onSelectConversation,\n  onDeleteConversation,\n  onExportConversation,\n  className,\n}: ConversationHistoryProps) {\n\n  const formatDate = (date: Date) => {\n    const now = new Date();\n    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);\n\n    if (diffInHours < 1) {\n      return \"Just now\";\n    } else if (diffInHours < 24) {\n      return `${Math.floor(diffInHours)}h ago`;\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n\n  const getConversationTitle = (conversation: Conversation) => {\n    if (conversation.title) return conversation.title;\n\n    // Generate title from first user message\n    const firstUserMessage = conversation.messages.find(m => m.role === \"user\");\n    if (firstUserMessage) {\n      const text = firstUserMessage.parts\n        .filter((part: any) => part.type === 'text')\n        .map((part: any) => part.text)\n        .join(' ');\n      return text.length > 50 ? text.substring(0, 50) + \"...\" : text;\n    }\n\n    return \"New Conversation\";\n  };\n\n  return (\n    <Card className={cn(\"h-full\", className)}>\n      <CardHeader className=\"pb-3\">\n        <CardTitle className=\"flex items-center gap-2\">\n          <History className=\"h-5 w-5\" />\n          Conversation History\n          <Badge variant=\"secondary\" className=\"ml-auto\">\n            {conversations.length}\n          </Badge>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"p-4\">\n        <div className=\"h-[300px] overflow-y-auto\">\n          {conversations.length === 0 ? (\n            <div className=\"flex flex-col items-center justify-center h-full text-center text-muted-foreground py-8\">\n              <MessageSquare className=\"h-8 w-8 mb-2 opacity-50\" />\n              <p className=\"text-sm\">No conversations yet</p>\n              <p className=\"text-xs\">Start a chat to see your history</p>\n            </div>\n          ) : (\n            <div className=\"space-y-2\">\n              {conversations.map((conversation) => (\n                <div\n                  key={conversation.id}\n                  className={cn(\n                    \"group flex items-center gap-2 p-2 rounded-lg border transition-colors hover:bg-muted/50 cursor-pointer\",\n                    currentConversationId === conversation.id && \"bg-muted border-primary\"\n                  )}\n                  onClick={() => onSelectConversation(conversation)}\n                >\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <MessageSquare className=\"h-3 w-3 text-muted-foreground shrink-0\" />\n                      <span className=\"text-xs text-muted-foreground\">\n                        {formatDate(conversation.updatedAt)}\n                      </span>\n                    </div>\n                    <p className=\"text-sm font-medium truncate\">\n                      {getConversationTitle(conversation)}\n                    </p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {conversation.messages.length} messages\n                    </p>\n                  </div>\n                  <div className=\"flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity\">\n                    {onExportConversation && (\n                      <Button\n                        type=\"button\"\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        className=\"h-6 w-6\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          onExportConversation(conversation);\n                        }}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    )}\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-6 w-6 text-destructive hover:text-destructive\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        onDeleteConversation(conversation.id);\n                      }}\n                    >\n                      <Trash2 className=\"h-3 w-3\" />\n                    </Button>\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}",
      "type": "registry:component",
      "target": "components/formedible/ai/conversation-history.tsx"
    }
  ]
}